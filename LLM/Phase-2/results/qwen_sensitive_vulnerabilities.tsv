number	file_name	vulnerability	severity	is_sensitively_vulnerable	CWE/CVE/New	confidence_score	sensitive_function_responsible	standard_or_custom	explanation	code_snippet
1	youtube.com.js	Hardcoded API Key in Service Worker	High	false	N/A	N/A	```self.document = self; self.window = self; var ytcfg = { d: function () { return window.yt && yt.config_ || ytcfg.data_ || (ytcfg.data_ = {}); }, get: function (k, o) { return k in ytcfg.d() ? ytcfg.d()[k] : o; }, set: function () { var a = arguments; if (a.length > 1) ytcfg.d()[a[0]] = a[1];else { var k; for (k in a[0]) ytcfg.d()[k] = a[0][k]; } } }; ytc	N/A	{The hardcoded API key is a static configuration value embedded in the script, not a result of misuse of a sensitive function. It is a direct exposure of credentials, but no dynamic or unsafe function call is involved.}	N/A
2	gandi.net.js	Open Redirect Vulnerability	High	true	CWE-601	10	N/A	standard	{The `redirect` function is called with `decodedURL`, which is derived from `url.href` that is constructed based on user-controlled input from the URL. Since `url.href` is modified by `applyUserParams` using values retrieved from IndexedDB (which may be influenced by user input) and then passed to `redirect`, an attacker can manipulate the URL parameters to redirect users to arbitrary domains. The `redirect` function constructs a Response with a Location header set to the provided URL, enabling open redirect attacks.}	```return redirect(decodedURL);```
3	tiktok.com.js	External Script Import from Untrusted CDN	High	true	CWE-78	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a CDN (https://lf16-tiktok-common.tiktokcdn-us.com), which is not under the direct control of the application. Although the URL is hardcoded, the source is an external CDN, and if the CDN is compromised or misconfigured, it could serve malicious code. This constitutes a sensitive function misuse because importScripts() executes code from an external source without any sanitization or integrity checks, potentially leading to remote code execution.}	```importScripts('https://lf16-tiktok-common.tiktokcdn-us.com/obj/tiktok-web-common-tx/pns/runtime-worker/2.0.0.2/pns-runtime-sw.js');```
4	ampproject.org.js	Improper Error Handling for Missing 'q' Parameter Leading to DoS	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of the case when the 'q' parameter is missing in the URL search string. The code assumes the parameter is present and attempts to access index [1] of the match result, which will be undefined, leading to a runtime error. This is not due to misuse of a sensitive function, but rather a logic flaw in error handling.}	```const searchQuery = decodeURIComponent(url.search.match(/q=([^&]+)/)[1]);```
5	ampproject.org.js	Incorrect Cache Deletion Leading to Data Inconsistency	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from using cache.delete() with the ignoreSearch option, which may unintentionally delete cache entries that differ only in query parameters. This is a misconfiguration or misuse of cache semantics, not a sensitive function misuse. The function itself is not inherently dangerous when used correctly, and the issue is more about incorrect logic than security-sensitive function abuse.}	```cache.delete(request, { ignoreSearch: true });```
6	quora.com.js	Unrestricted Import of Code from Untrusted Sources	Medium	true	CWE-434	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a remote URL ('https://qsbr.cf2.quoracdn.net/-4-service_worker.js.out-34-3636fddc6fb8525d.webpack'), which is not dynamically constructed from untrusted input but is hardcoded. However, since the domain 'qsbr.cf2.quoracdn.net' is not under the control of the application and could potentially be compromised or misconfigured, this constitutes a medium-risk vulnerability. The script being imported is not sanitized or verified, and if the remote server is compromised, it could serve malicious code, leading to code injection and potential compromise of the service worker's functionality.}	"```self.importScripts(""https://qsbr.cf2.quoracdn.net/-4-service_worker.js.out-34-3636fddc6fb8525d.webpack"");```"
7	youtube.com.js	Hardcoded API Key in Service Worker	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static configuration value embedded in the script, not a result of misuse of a sensitive function. It is a direct exposure of credentials, but no dynamic or unsafe function call is involved.}	```self.document = self; self.window = self; var ytcfg = { d: function () { return window.yt && yt.config_ || ytcfg.data_ || (ytcfg.data_ = {}); }, get: function (k, o) { return k in ytcfg.d() ? ytcfg.d()[k] : o; }, set: function () { var a = arguments; if (a.length > 1) ytcfg.d()[a[0]] = a[1];else { var k; for (k in a[0]) ytcfg.d()[k] = a[0][k]; } } }; ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
8	youtube.com.js	Non-Standard Service Worker Environment Assumptions	Medium	false	N/A	N/A	N/A	N/A	{The assignment of `self.document = self; self.window = self;` is a non-standard practice to simulate a browser environment in a service worker, but it does not involve misuse of a sensitive function. It is a structural assumption, not a function misuse.}	```self.document = self; self.window = self;```
9	gandi.net.js	Open Redirect Vulnerability	High	true	CWE-601	10	N/A	standard	{The `redirect` function is called with `decodedURL`, which is derived from `url.href` that is constructed from user-controlled input via `searchParams` and `localePref` from IndexedDB. Since `url.href` is built dynamically based on user-provided parameters and stored preferences, an attacker can manipulate these to craft a malicious URL, leading to an open redirect. The `redirect` function, being a custom wrapper around `Response`, sends a 302 redirect to the constructed URL, enabling redirection to arbitrary domains.}	```return redirect(decodedURL);```
10	tiktok.com.js	External Script Import from Untrusted CDN	High	true	CWE-78	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a CDN (https://lf16-tiktok-common.tiktokcdn-us.com), which is not under the direct control of the application. While the URL is hardcoded, the domain is external and potentially untrusted, making it a high-risk vector for supply chain attacks if the CDN is compromised or if the script is tampered with. This constitutes a sensitive function misuse because the script is loaded from an external source without verification, allowing an attacker to inject malicious code into the service worker.}	```importScripts('https://lf16-tiktok-common.tiktokcdn-us.com/obj/tiktok-web-common-tx/pns/runtime-worker/2.0.0.2/pns-runtime-sw.js');```
11	xiaomi.com.js	Insecure Caching of Responses	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the `cacheWillUpdate` function returning responses with status 200 or 0, which may allow caching of responses that should not be cached (e.g., non-200 responses that are not errors). However, this is not due to misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather a logic flaw in the caching policy. The function itself is not inherently dangerous; it's the policy that is flawed.}	```const cacheWillUpdate: async ({ response: e }) => 200 === e.status || 0 === e.status ? e : null```
12	twitch.tv.js	URL Redirection (Open Redirect	Medium	true	CWE-601	N/A	new URL	standard	{The function `new URL(i.redirectUrl)` constructs a URL from user-controlled input `i.redirectUrl`, which is derived from push notification data. Since this input is not validated or sanitized, an attacker can craft a malicious redirect URL, leading to an open redirect vulnerability. The URL is then used to navigate or focus a client window, potentially redirecting users to phishing or malicious sites.}	```return t.key ? s(''.concat(a.BrowserGame, '/').concat(t.key)).href : s(a.BrowserGame).href;```
13	twitch.tv.js	URL Redirection (Open Redirect	Medium	true	CWE-601	N/A	new URL	standard	{The function `new URL(i.redirectUrl)` is used to parse a URL from the `redirectUrl` field in notification data, which is user-controlled via push messages. Without validation, this allows an attacker to redirect users to arbitrary domains, resulting in an open redirect. The subsequent `focus()` or `navigate()` operations on the client window execute this redirection, posing a security risk.}	```var e = new URL(i.redirectUrl), r = 0, o = t, n.label = 2;```
14	ampproject.org.js	Improper Error Handling for Missing 'q' Parameter Leading to DoS	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of the case when the 'q' parameter is missing in the URL search string. The code assumes the parameter is present and attempts to access index [1] of the match result, which will be undefined, leading to a runtime error. This is not due to misuse of a sensitive function but rather a logic flaw in error handling.}	```const searchQuery = decodeURIComponent(url.search.match(/q=([^&]+)/)[1]);```
15	ampproject.org.js	Incorrect Cache Deletion Leading to Data Inconsistency	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from the use of `cache.delete(request, { ignoreSearch: true });` which may delete unintended cache entries due to the `ignoreSearch` option. However, this is not a misuse of a sensitive function per se, but rather a misconfiguration or misunderstanding of the `ignoreSearch` behavior. The function `cache.delete()` is used correctly in terms of security, but the logic may lead to data inconsistency.}	```cache.delete(request, { ignoreSearch: true });```
16	crashlytics.com.js	Deserialization of Untrusted Data	High	true	CWE-502	10	N/A	standard	{The function `Ma` is a deserialization function (Ea(Ka)) that parses JSON input from untrusted sources (e.g., `b.data` from a message event). Since the input is not sanitized or validated, an attacker can craft malicious JSON payloads to trigger arbitrary object creation or code execution, leading to deserialization of untrusted data.}	```var d; try { d = Ma(c); } catch (h) { return; } var e = O(d, 1);```
17	crashlytics.com.js	Insecure Direct Object Reference	Medium	false	N/A	0	N/A	N/A	{The `postMessage` function is used to send data to clients, but the vulnerability is not due to misuse of a sensitive function. The issue stems from lack of proper access control or validation on the recipient client, not from the function itself being misused with untrusted input.}	```d.postMessage(b);```
18	crashlytics.com.js	Improper Input Validation	Medium	false	N/A	0	N/A	N/A	{The `fetch` method is used in a context where the input is not validated, but the vulnerability is not caused by misuse of a sensitive function. The issue lies in the logic flow and lack of input sanitization, not in the function being inherently misused with dynamic input.}	```var b = new Va(a.g, b).fetch();```
19	crashlytics.com.js	Improper Error Handling	Low	false	N/A	0	N/A	N/A	{The `da` function is used to throw errors asynchronously, but it is not misused with untrusted input. The vulnerability is due to improper error handling logic, not because of a sensitive function being improperly used with dynamic data.}	```da(a);```
20	quora.com.js	Unrestricted Import of Code from Untrusted Sources	Medium	true	CWE-434	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a remote URL (https://qsbr.cf2.quoracdn.net/-4-service_worker.js.out-34-3636fddc6fb8525d.webpack). Although the URL is hardcoded, the domain (qsbr.cf2.quoracdn.net) is not under direct control of the application developer and could be compromised or misconfigured, allowing an attacker to serve malicious code. This constitutes a sensitive function misuse because importScripts() executes code from an external source without any validation or sanitization, leading to potential code injection and compromise of the service worker’s execution context.}	"```self.importScripts(""https://qsbr.cf2.quoracdn.net/-4-service_worker.js.out-34-3636fddc6fb8525d.webpack"");```"
21	walmart.com.js	Insecure postMessage Usage	High	true	N/A	N/A	postMessage	standard	{The postMessage function is used to send messages between service worker and client frames. The code does not validate or sanitize the message data received from the client, allowing an attacker to inject arbitrary data that could be executed in the context of the service worker. This can lead to unauthorized access, data exfiltration, or further exploitation of the service worker's capabilities.}	```const e = new Map(), t = (e, t) => ({ F: e.F, p: t }), r = (e, t) => new Response(e, { headers: { 'content-type': t || 'text/html', 'Cache-Control': 'no-store' } }); self.onmessage = t => { const r = t.data, n = e.get(r.F); n && (e.delete(r.F), clearTimeout(n[1]), n[0](r)); };```
22	walmart.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the URL path in the onfetch handler. While the code checks if the pathname ends with 'proxytown', it does not validate or sanitize the input from the request. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a logic flaw in input handling.}	```self.onfetch = n => { const i = n.request, s = new URL(i.url).pathname; s.endsWith('proxytown') && n.respondWith((n => new Promise(async i => { const s = await n.clone().json(), o = await (r => new Promise(async n => { const i = ((e, t) => { const r = t.split('.').pop(); let n = e.find(e => e.url.endsWith(`?${r}`)); return n || (n = [...e].sort((e, t) => e.url > t.url ? -1 : e.url < t.url ? 1 : 0)[0]), n; })([...(await self.clients.matchAll())], r.F); if (i) { const s = [n, setTimeout(() => { e.delete(r.F), n(t(r, 'Timeout')); }, 1e4)]; e.set(r.F, s), i.postMessage(r); } else n(t(r, 'NoParty')); }))(s); i(r(JSON.stringify(o), 'application/json')); }))(i); };```
23	duolingo.com.js	Insecure Resource Loading via importScripts	Medium	false	CWE-434	N/A	N/A	N/A	{The importScripts calls use hardcoded, trusted paths (./sw/gcm.js and ./sw/offline.js) and do not involve dynamic or user-controlled input. Therefore, while the function itself is sensitive, its usage here is not vulnerable to misuse.}	"```importScripts(""./sw/gcm.js"");importScripts(""./sw/offline.js"");```"
24	sentinelone.net.js	Insecure Direct Object References (IDOR) via URL Exclusion Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a hardcoded list of excluded URLs that are bypassed without proper validation or sanitization. The code checks for substring matches using `indexOf`, which is not sufficient to prevent crafted URLs from bypassing the exclusion logic. This is not caused by misuse of a sensitive function but by flawed logic in URL filtering.}	```if (event.request.url.indexOf(excludedLinks[i]) !== -1) { return; }```
25	sentinelone.net.js	Improper Validation of HTTP Request Headers	Medium	false	N/A	N/A	N/A	N/A	{The code checks for 'ngsw-bypass' in headers or URL search parameters using `has()` and regex, but does not validate the context or origin of the request. This is a logic flaw rather than misuse of a sensitive function.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) { return; }```
26	sentinelone.net.js	Insecure Cache Busting Mechanism	Medium	true	N/A	N/A	`this.cacheBust`	custom	{The `cacheBust` method appends a random value to the URL without validating or sanitizing the input URL. This can lead to unintended cache-busting behavior or injection if the URL contains dynamic parameters. The function is custom and misused by directly concatenating a random string to the URL without proper sanitization.}	```const cacheBustReq = this.newRequestWithMetadata(this.cacheBust(req.url)```
27	sentinelone.net.js	Insecure Hash Algorithm (SHA)	Low	false	N/A	N/A	N/A	N/A	{The use of SHA-1 is a cryptographic weakness, but it is not caused by misuse of a sensitive JavaScript function. The function `sha1` is implemented internally and used for hashing, but the vulnerability stems from the algorithm choice, not improper function usage.}	```function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8```
28	sentinelone.net.js	Insecure Notification Content Handling	High	true	N/A	N/A	`showNotification`	standard	{The `showNotification` method is used with user-controlled data from the `desc['title']` field without sanitization. This allows an attacker to inject arbitrary content into notifications, potentially leading to phishing or social engineering attacks. The function is a standard browser API and is misused by passing unsanitized data directly.}	```await this.scope.registration.showNotification(desc['title']```
29	sentinelone.net.js	Insecure Window Opening	Medium	true	N/A	N/A	`openWindow`	standard	{The `openWindow` method is called with a URL constructed from `urlToOpen`, which is derived from user-controlled data (`onActionClick.url`). This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malware distribution. The function is a standard browser API and is misused by passing unsanitized user input.}	```await this.scope.clients.openWindow(urlToOpen);```
30	xhamster.com.js	Empty Fetch Event Listener Leading to Misconfigured Caching	Low	false	N/A	N/A	N/A	N/A	{The empty fetch event listener does not involve any sensitive function misuse; it merely registers a no-op handler, which may lead to misconfigured caching but does not stem from improper use of a sensitive function.}	```self.addEventListener('fetch', () => {});```
31	xhamster.com.js	Cache Poisoning via Unvalidated Message URLs	Medium	true	N/A	N/A	importScripts	standard	{The vulnerability arises from the use of importScripts() with dynamically constructed URLs derived from message payloads. Although importScripts() is not directly called in the provided code, the code processes message data to construct and handle requests that could lead to cache poisoning if the URLs are not validated. However, upon closer inspection, the code does not actually call importScripts() — it uses caches.open() and caches.match() for caching. Therefore, the original detection is misleading. The actual issue is that the code processes unvalidated URLs from message payloads (e.g., t.urlsToCache) and uses them to create Requests, which could lead to cache poisoning if the URLs are malicious. But since no sensitive function like importScripts() is used, this is not a sensitive function misuse.}	```self.addEventListener('message', e => { if (e.data && 'CACHE_URLS' === e.data.type) { let { payload: t } = e.data, n = Promise.all(t.urlsToCache.map(e => { 'string' == typeof e && (e = [e]); let t = new Request(...e); return this.handleRequest({ request: t }); })); e.waitUntil(n), e.ports && e.ports[0] && n.then(() => e.ports[0].postMessage(!0)); } });```
32	elmundo.es.js	Insecure Third-Party Script Import	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted third-party domain (as in 'https://aswpsdkeu.com/notify/v1/ua-sdk.min.js'), it introduces a high-risk vulnerability. The script from the external domain can be modified by an attacker, leading to arbitrary code execution within the service worker context, potentially compromising user data, intercepting network requests, or performing malicious actions under the site’s authority.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
33	sportybet.com.js	Insecure Resource Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URLs are hardcoded and point to external resources (//s.sporty.net/global/main/sw-toolbox.js and //s.sporty.net/global/main/sw-script.js). While the URLs are not dynamically constructed from untrusted input, the use of external scripts introduces a high-risk dependency. If the external server is compromised or the script is tampered with, the service worker could execute malicious code, leading to cache manipulation, data exfiltration, or request interception. This constitutes a high-severity vulnerability due to the trust placed in external resources.}	"```importScripts(""//s.sporty.net/global/main/sw-toolbox.js"")```"
34	sportybet.com.js	Insecure Resource Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URLs are hardcoded and point to external resources (//s.sporty.net/global/main/sw-toolbox.js and //s.sporty.net/global/main/sw-script.js). While the URLs are not dynamically constructed from untrusted input, the use of external scripts introduces a high-risk dependency. If the external server is compromised or the script is tampered with, the service worker could execute malicious code, leading to cache manipulation, data exfiltration, or request interception. This constitutes a high-severity vulnerability due to the trust placed in external resources.}	"```importScripts(""//s.sporty.net/global/main/sw-script.js"")```"
35	wps.com.js	Hardcoded API Secret in Fetch Request	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials in the fetch URL, not misuse of a sensitive function. The fetch function is used correctly, but the secret is exposed in plaintext.}	```fetch('https://www.google-analytics.com/mp/collect?api_secret=nSUqwfDIRYCHAa-PV8gS5Q&measurement_id=G-3TZLKYJJ0E', { method: 'POST', body: JSON.stringify({ client_id: cid, events: [{ name: 'fb_webpush', params: { install_id: data, action: action, title: title, body: body, label: options?.label || '', message_id: options?.message_id || '', push_msg_id: id } }] }) });```
36	wps.com.js	Open Redirect via Unvalidated Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL (jumpUrl) derived from notification.data.url, which is unvalidated and potentially controlled by an attacker. This allows an attacker to redirect users to arbitrary websites, leading to phishing or malicious redirection.}	```clients.openWindow(jumpUrl);```
37	wps.com.js	Open Redirect via Unvalidated Push Payload	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL (notificationClickJumpUrl) derived from the push payload, which is unvalidated and potentially controlled by an attacker. This allows an attacker to redirect users to arbitrary websites, leading to phishing or malicious redirection.}	```clients.openWindow(notificationClickJumpUrl);```
38	telegraaf.nl.js	External Script Inclusion Risk	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to load a script from a third-party domain ('https://aswpsdkus.com/notify/v1/ua-sdk.min.js'). While the URL is hardcoded, the risk arises because the script is loaded from an external, untrusted source. If the external script is compromised or malicious, it can execute arbitrary code within the context of the service worker, leading to potential data exfiltration, cache manipulation, or interception of network requests. Although the URL is not dynamically constructed from user input, the reliance on an external script introduces a high-risk dependency that can be exploited if the third-party source is not fully trusted or is compromised.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
39	nu.nl.js	Insecure External Script Loading	Medium	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard service worker API that loads and executes external scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL were derived from untrusted input (e.g., user-controlled parameters), it could lead to arbitrary script execution. However, in this case, the URLs are hardcoded and not dynamically constructed from user input, so the vulnerability is not due to sensitive function misuse. Therefore, the vulnerability is not classified as ""sensitively_vulnerable"" because the function is used safely with static, trusted URLs.}"	```self.importScripts('https://web-sdk.dpns-notifications.com/PNSServiceWorker.js');```
40	varzesh3.com.js	Open Redirect	High	true	CWE-601	9	N/A	standard	{The vulnerability arises from the use of `clients.openWindow(n)` where `n` is derived from `i.url` or `i.Url` in `t.notification.data`. Since this data is untrusted and can be controlled by an attacker via push notifications, it allows for an open redirect. The `clients.openWindow()` function is a standard browser API that opens a new window or tab with the specified URL, and when used with unsanitized input, it can be exploited to redirect users to malicious sites.}	"```const i = t.notification.data || {}, n = i.url || i.Url || ""/""; t.notification.close(), t.waitUntil(clients.matchAll({ type: ""window"", includeUncontrolled: !0 }).then(function (t) { if (t.length > 0) { let i = t[0]; for (let n = 0; n < t.length; n++) t[n].focused && (i = t[n]); if (n.toLowerCase() == i.url) return i.focus(); } return clients.openWindow(n); }));```"
41	lichess.org.js	Open Redirect via User-Controlled Navigation	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL derived from user-controlled data (e.g., t.fullId, t.threadId, etc.). Since the URL is constructed dynamically from untrusted input without validation or sanitization, an attacker can craft a notification payload that redirects users to arbitrary external sites, leading to an open redirect vulnerability.}	```let n = e.notification.data.userData, t = t.path || \'/\'; t.fullId ? n = \'/\' + t.fullId : t.threadId ? n = \'/inbox/\' + t.threadId : t.challengeId ? n = \'/\' + t.challengeId : t.streamerId ? n = \'/streamer/\' + t.streamerId + \'/redirect\' : t.mentionedBy ? n = \'/forum/redirect/post/\' + t.postId : t.invitedBy && (n = \'/study/\' + t.studyId);```
42	divar.ir.js	Open Redirect	High	true	N/A	9	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed from user-controlled data (a.id or a.mng_token). Since these values are derived from notification data, which can be manipulated by an attacker, this allows for open redirect attacks where the user is redirected to arbitrary URLs, potentially leading to phishing or malicious site redirection.}	```const { action: e, params: a } = t?.notification?.data || {}; switch (e) { case ACTION_TYPES.OPEN_CHAT_CONVERSATION: a?.id && t.waitUntil(clients.openWindow(`https://divar.ir/chat/${a.id}`)); break; case ACTION_TYPES.OPEN_CHAT_POSTCHI: t.waitUntil(clients.openWindow('https://divar.ir/chat/postchi')); break; case ACTION_TYPES.OPEN_POST_MANAGE: a?.mng_token && t.waitUntil(clients.openWindow(`https://divar.ir/manage/${a.mng_token}`)); }```
43	divar.ir.js	Improper Input Validation	Medium	true	N/A	9	JSON.parse	standard	"{The function JSON.parse is used on user-supplied data (n) after a simple string replacement (replaceAll(""'"", '""')), which is insufficient to sanitize or validate the input. This can lead to JSON parsing errors or, in some cases, injection of malicious payloads if the input is not properly validated, potentially leading to unintended behavior or data leakage.}"	```const { action: a, param: n, callback_url: s, title: i, body: c, source: r, push_id: o } = e; if ('divar' !== r) return; const l = JSON.parse(n.replaceAll(''', '''));```
44	dagbladet.no.js	Redundant Cache Registration for Same URL	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by redundant registration of the same URL pattern with different cache configurations, which may lead to unexpected behavior or inefficiency in caching.}	```workbox.routing.registerRoute(/^https:\/\/personvern.aller.no\/vendorlist.json/, workbox.strategies.cacheFirst({ cacheName: 'vendorlist', plugins: [new workbox.cacheableResponse.Plugin({ statuses: [0, 200] }), new workbox.expiration.Plugin({ maxEntries: 100, maxAgeSeconds: month })] }), 'GET'); workbox.routing.registerRoute(/^https:\/\/personvern.aller.no\/vendorlist.json/, workbox.strategies.cacheFirst({ cacheName: 'vendorlistCache', plugins: [new workbox.cacheableResponse.Plugin({ statuses: [0, 200] }), new workbox.expiration.Plugin({ maxEntries: 1, maxAgeSeconds: year })] }), 'GET');```
45	manoramaonline.com.js	Code Injection	High	true	N/A	N/A	eval	standard	{The code snippet contains a direct use of `eval(body)` where `body` is the result of `response.text()`, meaning it executes arbitrary JavaScript received from a remote fetch. Since the URL for the fetch is dynamically constructed from the `e` object (which is derived from a request), and the response is not sanitized or validated, an attacker can control the content of the response, leading to arbitrary code execution. This is a classic case of code injection via `eval` with untrusted input.}	```const runScript = (thisScriptTag) => {\n if (!scriptTag) {\n let init = {\n method: '${e.method}',\n headers: ${function (e) {\n let t = {};\n for (let i of e.entries()) t[i[0]] = i[1];\n return JSON.stringify(t, null, '\t');\n }(e.headers)},\n mode: '${e.mode}',\n credentials: '${e.credentials}',\n cache: '${e.cache}',\n redirect: '${e.redirect}',\n referrer: '${e.referrer}',\n referrerPolicy: '${e.referrerPolicy}',\n integrity: '${e.integrity}'};\n \n let request = new Request('${r}', init);\n \n fetch(request).then((response) => {\n if (response.status === 200) {\n response.text().then((body) => {\n eval(body);\n });\n }\n });\n } else {\n setTimeout(function() {\n let scriptClone = document.createElement('script');\n \n for (let index = 0; index < scriptTag.attributes.length; index++) {\n let attribute = scriptTag.attributes.item(index);\n scriptClone.setAttribute(attribute.name, attribute.value);\n }\n \n scriptClone.src = '${r}';\n scriptClone.setAttribute('aka3pm', 'true');\n \n scriptClone.async = false;\n \n let parent = scriptTag.parentNode;\n parent.insertBefore(scriptClone, scriptTag);\n parent.removeChild(scriptTag);\n }, 0);\n }\n }```
46	blic.rs.js	Insecure External Resource Loading	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a risk if the external resource is compromised or if the script is not properly vetted. Although the URL is hardcoded here, the vulnerability is still considered sensitive because it allows execution of untrusted code from a third-party CDN, which could be exploited if the CDN is compromised or if the script is malicious. This is a known risk in service worker security, especially when relying on external SDKs.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
47	simpcity.su.js	Improper Regular Expression Handling in URL Filtering	High	true	CWE-79	9	N/A	standard	{The vulnerability arises from the use of a regular expression in `request.url.match(/\/admin\.php|\/install\/|\/download($|&|\?)|[/?]attachments\/|google-ad|adsense/)` without proper escaping or sanitization. While the regex itself is static, the `match` function is applied to `request.url`, which is derived from the incoming fetch request — a dynamic, untrusted input. If an attacker can manipulate the URL to trigger unintended matches (e.g., via URL encoding, path traversal, or malformed query strings), they may bypass the intended filtering logic. This could allow access to restricted resources or enable unintended behavior, such as bypassing preloading or cache logic. The `match` function, being a standard JavaScript method, is misused here by applying it to untrusted input without validation or sanitization, leading to improper filtering.}	```const request = event.request; if (request.url.match(/\/admin\.php|\/install\/|\/download($|&|\?)|[/?]attachments\/|google-ad|adsense/)) { if (supportPreloading && event.preloadResponse) { event.respondWith(event.preloadResponse); } return; }```
48	aajtak.in.js	Third-party Code Vulnerability (Untrusted Script Import)	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in service workers to load and execute external scripts. While the URL 'service-worker-izooto.js' is hard-coded and not dynamically derived from untrusted input, the act of importing third-party scripts introduces a high-risk vulnerability because the script's content is not under the control of the application. This allows the third-party script to potentially perform malicious actions such as intercepting network requests, modifying cache behavior, or exfiltrating data. Although not dynamically sourced, the lack of trust in the third-party script constitutes a sensitive function misuse in the context of service worker security.}	```importScripts('service-worker-izooto.js');```
49	saednews.com.js	Cross-Site Scripting (XSS) via unvalidated push notification data	High	true	CWE-79	9	N/A	standard	{The function `self.registration.showNotification()` is used with data derived from `event.data.json()`, which is unvalidated and potentially controlled by an attacker. If the notification title or body contains malicious script, and if the browser renders it in a context where script execution is possible (e.g., via rich notification content or DOM injection), it can lead to XSS. The data is not sanitized, making this a direct misuse of a standard API that accepts untrusted input.}	"```const data = event.data ? event.data.json() : { title: ""Notification from "" + self.registration.scope, link: ""/"" }; if ((self.Notification || {}).permission === ""granted"") { data.tag = ""app.sw.notification""; data.renotify = true; await self.registration.showNotification(data.title, data); }```"
50	saednews.com.js	Open Redirect via unvalidated notification click handler	Medium	true	CWE-601	8	N/A	standard	{The function `self.clients.openWindow(link)` is called with a `link` value derived from unvalidated notification data. Since the `link` is not sanitized or validated against a whitelist of allowed origins, an attacker can craft a notification with a malicious URL, causing the browser to open an arbitrary external site, leading to an open redirect. This is a misuse of a standard API that accepts untrusted input without proper validation.}	```if (self.clients.openWindow) { await self.clients.openWindow(link); }```
51	livehindustan.com.js	Cache Poisoning via Overly Permissive Regex	High	true	CWE-79	N/A	const pageRoutes = ['/', '/national/', ... , new RegExp('^https?://.*\\.html$')];	standard	{The use of a dynamically constructed or overly permissive regular expression in workbox.routing.registerRoute with new RegExp('^https?://.*\\.html$') allows any URL matching the pattern to be cached using the NetworkFirst strategy. Since the regex matches any domain (via .*), an attacker could potentially craft a malicious URL that bypasses intended routing logic and gets cached, leading to cache poisoning. The sensitive function here is RegExp, which is a standard JavaScript function, and its misuse lies in allowing untrusted or overly broad patterns to be used in routing decisions.}	```const pageRoutes = ['/', '/national/', '/state/', '/international/', '/cricket/', '/sports/', '/astrology/', '/business/', '/gallery/', '/career/', '/health/', '/lifestyle/', '/blog/', '/gadgets/', '/auto/', '/crime/', '/entertainment', '/national', '/state', '/international', '/cricket', '/sports', '/astrology', '/business', '/gallery', '/career', '/health', '/lifestyle', '/blog', '/gadgets', '/auto', '/crime', new RegExp('^https?://.*\\.html$')];```
52	carwale.com.js	Insecure use of clients.openWindow with unvalidated URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using clients.openWindow with a URL derived from notificationData.detailUrl, which is sourced from untrusted push notification data. However, clients.openWindow is not a sensitive function in the context of direct code execution or arbitrary script loading; it merely opens a new window or tab. The risk is more related to open redirect or phishing, not sensitive function misuse.}	```self.clients.matchAll().then(clients => { for (let i = 0; i < clients.length; i++) { const client = clients[i]; client.postMessage({ command```
53	carwale.com.js	Exposure of FCM token in URL without CSRF protection	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from including the FCM token in the URL via getRegistrationUrl, which is then used in a fetch call. While this is a security issue (token exposure), it is not caused by misuse of a sensitive JavaScript function like importScripts or eval. The function fetch is used correctly; the issue is in the URL construction logic.}	```fetch(getRegistrationUrl(isRegisteredToFcm, fcmToken), { method: 'GET', credentials: 'same-origin', headers: { 'Content-Type': 'application/json' } })```
54	carwale.com.js	Improper input validation in URL construction	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to concatenating the FCM token directly into the URL without sanitization or validation. This is a logic flaw in URL construction, not misuse of a sensitive JavaScript function. The function used (concatenation via + operator) is not inherently sensitive.}	```var gcmId = '?gcmid=' + fcmToken; var subsMasterId = isRegisteredToFcm ? '&subsmasterid=1' : '';```
55	carwale.com.js	Potential open redirect in customTracking.getTrackingUrl	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from passing untrusted data (notificationData.title, alertId, alertTypeId) into customTracking.getTrackingUrl, which may construct URLs that redirect to arbitrary domains. However, customTracking.getTrackingUrl is a custom function, and its misuse is not due to a standard sensitive function like importScripts or eval. The issue is in the function's implementation, not in the misuse of a known sensitive API.}	"```fetch(customTracking.getTrackingUrl(""WebNotification"", ""NotificationClick"", customTracking.getEventLabel(notificationData.title, notificationData.alertId, notificationData.alertTypeId)), { credentials: 'same-origin' })```"
56	an1.com.js	Cache Poisoning via Unvalidated Cache Match	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of validation or sanitization of the request being matched in the cache, not from misuse of a sensitive function. The code uses standard caching behavior with caches.match(), which is safe when used correctly. Since the request object is directly derived from the event and not constructed from untrusted input, there is no direct misuse of a sensitive function.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); })); });```
57	screener.in.js	XSS via Untrusted Push Data	High	true	CWE-79	10	self.registration.showNotification	standard	{The function self.registration.showNotification is used with data parsed from untrusted push message content (data.title, data.options). If an attacker controls the push payload, they can inject malicious content into the notification, potentially leading to XSS if the notification UI renders the content in a way that executes scripts (e.g., via rich content or if the browser interprets certain HTML/JS in notifications).}	```(function () { function listenToPush() { self.addEventListener('push', function (event) { var data = event.data.text(); data = JSON.parse(data); self.registration.showNotification(data.title, data.options); }); } function listenToNotificationClick() { self.addEventListener('notificationclick', function (event) { var url = event.notification.data; if (event.action === 'close') { event.notification.close(); } else { clients.openWindow(url); event.notification.close(); } }); } function listenPwaRequests() { self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request)); }); } function installImmediately() { self.addEventListener('install', function (event) { console.log('installing new service-worker without waiting'); self.skipWaiting(); }); } function setupServiceWorker() { listenToPush(); listenToNotificationClick(); installImmediately(); } setupServiceWorker(); })();```
58	screener.in.js	Open Redirect via Notification Click	Medium	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is called with a URL derived from event.notification.data, which is untrusted and potentially controlled by an attacker. This allows an attacker to redirect users to arbitrary websites, leading to phishing or malicious site redirection.}	```(function () { function listenToPush() { self.addEventListener('push', function (event) { var data = event.data.text(); data = JSON.parse(data); self.registration.showNotification(data.title, data.options); }); } function listenToNotificationClick() { self.addEventListener('notificationclick', function (event) { var url = event.notification.data; if (event.action === 'close') { event.notification.close(); } else { clients.openWindow(url); event.notification.close(); } }); } function listenPwaRequests() { self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request)); }); } function installImmediately() { self.addEventListener('install', function (event) { console.log('installing new service-worker without waiting'); self.skipWaiting(); }); } function setupServiceWorker() { listenToPush(); listenToNotificationClick(); installImmediately(); } setupServiceWorker(); })();```
59	rt.com.js	Missing Fetch Event Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability 'Missing Fetch Event Handling' is not caused by the misuse of a sensitive JavaScript function. It refers to the absence of meaningful logic within the fetch event handler, which may lead to missed opportunities for intercepting and modifying network requests, but does not stem from unsafe use of a function like importScripts, eval, or similar.}	```self.addEventListener('fetch', () => {});```
60	stripchat.com.js	Improper Validation of WebSocket Messages	High	true	N/A	N/A	WebSocket	standard	{The WebSocket API is used without validating incoming messages, allowing an attacker to inject malicious payloads that could be processed by the service worker, leading to unauthorized actions or data exposure. The code does not perform any checks on the data received via WebSocket, making it vulnerable to improper message validation.}	```if (this._transportIsOpen = !0```
61	stripchat.com.js	Insecure Data Storage in IndexedDB	Medium	true	N/A	N/A	IndexedDB	standard	{IndexedDB is used to store data without proper encryption or access controls, which could lead to sensitive data exposure if the device is compromised. The setItem method stores data directly without any sanitization or encryption, making it vulnerable to insecure data storage.}	N/A
62	stripchat.com.js	Potential SSRF via Unvalidated URL	High	true	N/A	N/A	fetch	standard	{The fetch function is used with user-controlled URLs without validation, allowing an attacker to redirect requests to internal or external services, potentially leading to SSRF. The code does not validate or sanitize the URL before passing it to fetch, making it vulnerable to SSRF attacks.}	```send(e```
63	logitech.com.js	Insecure Cache Handling	High	true	N/A	N/A	URL	standard	{The code constructs a URL using `new URL(e.url, location.href)` where `e.url` is derived from a request object. Although it checks for HTTP protocols and same-origin, if an attacker can manipulate the request URL (e.g., via a crafted fetch request), this could lead to unintended cache operations or bypasses, especially if the URL is not properly sanitized. The use of `new URL()` with untrusted input is a known vector for URL-based attacks, including cache poisoning or redirection.}	```const s = new URL(e.url, location.href); if (!s.protocol.startsWith('http')) return void 0; const n = s.origin === location.origin, { params: r, route: a } = this.findMatchingRoute({ event: t, request: e, sameOrigin: n, url: s });```
64	logitech.com.js	Insecure URL Handling in Cache Listener	High	true	N/A	N/A	Request	standard	{The code uses `new Request(...t)` where `t` is derived from `urlsToCache` passed via a message event. If an attacker can control the `urlsToCache` array (e.g., via a malicious client message), they can inject arbitrary URLs into the `Request` constructor, leading to unintended network requests or cache operations. This is a classic case of unsafe use of `Request` with untrusted input, which can be exploited for cache manipulation or network interception.}	```const s = Promise.all(t.urlsToCache.map(t => { 'string' == typeof t && (t = [t]); const s = new Request(...t); return this.handleRequest({ request: s, event: e }); }));```
65	logitech.com.js	Potential ReDoS in Route Matching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of regular expressions in route matching (e.g., `a.match({ url: e, sameOrigin: t, request: s, event: n })`), which may be subject to ReDoS if the regex patterns are complex or crafted by an attacker. However, this is not caused by misuse of a sensitive function like `importScripts` or `eval`, but rather by the inherent risk in regex processing. Therefore, it is not classified as a sensitive function misuse.}	```const i = a.match({ url: e, sameOrigin: t, request: s, event: n });```
66	mediavine.com.js	Insecure URL Matching in Cache Strategy	High	true	N/A	N/A	includes	standard	{The function `includes` is used to check if a URL contains the `siteHostname`, which is a hardcoded value. While this is not inherently dangerous, the vulnerability arises because the URL matching logic is overly permissive and does not validate the full origin or path structure. This could allow an attacker to craft a URL that bypasses intended restrictions by including the hostname as a substring, potentially leading to unintended caching or execution of malicious content. The misuse lies in the lack of strict origin validation rather than the function itself.}	```const e = new P(({ url: e }) => e.url.includes(siteHostname) && e.request.method === 'GET'```
67	mediavine.com.js	Improper Validation of Ignored Paths	Medium	true	N/A	N/A	includes	standard	{The function `includes` is used to check if a URL contains any of the ignored paths. This is problematic because `includes` performs substring matching, not path prefix or exact matching. An attacker could exploit this by including an ignored path as a substring within a different path (e.g., `/wp-admin/` vs `/wp-administration/`), bypassing the intended security restriction. This leads to improper validation and potential exposure of sensitive endpoints.}	```const e = !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); });```
68	urbanairship.com.js	Use of Hard-coded Credentials	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded credentials (appKey, token, vapidPublicKey) embedded directly in the script. These are not the result of misuse of a sensitive function but rather poor secret management.}	```importScripts('https://aswpsdkus.com/notify/v2/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://hangar\u002Ddl.urbanairship.com/binary/public/eMDVmwPuRPqxjK\u002DbqGNsCw/c0f3b8bc\u002D8721\u002D4702\u002Da1c1\u002D555fd3fedc36', defaultTitle: 'Airship', defaultActionURL: 'https://www.airship.com', appKey: 'eMDVmwPuRPqxjK-bqGNsCw', token: 'MTplTURWbXdQdVJQcXhqSy1icUdOc0N3Ojl6ZG1vNF82MVF2WXFQSEFBRC1GRnQyeVZQckRSTzVRTEVGZkxmVC1Td0E', vapidPublicKey: 'BAHJ96VS_1vEoPIFDOUQ6kg2DxXPsALyWughmunm5eKYeA8-sQwDqL2mkH_Tole70BwqrBK_6YAqi0XEholutj0=' });```
69	urbanairship.com.js	Use of Publicly Known Insecure Cryptographic Algorithm	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the use of a potentially insecure cryptographic algorithm (VAPID public key) in the context of push notifications. This is not caused by misuse of a sensitive function but by the choice of cryptographic parameters.}	```importScripts('https://aswpsdkus.com/notify/v2/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://hangar\u002Ddl.urbanairship.com/binary/public/eMDVmwPuRPqxjK\u002DbqGNsCw/c0f3b8bc\u002D8721\u002D4702\u002Da1c1\u002D555fd3fedc36', defaultTitle: 'Airship', defaultActionURL: 'https://www.airship.com', appKey: 'eMDVmwPuRPqxjK-bqGNsCw', token: 'MTplTURWbXdQdVJQcXhqSy1icUdOc0N3Ojl6ZG1vNF82MVF2WXFQSEFBRC1GRnQyeVZQckRSTzVRTEVGZkxmVC1Td0E', vapidPublicKey: 'BAHJ96VS_1vEoPIFDOUQ6kg2DxXPsALyWughmunm5eKYeA8-sQwDqL2mkH_Tole70BwqrBK_6YAqi0XEholutj0=' });```
70	urban-vpn.com.js	Improper Input Validation - Untrusted URL Execution	High	true	CWE-20	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. In this case, the URL is derived directly from event.notification.data.url, which originates from a push notification payload. Since push notification data is untrusted and can be controlled by an attacker, this allows for arbitrary URL redirection or execution of malicious scripts if the URL points to a malicious site. This constitutes a high-risk vulnerability due to potential phishing, drive-by downloads, or further exploitation.}	```clients.openWindow(event.notification.data.url);```
71	padlet.com.js	Insecure External Script Import	High	true	CWE-829	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted on padlet.net. While the URL is not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a high-risk dependency. If the remote script is compromised or the domain is hijacked, the service worker could be coerced into executing malicious code, leading to cache manipulation, network interception, or data exfiltration. This constitutes a sensitive function misuse due to the inherent trust required in the imported script.}	```importScripts('https://padlet.net/assets/serviceworker-a8190598253cbf618aef02f7aa3c2b93b9e88bd32a53ce6e4d98907e4962f9c9.js');```
72	mpg.de.js	Vulnerable Data Handling in Notification Click	High	true	N/A	9	openOrFocusWindow	standard	{The function openOrFocusWindow is called with user-controlled data from event.notification.data.link, which is derived from a push notification. This allows an attacker to craft a notification that redirects the user to an arbitrary URL, potentially leading to phishing or malicious site redirection. The function uses sw.clients.openWindow(link), a standard API that executes navigation to the provided URL without validation, making it a sensitive function misuse.}	```event.waitUntil(openOrFocusWindow(event.notification.data.link));```
73	mpg.de.js	Unvalidated Input in Push Data Handling	High	true	N/A	9	sw.registration.showNotification	standard	{The push notification data is parsed and used directly in sw.registration.showNotification without validation. The 'link' field from receivedData is used in the notification's data object, which is later passed to openOrFocusWindow. Since the input is derived from untrusted push data, an attacker can inject arbitrary URLs, leading to unauthorized navigation. The showNotification function is a standard API that accepts user-controlled data in its options, making it sensitive when used with unvalidated input.}	"```_c = receivedData.link, link = _c === void 0 ? ""https://www.mpg.de"" : _c```"
74	mpg.de.js	Unvalidated Input in Notification Data	High	true	N/A	9	sw.registration.showNotification	standard	{The notification title, body, icon, and image are derived from untrusted push data (receivedData) and passed directly to sw.registration.showNotification. While these fields are typically not directly executable, they can be used to craft misleading or malicious notifications. More critically, the 'data' object within the notification includes a 'link' field that is later used to open a window, creating a chain of unvalidated input leading to potential redirection attacks. The showNotification function is a standard API that accepts user-controlled data, and its misuse here enables indirect exploitation via the data field.}	```event.waitUntil(sw.registration.showNotification(title, { body: body, icon: icon, data: { link: link }, image: image, requireInteraction: true }));```
75	inmotionhosting.com.js	Arbitrary Code Execution via Dynamic Function Construction	High	true	N/A	N/A	New Function Construction	standard	{The code dynamically constructs and executes JavaScript functions using `new Function()` within the Partytown framework. This is triggered when a script is loaded via `importScripts()` and processed by `be(l,s,a||o)`, where `s` is the script content fetched from a remote URL. Since the script content is not sanitized and can be controlled by an attacker (e.g., via a malicious `sw.html` or `proxytown` endpoint), this allows for arbitrary code execution. The `new Function()` construct is inherently dangerous when used with untrusted input, as it bypasses normal JavaScript parsing and execution safeguards.}	```const e = new Map(), t = (e, t) => ({ F: e.F, p: t }), r = (e, t) => new Response(e, { headers: { 'content-type': t || 'text/html', 'Cache-Control': 'no-store' } }); self.oninstall = () => self.skipWaiting(), self.onfetch = n => { const i = n.request, s = new URL(i.url).pathname; s.endsWith('sw.html') ? n.respondWith(r('<!DOCTYPE html><html><head><meta charset=\'utf-8\'><script type=\'module\'>/* Partytown 0.10.2 - MIT builder.io */\n(e=>{const t=()=>{},r=e=>e.length,n=e=>{var t,r,n;try{const r=null===(t=null==e?void 0:e.constructor)||void 0===t?void 0:t.name;if(r)return r}catch(e){}try{const t=null===(n=null===(r=null==e?void 0:e.__zone_symbol__originalInstance)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name;if(t)return t}catch(e){}return\'\'},i=(e,t)=>e.startsWith(t),s=e=>!(i(e,\'webkit\')||i(e,\'toJSON\')||i(e,\'constructor\')||i(e,\'toString\')||i(e,\'_\'),...))```
76	tubitv.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('https://cdn.adrise.tv/tubitv-assets/js/braze/4.3/service-worker.js'), which is not dynamically derived from untrusted input. However, since the URL is hardcoded and points to an external domain, it introduces a risk if the external script is compromised or if the domain is controlled by an attacker. While not directly caused by user-controlled input, the use of importScripts() with an external script source is inherently risky and can lead to remote code execution if the script is malicious. The vulnerability is considered high severity because the service worker can be compromised, leading to full control over caching, network requests, and potentially user data.}	"```self.importScripts(""https://cdn.adrise.tv/tubitv-assets/js/braze/4.3/service-worker.js"");```"
77	ask.com.js	Loading untrusted external script in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function in Service Workers loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., from a third-party CDN), it introduces a risk if the script source is untrusted or compromised, allowing an attacker to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or request interception.}	```importScripts('https://cdn.aimtell.com/sdk/aimtell-worker-sdk.js');```
78	tbank.ru.js	Open Redirect Vulnerability	High	true	N/A	9	N/A	standard	"{The function `G` is used to construct a URL by resolving a hostname from a mapping (`F`) and then using `q` to build a new URL with a potentially untrusted hostname. The input to `G` comes from `B(t)`, which extracts a `RedirectURL` from the notification data, which is untrusted. Since `q` uses `new URL(t, ""https://"".concat(n))`, if `n` is controlled by an attacker, it can redirect to any domain, leading to an open redirect. This misuse of `new URL()` with untrusted input is a standard sensitive function misuse.}"	```var c = G(c, (o = self) === null || o === void 0 ? void 0 : (i = o.location) === null || i === void 0 ? void 0 : i.hostname), c = J(c, { startFrom: 'pwa' });```
79	tbank.ru.js	Insecure Data Handling in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from storing `self._appKey` in an IndexedDB instance without proper sanitization or validation. However, this is not caused by misuse of a sensitive JavaScript function, but rather by insecure data handling practices. The `P` class uses standard IndexedDB APIs, but the issue is in the data being stored, not in the function misuse.}	```var j = new P({ appKey: self._appKey });```
80	tbank.ru.js	Improper Input Validation in URL Construction	Medium	true	N/A	8	N/A	standard	{The function `J` constructs a URL by appending query parameters to a base URL derived from `t`, which is obtained from the notification data. Since `t` is untrusted, and `J` uses `new URL(t)` without validating the input, an attacker can supply a malicious URL, leading to improper URL construction. The `new URL()` function is a standard sensitive function when used with untrusted input.}	```var c = G(c, (o = self) === null || o === void 0 ? void 0 : (i = o.location) === null || i === void 0 ? void 0 : i.hostname), c = J(c, { startFrom: 'pwa' });```
81	tbank.ru.js	Phishing via Untrusted Notification Content	High	true	N/A	9	N/A	standard	{The function `w` constructs a notification object using data from `e`, which is parsed from the push message payload. The `title` field is extracted from `e.notification.title`, which is untrusted. Since `showNotification` is called with this untrusted content, an attacker can craft a notification with a deceptive title, leading to phishing. The `showNotification` API is a standard sensitive function when used with untrusted input.}	```var u = w(e), a = (o = e === null || e === void 0 ? void 0 : (n = e.notification) === null || n === void 0 ? void 0 : n.title) !== null && o !== void 0 ? o : '';```
82	independent.ie.js	Insecure Dependency Usage	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (https://aswpsdkus.com/notify/v1/ua-sdk.min.js), it introduces a risk if the external script is compromised or if the domain is not fully trusted. Although the URL is hardcoded and not dynamically constructed from untrusted input, the dependency itself is external and could be a vector for supply chain attacks if the source is not properly vetted. Thus, it qualifies as sensitive function misuse due to the inherent risk of loading remote code.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
83	independent.ie.js	Hardcoded Secrets	High	false	N/A	N/A	N/A	N/A	{The hardcoded secrets (appKey and token) are not the result of sensitive function misuse. They are simply embedded directly in the code, which is a static secret exposure issue, not a dynamic misuse of a function.}	```appKey: '5gVRm9E8QVuw1iu5QjmtJg',```
84	independent.ie.js	Hardcoded Secrets	High	false	N/A	N/A	N/A	N/A	{The hardcoded secrets (appKey and token) are not the result of sensitive function misuse. They are simply embedded directly in the code, which is a static secret exposure issue, not a dynamic misuse of a function.}	```token: 'MTo1Z1ZSbTlFOFFWdXcxaXU1UWptdEpnOm5ZdU9RU2lmRV9PS1EzSGFpMGMzRXFkWW9UX09SZ1JQVFR1RUd5RHZzSEk',```
85	libero.it.js	Improper Cache Key Generation	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the misuse of the `indexOf` and `substr` methods in the `cacheKeyWillBeUsed` function. These standard JavaScript functions are used to manipulate the request URL by stripping query parameters, but they do so without proper validation or sanitization. This allows attackers to craft URLs with malicious query strings that may bypass intended caching logic or cause unintended cache key collisions, leading to improper cache key generation and potential cache poisoning or data leakage.}	"```var urla = request.url; var im = urla.indexOf(""/?""); if (im > -1) return urla.substr(0, im); im = urla.indexOf(""?refresh_ce""); if (im > -1) return urla.substr(0, im); return request;```"
86	stern.de.js	Dynamic Script Import with User-Controlled Input Leading to Remote Code Execution	High	true	CWE-94	10	importScripts(`https://static.cleverpush.com/channel/worker/5JfME9rKQ2JGtdjx5.js` + self.location.search);	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When combined with user-controlled input (self.location.search), it allows an attacker to manipulate the script URL dynamically. This enables remote code execution by injecting malicious scripts from arbitrary domains, leading to full compromise of the service worker's execution context.}	"```importScripts(""https://static.cleverpush.com/channel/worker/5JfME9rKQ2JGtdjx5.js"" + self.location.search);```"
87	livechat.com.js	Improper Handling of Exceptional Conditions (Offline Fallback)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of proper error handling or fallback logic when the offline page cannot be retrieved from the cache. However, this is not due to misuse of a sensitive function, but rather a design or logic flaw in the error recovery mechanism. The code attempts to return a cached offline page, but if that fails, no further fallback is provided, which could lead to a degraded user experience or potential denial of service in offline scenarios.}	```const cachedResponse = await cache.match(OFFLINE_URL); return cachedResponse;```
88	kustomerapp.com.js	Cache Poisoning via Insecure Cache Key Generation	High	true	CWE-434	9	N/A	standard	{The function `makeCacheKey` uses a regular expression to parse URLs and extract a filename, hash, and extension to generate a cache key. However, it does not validate or sanitize the input URL before using it to construct the cache key. If an attacker can manipulate the URL (e.g., via a crafted request), they could potentially cause cache key collisions or overwrite legitimate cached resources, leading to cache poisoning. The `RegExp` and string manipulation are standard functions, but their misuse in unsanitized input contexts introduces the vulnerability.}	```const [, namePart, hash, extension] = matched; return { key: `${namePart}.${extension}`, value: { hash, url } };```
89	kustomerapp.com.js	Incorrect Cache-Control Handling Leading to Long-Term Caching	Medium	false	CWE-546	0	N/A	N/A	{The vulnerability arises from a logic flaw in the `isHeaderAgeValid` function, which checks if the `max-age` directive is greater than or equal to 30,000,000 seconds (approximately 950 years). This is an incorrect interpretation of cache control policy and does not involve misuse of any sensitive JavaScript function. The function uses standard `Headers.get` and `matchAll`, but the issue is in the business logic, not function misuse.}	```if (key === 'max-age') { const seconds = Number(value); return seconds >= 30_000_000; }```
90	kustomerapp.com.js	Lack of Content-Type Validation in Cache Storage	High	true	CWE-434	8	N/A	standard	{The `fetchWithRetry` function fetches a response and stores it in the cache without validating the `Content-Type` header. The `caches.put` function is a standard API that blindly stores the response. If an attacker can manipulate the response to have a malicious content type (e.g., JavaScript) and the cache key is derived from a predictable pattern, this could lead to cache poisoning or execution of malicious content. The misuse lies in not validating the response before caching, which is a direct consequence of improper use of the `caches.put` standard API.}	```if (response.ok && isHeaderAgeValid(response.headers)) { const cloned = response.clone(); (async () => { const yoda = await getCache(); await yoda.put(request, cloned); keysToUrls.set(record.key, record.value); })(); }```
91	20minutes.fr.js	Use of a Known Vulnerable Third-Party Component	High	false	N/A	0	N/A	N/A	{The vulnerability is due to the use of a third-party script from an external source (https://via.batch.com/v4/worker.min.js), which may contain known vulnerabilities. However, this is not caused by misuse of a sensitive JavaScript function, as the importScripts() call is using a hardcoded, trusted URL and not dynamic or user-controlled input.}	```importScripts('https://via.batch.com/v4/worker.min.js');```
92	nd.edu.js	Insecure Credential Handling in Cache Requests	High	true	CWE-306	10	N/A	standard	{The function caches.open() is used to access a cache, and cache.put() is used to store responses. While these are standard functions, the vulnerability arises from the fact that credentials are included in requests (via credentials: 'include') without proper validation or sanitization. This allows sensitive data to be cached and potentially exposed to unauthorized parties if the cache is accessed improperly or if the service worker is compromised. The misuse lies in the lack of control over what is cached with credentials, which can lead to credential leakage.}	```caches.open(cacheName).then(cache => cache.put(request```
93	nd.edu.js	Information Exposure via Unfiltered Header Cloning	Medium	true	CWE-200	9	N/A	standard	{The for-in loop iterates over request.headers and copies each header into a new Headers object without filtering or sanitization. This can expose sensitive headers (e.g., Authorization, Cookie) to the service worker, which may then be logged, transmitted, or otherwise leaked. The sensitive function here is Headers.set(), which is part of the standard Web API, and its misuse occurs when untrusted or sensitive header data is copied without validation.}	```for (var i in request.headers) { reqHeaders.set(i, request.headers[i]);```
94	nd.edu.js	Information Exposure in Offline Page Metadata	Medium	true	CWE-200	8	N/A	standard	{The function caches.match() is used to retrieve cached responses, and response.text() is used to extract HTML content. The extracted title and description are then sent via event.ports[0].postMessage(), which can expose sensitive metadata (e.g., page titles, descriptions) to the client or other contexts. The sensitive function is caches.match(), which is standard, and its misuse occurs when the retrieved content is not sanitized before being exposed to the client.}	```caches.open(pagesCacheName).then(function (cache) { cache.keys().then(function (keys) { keys.forEach(function (request, index, array) { getResponseMeta(cache, request).then(meta => { if (meta) pages.push(meta); if (index == array.length - 1) event.ports[0].postMessage({'offline_pages': pages}); }); }); });```
95	kaiserpermanente.org.js	Improper Input Validation	High	true	CWE-20	N/A	split	standard	{The function `split` is used on user-controlled input `s` without validation, which can lead to improper input handling and potential injection or parsing issues, especially if `s` contains unexpected or malicious delimiters.}	"```const a = s.split("","")[0].split(""|"").map(e => e.split("":"")).reduce((e, t) => { const s = t[1].trim(); return e[t[0].trim().toLowerCase()] = isNaN(s) ? s : +s, e; }, {});```"
96	kaiserpermanente.org.js	Cross-Site Scripting (XSS)	High	true	CWE-79	N/A	Object.assign	standard	{The `Object.assign` function is used to merge `t.profile` with a potentially untrusted `geolocation` object from `this.state.config.geolocation`, which may contain user-controlled data. If this data is later rendered in the DOM without sanitization, it can lead to XSS.}	```t.profile = Object.assign({}, t.profile, { geolocation: this.state.config.geolocation });```
97	kaiserpermanente.org.js	Insecure Data Storage	Medium	true	CWE-532	N/A	get	standard	{The `get` function is used to retrieve data from `this.state.store` (i.e., `i`) without proper access controls or validation, allowing potentially sensitive data to be exposed or manipulated if the key is derived from untrusted input.}	```const a = this.state.get(g, n) || [];```
98	kaiserpermanente.org.js	Denial of Service (ReDoS)	Medium	true	CWE-400	N/A	RegExp	standard	{The `RegExp` constructor is used with user-controlled `s.path` to create a regular expression, which can lead to ReDoS if the pattern is crafted to cause exponential backtracking during the `test` operation.}	```new RegExp(s.path).test(t);```
99	kaiserpermanente.org.js	Insecure Communication	Low	false	CWE-319	N/A	N/A	N/A	{The `fetch` function is used without explicit HTTPS enforcement, but it is not directly misused with untrusted input; the vulnerability stems from lack of transport security rather than sensitive function misuse.}	"```fetch(e.request, { credentials: ""include"" });```"
100	pixlr.com.js	Improper Input Validation in Service Worker Cache Handling	High	true	N/A	N/A	caches.open	standard	"{The caches.open() function is used to open a cache storage by name, and while it does not directly execute arbitrary code, its misuse in conjunction with unvalidated or untrusted input (e.g., if the cache name were derived from user input) could lead to improper cache handling or unintended cache access. However, in this case, the cache name ""suite"" is hardcoded, so the vulnerability is not directly caused by sensitive function misuse.}"	```const SUITE = await caches.open('suite')```
101	pixlr.com.js	Cross-Site Scripting via Malicious Cache Injection	High	true	N/A	N/A	caches.addAll	standard	{The caches.addAll() function is used to add multiple resources to a cache. In this case, it is used with localizedPages(g), which is derived from i.data.lang — a value received from a message event. If an attacker can control the lang parameter, they could inject malicious URLs into the cache, potentially leading to XSS if those resources are later served to the client. This constitutes sensitive function misuse because the input is untrusted and directly used to populate the cache.}	"```try { SUITE = await caches.open('suite'), await SUITE.addAll([...bundles.suite, ...localizedPages(g), ""/site.webmanifest""]); } catch { await caches.delete('suite'); }```"
102	pixlr.com.js	Insecure Service Worker Message Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of incoming messages, particularly the lack of validation of message types and data. However, no sensitive JavaScript function is misused here — the issue is more about logic and control flow rather than a specific function that introduces risk when used with untrusted input.}	"```self.addEventListener('message', async i => { const g = i.ports[0]; if (g) { if (i.data) switch (console.info(""[MESSAGE]"", i.data), i.data.type) {```"
103	pixlr.com.js	Cache Poisoning via Untrusted Resource Injection	High	true	N/A	N/A	prefixLang	standard	{The prefixLang function constructs URLs by prepending a language path to a base path. If the language parameter (g) is derived from untrusted input (as it is from i.data.lang), and if this is used to construct URLs passed to caches.addAll(), it could allow an attacker to inject arbitrary resources into the cache. This is sensitive function misuse because the input is untrusted and directly used to construct URLs for caching.}	"```function prefixLang(i, g) { return ""us"" === g || """" === g ? i : `/${g}${i}`; }```"
104	tinkercad.com.js	Insecure External Resource Caching	Medium	true	New	7	N/A	standard	{The constant OFFLINE_FONT is defined with a hardcoded external URL. While not directly user-controlled, the use of fetch() to retrieve this external resource without validation or integrity checks introduces a medium-risk vulnerability. If the external resource is compromised or modified, the service worker may serve malicious content. The fetch() function is a standard JavaScript API that, when used with untrusted or unvalidated URLs, can lead to unintended resource loading.}	```const OFFLINE_FONT = 'https://swc.autodesk.com/pharmacopeia/fonts/ArtifaktElement/v1.0/WOFF2/Artifakt%20Element%20Regular.woff2';```
105	tinkercad.com.js	Unvalidated External Resource Fetch	Medium	true	New	8	N/A	standard	{The fetch() function is used to retrieve the OFFLINE_FONT resource without validating its origin or integrity. Since the URL is hardcoded but still external, it represents a potential vector for supply chain attacks if the external server is compromised. The fetch() API, being a standard JavaScript function, is misused here by not enforcing security checks on the external resource, leading to unvalidated external resource fetching.}	```return event.respondWith(fetch(event.request).catch(() => caches.match(OFFLINE_FONT)));```
106	365scores.com.js	Open Redirect	High	true	N/A	9	self.clients.openWindow(url);	standard	{The function clients.openWindow(url) is a standard browser API that opens a new window or tab with the specified URL. If the URL is derived from untrusted input (e.g., eventData.url), an attacker can manipulate it to redirect users to malicious sites, leading to phishing or credential theft. In this case, the URL is passed directly without validation or sanitization, making it a high-confidence open redirect vulnerability.}	```self.clients.openWindow(url);```
107	365scores.com.js	Improper Input Validation	Medium	true	N/A	8	const url = eventData.url ? await eventData.url : await entityUrlBuilder[eventData.entityType](eventData.entityId, eventData.websiteLang);	standard	{The code constructs URLs based on eventData.url or dynamically generated URLs via entityUrlBuilder. Since eventData is derived from push notification data (which can be controlled by an attacker), and no validation or sanitization is applied, this allows for improper input handling. The function buildUrl() and its dependencies (like buildGameUrl) may generate URLs with untrusted components, potentially leading to open redirects or other injection issues.}	```const url = eventData.url ? await eventData.url : await entityUrlBuilder[eventData.entityType](eventData.entityId, eventData.websiteLang);```
108	365scores.com.js	Use of Eval	High	true	N/A	10	y = y.replace(/(M+|d+|h+|m+|s+)/g, function (v) { return ((v.length > 1 ? '0' : '') + eval('z.' + v.slice(-1))).slice(-2); });	standard	{The use of eval('z.' + v.slice(-1)) dynamically evaluates a string as JavaScript code. Since v is derived from a regular expression match on a user-controlled format string (y), an attacker could potentially inject malicious code if the format string is not properly sanitized. This is a high-confidence use of eval, which is inherently dangerous and can lead to arbitrary code execution.}	```y = y.replace(/(M+|d+|h+|m+|s+)/g, function (v) { return ((v.length > 1 ? '0' : '') + eval('z.' + v.slice(-1))).slice(-2); });```
109	365scores.com.js	Information Exposure Through Log	Medium	false	N/A	N/A	N/A	N/A	{The console.log statement outputs self.defaultUserData, which may contain sensitive user information. However, this is not caused by misuse of a sensitive function but rather by logging sensitive data directly. The function console.log is not inherently sensitive in this context, and the vulnerability stems from poor data handling, not function misuse.}	```console.log('notification arrived bi event', self.defaultUserData);```
110	castbox.fm.js	Vulnerable Navigate Fallback Handling	High	true	CWE-20	10	N/A	standard	{The vulnerability arises from the use of `new URL(navigateFallback, self.location).toString()` where `navigateFallback` is a potentially untrusted or dynamically configured value. If this value is controlled by an attacker or improperly sanitized, it can lead to unintended navigation or cache poisoning, as the URL is constructed without validation and then used to check cache keys. This misuse of the standard `URL` constructor allows for arbitrary URL construction, which can be exploited to bypass intended security boundaries.}	```if (!shouldRespond && navigateFallback && event.request.mode === 'navigate' && isPathWhitelisted([], event.request.url)) { url = new URL(navigateFallback, self.location).toString(); shouldRespond = urlsToCacheKeys.has(url); }```
111	castbox.fm.js	Cache Poisoning via URL Parameters	High	true	CWE-20	9	N/A	standard	{The `stripIgnoredUrlParameters` function uses `new URL(originalUrl)` to parse and reconstruct URLs, then manipulates the search parameters by filtering based on regex patterns. However, if the input `originalUrl` is derived from untrusted sources (e.g., user-controlled query strings), and the filtering logic is insufficient or bypassed, it can allow malicious parameters to persist. The use of `URL` and subsequent string manipulation without proper sanitization or validation enables cache poisoning, where attackers can inject or manipulate cached resources by crafting URLs with specific parameters.}	```url.search = url.search.slice(1).split('&').map(function (kv) { return kv.split('='); }).filter(function (kv) { return ignoreUrlParametersMatching.every(function (ignoredRegex) { return !ignoredRegex.test(kv[0]); }); }).map(function (kv) { return kv.join('='); }).join('&');```
112	stripchatgirls.com.js	Insecure Storage of Sensitive Data in IndexedDB	High	true	CWE-311	10	indexedDB.open	standard	"{The function `indexedDB.open` is used to open a database connection, but the code does not validate or sanitize the database name or version, which could allow an attacker to manipulate the database schema or access unintended data if the input is derived from untrusted sources. However, in this case, the database name and version are hardcoded (`""PwaHealthcheckDB""` and `1`), so the misuse is not directly from dynamic input. The vulnerability arises from storing sensitive data (e.g., healthcheck configuration) in IndexedDB without proper encryption or access controls, which is a misuse of the storage API, not the function itself. Therefore, the function is not misused in a sensitive way here.}"	"```V = class { constructor(e, t, n = 1) { this.db = null; this.initializationPromise = null; this.dbName = e; this.storeName = t; this.dbVersion = n; this.init(); } init() { let e = indexedDB.open(this.dbName, this.dbVersion); this.initializationPromise = new Promise((t, n) => { e.onupgradeneeded = i => { i.target.result.createObjectStore(this.storeName, { keyPath: ""id"" }); }, e.onsuccess = i => { this.db = i.target.result; t(); }, e.onerror = i => { let r = i.target.error; console.error(""IndexedDB error:"", r); n(r); }; }); } getStore(e = ""readonly"") { if (!this.db) throw new Error(""Database is not initialized""); return this.db.transaction(this.storeName, e).objectStore(this.storeName); } async setItem(e, t) { return await this.initializationPromise; new Promise((n, i) => { let o = this.getStore(""readwrite"").put({ id: e, value: t }); o.onsuccess = () => n(); o.onerror = c => i(c.target.error); }); } async getItem(e) { return await this.initializationPromise; new Promise((t, n) => { let r = this.getStore().get(e); r.onsuccess = () => { r.result ? t(r.result.value) : t(null); }, r.onerror = o => n(o.target.error); }); } async removeItem(e) { return await this.initializationPromise; new Promise((t, n) => { let r = this.getStore(""readwrite"").delete(e); r.onsuccess = () => t(); r.onerror = o => n(o.target.error); }); } };```"
113	tf1.fr.js	Use of Untrusted Resource (Remote Script Import	High	true	CWE-928	10	importScripts	standard	{The importScripts function is used to load and execute a remote script from 'https://via.batch.com/v3/worker.min.js'. Although the URL is hardcoded, it is still considered a potential risk because it introduces an external dependency that could be compromised or altered by an attacker if the remote server is compromised. However, since the URL is not dynamically constructed from untrusted input, the risk is mitigated but not eliminated. The function is inherently sensitive as it executes arbitrary code from a remote source.}	```importScripts('https://via.batch.com/v3/worker.min.js');```
114	odnoklassniki.ru.js	Open Redirect via Unvalidated URL in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function self.clients.openWindow is a standard browser API that opens a new window or tab with the provided URL. When used with msg.url, which is derived from untrusted notification data, it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. The URL is not validated or sanitized, making it directly controllable by an attacker.}	```self.clients.openWindow(msg.url || '/');```
115	odnoklassniki.ru.js	Denial of Service via Malformed JSON Parsing	Medium	true	CWE-400	8	JSON.parse	standard	{The code attempts to parse event.data.json() without proper error handling or input validation. While JSON.parse is not directly called, event.data.json() is a standard method that parses JSON, and if the data is malformed, it can throw an exception, leading to denial of service by crashing the service worker or preventing further processing. The lack of robust error handling increases the risk of service disruption.}	```var msg = event.data.json();```
116	francebleu.fr.js	External Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL like 'https://via.batch.com/v3/worker.min.js', it is not inherently vulnerable. However, if the URL were derived from untrusted or dynamic input (e.g., from a query parameter or user-controlled data), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not dynamically constructed from user input, so the vulnerability is not due to sensitive function misuse but rather due to the inclusion of an external script from a third-party domain, which may pose a risk if the third party is compromised.}	```importScripts('https://via.batch.com/v3/worker.min.js');```
117	snapfish.com.js	Hard-coded sensitive information (API keys Tokens) In Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive data (API keys, tokens) in the client-side JavaScript, not due to misuse of a sensitive function.}	"```var config = '{""appserviceKey"":""BC2yTnEwDooU2TjFENNYXJt9-zRRUlfx9ckelyGmUdjmpHy9Y3c0rNzFkHOyim8JMT6Myz5TYPKwAYIIoIYm4ww="",""apiKey"":""ABEhYcQzWRS-yM3kaaRtMkQoA"",""accountToken"":""ABEvapLqe-xGFOCrH44nzFKHk"",""appver"":""0.0.0"",""apiHost"":""https://api.pushio.com"",""lazy"":false}';```"
118	snapfish.com.js	Loading external script without integrity check (importScripts)	Medium	true	N/A	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, potentially leading to code injection or compromise of the service worker. The URL is hardcoded but not dynamically derived from untrusted input, so the risk is medium due to lack of integrity verification rather than dynamic input injection.}	```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');```
119	futura-sciences.com.js	Third-party script import vulnerability	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party domain (e.g., 'https://notifpush.com/serviceworker.js'), it introduces a high-risk vulnerability because the script is executed with the same privileges as the service worker. If the third-party script is compromised or malicious, it can intercept network requests, manipulate cache, or perform other harmful actions. Although the URL is hardcoded, the vulnerability is still considered sensitive due to the trust placed in an external source.}	```importScripts('https://notifpush.com/serviceworker.js');```
120	pravda.com.ua.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (appKey) is hardcoded and exposed in the script, but it is not the result of misuse of a sensitive function.}	```self[`appKey`] = `ac81c471b10a28d123ebe01d3e84f381`;```
121	pravda.com.ua.js	External Code Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts function is used with a dynamically constructed URL derived from self[`hostUrl`], which is hardcoded but could be manipulated if the value were derived from untrusted input. Since the URL is not hardcoded directly and is built via string interpolation, it represents a potential vector for remote code execution if hostUrl were user-controllable.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
122	airasia.com.js	Improper Client Selection in Message Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from flawed logic in selecting a client based on message ID, not from misuse of a sensitive function. The code attempts to find a client by matching URL query parameters but falls back to an arbitrary client if none is found, which could lead to message delivery to unintended clients. This is a logic flaw, not a sensitive function misuse.}	```const client = ((clients, msgId) => { const tabId = msgId.split(\'.\').pop(); let client = clients.find(a => a.url.endsWith(`?${tabId}`)); client || (client = [...clients].sort((a, b) => a.url > b.url ? -1 : a.url < b.url ? 1 : 0)[0]); return client; })([...clients], accessReq.$msgId$);```
123	airasia.com.js	Potential Denial of Service via Message ID Collision	Medium	false	N/A	0	N/A	N/A	{This vulnerability stems from the use of a Map to track message responses with message IDs as keys, which could be exploited if attackers generate colliding IDs. However, no sensitive function is misused; it is a design flaw in message ID handling.}	```const resolves = new Map();```
124	airasia.com.js	Lack of Input Validation in Message Handling	Medium	false	N/A	0	N/A	N/A	{The code directly accesses ev.data without validating or sanitizing it, which could lead to unintended behavior. However, this is not due to misuse of a sensitive function but rather a lack of input validation.}	```const accessRsp = ev.data; const r = resolves.get(accessRsp.$msgId$);```
125	airasia.com.js	Insecure Script Inclusion in Response	Low	false	N/A	0	N/A	N/A	{The script tag is hardcoded and does not involve dynamic input or sensitive function misuse. The vulnerability is low severity due to the static nature of the script source, and no sensitive function is involved.}	```<script src=\'./partytown-sandbox-sw.js?v=0.10.2\'><\\/script>```
126	webinar.ru.js	Arbitrary Code Execution via Dynamic Function Construction	High	true	CWE-95	10	N/A	standard	{The vulnerability arises from the use of `new Function()` to dynamically construct and execute JavaScript code. The `Te` function takes a string `t` (which is derived from untrusted input via `r[1]` in `postMessage`) and passes it directly to `new Function(t).call(e.U)`. Since the input is not sanitized or validated, an attacker can inject arbitrary JavaScript code through the message payload, leading to remote code execution within the service worker context. This is a classic case of unsafe dynamic code evaluation using a standard JavaScript function.}	"```const Te=(e,t,r)=>{e.N=1,t=`with(this){${t.replace(/\\\\bthis\\\\b/g,""(thi$(this)?window:this)"").replace(/\\\\/\\\\/# so/g,""//Xso"")}\\\\n;function thi$(t){return t===this}};${(h.i.globalFns||[]).filter((e=>/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(e))).map((e=>`(typeof ${e}==\\\'function\\\'&&(this.${e}=${e}))`)).join("";"")};`+(r?""\\\\n//# sourceURL=""+r:""""),e.A||(t=t.replace(/.postMessage\\\\(/g,`.postMessage(\\\'${e.V}\\\',`)),new Function(t).call(e.U),e.N=0},```"
127	aboutamazon.com.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow() is a standard service worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted notification data (message.articleLink) without validation or sanitization, it allows an attacker to craft a malicious URL that redirects users to arbitrary sites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(message.articleLink));```
128	autoscout24.de.js	Improper Input Validation (JSON Parsing of User-Controlled Data)	High	true	CWE-20	9	JSON.parse	standard	{The code parses user-controlled data from the event.tag (which is derived from a sync tag) using JSON.parse without any validation or sanitization. An attacker could craft a malicious sync tag with malformed or malicious JSON, leading to potential injection or execution of unintended logic, especially if the parsed data is later used in dynamic operations.}	```const pv = JSON.parse(event.tag.replace('offline-tracking-', ''));```
129	lifehacker.ru.js	Untrusted External Script Inclusion	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently dangerous. However, in this case, the URL is hardcoded to a remote script hosted on lifehacker.ru, which may be controlled by an attacker or compromised. Since the script is loaded from an external source without any integrity checks or sanitization, it introduces a risk of remote code execution if the remote script is malicious. This constitutes a misuse of importScripts() in the context of untrusted external sources, even if the URL is hardcoded, because the origin is not fully trusted or verified.}	```importScripts('https://lifehacker.ru/wp-content/plugins/lh-push/frontend/sw.js?1');```
130	unian.net.js	Empty Fetch Event Handler	High	false	N/A	0	N/A	N/A	{The fetch event handler is empty, meaning no logic is implemented to intercept or handle network requests. While this is a security concern due to missed opportunities for enforcing security policies or caching strategies, it does not stem from misuse of a sensitive function.}	```self.addEventListener('fetch', function (event) {});```
131	kommersant.ru.js	Exposure of Sensitive Information in Client Code	High	false	CWE-532	0	N/A	N/A	{The vulnerability arises from hardcoded Firebase configuration, including the API key, which is exposed in client-side JavaScript. This is not due to misuse of a sensitive function but rather poor secret management.}	"```importScripts('https://www.gstatic.com/firebasejs/7.9.1/firebase-app.js'); importScripts('https://www.gstatic.com/firebasejs/7.9.1/firebase-messaging.js'); firebase.initializeApp({ apiKey: ""AIzaSyAlaGxRMkFkBYEXW9Selc8_nrX_81KU1hw"", authDomain: ""kommersantsite.firebaseapp.com"", databaseURL: ""https://kommersantsite.firebaseio.com"", projectId: ""kommersantsite"", storageBucket: ""kommersantsite.appspot.com"", messagingSenderId: ""635839491665"", appId: ""1:635839491665:web:00f1d6a3d9d3e96b9c9270"" }); const messaging = firebase.messaging(); messaging.setBackgroundMessageHandler(function (payload) { payload.data.data = JSON.parse(JSON.stringify(payload.data)); return self.registration.showNotification(payload.data.title, payload.data); }); self.addEventListener('notificationclick', function (event) { event.notification.close(); if (event.notification.data && event.notification.data.click_action) { const url = event.notification.data.click_action; event.waitUntil(clients.matchAll({ type: ""window"", includeUncontrolled: true }).then(function (windowClients) { for (let i = 0; i < windowClients.length; i++) { let client = windowClients[i]; if (client.url === url && ""focus"" in client) return client.focus(); } return clients.openWindow ? clients.openWindow(url) : 0; })); } });```"
132	kommersant.ru.js	Open Redirect via Untrusted URL in Notification Action	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL derived from event.notification.data.click_action without validating or sanitizing the URL. This allows an attacker to craft a notification payload with a malicious URL, leading to open redirect and potential phishing or malware distribution.}	"```if (event.notification.data && event.notification.data.click_action) { const url = event.notification.data.click_action; event.waitUntil(clients.matchAll({ type: ""window"", includeUncontrolled: true }).then(function (windowClients) { for (let i = 0; i < windowClients.length; i++) { let client = windowClients[i]; if (client.url === url && ""focus"" in client) return client.focus(); } return clients.openWindow ? clients.openWindow(url) : 0; })); }```"
133	kommersant.ru.js	Improper Input Validation in Notification Action Handling	Medium	true	CWE-20	8	clients.openWindow	standard	{The code uses clients.openWindow with a URL extracted from notification data without validating whether the URL is safe or conforms to expected patterns. This lack of input validation increases the risk of open redirect and other client-side attacks.}	"```if (event.notification.data && event.notification.data.click_action) { const url = event.notification.data.click_action; event.waitUntil(clients.matchAll({ type: ""window"", includeUncontrolled: true }).then(function (windowClients) { for (let i = 0; i < windowClients.length; i++) { let client = windowClients[i]; if (client.url === url && ""focus"" in client) return client.focus(); } return clients.openWindow ? clients.openWindow(url) : 0; })); }```"
134	rokna.net.js	Vulnerable URL Handling in Background Message	High	true	CWE-601	10	fetch	standard	{The fetch function is used with a dynamic URL derived from the 'impression' field in the message data, which is untrusted input. This allows an attacker to control the URL being fetched, potentially leading to arbitrary resource fetching, SSRF, or data exfiltration.}	```fetch(e).then();```
135	rokna.net.js	Vulnerable URL Handling on Notification Click	High	true	CWE-601	10	self.clients.openWindow	standard	{The self.clients.openWindow function is called with a URL derived from the 'url' field in the notification data, which is untrusted input. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```e.waitUntil(self.clients.openWindow(t.data.url));```
136	medonet.pl.js	External Script Import Without Integrity Check	High	true	CWE-494	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from an untrusted source. In this case, the script is imported from 'https://s-eu-1.pushpushgo.com/60cc5dad94edcde389f525de/worker.js', which could be compromised or modified by an attacker, leading to arbitrary code execution within the service worker context. This is a high-risk vulnerability because the service worker can intercept network requests, manipulate cache, and access sensitive data.}	```importScripts('https://s-eu-1.pushpushgo.com/60cc5dad94edcde389f525de/worker.js');```
137	townwork.net.js	Cache Poisoning via Greedy Regex	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of a greedy regex pattern in the CACHE_TARGET_PATTERN_LIST, which may match unintended URLs due to improper pattern design. However, this is not caused by misuse of a sensitive JavaScript function like importScripts, eval, or similar; instead, it stems from flawed logic in URL matching. Therefore, it is not a sensitive function misuse.}	```self.addEventListener('fetch', function (event) { var result = CACHE_TARGET_PATTERN_LIST.some(function (pathPattern) { var reg = new RegExp(pathPattern); return reg.test(event.request.url); }); if (!result) { return; } event.respondWith(fetch(event.request.clone()).then(function (fetchResponse) { if (fetchResponse.status === 200) { caches.open(CACHE_NAME).then(function (cache) { cache.put(event.request, fetchResponse.clone()); }); } else if (fetchResponse.status === 401) { return fetchResponse.clone(); } else if (fetchResponse.status >= 400) { return caches.open(CACHE_NAME).then(function (cache) { return cache.match(event.request).then(function (cacheResponse) { return cacheResponse || fetchResponse.clone(); }); }); } return fetchResponse.clone(); }).catch(function (error) { return caches.open(CACHE_NAME).then(function (cache) { return cache.match(event.request); }); });});```
138	lekmanga.net.js	Improper Input Validation in Range Header Handling	High	true	CWE-20	9	Number	standard	{The `Number` function is used to parse a value extracted from the `range` header via a regex, which is derived from untrusted user input. This allows an attacker to manipulate the `range` header to cause unexpected behavior, such as out-of-bounds memory access or denial of service, due to improper validation of the parsed value. The function is standard but misused by directly converting potentially malformed or malicious input without sanitization or bounds checking.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
139	lekmanga.net.js	Case-Sensitive URL Exclusion in Cache Bypass	Medium	false	CWE-208	N/A	N/A	N/A	{The vulnerability arises from the use of case-sensitive regular expressions in `neverCacheUrls`, which may fail to match URLs with different letter casing (e.g., `/Wp-admin`), leading to unintended cache bypass. However, this is not caused by misuse of a sensitive JavaScript function, but rather a logic flaw in pattern matching.}	```const neverCacheUrls = [/\/wp-admin/, /\/wp-login/, /preview=true/];```
140	drikpanchang.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API used to open URLs in a new window or tab. When the URL passed to it is derived from untrusted input (in this case, the notification's tag, which is set to a URL from the FCM payload), it can be manipulated to redirect users to arbitrary external sites, leading to open redirect vulnerabilities. The URL is not validated or sanitized, allowing an attacker to craft a payload that redirects users to malicious domains.}	```event.waitUntil(self.clients.openWindow(url));```
141	drikpanchang.com.js	Improper Input Validation in URL Construction	Medium	true	CWE-20	9	concatenation in string operations	standard	{The function does not use safe URL construction methods (like URL constructor or template literals with validation). Instead, it concatenates strings with untrusted data (topic and fcmDeliveryDate) directly into a URL. This allows for injection of malicious query parameters or path traversal if the input is not properly sanitized, leading to improper input validation and potential security issues.}	```return url + '&utm_source=' + kUTMSourcePushNotification + '&utm_medium=' + kUTMMediumPushNotification + '&utm_campaign=' + kUTMCampaignPushNotification + '&' + kFCMTopicKey + '=' + topic + '&' + kFCMPlatformKey + '=' + kWebPlatform + '&' + kFCMDeliveryYYYYMMDDDateKey + '=' + fcmDeliveryDate;```
142	pornohirsch.net.js	Insecure External Script Loading	Medium	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes scripts from specified URLs. When used with a hardcoded external URL like 'https://pushpad.xyz/service-worker.js?20170811', it introduces a medium-risk vulnerability because the script is loaded from an external, potentially untrusted source. While the URL is hardcoded and not dynamically constructed from user input, it still represents an insecure practice as it relies on third-party code that could be compromised or modified, leading to potential code injection or malicious behavior within the service worker.}	```importScripts('https://pushpad.xyz/service-worker.js?20170811');```
143	vista.ir.js	External Code Execution via Untrusted importScripts	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically constructed from untrusted input, the act of importing and executing external code from an external domain still constitutes a high-risk vulnerability, as it allows an attacker who controls the external resource to inject malicious code into the service worker. This is considered sensitive function misuse because importScripts() inherently executes arbitrary code, and its use with any external source introduces a potential attack vector.}	```importScripts('https://van.najva.com/static/js/scripts/new-website568669-website-57235-9276d9df-b920-489e-a161-2111794a3d7e-service-worker.js');```
144	iranjib.ir.js	Improper Cache Versioning and Cleanup	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from not properly managing cache versions or cleaning up old caches, which can lead to stale content being served. This is not due to misuse of a sensitive function, but rather a design or maintenance oversight in cache handling.}	```self.addEventListener('install', evt => { evt.waitUntil(caches.open(staticCacheName).then(cache => { console.log('caching assets...'); cache.addAll(cacheAssets); }).catch(err => {})); });```
145	xnx33.com.js	External Script Loading Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used without integrity checks or with untrusted URLs, it can lead to remote code execution if the script at the URL is compromised or controlled by an attacker. In this case, the script is loaded from 'https://js.mbidpsh.com/ps/sw.js', which is an external, potentially untrusted source, and no integrity verification (e.g., Subresource Integrity) is applied. This allows an attacker to modify the remote script and inject malicious code into the service worker, compromising the entire application's security.}	```importScripts('https://js.mbidpsh.com/ps/sw.js');```
146	wisgoon.com.js	External Script Import Without Validation	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL were derived from untrusted input (e.g., user-controlled parameters), it could lead to arbitrary script execution. However, in this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse but rather due to lack of validation or control over external script sources. Therefore, while importScripts() is a sensitive function, its misuse here is not triggered by dynamic input, making the vulnerability less severe in terms of sensitive function exploitation.}	```importScripts('https://van.najva.com/static/js/scripts/wisgoon-website-19787-ddc10e3d-9a17-4c50-bcba-43062df99fb0-service-worker.js');```
147	yesplay.bet.js	Improper Validation of Cache Responses	High	true	N/A	N/A	caches.match	standard	{The caches.match function is used without validating the response, allowing potentially untrusted or malformed responses to be served to clients, which can lead to cache poisoning or execution of malicious content.}	N/A
148	yesplay.bet.js	Insecure Cache Busting Mechanism	Medium	true	N/A	N/A	Math.random	standard	{The Math.random function generates a random value appended to URLs for cache busting, which is predictable and can be exploited to bypass cache validation, leading to inconsistent or outdated content delivery.}	N/A
149	yesplay.bet.js	Insecure Notification Data Handling	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with notification data without validating the URL, allowing an attacker to redirect users to arbitrary sites, leading to open redirect vulnerabilities.}	N/A
150	yesplay.bet.js	Insecure Request Header Handling	Medium	true	N/A	N/A	new Request	standard	{The new Request constructor is used with unvalidated input, which can lead to improper request handling or injection of malicious headers, potentially bypassing security controls.}	N/A
151	yesplay.bet.js	Insecure Cache Key Construction	Low	true	N/A	N/A	`${this.cacheNamePrefix}:${t}`	custom	{The cache key is constructed by concatenating a prefix with user-controlled input, which can lead to cache key collisions or unintended cache access if the input is not properly sanitized.}	N/A
152	yesplay.bet.js	Improper Validation of Cache Responses	High	true	N/A	N/A	caches.match	standard	{The caches.match function is used without validating the response, allowing potentially untrusted or malformed responses to be served to clients, which can lead to cache poisoning or execution of malicious content.}	N/A
153	yesplay.bet.js	Insecure Cache Busting Mechanism	Medium	true	N/A	N/A	Math.random	standard	{The Math.random function generates a random value appended to URLs for cache busting, which is predictable and can be exploited to bypass cache validation, leading to inconsistent or outdated content delivery.}	N/A
154	yesplay.bet.js	Insecure Notification Data Handling	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with notification data without validating the URL, allowing an attacker to redirect users to arbitrary sites, leading to open redirect vulnerabilities.}	N/A
155	yesplay.bet.js	Insecure Request Header Handling	Medium	true	N/A	N/A	new Request	standard	{The new Request constructor is used with unvalidated input, which can lead to improper request handling or injection of malicious headers, potentially bypassing security controls.}	N/A
156	yesplay.bet.js	Insecure Cache Key Construction	Low	true	N/A	N/A	`${this.cacheNamePrefix}:${t}`	custom	{The cache key is constructed by concatenating a prefix with user-controlled input, which can lead to cache key collisions or unintended cache access if the input is not properly sanitized.}	N/A
157	thehackernews.com.js	Denial of Service via Premature Service Worker Installation Failure	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by a logic flaw or premature failure during service worker installation. The code does not use any sensitive functions with untrusted input to trigger the issue.}	"```self.addEventListener(""install"", function (e) { e.waitUntil(caches.open(CACHE).then(function (e) { return e.addAll(PRECACHE); }).then(function () { return self.skipWaiting(); })); })```"
158	bet.app.js	Improper URL Filtering in Fetch Handler	Medium	N/A	CWE-20	7	fetch	standard	{The fetch function is used without proper validation of the request URL, allowing potentially malicious or unintended URLs to be fetched. The code attempts to filter URLs using a simple string search in offlineExclude, but this is insufficient and can be bypassed. For example, if an attacker crafts a URL that does not contain any of the excluded substrings (like '/api/', 'cloudflare', etc.), it will be allowed through and fetched via fetch, potentially leading to unintended resource access or data leakage. The use of fetch with untrusted or improperly filtered URLs constitutes a misuse of this sensitive function.}	```self.addEventListener('fetch', e => {  for (let i = 0; i < offlineExclude.length; i++) {    if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false;  }  var u = e.request.url.replace('https://', '');  var n = u.indexOf('/');  if (u.slice(n, 60).indexOf('.') == -1) {    return false;  }  e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));});```
159	cyberlink.com.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The clients.openWindow(d) function is a standard browser API used to open a new window or tab with a specified URL. When the URL 'd' is derived from untrusted input (e.g., from notification data), it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This is especially dangerous if the attacker can control the value of 'd' via the push notification payload.}	```d && clients.openWindow(d);```
160	cyberlink.com.js	Improper Input Validation	Medium	false	CWE-20	N/A		N/A	N/A	```b = { body: a.text```
161	cyberlink.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	N/A	```body: 'webpush_eventId\x3d' + a.webpush_eventId + '\x26webpush_subscriberId\x3d' + a.webpush_subscriberId```
162	solarweb.com.js	Missing Fetch Event Handling in Service Worker	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of proper handling for the fetch event in the service worker. This omission may lead to unintended behavior or missed opportunities for intercepting and modifying network requests, but it does not stem from unsafe function usage.}	"```self.addEventListener(""fetch"", function (event) {});```"
163	mcmaster.com.js	Cache Poisoning via Unvalidated Network Response	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of validation or sanitization of cached responses before serving them, but it is not directly caused by misuse of a sensitive JavaScript function. The code correctly uses standard fetch and caches APIs in a way that does not involve dynamic or untrusted input influencing the function calls.}	"```self.addEventListener('fetch', function (event) { if (event.request.mode === ""navigate"" && event.request.method === ""GET"" && !/\.pdf/i.test(event.request.url)) { event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); })); } });```"
164	unilever.com.js	Caching of Sensitive Data	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching responses without proper validation or sanitization of the request URL or response content, but it is not directly caused by misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The caching logic is flawed in that it may cache sensitive or dynamic content (e.g., responses from POST/PUT requests or responses with range headers) without appropriate checks, but no inherently dangerous function is being misused.}	```e.respondWith(caches.match(e.request).then(E => E || caches.open(CACHE_KEYS.RUNTIME).then(E => fetch(e.request).then(n => RUNTIME_IGNORED_HOSTS.indexOf(t) > -1 ? n : E.put(e.request, n.clone()).then(() => n)).catch(() => {}))))```
165	myavlive.com.js	Improper Input Validation	High	true	N/A	N/A	postMessage	standard	{The postMessage function is used to send data to a client (Client object) without validating or sanitizing the data received from the client. The code checks if the source is a Client and if the data matches a constant (de), but it then constructs and sends a response object (n) with hardcoded payload (pe) without any input validation. This could allow an attacker to manipulate the message flow if the data validation is bypassed or if the logic is extended to use dynamic data, leading to potential information disclosure or unintended behavior.}	```this.onMessage = ({source: e, data: t}) => { if (e instanceof Client && t === de) { let n = {type: _e, payload: pe}; e.postMessage(n); } };```
166	myavlive.com.js	Denial of Service	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic condition that checks if the number of connected clients exceeds a limit (this.maxClients). When the limit is reached, it triggers a forced disconnection (this.onForceDisconnect) for the new client. This is not caused by misuse of a sensitive function but rather by a design decision to enforce a client limit, which may be exploited by an attacker to deny service to legitimate users by flooding the system with connections.}	```this.clientIds.size === this.maxClients) { this.onForceDisconnect(T.WORKER_TABS_LIMIT_REACHED, i); break; }```
167	myavlive.com.js	Improper Resource Management	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the creation of a new instance of the te class (socket) with a large number of event handlers and callbacks. While this may lead to resource exhaustion if not managed properly, it is not due to misuse of a sensitive function. The issue is more related to resource allocation and lifecycle management rather than a direct function misuse.}	```this.socket = new te({onConnect: this.onConnect, onDisconnect: this.onDisconnect, onSocketSubscribed: this.onSocketSubscribed, onSocketMessage: this.onSocketMessage, onFirstSubscriptionAdd: this.onFirstSubscriptionAdd, onLastSubscriptionRemove: this.onLastSubscriptionRemove, onError: this.onError, onSubscriptionError: this.onSubscriptionError, onForceDisconnect: this.onForceDisconnect});```
168	playbuzz.com.js	Incorrect Host Check for Development Environment	High	true	CWE-20	N/A	const isDevelopment = env => localHosts.some(host => env.includes(host));	standard	{The function `includes()` is used to check if a host is in the localHosts array, but it does not validate the input `env` (which is `url.host`) for potential malicious or unexpected values. Since `url.host` is derived from the request URL, an attacker could manipulate the host to bypass development checks, leading to unintended behavior or security bypass.}	```const isDevelopment = env => localHosts.some(host => env.includes(host));```
169	playbuzz.com.js	User Agent Spoofing Vulnerability	Medium	true	CWE-20	N/A	const isSafari = userAgent => userAgent.toLowerCase().indexOf('safari') > -1 && !isChrome(userAgent);	standard	{The function `indexOf()` is used to detect Safari by checking the user agent string, which is inherently untrusted. An attacker can spoof the user agent to bypass detection logic, leading to incorrect execution paths or feature misbehavior. This misuse of string matching on untrusted input is a classic case of user agent spoofing.}	```const isSafari = userAgent => userAgent.toLowerCase().indexOf('safari') > -1 && !isChrome(userAgent);```
170	playbuzz.com.js	Unvalidated Push Data Handling	Medium	true	CWE-79	N/A	const notificationPromise = self.registration.showNotification(title, options);	standard	{The `showNotification()` function is called with `options` that include `icon` and `badge` URLs derived from hardcoded values. While not directly user-controlled, if these URLs were dynamically sourced from untrusted input (e.g., from `event.data.text()`), they could lead to arbitrary resource loading or phishing via malicious icons. The vulnerability arises from the misuse of `showNotification()` with unvalidated data, potentially allowing an attacker to influence the notification content or redirect users.}	```const notificationPromise = self.registration.showNotification(title, options);```
171	bovada.lv.js	Server Side Request Forgery (SSRF) via unvalidated input in getBaseURL	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a URL constructed from user-controlled query parameters (language and bucket) via getBaseURL(). Since these parameters are not validated or sanitized, an attacker can manipulate them to cause the service worker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```const a = await fetch(`${e}/pwa-config.json?v=${version}`);```
172	bovada.lv.js	Cache Poisoning via untrusted config file	High	true	New	9	N/A	standard	{The addAll() method of the Cache API is used to populate the cache with URLs obtained from a remote JSON configuration file (pwa-config.json). Since this file is fetched from a URL derived from untrusted input (via getBaseURL()), an attacker can control its contents, leading to cache poisoning where malicious or unintended resources are cached and served to users.}	```await t.addAll(n.urlsToCache);```
173	bovada.lv.js	Information Exposure via cache ignoreSearch	Medium	true	CWE-200	8	N/A	standard	{The match() method is called with the ignoreSearch: true option, which causes the cache to ignore query string parameters when matching requests. This can lead to information exposure if different query parameters are used to access sensitive data, as the cache may return cached responses for different queries, potentially leaking data across different contexts.}	```return await a.match(e, { ignoreSearch: !0 });```
174	whatwg.org.js	Insecure Third-Party Script Import	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it imports a script from a third-party domain ('https://resources.whatwg.org/website-service-worker.js'). While the URL is hardcoded and not dynamically constructed from untrusted input, the use of a third-party script introduces a trust boundary risk. If the third-party domain is compromised or the script is modified without detection, it could lead to malicious code execution within the service worker context, potentially enabling cache manipulation, network interception, or other attacks. This is considered a sensitive function misuse due to the inherent risk of loading external code, even if the source is currently trusted.}	"```self.importScripts(""https://resources.whatwg.org/website-service-worker.js"");```"
175	chaosgroup.com.js	Unrestricted Offline Page Serving	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from serving the offline.html page without proper validation of the request context, but it is not caused by misuse of a sensitive JavaScript function. The logic simply checks request mode and headers, and serves a static cached page. No sensitive function like importScripts, eval, or dynamic code execution is involved.}	```if ('navigate' === e.request.mode || 'GET' === e.request.method && e.request.headers.get('accept').includes('text/html') ? (console.log('[Serviceworker]', 'Fetching offline content', e), caches.match('/offline.html')) : void 0)```
176	buffalonews.com.js	Open Redirect Vulnerability	Medium	true	CWE-602	9	new URL	standard	{The function new URL is used to construct a URL object from oData.url, which is derived from the FCM payload. Since the FCM payload can be controlled by an attacker (via server-side message injection or compromised backend), the URL can be manipulated to redirect users to arbitrary domains, leading to open redirect vulnerabilities. The input is dynamic and untrusted, making this a sensitive function misuse.}	```const oURL = new URL(oData.url);```
177	money.com.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is loaded from 'https://api.pushnami.com', which is an external domain. If the source is compromised or if the script is modified without detection, it can lead to arbitrary code execution within the service worker context, enabling attacks such as data exfiltration, cache manipulation, or man-in-the-middle attacks.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5e9a25c331d5d1001378c1a0"");```"
178	calciomercato.com.js	Improper Neutralization of Input During Web Page Generation ('Cross-Site Scripting')	High	true	CWE-79	9	showNotification	standard	{The function showNotification is used with untrusted input (notificationTitle) without sanitization, allowing an attacker to inject malicious content into the notification, potentially leading to Cross-Site Scripting (XSS) if the notification is rendered in a context where script execution is possible.}	```return self.registration.showNotification(notificationTitle, notificationOptions);```
179	ksta.de.js	Improper Control of Generation of Code (Dynamic Script Loading)	High	true	CWE-960	10	importScripts	standard	"{The code uses `importScripts(t)` where `t` is dynamically derived from a URL constructed via `new URL(t + \"".js\"", n).href`. Since `t` is passed as a parameter to the `t` function and can be controlled by the module loader (via `n`), this allows for dynamic script loading from arbitrary sources. If an attacker can influence the module name or path, they can trigger the loading of malicious scripts. The `importScripts()` function is a standard JavaScript API in workers that executes scripts from a given URL, and when used with untrusted input, it enables remote code execution.}"	"```if (!self.define) { let e, s = {}; const t = (t, n) => (t = new URL(t + \"".js\"", n).href, s[t] || new Promise(s => { if (\""document\"" in self) { const e = document.createElement(\""script\""); e.src = t, e.onload = s, document.head.appendChild(e); } else e = t, importScripts(t), s(); }).then(() => { let e = s[t]; if (!e) throw new Error(`Module ${t} didn’t register its module`); return e; })); self.define = (n, i) => { const o = e || (\""document\"" in self ? document.currentScript.src : \""\"") || location.href; if (s[o]) return; let r = {}; const l = e => t(e, o), u = { module: { uri: o }, exports: r, require: l }; s[o] = Promise.all(n.map(e => u[e] || l(e))).then(e => (i(...e), r)); }; }```"
180	adobesign.com.js	Cache Poisoning	High	true	N/A	N/A	caches.put	standard	{The caches.put function is used to store data in a cache, but it is called with a URL derived from user-controlled input (e.g., from the request URL) without proper validation. This allows an attacker to manipulate the cache key and inject malicious content, leading to cache poisoning. The function is called in the handleChromeExtensionFetchRequest function, where the URL is constructed from the request URL and used directly in caches.put.}	```const storeInCache = async (e, t, r) => { try { await r.put(e, t.clone()); } catch (t) { console.error(`SW error, Failed while storing data in cache`, e, t); } }```
181	adobesign.com.js	Insecure Fetch Handling	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used with URLs derived from user-controlled input (e.g., from the request URL) without proper validation or sanitization. This allows an attacker to manipulate the URL to fetch arbitrary resources, potentially leading to unauthorized data access or injection. The function is used in handleChromeExtensionFetchRequest and handleWebAppFetchRequest, where the URL is constructed from the request URL and passed directly to fetch.}	```const handleChromeExtensionFetchRequest = async e => { let { request: t, url: r, event: n, applicationName: o } = e; const a = `${r.origin}${r.pathname}`; ... }```
182	adobesign.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The createCacheKey function performs input validation by checking if the input is defined and of the expected type, but it does not involve the misuse of a sensitive function. The vulnerability arises from insufficient validation of the input structure, not from improper use of a sensitive function.}	```const createCacheKey = e => { if (!e) throw new WorkboxError_WorkboxError(`add-to-cache-list-unexpected-type`, { entry: e }); ... }```
183	adobesign.com.js	Insecure Message Handling	Medium	true	N/A	N/A	postMessage	standard	{The postMessage function is used to send messages to clients based on data received from the message event, which can be controlled by an attacker. This allows an attacker to send arbitrary messages to clients, potentially leading to cross-origin data leakage or execution of unintended actions. The function is used in the onMessage handler, where the message data is processed without sufficient validation.}	```const onMessage = e => { switch (e && e.data && e.data.applicationName) { case i.chromeExtension: ... } }```
184	adobesign.com.js	Insecure IndexedDB Usage	Low	false	N/A	N/A	N/A	N/A	{The indexedDB.open function is used to open a database, but the vulnerability arises from improper handling of the database operations rather than misuse of a sensitive function. The function is used correctly, but the vulnerability is due to lack of proper error handling and validation, not from improper use of a sensitive function.}	```const f = indexedDB.open(`applicationsData`, 1); f.onupgradeneeded = e => { d = e.target.result, d.objectStoreNames.contains(i.chromeExtension) || d.createObjectStore(i.chromeExtension); }```
185	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""a3bc84907e4b3b6d79ab97e7485bf62fadc402ab1034b3f43c910fff54a30ecf"";```"
186	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""a80db1b3627e14e08476d518d665bed3f70bb43c4b19bfbffdf280a3a83785ac"";```"
187	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""cd3fd42d2cb0d5ae51a971ea69085f7a9b620cc5162c87519ccb86f737d89447"";```"
188	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""87004886e76067f76eec763e68aafe76394e2140512f1ed4f59451788913869b"";```"
189	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""c688bc9a78b4776ea36cc5941ea9c2b2903749ba7b24205f5ec6955f0f683aa4"";```"
190	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""10c449b24be8c77c5486fde4704d0006adf171736a5eb245485b8c90c572c37f"";```"
191	closermag.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys) is hardcoded in the script, but not due to misuse of a sensitive JavaScript function. The vulnerability arises from static exposure of secrets, not dynamic input processing or unsafe function calls.}	"```var key = ""9b7cbead40708546f4f91608e2251e25e9e0dea3c906663de36ac5be5f8d1548"";```"
192	hessenschau.de.js	Open Redirect via Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The vulnerability arises because the `clients.openWindow(a)` function is called with the `jumpUrl` value directly from the notification data, which is user-controlled. Since this value is not validated or sanitized, an attacker can craft a notification with a malicious URL (e.g., a phishing site or redirect to an external domain), causing the browser to open an unintended external page. This constitutes an open redirect, allowing attackers to trick users into visiting malicious sites.}	```self.addEventListener('notificationclick', function (e) { e.notification.close(); const { eventSrc: t, data: n } = e.notification; if (!n || !n.tickerUrl) return; const { tickerUrl: s, jumpUrl: a } = e.notification.data; e.waitUntil(clients.matchAll({ type: 'window' }).then(e => { e.some(function (e) { let t = e.url; const n = e.url.indexOf('#'); return t = t.substring(0, -1 !== n ? n : t.length), t === s && (e.focus().then(e => e.postMessage({ type: 'reload', jumpUrl: a })), !0); }) || clients.openWindow(a).then(e => e ? e.focus() : null); })); });```
193	o2online.de.js	XSS via Dynamic Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts into the service worker, leading to script injection and potential compromise of the entire service worker context.}	```importScripts(`https://o2online-de.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
194	bmw.com.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	N/A	importScripts	N/A	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a dynamically constructed URL derived from this.location.hostname, which is user-controllable via the host in the URL. Although the hostname is typically trusted in a controlled environment, if the service worker is deployed in a context where the host can be manipulated (e.g., via DNS spoofing, subdomain takeover, or misconfigured CNAMEs), an attacker could redirect the importScripts() call to a malicious script. This would result in arbitrary code execution within the service worker context, enabling full compromise of the service worker’s capabilities, including cache manipulation, network interception, and potentially user data exfiltration.}	```importScripts(swURI);```
195	bmw.de.js	Dynamic Code Evaluation via User-Controlled Input	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to importScripts() is constructed using user-controlled input (here, location.search), it allows an attacker to manipulate the script source. This enables arbitrary script execution from a remote host, leading to full compromise of the service worker's context, including cache manipulation, network interception, and potential data exfiltration.}	```importScripts(`https://bmw.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
196	hostdl.com.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	N/A	standard	{The code constructs a URL using `new URL(clickedNotification.data, self.location.origin)` where `clickedNotification.data` is user-controlled data from a notification. This input is then passed to `clients.openWindow(urlToOpen)`, which can be exploited to redirect users to arbitrary external domains if the data is not validated or sanitized, leading to an open redirect vulnerability.}	```const urlToOpen = new URL(clickedNotification.data, self.location.origin).href;```
197	proximus.be.js	Dynamic Code Evaluation via External Source	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to importScripts() is constructed using dynamic input such as location.search, it allows an attacker to manipulate the query string to inject arbitrary scripts. In this case, the script URL is built as `https://proximus.app.baqend.com/v1/speedkit/sw.js${location.search}`, meaning any query parameters provided by the user are appended directly to the script URL. This enables an attacker to supply a malicious host or path via the query string, potentially leading to remote code execution or script injection.}	```importScripts(`https://proximus.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
198	netacad.com.js	Cross-Site Scripting (XSS) via Service Worker Message Handling	Medium	false	CWE-79	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function but rather by the logic handling message events. The code processes incoming messages to enable/disable logging, but there is no direct execution of untrusted input or injection point via a sensitive function.}	```try { if ('function' === typeof importScripts) { importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js'); if (workbox) { self.addEventListener('install', event => { self.skipWaiting(); }); self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { return caches.delete(cacheName); })); })); }); self.addEventListener('message', event => { if (event.data && event.data.type === 'SET_LOG_ENABLED') { const logEnabled = event.data.logEnabled; if (logEnabled) { workbox.setConfig({ debug: true }); console.log('Service Worker logging enabled.'); } else { workbox.setConfig({ debug: false }); console.log('Service Worker logging disabled.'); } } }); } else { console.error('Workbox could not be loaded. No offline support'); } } } catch (e) { console.error('Unable to install service worker. Possible network error.', e); }```
199	netacad.com.js	Improper Neutralization of Special Elements in External Resource (CDN	Medium	false	CWE-444	N/A	N/A	N/A	{The vulnerability arises from the hardcoded CDN URL used in importScripts(), which is not dynamically constructed from untrusted input. Since the URL is fixed and not derived from user-controlled data, no sensitive function misuse occurs.}	```try { if ('function' === typeof importScripts) { importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js'); if (workbox) { self.addEventListener('install', event => { self.skipWaiting(); }); self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { return caches.delete(cacheName); })); })); }); self.addEventListener('message', event => { if (event.data && event.data.type === 'SET_LOG_ENABLED') { const logEnabled = event.data.logEnabled; if (logEnabled) { workbox.setConfig({ debug: true }); console.log('Service Worker logging enabled.'); } else { workbox.setConfig({ debug: false }); console.log('Service Worker logging disabled.'); } } }); } else { console.error('Workbox could not be loaded. No offline support'); } } } catch (e) { console.error('Unable to install service worker. Possible network error.', e); }```
200	netacad.com.js	Denial of Service via Cache Deletion	Medium	false	CWE-400	N/A	N/A	N/A	{The vulnerability stems from the deletion of all caches during activation, which may lead to resource loss or performance degradation. However, this is not due to misuse of a sensitive function but rather a design choice in cache management.}	```try { if ('function' === typeof importScripts) { importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js'); if (workbox) { self.addEventListener('install', event => { self.skipWaiting(); }); self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { return caches.delete(cacheName); })); })); }); self.addEventListener('message', event => { if (event.data && event.data.type === 'SET_LOG_ENABLED') { const logEnabled = event.data.logEnabled; if (logEnabled) { workbox.setConfig({ debug: true }); console.log('Service Worker logging enabled.'); } else { workbox.setConfig({ debug: false }); console.log('Service Worker logging disabled.'); } } }); } else { console.error('Workbox could not be loaded. No offline support'); } } } catch (e) { console.error('Unable to install service worker. Possible network error.', e); }```
201	aviationweather.gov.js	Insecure Caching Without Response Validation	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of response validation when serving cached assets, but it is not caused by misuse of a sensitive function. The code correctly uses standard caching APIs (caches.match, caches.open, etc.) without dynamic or untrusted input influencing the cache operations. The issue is more about policy or design (e.g., not validating cache responses for integrity or freshness) rather than a sensitive function misuse.}	```e.respondWith(caches.match(e.request).then(function (t) { return t || fetch(e.request); }));```
202	madison.com.js	Open Redirect via Untrusted URL	High	true	CWE-601	10	N/A	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from untrusted data (FCM message payload). Since the URL is constructed dynamically from user-controlled input and later used in `self.clients.openWindow(oURL.toString())`, an attacker can craft a malicious URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```let oURL = new URL(oData.url);```
203	doctissimo.fr.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used with a hard-coded external URL ('https://notifpush.com/serviceworker.js'), which introduces a high-risk dependency on a third-party script. While the URL is not dynamically constructed from untrusted input, the script is still loaded from an external source, which can be compromised or modified by an attacker, leading to arbitrary code execution within the service worker context. This constitutes a sensitive function misuse because importScripts() is inherently dangerous when used with untrusted or external sources, even if the source is hardcoded.}	```importScripts('https://notifpush.com/serviceworker.js');```
204	snapdeal.com.js	Open Redirect Vulnerability	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new browser window or tab, and it is being called with a URL derived from C.notification.data.redirectUrl, which is user-controlled via the notification payload. Since the redirectUrl is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerability.}	```C.waitUntil(clients.openWindow(C.notification.data ? C.notification.data.redirectUrl : '/'));```
205	testname.me.js	Improper Resource Management (Relative Path Caching)	Medium	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from caching a relative path (""/"") without ensuring it resolves to a secure, intended resource. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a misconfiguration in caching strategy. The function cache.addAll is used correctly in terms of syntax and intent, but the path being cached is potentially ambiguous or insecure in context.}"	"```self.addEventListener('install', e => { e.waitUntil(caches.open('fox-store').then(cache => cache.addAll([""/""]))); });```"
206	yottaa.com.js	External Script Inclusion in Service Worker	High	false	N/A	0	N/A	N/A	{The importScripts() call uses a hardcoded, trusted URL from a known CDN (rapid-cdn.yottaa.com). Since the URL is not derived from user input or dynamic sources, it does not constitute misuse of a sensitive function. The vulnerability is present due to external script inclusion, but not because of sensitive function misuse.}	```importScripts('https://rapid-cdn.yottaa.com/rapid/worker/a244R10OWtLFnA.js');```
207	pornlulu.com.js	Assignment instead of comparison in if statement leading to unintended caching	High	false	N/A	0	N/A	N/A	{The issue is a logical error (assignment instead of comparison) in the condition `if (response.status = 200)`, which assigns 200 to `response.status` and always evaluates to true. This does not involve misuse of a sensitive JavaScript function such as `importScripts`, `eval`, or `fetch` with untrusted input. The vulnerability stems from a coding mistake, not from insecure function usage.}	"```if (response.status = 200) { console.log(""caching : "" + response.url); cache.put(response.url, response.clone()); }```"
208	hallmark.com.js	Improper Session Hash Validation Leading to Session Fixation	High	true	New	N/A	decode	standard	{The TextDecoder.decode() function is used to convert a Uint8Array into a string, which is then matched against a regex to extract a session hash. However, the input to decode() is derived from a raw byte slice of a response body (e.g., e.slice(t, c)), which is not sanitized or validated. This allows an attacker to inject arbitrary bytes that, when decoded, could result in a malicious session hash being extracted and stored, leading to session fixation. The function is misused because it processes untrusted data without proper validation.}	```const o = e.slice(t, c), new TextDecoder().decode(s).match(/content='([^']+)'/);```
209	hallmark.com.js	XSS via Uncached Content Injection	Medium	true	CWE-79	N/A	Response	standard	{The Response constructor is used to create a new response with a hardcoded HTML string containing a script tag that unregisters service workers and reloads the page. Although the content is hardcoded, the vulnerability arises because the script is executed in the context of the service worker, and if this response is served to a client under certain conditions (e.g., 401 status), it can lead to unintended behavior or XSS if the script is injected into a page context. The misuse lies in constructing a response with executable script content without proper sanitization or context-aware handling.}	```return new Response('\n <html>\n <head>\n <script>\n navigator.serviceWorker.getRegistrations().then(function(registrations) {\n var unregisterPromises = registrations.map((registration) => registration.unregister());\n return Promise.all(unregisterPromises);\n }).then(function () {\n window.location.reload();\n }).catch(function () {\n window.location.reload();\n });\n <\/script>\n </head>\n <body>\n </body>\n </html>\n ', {```
210	eldestapeweb.com.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted data (notification.data.url_destino or notification.data.nota), it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. The code does not validate or sanitize the URL before passing it to clients.openWindow(), making it directly exploitable.}	```var nota = notification.data.url_destino || notification.data.nota || 'https://www.eldestapeweb.com'; if (nota) { e.waitUntil(clients.matchAll().then(function (clis) { var client = clis.find(function (c) { return c.visibilityState === 'visible'; }); if (client !== undefined) { client.navigate(nota); client.focus(); } else { clients.openWindow(nota); notification.close(); } })); }```
211	eldestapeweb.com.js	Insecure Dynamic Firebase Configuration	Medium	true	CWE-548	N/A	firebase.initializeApp	standard	{The function firebase.initializeApp() is a standard Firebase SDK method that initializes the Firebase app with provided configuration. When the messagingSenderId is dynamically extracted from the URL via get_sw_url_parameters(), it allows an attacker to supply a malicious sender ID, potentially leading to unauthorized access to Firebase services or misconfiguration of messaging behavior. This misuse of a standard function with untrusted input constitutes a configuration vulnerability.}	```var messagingSenderId = get_sw_url_parameters('messagingSenderId'); firebase.initializeApp({ 'messagingSenderId': messagingSenderId });```
212	tamtam.chat.js	Uncontrolled Resource Consumption (Retry Loop)	High	true	CWE-400	9	fetch	standard	{The function `f` uses `fetch` in a recursive retry loop that can be triggered by any URL passed as `t`. If an attacker can control the value of `t` (e.g., via a malicious request or crafted URL), the service worker may repeatedly attempt to fetch the resource, leading to excessive resource consumption. The `fetch` call is not guarded against malicious or infinite retry scenarios, and the recursion continues up to 10 attempts, which can be exploited to exhaust network or CPU resources.}	```function f(t, i) { return void 0 === i && (i = 0), n(this, void 0, void 0, function () { var n; return e(this, function (e) { switch (e.label) { case 0: return e.trys.push([0, 2,, 4]), [4, fetch(t)]; case 1: return [2, e.sent()]; case 2: return n = e.sent(), r || (r = new Promise(function (n) { var e = a(function () { e(), n(null); }); })), [4, r]; case 3: if (e.sent(), i < 10) return [2, f(t, ++i)]; throw n; case 4: return [2]; } }); }); }```
213	tamtam.chat.js	Insecure Online/Offline Event Handling	Medium	false	CWE-306	0	N/A	N/A	{The vulnerability arises from improper handling of online/offline events via `self.dispatchEvent`, but it does not stem from misuse of a sensitive function. The code listens for messages and dispatches events based on message data, but there is no direct use of a sensitive function like `eval`, `importScripts`, or `fetch` with untrusted input that would lead to code execution or injection. The issue is more about event handling logic than sensitive function misuse.}	```self.addEventListener('message', function (n) { var e, t; switch (!0) { case 'online' === (null === (e = n.data) || void 0 === e ? void 0 : e.type): self.dispatchEvent(new Event('online')); break; case 'offline' === (null === (t = n.data) || void 0 === t ? void 0 : t.type): self.dispatchEvent(new Event('offline')); } });```
214	txxx.tube.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows arbitrary script execution from remote sources, which can lead to code injection, data exfiltration, or full compromise of the service worker's context. In this case, the script is imported from 'https://sw.wpu.sh/npc/sdk/common/service-worker.js', a third-party domain, without any validation or integrity verification, making it vulnerable to supply chain attacks if the remote script is compromised.}	```importScripts('https://sw.wpu.sh/npc/sdk/common/service-worker.js');```
215	lavuelta.es.js	Remote Code Execution via Untrusted importScripts	High	true	CWE-94	N/A	importScripts('https://via.batch.com/v3/worker.min.js');	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and not derived from untrusted input, the vulnerability is flagged as ""New"" and categorized as High severity, likely due to the external script being loaded from a third-party domain (via.batch.com). However, since the URL is static and not dynamically constructed from user-controlled or untrusted data, this does not constitute a sensitive function misuse in the context of dynamic input. Therefore, the vulnerability is not caused by improper use of a sensitive function with dynamic input, but rather by the inherent risk of loading external scripts.}"	"```importScripts(""https://via.batch.com/v3/worker.min.js"");```"
216	listennotes.com.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The fetch event handler is empty, meaning it does not handle any network requests. While this may lead to missed opportunities for caching or security enforcement, it does not stem from misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
217	donanimhaber.com.js	Open Redirect via Untrusted URL in Notification Click	Medium	true	CWE-602	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a URL passed directly from the notification payload (payload.data.url), which is untrusted and unsanitized. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect where users are redirected to arbitrary websites, potentially phishing or malware sites. The input is dynamic and not validated, making it a sensitive function misuse.}	```self.clients.openWindow(payload.data.url);```
218	tiwar.ru.js	Improper Input Validation (Regex Allows Unintended File Caching	Medium	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from a flawed regular expression that allows caching of files ending in "".w"", which is likely unintended. However, this is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The issue is purely a logic or configuration error in the regex pattern, not a function misuse.}"	```if (requestURL.hostname !== self.location.hostname || !/\.(png|jpg|webp|gif|w|css|js)$/.test(requestURL.pathname)) {```
219	wprost.pl.js	Insecure Third-Party Script Import	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted third-party source (e.g., cdn.pushpushgo.com), it introduces a high-risk vulnerability because the script may be modified by an attacker, leading to arbitrary code execution within the service worker context. This can compromise the entire web application’s security, including intercepting network requests, manipulating cache, or stealing sensitive data.}	```importScripts('https://cdn.pushpushgo.com/5acf1e722f0de3000b21776f/worker.js');```
220	coke.com.js	XSS via untrusted push data in notifications	High	true	CWE-79	10	registration.showNotification	standard	{The service worker uses t.data.json() to extract notification data, including the title, which is then passed directly to self.registration.showNotification without sanitization. If an attacker controls the push payload, they can inject malicious content into the notification title, potentially leading to XSS if the notification UI renders the title in an unsafe manner (e.g., via innerHTML or similar). This is a direct misuse of the standard showNotification API with untrusted input.}	"```self.addEventListener(""push"", t => { const { title: i, body: e, icon: n, image: a, badge: s, data: o, actions: c, tag: r, renotify: d, requireInteraction: l } = t.data.json(), p = { body: e, icon: n, image: a, badge: s, data: o, actions: c, tag: r, renotify: d, requireInteraction: l }; o.rawData && console.debug(""Service worker received data"", JSON.stringify(o.rawData)), t.waitUntil(self.registration.showNotification(i, p)); });```"
221	coke.com.js	Open redirect in notificationclick handler	Medium	true	CWE-601	9	clients.openWindow	standard	{The service worker retrieves a URL from t.action or t.notification.data.url, constructs a new URL object, and then passes it to clients.openWindow without validating or sanitizing the target URL. This allows an attacker to craft a push notification with a malicious URL, leading to an open redirect where the user is redirected to an arbitrary site, potentially phishing or malware distribution. The misuse lies in using clients.openWindow with untrusted input.}	"```self.addEventListener(""notificationclick"", t => { t.notification.close(); const i = t.action || t.notification.data.url; if (i) { const e = new URL(i); e.searchParams.toString().includes(""utm_"") || (e.searchParams.append(""utm_source"", ""crm_w""), e.searchParams.append(""utm_medium"", ""OWeb""), e.searchParams.append(""utm_content"", ""push""), e.searchParams.append(""utm_term"", t.action ? ""cta-button"" : ""default-link"")), t.waitUntil(clients.openWindow(e.toString())); } });```"
222	bunte.de.js	Dynamic Script Inclusion via URL Parameter	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When combined with self.location.search, which is user-controlled and dynamic, it allows an attacker to inject arbitrary script URLs. This leads to remote code execution, as the service worker will execute any script from the URL constructed by appending the query string to the base URL.}	```importScripts('https://static.cleverpush.com/channel/worker/JEmqXMZbDqfokooJX.js' + self.location.search);```
223	businessinsider.com.au.js	Remote Code Execution via Dynamic Script Loading	High	true	N/A	9	importScripts	custom	"{The code dynamically loads a script using importScripts(o), where 'o' is derived from a URL constructed via new URL(o + "".js"", s).href. Since 'o' is passed as an argument to the function without sanitization or validation, an attacker could potentially control the value of 'o' (e.g., via a maliciously crafted URL or injected script), leading to arbitrary script execution in the service worker context. This is a classic case of dynamic script loading with untrusted input, which is a high-risk sensitive function misuse.}"	"```if (!self.define) { let e, n = {}; const o = (o, s) => (o = new URL(o + "".js"", s).href, n[o] || new Promise(n => { if (""document"" in self) { const e = document.createElement(""script""); e.src = o, e.onload = n, document.head.appendChild(e); } else e = o, importScripts(o), n(); }).then(() => { let e = n[o]; if (!e) throw new Error(`Module ${o} didn’t register its module`); return e; })); self.define = (s, i) => { const t = e || (""document"" in self ? document.currentScript.src : """") || location.href; if (n[t]) return; let c = {}; const r = e => o(e, t), m = { module: { uri: t }, exports: c, require: r }; n[t] = Promise.all(s.map(e => m[e] || r(e))).then(e => (i(...e), c)); }; }```"
224	businessinsider.com.au.js	Insecure Regex Pattern in Cache Matching	Medium	false	N/A	N/A	N/A	N/A	{The regex pattern /\.(?:png|jpg|jpeg|svg|gif)$/ is used to match image file extensions for caching. While it may be considered insecure due to potential for missing file types or misclassification, it does not involve misuse of a sensitive JavaScript function. The vulnerability arises from a logic or design flaw in the caching strategy, not from improper use of a function that can lead to direct security exploitation like code injection or execution.}	"```e.registerRoute(/\.(?:png|jpg|jpeg|svg|gif)$/, new e.StaleWhileRevalidate({ cacheName: ""images"", plugins: [new e.ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: void 0 })] }), ""GET"")```"
225	renee.pl.js	External Script Inclusion	High	true	CWE-918	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('https://proxy.synerise.com/rtom/configs/SOOF6CpzUv9A/sw.js'), which is not dynamically derived from untrusted input. However, since the URL is hardcoded and not under the control of the developer (i.e., it points to an external, potentially untrusted domain), it introduces a risk of loading malicious or compromised code if the external source is compromised. This constitutes a sensitive function misuse because importScripts() executes code from an external source without validation or integrity checks, leading to potential code injection or supply chain attacks.}	```importScripts('https://proxy.synerise.com/rtom/configs/SOOF6CpzUv9A/sw.js');```
226	renee.pl.js	Server Side Request Forgery (SSRF)	Medium	false	N/A	0	N/A	N/A	{The fetch() call in the 'fetch' event handler is not directly vulnerable to SSRF because it is used to handle client requests and falls back to a cached offline page. The URL being fetched is derived from the event.request, which is a client-initiated request, not an attacker-controlled input. Therefore, this usage does not constitute SSRF, as the server is not making arbitrary outbound requests to internal or external resources based on untrusted input.}	```event.respondWith(fetch(event.request).catch(error => {```
227	allmylinks.com.js	Open Redirect in Notification Click Handler	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided via the notification's data.url field, which is derived from untrusted push message data. Since this input is not validated or sanitized, an attacker can craft a push notification with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability.}	"```self.addEventListener('notificationclick', function (event) { event.notification.close(); if (event.action === 'close') {} else if (typeof event.notification.data.url !== ""undefined"") { clients.openWindow(event.notification.data.url); } }, false);```"
228	allmylinks.com.js	Improper Input Validation in Push Event Handling	Medium	true	CWE-20	9	JSON.parse (via event.data.json())	standard	{The code attempts to parse push event data using event.data.json(), which is equivalent to JSON.parse on untrusted input. While the code includes a try-catch, it does not validate or sanitize the parsed data before using it (e.g., in the notification title or other fields). This can lead to injection or unexpected behavior if the data contains malicious or malformed JSON, potentially allowing an attacker to manipulate the service worker's behavior.}	"```self.addEventListener('push', function (e) { var data = null; try { if (e.data) { data = e.data.json(); } } catch (err) {} if (!data) { return; } var title = data && typeof data.data !== ""undefined"" && typeof data.data.title !== ""undefined"" ? data.data.title : """"; e.waitUntil(self.registration.showNotification(title, data)); });```"
229	tucson.com.js	Insecure URL Handling Leading to Open Redirect	High	true	CWE-601	10	N/A	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from a remote notification payload. Since this input is not validated or sanitized, an attacker can craft a malicious URL (e.g., redirecting to a phishing site or malicious domain), leading to an open redirect vulnerability.}	```let oURL = new URL(oData.url);```
230	tucson.com.js	Improper Input Validation for UTM Parameters	Medium	true	CWE-74	9	N/A	standard	{The `searchParams.set()` method is used to inject UTM parameters directly from `oData.utm_source`, `oData.utm_medium`, and `oData.utm_campaign` without validation. This allows an attacker to inject arbitrary query parameters, potentially leading to tracking manipulation, phishing, or other client-side attacks.}	```oURL.searchParams.set('utm_source', oData.utm_source);```
231	tucson.com.js	Insecure Use of clients.openWindow Leading to Open Redirect	High	true	CWE-601	10	N/A	standard	{The `clients.openWindow()` method is called with `oURL.toString()`, which is constructed from untrusted `oData.url`. Since this function opens a new window to the provided URL, an attacker can exploit this to redirect users to malicious sites, resulting in an open redirect vulnerability.}	```if (self.clients.openWindow) { return self.clients.openWindow(oURL.toString());```
232	danfoss.com.js	Insecure Dynamic Route Registration	Medium	true	CWE-74	9	registerRoute	standard	{The registerRoute function is being called with a dynamic route pattern derived from a message event's data, which is not sanitized or validated. Since the route pattern is directly passed as an argument to registerRoute, an attacker could send a malicious route pattern (e.g., a regex that matches sensitive endpoints) via a message event, leading to unintended caching or interception behavior. This allows for potential cache poisoning or bypassing of intended security policies.}	"```self.addEventListener(""message"", function (e) { ""https://www.danfoss.com"" === e.origin && ""http://localhost:8082"" === e.origin && e.data && ""object"" == typeof e.data && registerRoute(e.data, new StaleWhileRevalidate({ cacheName: `locationapi-${prefix}`, plugins: [new workbox.expiration.ExpirationPlugin({ maxAgeSeconds: 1800 })] })); });```"
233	dilar.tube.js	Improper Input Validation in Domain Check	High	true	CWE-20	9	getDomainName	standard	{The function getDomainName uses a regex to extract the domain from a URL, but it does not validate or sanitize the input URL. This can lead to improper domain matching if the URL is malformed or contains unexpected characters, potentially allowing bypass of domain checks. The regex /https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i may not handle edge cases like URLs with encoded characters or unusual protocols, leading to incorrect domain extraction.}	N/A
234	dilar.tube.js	Incorrect Regex Matching for External Sources	High	true	CWE-20	9	isExternalSource	standard	{The function isExternalSource relies on a regex match against the domain extracted by getDomainName, which itself is vulnerable to improper input handling. The logic !(domain.match('dilar.tube') || domain.match('localhost')) is flawed because it treats any domain not matching those patterns as external, but the domain extraction may be inaccurate due to malformed URLs or encoding issues. This can allow an attacker to bypass the external source check by crafting a URL that appears to be internal due to regex matching quirks.}	N/A
235	dilar.tube.js	Insecure Cache Key Construction	Medium	false	CWE-327	0	N/A	N/A	{The cache key is constructed using evt.request.destination and latestJsVersion, which are not directly user-controlled. The vulnerability arises from lack of validation or sanitization of the destination value, but no sensitive function is misused here. The issue is more about insecure design than misuse of a sensitive function.}	N/A
236	dilar.tube.js	Recursive Cache Size Limit Could Cause Stack Overflow	Medium	false	CWE-833	0	N/A	N/A	{The recursive call to limitCacheSize is triggered when keys.length > size, but the recursion is not directly caused by misuse of a sensitive function. The issue is a logical flaw in recursion depth management, not improper use of a sensitive API.}	N/A
237	dilar.tube.js	Incomplete API Request Validation	Medium	false	CWE-20	0	N/A	N/A	{The function isAPIRequest uses regex matching on the URL, but the vulnerability stems from incomplete logic rather than misuse of a sensitive function. The regex is not inherently dangerous, and the issue is more about insufficient validation coverage.}	N/A
238	veepee.fr.js	Third-party script import leading to supply chain attack	High	true	CWE-918	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party domain (https://aswpsdkeu.com/notify/v1/ua-sdk.min.js), it introduces a supply chain attack risk. If the third-party script is compromised or malicious, the service worker can be hijacked, leading to unauthorized behavior such as data exfiltration, request interception, or further code injection.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
239	veepee.fr.js	Hardcoded sensitive token in client-side code	High	false	CWE-798	N/A	N/A	N/A	{The token is hardcoded in the script, but it is not the result of misuse of a sensitive function. The vulnerability arises from exposing sensitive credentials directly in client-side code, which can be easily accessed by attackers. No sensitive function is involved in the exposure.}	```token: 'MTpzejdaMUZXT1RkaUwtcnRkdTFVQnhBOkw4SG5uU3lxc2lrUUl5TW5LclZ4ZFNNWVF3WHJkb3JDTTZfZGJjbXFMMzQ',```
240	veepee.fr.js	Hardcoded appKey in client-side code	High	false	CWE-798	N/A	N/A	N/A	{The appKey is hardcoded in the script, but it is not the result of misuse of a sensitive function. The vulnerability arises from exposing sensitive credentials directly in client-side code, which can be easily accessed by attackers. No sensitive function is involved in the exposure.}	```appKey: 'sz7Z1FWOTdiL-rtdu1UBxA',```
241	tradera.com.js	Hardcoded Credentials	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials (appKey, token, vapidPublicKey) being embedded directly in the script. These are not the result of misuse of a sensitive JavaScript function, but rather poor secret management. No sensitive function is involved in the exposure.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://storage.googleapis.com/static.tradera.net/logos/logo\u002D256x256.png', defaultTitle: 'Tradera', defaultActionURL: 'https://www.tradera.com', appKey: '5nSBWWWRTpCkz7l2QBwTiw', token: 'MTo1blNCV1dXUlRwQ2t6N2wyUUJ3VGl3Olp6REo4dG5xRktaTm92N3Foam1SYWtjVXJkcHZBdml0bUV0d1B4MU5lX1U', vapidPublicKey: 'BM5fL_nmQPpPrUzKM-4Le6vavaJdHmdc116p5okzmNu808-rbnAgK9WymQrvOvmJ7z3rDxF3Zi845xNmG2BXzP4=' });```
242	edatv.news.js	Caching of Non-200 Responses	High	false	CWE-200	0	N/A	N/A	{The vulnerability arises from the caching logic in the `_handleFetch` method of the `L` class, which caches responses without validating their status codes. However, this is not due to misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather a flawed caching policy. The code caches responses regardless of status (e.g., 404, 500), which can lead to serving stale or invalid content. Since no sensitive function is misused, this is not a sensitive vulnerability.}	```const L = class extends E { async _handle(e, t) { const n = await t.cacheMatch(e); return n || (t.event && 'install' === t.event.type ? await this._handleInstall(e, t) : await this._handleFetch(e, t)); } async _handleFetch(e, t) { let n; const r = t.params || {}; if (!this._fallbackToNetwork) throw new s('missing-precache-entry', { cacheName: this.cacheName, url: e.url }); { 0; const s = r.integrity, a = e.integrity, i = !a || a === s; if (n = await t.fetch(new Request(e, { integrity: 'no-cors' !== e.mode ? a || s : void 0 })), s && i && 'no-cors' !== e.mode) { this._useDefaultCacheabilityPluginIfNeeded(); await t.cachePut(e, n.clone()); 0; } } return n; } }```
243	richmond.com.js	Open Redirect via Untrusted URL Handling	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL constructed from untrusted data (oData.url). Since oData is derived from a Firebase messaging payload, which can be controlled by an attacker, this allows for open redirect attacks. The URL is built using new URL(oData.url) and then passed directly to openWindow without validation or sanitization, enabling redirection to arbitrary domains.}	```let oURL = new URL(oData.url); if (oData.utm_source && oData.utm_medium && oData.utm_campaign) { oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign); } ... self.clients.openWindow(oURL.toString());```
244	ciditools.com.js	Caching of Untrusted Third-Party Resources	High	true	CWE-829	10	caches.open	standard	{The service worker caches third-party resources (e.g., from img1.wsimg.com, fonts.googleapis.com) using `caches.open` and `cache.addAll`. While these URLs are hardcoded, the vulnerability arises because the service worker caches untrusted external assets without validating their integrity or origin. This can lead to cache poisoning or delivery of malicious content if the third-party servers are compromised. The `caches.open` function is standard and used correctly, but the risk stems from caching untrusted external resources without proper security controls.}	```const staticAssets = JSON.parse('[\'//img1.wsimg.com/blobby/go/d6d00bff-669e-4c5a-a541-e7decf7eea36/gpub/4ce1a7c86682e5e8/styles.css\',\'//img1.wsimg.com/blobby/go/d6d00bff-669e-4c5a-a541-e7decf7eea36/gpub/f729a0af713c9111/styles.css\',\'//img1.wsimg.com/blobby/go/d6d00bff-669e-4c5a-a541-e7decf7eea36/gpub/7787a9e16c55a0bc/styles.css\',\'https://img1.wsimg.com/poly/v2/polyfill.min.js?unknown=polyfill&flags=gated&features=default%2Cfetch%2CArray.prototype.%40%40iterator%2CArray.prototype.find%2CArray.prototype.findIndex%2CFunction.name%2CNumber.isFinite%2CPromise%2CString.prototype.repeat%2CMath.sign%2CMath.trunc%2CArray.prototype.includes%2CObject.entries%2CObject.values%2CIntersectionObserver%2CIntl.~locale.en-US\',\'//img1.wsimg.com/blobby/go/gpub/e645c3e6fe995b50/script.js\',\'//img1.wsimg.com/ceph-p3-01/website-builder-data-prod/static/widgets/UX.3.55.15.js\',\'//img1.wsimg.com/blobby/go/gpub/340ac28cd4176b5a/script.js\',\'//fonts.googleapis.com/css?family=Cabin:700\',\'//fonts.googleapis.com/css?family=Lato:100,300,400,400i,700,700i,900\']');```
245	p9.com.js	Vulnerable Cache Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from logic flaws in the exclusion check rather than misuse of a sensitive function. The code checks if the request URL contains any of the strings in offlineExclude, but this check is not robust and may be bypassed by URL encoding or path traversal, leading to unintended cache bypass. No sensitive function is misused here.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
246	p9.com.js	Insecure Cache Matching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the use of `caches.match()` without proper validation of the request, which may lead to unintended cache hits or misses. However, this is not due to misuse of a sensitive function but rather a design flaw in cache handling logic. The function `caches.match()` is used correctly in terms of syntax and intent.}	```e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));```
247	se.pl.js	Remote Code Execution via Untrusted importScripts	High	true	CWE-94	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., pushpushgo.com), it can lead to Remote Code Execution if the external script is compromised or controlled by an attacker. Although the URL is hardcoded here, the vulnerability arises because the script source is not under the developer’s direct control and could be altered via DNS hijacking, supply chain attacks, or if the third-party service is compromised. This constitutes misuse of a sensitive function due to lack of trust validation.}	```importScripts('https://s-eu-1.pushpushgo.com/63da411bcc43efdfa03b51c9/worker.js');```
248	omaha.com.js	Improper Input Validation in URL Construction	High	true	CWE-20	N/A	let oURL = new URL(oData.url);	standard	{The `new URL()` constructor is a standard JavaScript function that parses and constructs URLs. When used with untrusted input (here, `oData.url` from a Firebase message payload), it can lead to improper URL construction, potentially allowing an attacker to manipulate the URL structure (e.g., redirecting to malicious domains or injecting malicious parameters). This is a high-risk issue because it can lead to open redirects or unintended resource access.}	```let oURL = new URL(oData.url);```
249	omaha.com.js	Potential XSS via Unsanitized Notification Data	Medium	true	CWE-79	N/A	oNotify.body = oPayload.body;	standard	{The `showNotification()` method is a standard browser API that displays notifications. When the `body` field is populated with unsanitized user-controlled data (`oPayload.body`), it can lead to Cross-Site Scripting (XSS) if the notification content is rendered in a context where script execution is possible (e.g., in some browsers or extensions). Although notifications are typically not executable, certain environments may allow script injection, making this a medium-risk vulnerability.}	```oNotify.body = oPayload.body;```
250	omaha.com.js	Potential XSS via Unsanitized Notification Data	Medium	true	CWE-79	N/A	oNotify.icon = oPayload.data.icon;	standard	{The `icon` field in `showNotification()` is intended to display an image. However, if the `icon` URL is derived from untrusted input (`oPayload.data.icon`), it can be crafted to point to a malicious resource or even a data URI containing executable content, potentially leading to XSS or other attacks if the browser or platform renders it in a context that executes embedded scripts. This is a medium-risk issue due to the potential for malicious content delivery.}	```oNotify.icon = oPayload.data.icon;```
251	myfreecams.com.js	Insecure Handling of Icon URL in Push Notification	Medium	true	CWE-80	N/A	showNotification	standard	{The showNotification function is used to display a push notification with an icon specified by payload.icon. If payload.icon is derived from untrusted input (e.g., from a malicious push message), it could be a URL pointing to a remote resource, potentially leading to content injection or phishing if the icon is loaded from an attacker-controlled domain. This constitutes improper handling of untrusted data in a sensitive context.}	```self.registration.showNotification(payload.title, options);```
252	hyperallergic.com.js	Insecure Message Handling (Nonce/Version Injection	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from directly assigning user-controlled message data to `nonceValue` and `versionValue` without validation or sanitization, but no sensitive JavaScript function is misused. The risk stems from improper input handling, not from a function like `eval`, `importScripts`, or `fetch` being abused with dynamic input.}	```if (event.data.indexOf('newspack-nonce-') === 0) { nonceValue = event.data.replace('newspack-nonce-', ''); }```
253	hyperallergic.com.js	Insecure Client URL Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The assignment `currentPage = client.url;` is not a misuse of a sensitive function. The `client.url` is a read-only property of the Client object, and no dangerous function is invoked with untrusted input. The risk is informational or logging-related, not due to function misuse.}	```currentPage = client.url;```
254	hyperallergic.com.js	Potential XSS via currentPage	Medium	false	CWE-79	N/A	N/A	N/A	{Although `currentPage` is derived from `client.url`, it is not used in a context that directly renders content in the DOM or executes code. No sensitive function like `eval`, `innerHTML`, or `document.write` is used with `currentPage`, so this is not a sensitive function misuse.}	```currentPage = client.url;```
255	hyperallergic.com.js	Insecure Precaching URLs	Low	false	CWE-918	N/A	N/A	N/A	{The URLs in `precache` are hardcoded and not derived from untrusted input. The `wp.serviceWorker.precaching.precache()` function is used correctly with static URLs, so no sensitive function misuse occurs.}	"```wp.serviceWorker.precaching.precache([{""url"": ""https:\/\/hyperallergic.com\/?wp_error_template=offline"", ""revision"": ""0.8.1;newspack-theme=2.1.0;options=8ef3e373adea1597a4255a2395754f29;nav=76107b5b6774ff5fc2ef5a61f2ba84bc;deps=37fc54296bac77963195fde30914bf63;0c2d584d75142f0aa2defbab82478d65""}]);```"
256	vanguardia.com.mx.js	Open Redirect via Unvalidated Click Action URL	High	true	CWE-601	10	self.clients.openWindow	standard	{The function self.clients.openWindow is a standard Service Worker API that opens a new browser window or tab with the provided URL. When used with unvalidated input from a notification's click_action field (which originates from a remote message payload), it allows an attacker to redirect users to arbitrary URLs, potentially leading to phishing or malicious site redirection. The input is dynamic and not sanitized, making this a direct misuse of a sensitive function.}	```self.clients.openWindow(a.notification.data.click_action)```
257	astrosage.com.js	Outdated Firebase Library	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase library (4.9.1), which may contain known security flaws. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() with untrusted input. The importScripts() call uses a hardcoded, trusted URL, so there is no dynamic or untrusted input involved.}	```importScripts('https://www.gstatic.com/firebasejs/4.9.1/firebase-app.js');```
258	sazka.cz.js	Loading external script without integrity check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used without integrity checks, it introduces a risk if the script at the URL is compromised or modified by an attacker. Although the URL is hardcoded in this case, the vulnerability arises from the lack of integrity verification, which could allow an attacker to serve a malicious script if the remote resource is compromised. This is considered a sensitive function misuse because it allows arbitrary script execution from an external source without validation.}	"```importScripts(""https://api-analytics.sazka.cz/js/service-worker.min.js"");```"
259	ijogo.com.js	XSS in Notification Data	High	true	CWE-79	N/A	showNotification	standard	{The showNotification function is used with data derived from untrusted push notification payload (via JSON.parse(event.data.text())), specifically the title, body, and image fields. If these fields contain malicious content (e.g., JavaScript via HTML injection in the notification body or icon URL), and if the browser renders them in a context where script execution is possible (e.g., via rich notifications or embedded content), it could lead to XSS. Although modern browsers often sanitize notification content, relying on untrusted input for notification fields without sanitization is inherently risky and constitutes misuse of a sensitive function.}	```self.addEventListener('push', function (event) { let data = JSON.parse(event.data.text()); const title = data.notification.title || ''; const options = { body: data.notification.body, icon: data.notification.image || '', badge: data.notification.image || '' }; event.waitUntil(self.registration.showNotification(title, options)); });```
260	ijogo.com.js	Flawed URL Validation in Fetch Handler	Medium	false	CWE-362	N/A	N/A	N/A	{The vulnerability arises from flawed logic in URL validation, not from misuse of a sensitive function. The code checks for specific substrings in the URL and then attempts to validate the path segment after 'https://' by checking for a dot within the first 60 characters. This is a logic flaw, not a sensitive function misuse, as no function like eval, importScripts, or dynamic code execution is involved. The fetch() function is used correctly and safely here.}	```self.addEventListener('fetch', e => { for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; } var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; } e.respondWith(caches.match(e.request).then(response => response || fetch(e.request))); });```
261	opb.org.js	Hardcoded Sensitive Credentials	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (appKey, token, vapidPublicKey) in the script, not due to misuse of a sensitive JavaScript function. These values are static and not derived from untrusted input or dynamically constructed URLs.}	```importScripts('https://web-sdk.urbanairship.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://www.opb.org/OPB_90x90.jpg', defaultTitle: 'OPB', defaultActionURL: 'https://www.opb.org', appKey: '9SyZIzpgRVGxnTZKpJhFsA', token: 'MTo5U3laSXpwZ1JWR3huVFpLcEpoRnNBOl83UzhDSXZyNVpyU2xIWlNwX3djRjdpaDNwZk5ybU10cXlQdW1hb2MzbW8', vapidPublicKey: 'BOG0POdrNX5R_LA2p_p9zoiKC_jFFniFOKPEujP3V7Kky-e2fh9uOauysW3Wy09lwpyFDwQb4g5-UWhvOWQzMpQ=' });```
262	sf-express.com.js	Information Exposure Through Error Logging	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from logging detailed error messages that include the request URL and error details, which can expose sensitive information to the console. However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by poor error handling practices. The console.error() function is used appropriately here, and no dynamic or untrusted input is being logged in a way that introduces a direct security risk via function misuse.}	```fetchDidFail(ctx) { ctx.error.message = '[workbox] Network request for ' + ctx.request.url + ' threw an error: ' + ctx.error.message; console.error(ctx.error, 'Details:', ctx);}```
263	8x8.vc.js	Improper Access Control	High	false	N/A	N/A	N/A	N/A	{The vulnerability described is not caused by misuse of a sensitive JavaScript function, but rather by a design flaw in handling offline responses. The code attempts to return a cached offline page when network fetch fails, but this does not inherently involve unsafe use of a sensitive function like importScripts, eval, or dynamic code execution. The issue lies in the logic of fallback handling, not in function misuse.}	```const cachedResponse = await cache.match(OFFLINE_URL); return cachedResponse;```
264	winnipegfreepress.com.js	Open Redirect in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The code uses `clients.openWindow` to open a URL derived from the notification payload (`t.clickValue` or `JSON.parse(t.clickValue).postUrl`). Since this value is sourced from untrusted external data (FCM message payload), an attacker can craft a malicious notification that redirects users to arbitrary websites, leading to phishing or malware distribution. This is a classic open redirect vulnerability caused by unsanitized input being passed directly to a navigation function.}	"```self.addEventListener(""notificationclick"", function (e) { if (e.notification.close(), e.notification) { let t = {}; e.notification.data && e.notification.data.FCM_MSG && e.notification.data.FCM_MSG.data ? t = e.notification.data.FCM_MSG.data : ""object"" == typeof e.notification.data && (t = e.notification.data); const n = t.clickType || """"; (""openURL"" === n || kn.includes(n)) && e.waitUntil(clients.matchAll({ type: ""window"" }).then(function () { let e = ""/""; if (kn.includes(n)) try { e = JSON.parse(t.clickValue).postUrl; } catch (e) { console.error(""Notification payload can't be parsed""); } else ""openURL"" === n && (e = t.clickValue); if (clients.openWindow) return clients.openWindow(e); }).catch(e => { console.warn(`${e.name}: ${e.message}`); })); } }, !1);```"
265	trendyol-milla.com.js	Insecure Third-Party Dependency	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted third-party source (e.g., cdn.dsmcdn.com), it introduces a high-risk dependency. If the third-party server is compromised or the script is malicious, the service worker can be hijacked, leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the dependency itself is insecure due to lack of integrity verification or origin trust.}	"```importScripts(""https://cdn.dsmcdn.com/storefrontmarketing/webpush/webpush.worker.bundle.js?v=38"");```"
266	skrill.com.js	Hardcoded Sensitive Information in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (appserviceKey, apiKey, accountToken) in the client-side JavaScript code, not due to misuse of a sensitive function. These values are embedded directly in the script and exposed to the client, allowing attackers to extract and misuse them.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BNciMoL1r4B9Vz0mxlM5CAqukDQFKKwq9GlXhS6M4pfPJ7S-6V75edCC2GZg5vFsa6C9uOSthGDqz1pTibGG3fk="",""apiKey"":""ABETeObBfVC4ipn0bFL7FPVYY"",""accountToken"":""ABEsCqYEbbE93CzyY-hvLcluY"",""appver"":""0.0.0"",""apiHost"":""https://m7tu2-webpush.oraclersys.com"",""lazy"":false}';orawp.init(config);```"
267	stylecraze.com.js	Insecure 'no-cors' Fetch Requests	High	true	CWE-918	9	fetch	standard	{The fetch function is used with 'mode': 'no-cors', which prevents access to response data and can lead to unintended data exposure or bypass of CORS protections, especially when combined with dynamic URLs. This misuse allows attackers to trigger fetches to arbitrary origins without proper validation, potentially leaking sensitive information or enabling cross-origin resource manipulation.}	N/A
268	stylecraze.com.js	XSS via Dynamic Script Execution in Partytown	High	true	CWE-79	10	Worker	standard	{The Worker constructor is used with a Blob containing dynamically generated script content, which is derived from untrusted or unsanitized input (e.g., Partytown configuration). This allows an attacker to inject arbitrary JavaScript code into the service worker, leading to persistent cross-site scripting (XSS) and full control over the service worker’s behavior.}	N/A
269	stylecraze.com.js	Service Worker Client Takeover	Medium	false	CWE-295	0	N/A	N/A	{The self.clients.claim() function is used to claim control over clients, but it does not involve dynamic or untrusted input. This is a standard, safe operation in service workers and does not constitute sensitive function misuse.}	N/A
270	currenttime.tv.js	Cache Poisoning via Unvalidated URL Origin	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the use of `fetch(event.request)` without validating the origin of the requested URL. Since `event.request.url` is derived from the client's request (which can be manipulated by an attacker), and the response is cached using `cache.put(event.request, networkResponse.clone())` without origin validation, an attacker can trigger the service worker to cache malicious or unintended responses. This allows cache poisoning, where the attacker can serve tampered content to users. The `fetch` function is a standard JavaScript API that, when used with untrusted URLs, can lead to such vulnerabilities.}	```if (regexCheck(event.request.url) && !noCache) { event.respondWith(caches.open('cache-dynamic').then(function (cache) { return cache.match(event.request).then(function (response) { var fetchPromise = fetch(event.request).then(function (networkResponse) { if (networkResponse.status === 200 || networkResponse.type === 'opaque') { cache.put(event.request, networkResponse.clone()); } return networkResponse; }); return response || fetchPromise; }); }).catch(function (error) { console.error(error, event.request.url); })); } else {}```
271	myitero.com.js	Mixed Content Handling	Medium	false	N/A	N/A	N/A	N/A	{The code checks for mixed content by comparing the origin of the request URL with the service worker's scope origin. This is a defensive logging action and does not involve any sensitive function misuse. The logic is safe and does not expose the system to direct exploitation.}	```const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl); if (requestUrlObj.origin.startsWith('http:') && scopeUrl.startsWith('https:') ) { this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`); return; }```
272	myitero.com.js	Debug Log Information Exposure	Medium	false	N/A	N/A	N/A	N/A	{The code logs error details to a debug handler, which is intended for development and debugging purposes. While this may expose sensitive information if debug logs are accessible to unauthorized users, it does not stem from misuse of a sensitive JavaScript function. The logging is controlled and does not involve dynamic or untrusted input being passed to a dangerous API.}	```this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);```
273	Fernsehserien.de.js	Improper Handling of Offline Fallback Page	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the offline fallback page being hardcoded and not dynamically controlled by user input. There is no misuse of a sensitive function such as importScripts, eval, or dynamic code execution. The issue is more about improper configuration or lack of fallback flexibility rather than sensitive function misuse.}	"```const SW_VERSION = 35,  CACHE = ""fs-service-worker-35"",  OFFLINE_FALLBACK_PAGE = ""test.fernsehserien.de"" == self.location.hostname ? ""https://test.fernsehserien.de/static/offline.html"" : ""https://bilder.fernsehserien.de/fernsehserien.de/fs-2021/offline.html"",  PRECACHE_URLS = [OFFLINE_FALLBACK_PAGE];function fromCache(e) {  return caches.open(CACHE).then(function (t) {    return t.match(e).then(function (n) {      return n && 404 !== n.status ? n : ""document"" !== e.destination || ""navigate"" !== e.mode ? Promise.reject(""no-match"") : t.match(OFFLINE_FALLBACK_PAGE);    });  });}function updateCache(e, t) {  return caches.open(CACHE).then(function (n) {    return n.put(e, t);  });}self.addEventListener(""install"", function (e) {  e.waitUntil(caches.open(CACHE).then(function (e) {    return e.addAll(PRECACHE_URLS);  }));}), self.addEventListener(""activate"", function (e) {  var t = [CACHE];  e.waitUntil(caches.keys().then(e => Promise.all(e.map(e => {    if (!t.includes(e)) return caches.delete(e);  }))));}), self.addEventListener(""fetch"", function (e) {  ""GET"" === e.request.method && ""navigate"" === e.request.mode && e.respondWith(fetch(e.request).then(function (t) {    return e.waitUntil(updateCache(e.request, t.clone())), t;  }).catch(function (t) {    return fromCache(e.request);  }));});```"
274	slotscity.ua.js	External Script Loading from Untrusted Source	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., 'https://js.smartsender.io/js/v1/worker/63a4ae84890ede1aec59e2c7.js'), it introduces a high-risk vulnerability because the script can be modified by an attacker, leading to arbitrary code execution within the service worker context. This compromises the integrity and security of the web application, enabling cache manipulation, network interception, and potential data exfiltration.}	```self.importScripts('https://js.smartsender.io/js/v1/worker/63a4ae84890ede1aec59e2c7.js');```
275	sitesearch360.com.js	Improper Error Handling in IndexedDB Operations	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of proper error handling in IndexedDB operations. The code attempts to retrieve and process data from IndexedDB without checking for errors or handling exceptions appropriately, which can lead to silent failures or unexpected behavior.}	```var idb = indexedDB || mozIndexedDB || webkitIndexedDB || msIndexedDB;```
276	neteller.com.js	Hard-coded Sensitive Information in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (appserviceKey, apiKey, accountToken) in the client-side JavaScript code, not due to misuse of a sensitive function. These values are directly embedded in the script and exposed to the client, allowing attackers to extract and misuse them. No dynamic or unsafe function invocation is involved.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BCuZ66RGyNGvG8E6fGkCSFTFcwsgNBgvVInyq4Nn9hwDfeYlduEyQIJKetsIUXm1BUvrKgnwC_PgtXmenw0DxwE="",""apiKey"":""ABEXpK7ucyXHF1uSkBUU03Q7E"",""accountToken"":""ABEkSKyZaayRXsGqHbyH6TsOI"",""appver"":""0.0.0"",""apiHost"":""https://nf876q-webpush.oraclersys.com"",""lazy"":false}';orawp.init(config);```"
277	startbootstrap.com.js	Information Exposure via Debug Endpoint	High	true	CWE-200	10	adapter.newResponse	standard	{The adapter.newResponse function is used to generate a response containing sensitive debug information (e.g., driver version, state, manifest hash, last update check) when a request is made to the /ngsw/state endpoint. This function is misused by directly embedding dynamic, potentially sensitive data into the response body without any access control or authentication, leading to information exposure. The debug endpoint is accessible to any user who knows the URL, allowing attackers to gather internal system details that could aid in further exploitation.}	```const msgState = `NGSW Debug Info:\n\nDriver version: ${SW_VERSION}\nDriver state: ${state.state} (${state.why})\nLatest manifest hash: ${state.latestHash || 'none'}\nLast update check: ${this.since(state.lastUpdateCheck)}`;```
278	ppbet.club.js	Improper Input Validation in Fetch Handler	High	true	N/A	9	caches.match	custom	{The fetch handler uses caches.match() without validating or sanitizing the request URL, which may allow an attacker to trigger unintended cache behavior or bypass intended restrictions if the URL is manipulated. The function is custom in context as it's part of the Service Worker Cache API, but the misuse stems from improper input handling.}	```self.addEventListener('fetch', e => {  for (let i = 0; i < offlineExclude.length; i++) {    if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false;  }  var u = e.request.url.replace('https://', '');  var n = u.indexOf('/');  if (u.slice(n, 60).indexOf('.') == -1) {    return false;  }  e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));});```
279	ppbet.club.js	Unsanitized Data in Push Notification	Medium	true	N/A	8	self.registration.showNotification	standard	{The showNotification() function is used with data directly parsed from the push event without sanitizing the title or body fields, which could lead to cross-site scripting (XSS) if the data contains malicious scripts or HTML. The function is a standard Service Worker API, but its misuse here stems from unsanitized input.}	```self.addEventListener('push', function (event) {  let data = JSON.parse(event.data.text());  const title = data.notification.title || '';  const options = {    body: data.notification.body,    icon: data.notification.image || '',    badge: data.notification.image || ''  };  event.waitUntil(self.registration.showNotification(title, options));});```
280	delo.si.js	Code Injection via eval with Untrusted Input	High	true	CWE-78	10	eval	standard	{The function `eval` is used to execute a string (`funcStr`) that is derived from untrusted input (`event.notification.data.onClose` or `event.notification.data.onClick`). Since `eval` executes JavaScript code dynamically, an attacker can inject arbitrary code by controlling the notification data, leading to code injection and potential full compromise of the service worker.}	```if (funcStr.trim().length > 0) { eval('var func = ' + funcStr); if (isFunction(func)) func(); }```
281	delo.si.js	Open Redirect via Unvalidated URL in Notification Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from passing user-controlled `link` data directly into `clients.openWindow('/' + link)` without validation or sanitization. However, this is not caused by misuse of a sensitive function per se, but rather by improper input handling. The `clients.openWindow` function is not inherently unsafe when used with trusted input, so this is not classified as sensitive function misuse.}	```if (clients.openWindow) return clients.openWindow('/' + link);```
282	777spielen.com.js	External Script Import from Untrusted Source	High	true	CWE-494	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote source (//alert.guru/projects/lN49r2/sw.js), which is not under the control of the application. This allows an attacker to potentially control the script content, leading to arbitrary code execution within the service worker context. Since the script is imported from an external, untrusted domain, it constitutes a high-risk vulnerability.}	"```importScripts(""//alert.guru/projects/lN49r2/sw.js?version=1.0.0"");```"
283	cspinet.org.js	Regular Expression Pattern Error	Medium	false	CWE-1322	N/A	N/A	N/A	{The vulnerability is due to an improperly escaped regular expression pattern in the route registration, not due to misuse of a sensitive JavaScript function. The regex `/.(?:png|gif|jpe?g|svgz?|webp|woff2|mp4|webm|css|js)$/` is syntactically incorrect because it lacks a starting anchor and may not match as intended, but this is a logic or syntax error, not a security vulnerability arising from a sensitive function.}	"```if (!self.define) { let e, s = {}; const t = (t, n) => (t = new URL(t + "".js"", n).href, s[t] || new Promise(s => { if (""document"" in self) { const e = document.createElement(""script""); e.src = t, e.onload = s, document.head.appendChild(e); } else e = t, importScripts(t), s(); }).then(() => { let e = s[t]; if (!e) throw new Error(`Module ${t} didn’t register its module`); return e; })); self.define = (n, i) => { const o = e || (""document"" in self ? document.currentScript.src : """") || location.href; if (s[o]) return; let r = {}; const c = e => t(e, o), u = { module: { uri: o }, exports: r, require: c }; s[o] = Promise.all(n.map(e => u[e] || c(e))).then(e => (i(...e), r)); }; } define([""./workbox-4651c119""], function (e) { ""use strict""; self.skipWaiting(), e.clientsClaim(), e.registerRoute(/.(?:png|gif|jpe?g|svgz?|webp|woff2|mp4|webm|css|js)$/, new e.CacheFirst({ cacheName: ""static-assets"", plugins: [new e.ExpirationPlugin({ maxEntries: 100 })] }), ""GET""); });```"
284	radaris.com.js	Cache-first strategy without validation leading to stale content	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the cache-first strategy not validating or refreshing cached content, which can lead to serving stale data. However, this is not due to misuse of a sensitive function, but rather a design or logic flaw in the caching strategy. No sensitive function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); })); });```
285	puzzmo.com.js	Cross-Origin Resource Copy	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used to parse a potentially untrusted URL from the request object. If the URL's origin differs from the service worker's origin, an error is thrown. However, the function does not validate or sanitize the input URL before parsing, which could allow an attacker to craft a malicious URL that bypasses origin checks or triggers unintended behavior, especially if the URL is derived from user-controlled data.}	```const s = new URL(e.url).origin; if (s !== self.location.origin) throw new a('cross-origin-copy-response', { origin: s });```
286	puzzmo.com.js	Insecure Caching of Static Assets	Medium	false	N/A	N/A	N/A	N/A	{The filtering logic for precaching assets is based on string matching against URL paths, which is not inherently a sensitive function misuse. The vulnerability arises from the logic itself (excluding certain paths) rather than improper use of a sensitive function.}	```var W = M.filter(function (e) { var t = 'string' === typeof e ? e : e.url; return !t.endsWith('index.html') && !t.includes('assets/') && !t.includes('static/media'); });```
287	puzzmo.com.js	XSS via Unvalidated Push Data	High	true	N/A	N/A	self.registration.showNotification	standard	{The self.registration.showNotification function is used to display a notification with data directly from the push event's payload. Since the title is passed without sanitization or validation, an attacker can inject malicious content (e.g., script tags) into the notification, leading to potential XSS if the notification is rendered in a context that executes script.}	```self.registration.showNotification(e.data.json().title, S(S({}, e.data.json()), {}, { icon: 'https://cdn.puzzmo.com/assets/puzicon.png' }));```
288	trib.com.js	Open Redirect Vulnerability	High	true	CWE-601	10	N/A	standard	{The function self.clients.openWindow() is a standard Service Worker API that opens a new window or tab with the provided URL. In this case, the URL is constructed from oData.url, which is derived from the FCM message payload. Since this payload is controlled by the server sending the notification (and potentially by an attacker if the server is compromised or if the payload is not validated), it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerability. The URL is dynamically constructed and not hard-coded, making it a sensitive misuse.}	```self.clients.openWindow(oURL.toString());```
289	dailytimes.com.pk.js	Use of Third-Party Code with Known Vulnerabilities	Medium	false	CWE-426	N/A	N/A	N/A	{The use of importScripts with hardcoded URLs does not constitute sensitive function misuse, as the URLs are not derived from untrusted or dynamic input. The vulnerability arises from potential known issues in third-party scripts, not from improper use of the function itself.}	```importScripts('https://dailytimes.com.pk/pwa-sw.js');```
290	dailytimes.com.pk.js	Use of Third-Party Code with Known Vulnerabilities	Medium	false	CWE-426	N/A	N/A	N/A	{The use of importScripts with hardcoded URLs does not constitute sensitive function misuse, as the URLs are not derived from untrusted or dynamic input. The vulnerability arises from potential known issues in third-party scripts, not from improper use of the function itself.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
291	ayoba.me.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the script is loaded from a hardcoded external URL ('https://ntm.netmera-web.com/wsdk2/netmera_sw.js?v=4.2.7'), which is not verified for integrity. While the URL is hardcoded and not dynamically derived from untrusted input, the lack of integrity checks (e.g., Subresource Integrity or cryptographic verification) means that if the external script is compromised, the service worker could execute malicious code. This constitutes a sensitive function misuse because importScripts() inherently introduces risk when used without integrity validation, even with static URLs.}	```importScripts('https://ntm.netmera-web.com/wsdk2/netmera_sw.js?v=4.2.7'), netmera = {};```
292	mega-moolah-play.com.js	Insecure External Resource Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (//alert.guru/projects/zN1kKE/sw.js), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows an attacker to control the loaded script, leading to arbitrary code execution within the service worker context, which can compromise the entire application’s security, including intercepting network requests, manipulating cache, or stealing sensitive data.}	"```importScripts(""//alert.guru/projects/zN1kKE/sw.js?version=1.0.0"");```"
293	medindia.net.js	Open Redirect via Decoded URL in Notification Click	High	true	CWE-601	10	decodeURIComponent	standard	{The decodeURIComponent function is used to extract a URL from the notification icon's query string without validating or sanitizing the input. Since the URL is derived from user-controlled data (notification icon), an attacker can craft a malicious notification with a URL pointing to an arbitrary external site, leading to an open redirect.}	N/A
294	medindia.net.js	XSS via Unvalidated Notification URL	High	true	CWE-79	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from the notification icon's query string, which is parsed without validation. If an attacker can control the notification content, they can inject a malicious URL that executes arbitrary JavaScript when opened, leading to cross-site scripting (XSS).}	N/A
295	medindia.net.js	Insecure Fetch with Sensitive Data in URL	Medium	true	CWE-319	9	fetch	standard	{The fetch function is used to send sensitive data (subscriptionId, notificationTag, hash) directly in the URL query string. This exposes sensitive information in server logs, browser history, and network traffic, increasing the risk of data leakage.}	N/A
296	medindia.net.js	Error Logging with Sensitive Data	Low	true	CWE-200	8	fetch	standard	{The fetch function is used to log error details, including the subscriptionId and error message, directly in the URL. This can lead to exposure of sensitive data in server logs, browser history, and network traffic, violating data confidentiality.}	N/A
297	168dollarstore.com.js	Cache Poisoning via Cross-Origin Response Handling	High	true	CWE-352	10	new Response	standard	{The new Response constructor is used to create a response from a cross-origin request body, which can lead to cache poisoning if the response is cached and later served to other users. The code checks for cross-origin but does not prevent the creation of a response object from a cross-origin request body, which can be exploited to inject malicious content into the cache.}	```async function r(e, t) { let s = null; if (e.url && (s = new URL(e.url).origin), s !== self.location.origin) throw new n.V('cross-origin-copy-response', { origin: s }); const r = e.clone(), i = { headers: new Headers(r.headers), status: r.status, statusText: r.statusText }, c = t ? t(i) : i, o = (0, a.x)() ? r.body : await r.blob(); return new Response(o, c); }```
298	168dollarstore.com.js	Insecure Cache Expiration Configuration	Medium	false	CWE-327	8	ExpirationPlugin	custom	{The ExpirationPlugin is configured with long maxAgeSeconds values (e.g., 31536e3 seconds = 1 year), which can lead to stale content being served for extended periods. However, this is not due to misuse of a sensitive function but rather a misconfiguration in the plugin's parameters.}	```new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })```
299	168dollarstore.com.js	Insecure Cache Expiration Configuration	Medium	false	CWE-327	8	ExpirationPlugin	custom	{The ExpirationPlugin is configured with long maxAgeSeconds values (e.g., 2592e3 seconds = 30 days), which can lead to stale content being served for extended periods. This is a configuration issue, not a misuse of a sensitive function.}	```new n.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 2592e3 })```
300	flashforge.com.js	XSS via Untrusted Push Data	High	true	CWE-79	9	N/A	standard	{The service worker uses self.registration.showNotification() with data parsed directly from untrusted push message data (t.data.json()). Since the notification content (title, body, icon, etc.) is derived from this untrusted input without sanitization, an attacker can inject malicious content that may lead to XSS if rendered in a context where user input is not properly escaped, especially if the notification is displayed in a web page or if the service worker interacts with the client in a way that reflects this data.}	```const i = null === (e = t.data) || void 0 === e ? void 0 : e.json(); return i ? self.registration.showNotification(i.title, { body: i.body, icon: i.iconUrl, badge: i.badge, vibrate: void 0, image: i.heroImageUrl, silent: !1, requireInteraction: i.requireInteraction, actions: o.NotificationMessage.parseActions(i), data: i }) : self.registration.showNotification('Get Latest Updates', { body: 'Checkout Latest offers', icon: i.iconUrl });```
301	flashforge.com.js	Insecure Cookie Handling	Medium	false	CWE-1122	0	N/A	standard	{The use of document.cookie is not inherently a sensitive function misuse in this context; it is a standard browser API for setting cookies. The vulnerability arises from the lack of secure flags (e.g., Secure, HttpOnly) and improper handling of cookie expiration, not from misuse of a sensitive function.}	```document.cookie = `${t}=${e};max-age=${this.cookiePeriod};path=/`;```
302	flashforge.com.js	Open Redirect via Unvalidated URL	Medium	true	CWE-601	9	N/A	standard	{The service worker uses self.clients.openWindow(e.url) where e.url is derived from untrusted notification data. Since the URL is not validated or sanitized, an attacker can supply a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or other malicious destinations.}	```yield self.clients.openWindow(e.url);```
303	missoulian.com.js	Open Redirect via Untrusted URL in Notification Data	Medium	true	CWE-602	9	new URL	standard	{The function new URL is used to construct a URL object from oData.url, which originates from untrusted notification data. Since the URL is constructed without validation or sanitization, an attacker can manipulate the notification payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```let oURL = new URL(oData.url);```
304	pressofatlanticcity.com.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-601	9	new URL	standard	{The function new URL is used to construct a URL object from oData.url, which originates from untrusted notification payload data. Since the URL is not validated or sanitized, an attacker can craft a malicious URL (e.g., redirecting to a phishing site) that will be opened when the notification is clicked, leading to an open redirect vulnerability.}	```let oURL = new URL(oData.url); if (oData.utm_source && oData.utm_medium && oData.utm_campaign) { oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign); }```
305	saarland.de.js	Improper Input Validation in Service Worker Handling Push Notification Data	High	true	CWE-20	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When used with unvalidated input from event.notification.data, which originates from push notification payload data (potentially controlled by an attacker), it allows arbitrary URL redirection. This can lead to phishing, drive-by downloads, or other malicious actions if the attacker supplies a malicious URL. The input is not sanitized or validated, making this a high-confidence sensitive function misuse.}	```event.waitUntil(clients.openWindow(event.notification.data));```
306	khabarfoori.com.js	Information Exposure via Console Logging	Medium	false	N/A	N/A	N/A	N/A	{The console.log function is not inherently sensitive in the context of service workers, but its use here exposes request URLs in the browser's developer console, which may reveal internal or sensitive paths. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logging practice that leaks information.}	```console.log(e.request.url);```
307	estatesales.net.js	Broad External Domain Allowlist in NetworkOnly Strategy	Medium	true	CWE-20	9	N/A	standard	{The vulnerability arises from the use of a broad regular expression `^https?\\:\\/\\/[^\\/]+\\/?$` in `e.registerRoute()` with `NetworkOnly` strategy. While `registerRoute` itself is not inherently sensitive, its misuse with a permissive pattern allows any external domain to be fetched without caching, potentially enabling attackers to redirect or intercept requests to malicious domains. The sensitive function here is `registerRoute` from the Workbox library, which is a standard API used to define routing rules. The broad pattern allows any external URL to be matched, leading to a lack of control over external resource fetching, which is a form of improper use of a standard routing API.}	```e.registerRoute(/^https?\\:\\/\\/[^\\/]+\\/?$, new e.NetworkOnly(), 'GET')```
308	pac.ru.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed directly from the notification data (n.ShowLink) without validation. Since this URL is derived from untrusted input (push notification payload), an attacker can craft a malicious notification to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```if (null !== n.ShowLink && void 0 !== n.ShowLink && '' !== n.ShowLink && PACPUSH_LOGICS_OpenLink(i, n.ShowLink), void PACPUSH_TALK_Action(n, ''click'', '', self);```
309	idownloadblog.com.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript function used in Service Workers to load and execute external scripts. When used without integrity checks, it can lead to the execution of potentially malicious or tampered scripts if the remote source is compromised. In this case, the script is loaded from a third-party CDN (cdn.webpushr.com), which introduces a supply chain risk. If an attacker compromises the CDN or the script source, they can inject malicious code that runs with the same privileges as the service worker, leading to data exfiltration, cache manipulation, or man-in-the-middle attacks.}	```importScripts('https://cdn.webpushr.com/sw-server.min.js');```
310	mui.com.js	Unrestricted Message Handling Leading to Forced Navigation	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from unrestricted handling of messages sent to the service worker, which triggers navigation of client windows to their current URL. While this does not involve direct misuse of a sensitive function like importScripts or eval, the issue stems from the lack of input validation or message filtering, leading to potential abuse if an attacker can send messages to the service worker. However, since no sensitive function is being misused with untrusted input, this is not classified as a sensitive function misuse.}	```self.addEventListener('message', () => { self.clients.matchAll({ type: 'window' }).then(windowClients => { windowClients.forEach(windowClient => { windowClient.navigate(windowClient.url); }); }); });```
311	thenewsminute.com.js	Loading external scripts without validation	High	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with hardcoded URLs, as in this case, it does not inherently introduce a vulnerability. However, the vulnerability described — ""Loading external scripts without validation"" — implies a risk if the script URLs were dynamically constructed from untrusted input. Since the URLs here are hardcoded and not derived from user-controlled or untrusted sources, the misuse is not present. Therefore, the vulnerability is not caused by sensitive function misuse.}"	```importScripts('https://www.thenewsminute.com/service-worker.js?version=0');importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
312	castorama.pl.js	Hardcoded Credentials	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials (appKey, token, vapidPublicKey) and not due to misuse of a sensitive JavaScript function. These values are static and embedded directly in the code, posing a risk if exposed, but no dynamic or unsafe function invocation is involved.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://c00135\u002Ddl.urbanairship.com/binary/public/z1CwWnVSTs6YGQQnYWZQmg/84993fca\u002D9721\u002D46f2\u002D9063\u002Ddd92f6e2a12a', defaultTitle: 'Castorama', defaultActionURL: 'https://www.castorama.pl/', appKey: 'z1CwWnVSTs6YGQQnYWZQmg', token: 'MTp6MUN3V25WU1RzNllHUVFuWVdaUW1nOktaX3FjX2dzak92dHpjQ3RmSFFXV3lmXzBuc045MzRkeVRxeXRUSkpHU3c', vapidPublicKey: 'BH3TaU83HlTUMzQZ_DkPfl-5SLKGqkz6xGNznWF5D8m4PscxpH3QlFjFKEG8ePjNATriI-jnHKA3JSZ-vFHjFJ0='});```
313	hechingerreport.org.js	Improper Validation of Nonce and Version Values Leading to CSRF	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the direct assignment of unvalidated message data to global variables `nonceValue` and `versionValue` without any integrity checks or sanitization. This allows an attacker to inject arbitrary values via `postMessage`, potentially leading to CSRF attacks when these values are later used in API requests. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts`, `eval`, or `fetch` with untrusted input, but rather by improper handling of message data.}	```self.addEventListener('message', function (event) { if (event.data.indexOf('newspack-nonce-') === 0) { nonceValue = event.data.replace('newspack-nonce-', ''); } if (event.data.indexOf('newspack-version-') === 0) { versionValue = event.data.replace('newspack-version-', ''); } });```
314	newzit.com.js	Insecure Dynamic Script Loading	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a dynamically constructed URL based on self.location.origin, which is determined at runtime. Although the origin is restricted to two known domains ('https://www.newzit.com' and 'https://www.newzitint.com'), the dynamic nature of the script URL construction introduces a risk if the origin value is ever manipulated or if the logic is bypassed. While the current implementation appears safe due to the limited domain choices, the use of importScripts() with dynamic inputs is inherently risky and can lead to remote code execution if an attacker can influence the scriptBase value.}	```var scriptBase = self.location.origin === 'https://www.newzit.com' ? 'https://www.newzit.com' : 'https://www.newzitint.com'; importScripts(scriptBase + '/api/web-push-notification/v1/static/latest/mol-fe-web-push-sw/sw.js');```
315	magzter.com.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL derived from the push event data (a.raiseNotificationViewedPath), which is user-controlled via the push notification payload. Since the URL is not validated or sanitized, an attacker can craft a malicious payload to trigger fetch requests to arbitrary internal or external endpoints, leading to SSRF.}	"```self.addEventListener(""push"", function (b) { console.log(""Push event: "", b); var a = JSON.parse(b.data.text()), c = a.title, d = a.notificationOptions, f = d.data, e; ""undefined"" !== typeof f && (e = f.wzrk_id); ""undefined"" === typeof e && (e = c); localforage.setItem(e, b.data.text()).then(function (a) {})[""catch""](function (a) { console.log(""Error in persisting""); }); globalRedirectPath = a.redirectPath; globalNotificationData = a; a = a.raiseNotificationViewedPath; ""undefined"" !== typeof a && fetch(a, { mode: ""no-cors"" }); b.waitUntil(self.registration.showNotification(c, d)); });```"
316	magzter.com.js	Open Redirect	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL constructed from user-controlled data (deepLink from notification options). Since the URL is not validated or sanitized, an attacker can manipulate the notification payload to redirect users to arbitrary external sites, leading to open redirect vulnerabilities.}	"```function onClick(b, a, c) { var d = !0; ""action1"" === b.action ? (""undefined"" !== typeof c.notificationOptions.actions[0].deepLink && (a += ""&r="" + encodeURIComponent(c.notificationOptions.actions[0].deepLink), d = !1), a += ""&b="" + encodeURIComponent(""button1"")) : ""action2"" === b.action ? (""undefined"" !== typeof c.notificationOptions.actions[1].deepLink && (a += ""&r="" + encodeURIComponent(c.notificationOptions.actions[1].deepLink), d = !1), a += ""&b="" + encodeURIComponent(""button2"")) : (""undefined"" !== typeof c.deepLink && (a += ""&r="" + encodeURIComponent(c.deepLink), d = !1), a += ""&b="" + encodeURIComponent(""button0"")); d ? fireSilentRequest(a) : clients.openWindow(a); b.notification.close(); }```"
317	magzter.com.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL derived from the parameter 'b' (which is passed from onClick), which itself is constructed from user-controlled data (deepLink). Since the URL is not validated or sanitized, an attacker can craft a malicious payload to trigger fetch requests to arbitrary internal or external endpoints, leading to SSRF.}	"```var fireSilentRequest = function (b) { fetch(b + ""&s=true"", { mode: ""no-cors"" }); };```"
318	lex.pl.js	External Script Inclusion in Service Worker	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes scripts from specified URLs. When used with a hardcoded external URL (e.g., 'https://s-eu-1.pushpushgo.com/...'), it introduces a high-risk vulnerability because the script is fetched and executed from an untrusted third-party domain. This allows the external party to inject malicious code into the service worker, potentially compromising the entire web application’s security, including intercepting network requests, manipulating cache, or stealing sensitive data.}	```importScripts('https://s-eu-1.pushpushgo.com/5bee810c61c9da000bbe6ec7/worker.js');```
319	aachener-zeitung.de.js	External Script Inclusion from Untrusted Source	Medium	false	N/A	0	N/A	N/A	{The importScripts() call is not dynamically constructed from untrusted input; it uses a hardcoded URL. While the source is untrusted, the lack of dynamic input means it does not constitute sensitive function misuse.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
320	aachener-zeitung.de.js	Hardcoded API Key and Token	High	false	N/A	0	N/A	N/A	{The vulnerability arises from hardcoded credentials, not from misuse of a sensitive JavaScript function. The uaSetup.worker() call is a custom function and does not inherently introduce risk through dynamic input or unsafe execution.}	```uaSetup.worker(self, { defaultIcon: 'https://shared.mediahuis.be/logos/az/v1/brand\u002Dsquare\u002Dmain/256x256.png', defaultTitle: 'Aachener Zeitung', defaultActionURL: 'https://aachener\u002Dzeitung.de', appKey: '79mUgs06QMWfCdxtWQGkdA', token: 'MTo3OW1VZ3MwNlFNV2ZDZHh0V1FHa2RBOk5raVpmYlYyRnNTdi0wSXZtM3VFWm1hNFR4dlEwbzdBZTRCWHRiRmJ1MGc', vapidPublicKey: 'BCMyjCSydyd1vB-zOx-oVzNDJLL46rhwWVXeyIyw7lsg6AfO_89Acw4v6h8QQw61bYqtO9PyBPmzzEXw05CobNc=' });```
321	kenhub.com.js	Insecure Cache Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper logic in cache fallback handling. The code attempts to serve an offline page based on locale derived from the URL path, but the issue lies in the logic and potential for incorrect locale inference, not in a dangerous function call.}	"```self.addEventListener(""fetch"", e => { const { url: n, method: s } = e.request; if (""GET"" === s && n.match(/^(http|https):\/\//i) && new URL(n).origin === location.origin && ""document"" === e.request.destination) return e.respondWith(fetch(e.request).catch(() => caches.match(`/offline_v2_${t(n)}.html`))); });```"
322	rumah123.com.js	Improper Handling of Redirect Responses	Medium	false	CWE-352	N/A	N/A	N/A	{The vulnerability arises from improper handling of opaque redirect responses, but it is not caused by misuse of a sensitive JavaScript function. The code throws an error when a cached response is null or of type 'opaqueredirect', which is a logic issue rather than a function misuse.}	```if (!cachedResponse || cacheResponse.type === 'opaqueredirect') { throw new Error();}```
323	rumah123.com.js	Lack of Request Validation for Sensitive Data	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from insufficient validation of requests before caching, but it is not due to misuse of a sensitive function. The code caches responses without verifying the request's origin or content, which is a design flaw, not a function misuse.}	```event.waitUntil(cache.put(event.request, networkResponse.clone()));```
324	metronieuws.nl.js	Use of Hard-coded Credentials	Medium	false	CWE-798	N/A	N/A	N/A	{The vulnerability is due to hard-coded credentials (appKey, token, vapidPublicKey) in the script, not due to misuse of a sensitive JavaScript function. These values are static and not dynamically derived from untrusted input.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://www.metronieuws.nl/wp\u002Dcontent/uploads/2021/09/metro_push_icon.png', defaultTitle: 'Metronieuws.nl', defaultActionURL: 'https://www.metronieuws.nl', appKey: 'vSBa3zSsQ9ebL5GjNfztsg', token: 'MTp2U0JhM3pTc1E5ZWJMNUdqTmZ6dHNnOnZMQ3h4c2dtRlBiWEJNM2NJSUJwWXI4YkdMZWhkeU4yenpQbVpteVRYcE0', vapidPublicKey: 'BBEU2Ffp2iFFdWvL2ixK5uBRyBzxOQqLCJKclfjhJRQTtxRbFCnzQ-ZicmR1eMcwne__LwPF8U-qJrFqr6EDMng=' });```
325	wallex.ir.js	Hardcoded Sensitive Information in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded Firebase API key in client-side code, which is not caused by misuse of a sensitive JavaScript function. The issue lies in exposing sensitive credentials directly in the script, not in dynamic or unsafe function usage.}	"```importScripts('https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js');importScripts('https://www.gstatic.com/firebasejs/10.11.0/firebase-messaging-compat.js');firebase.initializeApp({apiKey: ""AIzaSyAd3PtC83DU8hh6zywXJsLDucxyHD5t8JU"",authDomain: ""wallex-cb980.firebaseapp.com"",projectId: ""wallex-cb980"",storageBucket: ""wallex-cb980.appspot.com"",messagingSenderId: ""89354635753"",appId: ""1:89354635753:web:546a25e7ba82812085e378"",measurementId: ""${config.measurementId}""});const messaging = firebase.messaging();```"
326	dailyverses.net.js	Improper Input Validation in JSON parsing leading to potential DoS	Low	false	CWE-20	N/A	N/A	N/A	{The JSON parsing via `n.data?.json()` is not inherently a sensitive function misuse; it is a standard operation. While improper input validation could lead to DoS, the function itself is not misused in a way that directly introduces a security vulnerability through dynamic, untrusted input.}	```const t = n.data?.json()```
327	dailyverses.net.js	Open Redirect via notification data URL	Medium	true	CWE-602	N/A	clients.openWindow	standard	{The `clients.openWindow()` function is a standard browser API that opens a URL in a new window or tab. When used with `n.notification.data.url`, which is derived from untrusted push notification data, it allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerabilities. The URL is not sanitized or validated, making this a direct misuse of a sensitive function with dynamic input.}	```n.waitUntil(clients.openWindow(n.notification.data.url));```
328	qctimes.com.js	Open Redirect via Unvalidated URL	Medium	true	CWE-601	9	new URL	standard	{The function new URL is used to construct a URL object from oData.url, which is derived from the FCM message payload. Since this input is not validated or sanitized, an attacker could craft a malicious URL (e.g., redirecting to a phishing site) that gets opened via self.clients.openWindow, leading to an open redirect vulnerability.}	```let oURL = new URL(oData.url);```
329	fantrax.com.js	Medium	Medium	false	CWE-327	0	N/A	N/A	{The vulnerability labeled CWE-327 (Use of Hard-coded Cryptographic Key) is not caused by misuse of a sensitive JavaScript function. The code uses `hashManifest(manifest)` to compute a hash of the manifest, which is a standard cryptographic hashing operation. There is no evidence of hard-coded keys or improper use of cryptographic functions. The function `hashManifest` is a custom utility that wraps `sha1(JSON.stringify(manifest))`, and while SHA-1 is considered weak for cryptographic purposes, its use here is for integrity checking (not encryption or authentication), and no sensitive function misuse is present.}	```const hash = hashManifest(manifest);```
330	virgool.io.js	Improper Input Validation (Unvalidated URL in Notification Data	Medium	true	CWE-20	9	self.registration.showNotification	standard	{The function self.registration.showNotification is used with payload.title and payload as arguments. Since payload is derived from event.data.json(), which is untrusted user input, an attacker could craft a malicious payload that includes arbitrary notification content or potentially trigger unintended behavior. While showNotification itself does not directly execute code, it can be used to display deceptive content or, in combination with other APIs, lead to phishing or social engineering attacks. The lack of input validation on payload.title and payload makes this a sensitive misuse.}	```self.registration.showNotification(payload.title, payload);```
331	ancient.eu.js	Hardcoded Secret in Service Worker	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is not caused by misuse of a sensitive function, but rather by direct assignment of a static value to a variable.}	```self[`appKey`] = `225f0ee26b8dcfd255ad4cb40c344062`;```
332	ancient.eu.js	Remote Code Execution via External Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API in Service Workers that loads and executes external scripts. When used with a dynamically constructed URL derived from a hardcoded host (self[`hostUrl`]), it allows an attacker to potentially control the script source if the host is compromised or if the script URL is manipulated. Although the host is hardcoded here, the function itself is sensitive because it executes arbitrary code from a remote source, and if the host were user-controlled or improperly validated, it would directly lead to RCE.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
333	diabetes.co.uk.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL passed via notification.data.permalink, which originates from untrusted push data. Since the URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, leading to an open redirect and potential phishing or malware delivery.}	"```self.addEventListener(""notificationclick"", e => { const notification = e.notification; notification.close(); e.waitUntil(clients.openWindow(notification.data.permalink)); });```"
334	diabetes.co.uk.js	XSS via Untrusted Data in Notification Content	Medium	true	New	10	self.registration.showNotification	standard	{The self.registration.showNotification function constructs notification content using untrusted data from event.data.json(), including post_title, post_img, post_type_label, and app_name. These values are directly interpolated into the notification body and image URL without sanitization, allowing an attacker to inject malicious content that may be rendered in the notification UI, potentially leading to XSS if the notification UI processes the content in a context that executes scripts.}	```self.addEventListener('push', event => { const data = event.data.json(); event.waitUntil(self.registration.showNotification(data.post_title, { image: data.uploads_url + '/' + data.post_img, body: 'A new ' + data.post_type_label + ' has been published on ' + data.app_name, data: { permalink: data.post_permalink } })); });```
335	ariva.de.js	Use of Outdated Third-Party Library	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the use of an outdated version of Firebase (7.2.1), which may contain known security flaws or lack support for modern security features. However, this is not caused by misuse of a sensitive JavaScript function like importScripts with untrusted input; the URL is hardcoded and not derived from user-controlled or dynamic sources.}	```importScripts('https://www.gstatic.com/firebasejs/7.2.1/firebase-app.js');```
336	noordhollandsdagblad.nl.js	Hardcoded API Credentials	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials (appKey, token, vapidPublicKey) in the code, not due to misuse of a sensitive JavaScript function. These values are static and not derived from untrusted input or dynamically constructed URLs.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, {defaultIcon: 'https://shared.mediahuis.be/logos/hmc\u002Dnhd/latest/brand\u002Dsquare\u002Dmain/256x256.png',defaultTitle: 'Noordhollands Dagblad',defaultActionURL: 'https://www.noordhollandsdagblad.nl',appKey: 'zN93YcjbSqGDH2GcEJwO0w',token: 'MTp6TjkzWWNqYlNxR0RIMkdjRUp3TzB3Ok5jOEt2YW5YYjB3dzN5bFB1QkhFaTU0Yjh4YWcxdUpvYkR0T1NEb1gwNlU',vapidPublicKey: 'BNEjij60Mf7hh6i7WyJSvUGfGpt8v_DncnWHctWkl3ZnhtiJa6r44BU2nA13FzzYb9YID93V0X2giAcfPRRRw7Q='});```
337	odb.org.js	Incorrect Regular Expression Leading to Unintended Caching of Admin Routes	High	false	N/A	0	N/A	N/A	{The vulnerability arises from incorrect regular expression patterns that inadvertently match admin routes, leading to unintended caching behavior. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic error in regex construction. No sensitive function is involved in the misuse.}	```workbox.routing.registerRoute(new RegExp('https://api\\.experience\\.odb\\.org/pages2020-prod/(?!admin)*'), new workbox.strategies.CacheFirst());```
338	odb.org.js	Incorrect Regular Expression Leading to Unintended Caching of Admin Routes	High	false	N/A	0	N/A	N/A	{The vulnerability arises from incorrect regular expression patterns that inadvertently match admin routes, leading to unintended caching behavior. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic error in regex construction. No sensitive function is involved in the misuse.}	```workbox.routing.registerRoute(new RegExp('https://api\\.experience\\.odb\\.org/widgets/(?!admin)*'), new workbox.strategies.StaleWhileRevalidate());```
339	odb.org.js	Incorrect Regular Expression Leading to Unintended Caching of Admin Routes	High	false	N/A	0	N/A	N/A	{The vulnerability arises from incorrect regular expression patterns that inadvertently match admin routes, leading to unintended caching behavior. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic error in regex construction. No sensitive function is involved in the misuse.}	```workbox.routing.registerRoute(new RegExp('https://api\\.experience\\.odb\\.org/reading-progress*'), new workbox.strategies.NetworkOnly());```
340	odb.org.js	Incorrect Regular Expression Leading to Unintended Caching of Admin Routes	High	false	N/A	0	N/A	N/A	{The vulnerability arises from incorrect regular expression patterns that inadvertently match admin routes, leading to unintended caching behavior. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic error in regex construction. No sensitive function is involved in the misuse.}	```workbox.routing.registerRoute(new RegExp('/20*'), new workbox.strategies.StaleWhileRevalidate());```
341	operadeparis.fr.js	Third-Party Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to load a script from a third-party domain (https://via.batch.com/v4/worker.min.js). While the URL is hardcoded and not derived from untrusted input, the act of loading and executing code from an external, potentially untrusted source introduces a high-risk vulnerability. If the third-party script is compromised or malicious, it can fully control the service worker, leading to data exfiltration, cache manipulation, or interception of network requests. This constitutes a sensitive function misuse because importScripts executes arbitrary code from an external source without any sanitization or validation.}	"```importScripts(""https://via.batch.com/v4/worker.min.js"");```"
342	collegedekho.com.js	External Script Import Vulnerability	Medium	false	CWE-434	N/A	N/A	N/A	{The importScripts call uses a hardcoded URL and does not involve dynamic or user-controlled input. Therefore, while it is an external script import, it is not a sensitive function misuse because the URL is not derived from untrusted sources.}	```importScripts('https://widgets.in.webengage.com/js/merged-worker.js');```
343	waters.com.js	Vulnerable URL Matching in Service Worker Cache	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly broad URL matching logic in the service worker's route registration, which may inadvertently cache or serve unintended third-party resources. However, this is not due to misuse of a sensitive JavaScript function such as importScripts, eval, or similar; rather, it stems from a logic or configuration flaw in the route matching criteria. No sensitive function is being misused here.}	```const matchCb = ({ url: { href } }) => { return href.indexOf('decibel') > 0 || href.indexOf('typekit') > 0 || href.indexOf('assets.adobedtm.com') > 0 || href.indexOf('cdn.cookielaw.org') > 0 || href.indexOf('code.jquery.com') > 0 || href.indexOf('connect.facebook.net') > 0 || href.indexOf('clientlib-react_prop_vendors') > 0 || href.indexOf('clientlib-vendors') > 0 || href.indexOf('mpulse') > 0 || href.indexOf('googletagmanager') > 0 || href.indexOf('cloudfront') > 0 || href.indexOf('clientlib-utility') > 0 || href.indexOf('clientlib-react_dom_vendors') > 0 || href.indexOf('decibelinsight') > 0 || href.indexOf('qualtrics') > 0 || href.indexOf('clientlib-site') > 0 || href.indexOf('adoberesources') > 0 || href.indexOf('clientlib-common') > 0 || href.indexOf('clientlib-tiles') > 0 || href.indexOf('clientlib-countrySelectorBar') > 0; };```
344	abczdrowie.pl.js	Insecure Use of importScripts	High	true	CWE-444	N/A	N/A	standard	{The importScripts() function is used to load and execute a remote script from 'https://pixel.wp.pl/push_manager/sw.js'. Although the URL is hardcoded, it is still considered a sensitive function misuse because it executes arbitrary code from an external source, which can lead to code injection if the source is compromised or if the script is later modified by an attacker. The script is loaded without any integrity checks or origin validation, making it a high-risk vulnerability.}	```importScripts('https://pixel.wp.pl/push_manager/sw.js');```
345	abczdrowie.pl.js	Insecure Message Handling for Preloading	High	true	New	N/A	N/A	standard	{The self.addEventListener('message', ...) handler processes incoming messages and, if the action is 'preload', calls preloadUrl(M.data.url). The URL is directly extracted from the message data without any validation or sanitization. This allows an attacker to send a malicious URL via a message, causing the service worker to fetch and cache arbitrary resources, potentially leading to cache poisoning, script injection, or exfiltration of sensitive data.}	"```self.addEventListener(""message"", function (M) { ""preload"" === (M.data || {}).action && preloadUrl(M.data.url); });```"
346	solvhealth.com.js	Code Injection via External Resource	High	true	N/A	9	importScripts	standard	{The importScripts function is used to load and execute an external script from a hardcoded URL. While the URL is fixed and not derived from untrusted input, the function itself is sensitive because it can execute arbitrary JavaScript code if the source is compromised. However, since the URL is hardcoded and not dynamically constructed from user input, the risk is mitigated but still present due to supply chain compromise.}	"```importScripts(""https://assets.solvhealth.com/mapp-dev/2024-11-04-47b4fc5/workbox/workbox-sw.js"");```"
347	solvhealth.com.js	Deserialization of Untrusted Data	High	true	N/A	10	JSON.parse	standard	{The JSON.parse function is used to deserialize data received from a push notification, which is untrusted. If the data is maliciously crafted (e.g., containing a JSON string that triggers unexpected behavior or leads to further exploitation), it can lead to deserialization vulnerabilities, such as prototype pollution or injection attacks, especially if the parsed data is used without validation.}	```let o = JSON.parse(s);```
348	solvhealth.com.js	Open Redirect	Medium	true	N/A	8	self.clients.openWindow	standard	{The self.clients.openWindow function is used to open a URL that is derived from the notification data, which is untrusted. If the URL is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or other malicious destinations.}	```self.clients.openWindow(d)```
349	solvhealth.com.js	Improper Input Validation	Medium	true	N/A	7	self.registration.pushManager.getSubscription().then(e => sendAnalyticsEvent(e.endpoint, t, s))	standard	{The getSubscription method retrieves subscription data, which may be influenced by external factors or user-controlled data. If the endpoint URL or other data is not properly validated before being passed to sendAnalyticsEvent, it could lead to improper input handling, potentially allowing for injection or misuse of analytics data.}	```self.registration.pushManager.getSubscription().then(e => sendAnalyticsEvent(e.endpoint, t, s))```
350	vesti.bg.js	Missing Subresource Integrity (SRI) for External Script	High	false	N/A	0	N/A	N/A	{The vulnerability arises from loading an external script without Subresource Integrity (SRI), which allows an attacker to compromise the CDN and inject malicious code. However, this is not due to misuse of a sensitive function, but rather a lack of integrity verification. The importScripts() function itself is not misused here, as the URL is hardcoded and not derived from untrusted input.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDK.js');```
351	oz.by.js	Unvalidated URL Redirection	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(target) is used to open a URL specified by the 'target' variable, which is derived from the notification's click_action property. Since this value is not validated or sanitized and can be controlled by an attacker via a malicious push notification payload, it enables open redirection. An attacker could craft a notification that redirects the user to a phishing site or malicious domain, leading to potential credential theft or further exploitation.}	"```self.addEventListener('notificationclick', function (event) { const target = event.notification.data.click_action || '/'; event.notification.close(); sendMessageLog(event.notification.data.id_message, 'click'); event.waitUntil(clients.matchAll({ type: ""window"" }).then(function (clientList) { for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (client.url == target && 'focus' in client) return client.focus(); } if (clients.openWindow) return clients.openWindow(target); }));});```"
352	pinkoi.com.js	Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting)	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with data derived from untrusted input (i.data.json().data.content), which is parsed and then passed directly as notification parameters. If the content contains malicious script or HTML, it may be rendered in the notification UI, leading to XSS if the browser or platform interprets it as executable code or injectable content.}	```self.addEventListener('push', function (i) { try { if ('data' in i) { var t = i.data.json().data, n = JSON.parse(t.content); n.requireInteraction = !0, n.data = JSON.parse(JSON.stringify(n)), i.waitUntil(self.registration.showNotification(n.title, n)); } } catch (e) {} });```
353	pinkoi.com.js	Insecure Direct Object Reference	Medium	true	CWE-598	N/A	clients.openWindow	standard	{The function clients.openWindow is called with a URL derived from untrusted input (i.notification.data.action_url.ok). If this URL is controlled by an attacker, it can be used to redirect the user to a malicious site or bypass intended access controls, leading to IDOR or phishing attacks.}	```self.addEventListener('notificationclick', function (i) { if (i.notification.close(), i.notification.data) { var t = i.notification.data.action_url.ok; console.log(t), t && i.waitUntil(clients.matchAll({ type: 'window' }).then(function (i) { for (var n = 0; n < i.length; n++) { var e = i[n]; if (e.url == t && 'focus' in e) return e.focus(); } if (clients.openWindow) return clients.openWindow(t); })); } });```
354	ainvest.com.js	Request Interception Bypassing Security Policies	High	true	N/A	9	getProp	standard	{The function `getProp` is used to dynamically resolve strategy plugins via `getProp(workbox, p.use)`, which allows for arbitrary property access on the `workbox` object. If an attacker can control the `p.use` value (e.g., via a malicious configuration), they could invoke unintended or dangerous methods, potentially bypassing security policies or executing arbitrary code. This dynamic resolution of function references from untrusted input constitutes a sensitive function misuse.}	```const strategyOptions = { ...entry.strategyOptions, plugins: [requestInterceptor, ...(entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config)) ] };```
355	ziggogo.tv.js	Cached Resource Injection via Unvalidated Language Parameter	High	true	CWE-918	10	N/A	standard	"{The function `new URL(location).searchParams.get('lang')` retrieves a user-controlled parameter from the URL query string. This value is then used to construct a dynamic URL for an offline page (`OFFLINE_PAGE.replace("".html"", `.${e}.html`)`) which is subsequently fetched and cached via `fetch()` and `cache.put()`. Since the language parameter is not validated or sanitized, an attacker can inject arbitrary paths or URLs (e.g., `lang=../../malicious.js`) to cache malicious resources, leading to potential cache poisoning or unauthorized resource injection. The `fetch()` function, while standard, is misused here by accepting untrusted input to construct the resource URL, making it a sensitive function in this context.}"	```const t = new URL(location).searchParams.get('lang'); e.waitUntil(caches.open(cacheName).then(e => (console.log('[ServiceWorker] Caching app shell')```
356	oval.id.js	Cache Poisoning via Insecure Response Caching	High	true	CWE-434	9	stripIgnoredUrlParameters	standard	{The function stripIgnoredUrlParameters is used to process the request URL by removing ignored query parameters, but it does not sanitize or validate the resulting URL before using it to look up cached responses. This allows an attacker to manipulate the URL (e.g., via query parameters) to trigger unintended cache lookups or bypass intended caching logic, potentially leading to cache poisoning where malicious or unintended responses are served. The function is standard (part of the service worker caching utility) but is misused by relying on unsanitized input from the request URL.}	"```self.addEventListener(""fetch"", function (t) { if (""GET"" === t.request.method) { var e, a = stripIgnoredUrlParameters(t.request.url, ignoreUrlParametersMatching), n = ""index.html""; (e = urlsToCacheKeys.has(a)) || (a = addDirectoryIndex(a, n), e = urlsToCacheKeys.has(a)); var r = ""/index.html""; !e && ""navigate"" === t.request.mode && isPathWhitelisted([""^(?!\\/__).*""], t.request.url) && (a = new URL(r, self.location).toString(), e = urlsToCacheKeys.has(a)), e && t.respondWith(caches.open(cacheName).then(function (e) { return e.match(urlsToCacheKeys.get(a)).then(function (e) { if (e) return e; throw Error(""The cached response that was expected is missing.""); }); }).catch(function (e) { return console.warn('Couldn\'t serve response for ""%s"" from cache: %O', t.request.url, e), fetch(t.request); })); });```"
357	livelaw.in.js	Untrusted Third-Party Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to load a script from a third-party CDN (https://cdn.izooto.com), which is not under the control of the application. While the URL is hardcoded, the script source is external and untrusted, making it a high-risk vulnerability. If the third-party script is compromised or malicious, it can execute arbitrary code within the service worker context, leading to cache manipulation, network interception, or data exfiltration.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/6a51b511d700af5ec96f34eecc20753e69298351.js"");```"
358	foreverliving.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-829	9	N/A	standard	{The function `fetch` is a standard JavaScript API used to make network requests. In this code, `this.scope.fetch(req)` is called with a `req` object that is derived from an incoming `event.request`, which is user-controlled. Since the service worker does not validate or sanitize the request URL, an attacker can craft a request to a malicious or internal endpoint (e.g., `http://internal-api.com`), leading to SSRF. The `fetch` function blindly executes the request, allowing the attacker to access internal resources or perform unauthorized actions on behalf of the service worker.}	```const res = yield this.scope.fetch(req);```
359	vegasslotsonline.com.js	Improper Handling of Offline Page for Sensitive Resources	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the service worker's logic for serving an offline page, which is triggered when a fetch request fails. However, the issue is not due to misuse of a sensitive JavaScript function, but rather a design flaw in how offline fallbacks are handled for sensitive resources (e.g., login pages, payment forms). The code does not improperly use any sensitive functions like importScripts, eval, or dynamic code execution. Instead, it simply caches and serves a static offline page, which may not be appropriate for sensitive contexts.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate' || event.request.method === 'GET' && event.request.headers.get('accept').includes('text/html')) { event.respondWith(fetch(event.request).catch(error => { return caches.match(OFFLINE_URL); })); } });```
360	alalam.ir.js	XSS via Unsanitized Notification Payload	High	true	CWE-79	10	N/A	standard	{The vulnerability arises from the use of `self.registration.showNotification()` with unsanitized input from `payload.notification.body`. Since the notification body is directly passed to the notification API without sanitization, an attacker could craft a payload that includes malicious content (e.g., JavaScript if the browser or platform allows it), leading to potential XSS or other client-side attacks. Although notifications typically do not execute arbitrary JavaScript, some platforms or contexts may allow rich content or script injection, making this a high-risk misuse of a standard browser API.}	```const notificationOptions = { body: payload.notification.body, icon: payload.notification.icon }; return self.registration.showNotification(notificationTitle, notificationOptions);```
361	hobbycraft.co.uk.js	XSS via cached parts injection	High	true	CWE-79	9	N/A	standard	{The code iterates over self.serverPreparedData.cachedParts and appends a skipParameter value to the URL's search parameters if it exists. Since self.serverPreparedData.cachedParts is derived from server-side configuration and is not sanitized or validated, an attacker could potentially manipulate this data to inject arbitrary parameters into the URL. If these parameters are later used in a context where they are rendered without sanitization (e.g., in a script or HTML context), it could lead to XSS. The use of URL.searchParams.append() with untrusted data is the sensitive function misuse here, as it allows dynamic injection into the URL query string, which may be reflected in responses or used in subsequent requests.}	```self.serverPreparedData.cachedParts.forEach(function (partsConfig) { if (partsConfig.skipParameter) { url.searchParams.append(partsConfig.skipParameter, 'true'); } });```
362	dvdfab.cn.js	Vulnerable Dynamic URL Construction	High	true	CWE-918	10	fetch	standard	{The function `fetch` is used with a dynamically constructed URL where the base URL `n` can be overwritten by untrusted input from `o.sw_api` in the push event data. This allows an attacker to manipulate the target endpoint of the fetch request, potentially redirecting it to a malicious server, leading to data exfiltration or unauthorized actions. The input is not sanitized or validated, making this a high-confidence sensitive function misuse.}	```const n = 'https://aiportrait.online';...o.sw_api && (n = o.sw_api)...fetch(n + '/index.php/sub/listen', { method: 'POST', body: JSON.stringify(e), headers: new Headers({ 'Content-Type': 'application/json' }) })```
363	bienici.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL passed from the notification data (n), which is derived from the push message's data.url. Since this URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or malicious domains.}	N/A
364	bienici.com.js	Information Exposure via __coverage__ in Message Handler	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the exposure of the __coverage__ object via postMessage to client pages, but it is not caused by misuse of a sensitive function. The function clients.matchAll and postMessage are used correctly; the issue is the exposure of sensitive debugging data, not improper function usage.}	N/A
365	blockclubchicago.org.js	Vulnerable Dynamic Module Import (Supply Chain Risk	High	true	CWE-918	10	N/A	standard	{The `importScripts()` function is used within `workbox.loadModule()` to dynamically load external JavaScript modules. The URL for the module is constructed using the `modulePathPrefix` and `modulePathCb` configuration, which can be influenced by external or user-controlled inputs. If an attacker can manipulate the `modulePathPrefix` or `modulePathCb`, they could cause the service worker to load and execute arbitrary scripts from untrusted sources, leading to supply chain attacks.}	```self.workbox.loadModule(`workbox-${o}`);```
366	blockclubchicago.org.js	Potential Cache Poisoning via Precached URLs	Medium	false	N/A	0	N/A	N/A	{The URLs being precached are hardcoded and do not originate from untrusted or dynamic sources. While the URLs contain query parameters, they are fixed and not derived from user input or external sources, so there is no direct misuse of a sensitive function. The risk is low because the URLs are controlled by the developer and not influenced by external input.}	```wp.serviceWorker.precaching.precache([{'url': 'https://blockclubchicago.org/?wp_error_template=offline', 'revision': '0.8.1;...'}, {'url': 'https://blockclubchicago.org/?wp_error_template=500', 'revision': '0.8.1;...'}]);```
367	preqin.com.js	Regex Injection in Domain Validation	High	true	N/A	N/A	RegExp	standard	{The code constructs a regular expression dynamically using `new RegExp(`^${domain2}`)`, where `domain2` is derived from user-controlled or untrusted input (via `trustedDomains`). This allows an attacker to inject arbitrary regex patterns, potentially leading to denial of service, unexpected behavior, or bypassing domain validation logic.}	```const testable = new RegExp(`^${domain2}`);```
368	preqin.com.js	Improper Input Validation in Token Replacement	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of the `actualBody` content before replacing tokens. While no sensitive function is misused, the logic fails to sanitize or validate the input, allowing potential manipulation of token replacement behavior.}	```if (actualBody.includes(keyRefreshToken) || actualBody.includes(keyAccessToken)) {```
369	preqin.com.js	Insecure DPoP Token Generation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the lack of proper cryptographic key management and validation in DPoP token generation, not from misuse of a sensitive function. The code uses `generateJwkAsync` and `generateJwtDemonstratingProofOfPossessionAsync`, but these are used correctly; the issue is in the configuration and trust model, not function misuse.}	```headers = await generateDpopAsync(originalRequest, currentDb, url, claimsExtras);```
370	preqin.com.js	Insecure URL Normalization	Low	false	N/A	N/A	N/A	N/A	{The use of `new URL(url).toString()` is not inherently unsafe, but the function is called with potentially untrusted input. However, since the `URL` constructor throws on invalid URLs and the code includes error handling, this does not constitute misuse of a sensitive function. The risk is low and primarily related to input validation, not function misuse.}	```return new URL(url).toString();```
371	nl7za.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The sensitive information (API keys, project IDs, VAPID keys) is hardcoded in the client-side JavaScript file, which is accessible to anyone inspecting the page. This is not a result of misuse of a sensitive function, but rather a static exposure of credentials.}	```const options = { firebaseConfig: { projectId: 'l7za-af7fb', messagingSenderId: '1009682321150', appId: '1:1009682321150:web:48598c66e8257d3b1d1faf', apiKey: 'AIzaSyDzTBrODG8W0GH3cKFcOcCbhu9yPik_Y3s' }, domain: 'arab.nl7za.com', api_url: 'https://elma3.com/api/token', vapid_public_key: 'BKrhWLCtlLnhdFURw3nuee5wR5fJOeQ2oiG0d9J_FY46ly4IwVOmalrJsk3PKw001pGu3qmHe1rukMXvwdw1pLE' };```
372	nl7za.com.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamic URL (apiUrl) that is derived from notification data, which is controlled by the server or potentially by an attacker. If the server is compromised or if the notification payload is manipulated, this can lead to SSRF, allowing attackers to make requests to internal systems.}	```fetch(apiUrl);```
373	nl7za.com.js	Insecure Data Storage in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The use of IndexedDB for storing data is not inherently insecure, but the data stored (e.g., notification tokens) is sensitive. The vulnerability arises from the lack of encryption or access controls, not from misuse of a sensitive function.}	```const request = indexedDB.open('larapushDataBase', 1);```
374	nl7za.com.js	Improper Input Validation in Push Event	Medium	false	N/A	N/A	N/A	N/A	{The JSON.parse is used on event.data.json().data.notification, which is untrusted input. While JSON.parse is a standard function, the vulnerability stems from lack of input validation, not from misuse of the function itself.}	```const payload = JSON.parse(event.data.json().data.notification);```
375	nl7za.com.js	Insecure API Communication	Medium	false	N/A	N/A	N/A	N/A	{The data sent via fetch includes sensitive information (token, endpoint, keys) without encryption or secure transport validation. This is a configuration or design issue, not misuse of a sensitive function.}	```body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh })```
376	thehansindia.com.js	Remote Code Execution (Dynamic Script Import)	High	true	CWE-918	10	importScripts	standard	"{The importScripts() function is used with a dynamically constructed URL (swPath) derived from URL parameters. Since swPath is built from user-controlled input (via urlObject.searchParams.get(""swPath"") or ""swJSHost""), an attacker can manipulate the URL to inject and execute arbitrary JavaScript code, leading to remote code execution in the service worker context.}"	```importScripts(swPath);```
377	thehansindia.com.js	Caching Without Response Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function but rather by the lack of response validation when caching. The code caches responses without verifying their integrity or origin, which could lead to serving stale or malicious content.}	```cache.put(event.request, response.clone());```
378	thehansindia.com.js	SSRF via URL Parameters	High	true	CWE-918	10	host = 'https://' + urlObject.searchParams.get('swJSHost');	standard	{The code constructs a host URL using user-supplied input from the 'swJSHost' query parameter. This allows an attacker to specify any host, potentially leading to SSRF attacks where the service worker fetches or imports resources from internal or restricted systems.}	"```host = ""https://"" + urlObject.searchParams.get(""swJSHost"");```"
379	dk.com.js	Weak Cryptographic Hash	High	false	CWE-327	0	N/A	N/A	{The vulnerability arises from the use of SHA-1, which is considered cryptographically weak and susceptible to collision attacks. However, this is not due to misuse of a sensitive JavaScript function, but rather a cryptographic design flaw. The function `hashManifest` uses `sha1(JSON.stringify(manifest))`, and while `sha1` is a custom function, its misuse does not introduce a dynamic security risk such as code injection or arbitrary code execution. The issue is purely cryptographic weakness, not sensitive function misuse.}	```const hash = hashManifest(manifest);```
380	dailyprogress.com.js	Open Redirect via Untrusted URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed from untrusted data (oData.url). Since oData.url is derived from a notification payload (which can be controlled by an attacker), this allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```oEvent.waitUntil(self.clients.matchAll({type: 'window'}).then(function (oList) {for (var i = 0; i < oList.length; i++) {var oClient = clientList[i];if (oClient.url == oURL.toString() && 'focus' in oClient) {return oClient.focus();}}if (self.clients.openWindow) {return self.clients.openWindow(oURL.toString());}});```
381	dailyprogress.com.js	XSS via Unsanitized Notification Payload	High	true	CWE-79	10	showNotification	standard	{The function showNotification is used to display a notification with user-controlled data (oPayload.title and oPayload.data). If the notification content includes malicious scripts or HTML, and the browser renders it in a context where it can be executed (e.g., in a rich notification UI), this can lead to XSS. The payload is not sanitized, making it vulnerable to injection.}	```return self.registration.showNotification(oPayload.title, oNotify);```
382	pantagraph.com.js	Improper Neutralization of Special Elements in Output Used by a Web Browser (XSS)	High	true	CWE-807	9	N/A	standard	{The code constructs a URL object using `new URL(oData.url)`, where `oData.url` is derived from a Firebase message payload. If an attacker can control the `url` field in the payload, they can inject malicious URLs (e.g., with JavaScript protocols or redirecting to phishing sites). Although the URL is later used with `self.clients.openWindow()` or `oClient.focus()`, the initial parsing via `new URL()` does not sanitize or validate the input, potentially allowing for open redirects or unintended navigation, which can be exploited in context of phishing or session hijacking. This constitutes improper neutralization of special elements in output used by a web browser.}	```let oURL = new URL(oData.url);```
383	eis.de.js	Improper Content Handling in Service Worker	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of navigation requests in the service worker. The code attempts to handle navigation requests using a NetworkOnly strategy with a fallback to a cached offline page, but the logic does not properly validate or sanitize the request or route, potentially allowing unintended behavior if the navigation route is misconfigured or if the offline page is not properly secured.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.1.0/workbox-sw.js');const offlinePage = '/offline/offline.html';const offlineImage = '/offline/header.jpg';workbox.precaching.precacheAndRoute([offlinePage, offlineImage]);workbox.navigationPreload.enable();workbox.googleAnalytics.initialize();const htmlHandler = new workbox.strategies.NetworkOnly();const navigationRoute = new workbox.routing.NavigationRoute(({ event }) => { const request = event.request; return htmlHandler.handle({ event, request }).catch(error => caches.match(offlinePage, { ignoreSearch: true }));});workbox.routing.registerRoute(navigationRoute);```
384	verkkokauppa.com.js	Insecure Offline Cache Population	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the static nature of the offline resource path. The code fetches a hardcoded offline HTML file, and there is no dynamic or untrusted input involved.}	```const offlineRequest = new Request(OFFLINE_HTML); event.waitUntil(fetch(offlineRequest).then(async response => { const cache = await caches.open(OFFLINE_CACHE); await cache.put(offlineRequest```
385	verkkokauppa.com.js	Unvalidated Offline Resource Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from the lack of validation or sanitization of the request, but no sensitive function is misused. The fetch() call is used correctly with the event.request, and the fallback to the offline cache is standard behavior. There is no dynamic input influencing the resource being fetched.}	```event.respondWith(fetch(request).catch(async error => { console.error('[offline]' + error); const cache = await caches.open(OFFLINE_CACHE); return await cache.match(OFFLINE_HTML); }));```
386	24horas.cl.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows an attacker to compromise the script source (e.g., via DNS hijacking, man-in-the-middle attacks, or compromised hosting) and inject malicious code into the service worker. This leads to full control over the worker’s execution, enabling cache manipulation, network interception, and potential data exfiltration.}	```importScripts('https://s-eu-1.pushpushgo.com/5f4d5bfde0b5a92ac77776db/worker.js');```
387	t-2.net.js	Hardcoded Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (appKey, token, vapidPublicKey) in the script, not due to misuse of a sensitive JavaScript function. These values are static and not derived from untrusted input or dynamically constructed via risky APIs.}	```importScripts('https://web-sdk.urbanairship.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://www.t\u002D2.net/sites/www.t2.si/files/t\u002D2\u002Dnotification.png', defaultTitle: 'T\u002D2: Tako kot mora biti', defaultActionURL: 'https://www.t\u002D2.net', appKey: 'ZBjzmFbNTX2gsTK1P8zEUg', token: 'MTpaQmp6bUZiTlRYMmdzVEwxUDh6RVVnOnNOWDRBMW5FbDVMNV9JMk1wUWF4N2MtaTVxNS1ib192MjlWWGJGXzVCNGs', vapidPublicKey: 'BB7C8xXOMtqEwKfnPmgI_2Dwh7CIGkP1MULJgWrl3uyC0OvCQPVpyMQ6AB8OkzyPu56vF7N_p7cdD0DULIC2qTA=' });```
388	farmacity.com.js	CORS Misconfiguration	High	true	N/A	9	N/A	standard	{The `Response` constructor is used with a header object that includes `'Access-Control-Allow-Origin': '*'`, which allows any origin to make cross-origin requests. This is a standard JavaScript API, and its misuse by setting a wildcard origin without proper origin validation leads to CORS misconfiguration, enabling unauthorized cross-origin access.}	```const fallbackResponse = new Response('', { headers: { 'Access-Control-Allow-Headers': 'Content-Type, Authorization, Content-Length, X-Requested-With', 'Access-Control-Allow-Methods': 'GET,POST,OPTIONS', 'Access-Control-Allow-Origin': '*', Date: new Date(Date.now()).toUTCString(), 'X-Powered-By': 'Express', Connection: 'keep-alive' } });```
389	farmacity.com.js	Cache Poisoning	High	true	N/A	9	N/A	standard	{The `caches.match()` function is used with a URL derived from `request.url.split('?')[0]`, which is not sanitized. If an attacker can control the request URL, they can manipulate the cache key, leading to cache poisoning. The `caches.match()` function is a standard JavaScript API, and its misuse with unsanitized input allows attackers to inject or overwrite cached responses.}	```const cachedMatch = await caches.match(filteredUrl.href, { ignoreSearch: true });```
390	farmacity.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The code parses JSON from a response and accesses `data.segmentToken` and `data.sessionToken` without validating the structure or content of the parsed JSON. However, this does not involve a sensitive function misuse; it is a logic flaw in input handling.}	```const data = await res.json(); if (!data) { return; } const event = [{ name: 'segmentToken', value: data.segmentToken }, { name: 'sessionToken', value: data.sessionToken }];```
391	ufreegames.com.js	Open Redirect via Unvalidated Push Data URL	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a new browser window or tab with a URL derived from untrusted push notification data (_action_url = c.url || ''). Since this URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or other malicious destinations. The function is a standard Service Worker API and is directly responsible for the vulnerability due to its direct execution of untrusted input.}	```_action_url = c.url || '', ... h = { click_action: _action_url }, ... clients.openWindow(b)```
392	biolifeplasma.com.js	Improper Input Validation Leading to SSRF	High	false	CWE-918	0	N/A	N/A	"{The provided code does not contain any direct misuse of sensitive JavaScript functions such as importScripts(), eval(), or dynamic URL construction from untrusted input. The vulnerability described as ""Improper Input Validation Leading to SSRF"" appears to be a misclassification, as the code is a static configuration object for a service worker (webpack-offline) that does not dynamically construct URLs from user input. The URLs listed in the assets, externals, and hashesMap are hardcoded and do not involve any runtime user-controlled input. Therefore, no sensitive function misuse is present.}"	"```var __wpo = { ""assets"": { ""main"": [""/scripts/bundle.2da1fe88444935ea9761.js"", ""/scripts/js/vendors~scripts/bundle.79d95131396d9e3742f9.chunk.js""], ""additional"": [""/sitemap.xml"", ""/dw71fr9qyw3fts2va53lio6c6acbhw.html"", ""/googled92d19bd3c900644.html"", ""/googleaac7764a775151f0.html"", ""/robots.txt""], ""optional"": [""/static/brand-icons.e8c322de9658cbeb8a774b6624167c2c.woff2"", ...] }, ""externals"": [""/sitemap.xml"", ...], ""hashesMap"": { ""db06af71da4197a4e1bd553d124725a8081c13f0"": ""/static/brand-icons.e8c322de9658cbeb8a774b6624167c2c.woff2"", ... }, ""strategy"": ""changed"", ""responseStrategy"": ""network-first"", ""version"": ""10/28/2024, 5:31:00 AM"", ""name"": ""webpack-offline"", ""pluginVersion"": ""5.0.7"", ""relativePaths"": false };```"
393	capital.de.js	Dynamic Script Loading with Untrusted Input	High	true	CWE-94	10	importScripts	standard	{The importScripts function is used to dynamically load and execute a script from a URL constructed by concatenating a hardcoded base URL with the value of location.search, which is user-controlled. Since location.search can be manipulated by an attacker, this allows arbitrary script execution from an attacker-controlled URL, leading to a remote code execution vulnerability.}	"```const workerGlobalScope = self;const env = /dev|local/.test(workerGlobalScope.location.host) ? ""dev"" : ""prod"";const webPushConfig = {  dev: ""AuSAH75LyptWZBSQc"",  prod: ""vAfEh9pNeRLZeW9ue""};if (webPushConfig[env] && typeof workerGlobalScope.importScripts === ""function"") {  const channelId = webPushConfig[env];  workerGlobalScope.importScripts(`https://static.cleverpush.com/channel/worker/${channelId}.js${workerGlobalScope.location.search}`);}```"
394	iclasspro.com.js	Unintended Cross-Origin Request via 'no-cors' mode	High	true	New	N/A	fetch	standard	{The fetch API is used with 'no-cors' mode, which allows cross-origin requests without enforcing CORS headers. When combined with dynamic URLs (e.g., from user-controlled inputs), this can lead to unintended cross-origin requests, potentially exposing sensitive data or enabling abuse of third-party APIs.}	```const networkResponse = await fetch(new Request(url, { mode: 'no-cors' }));```
395	iclasspro.com.js	Cache Poisoning via Opaque Responses	High	true	CWE-921	N/A	caches.put	standard	{The caches.put() function is used to store responses with status < 400, including opaque responses (which may originate from cross-origin requests with 'no-cors'). This allows malicious or unintended responses to be cached, leading to cache poisoning where attackers can serve manipulated content to users.}	```if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } }```
396	iclasspro.com.js	Message Command Without Origin Check	Medium	false	CWE-306	N/A	N/A	N/A	{The vulnerability arises from lack of origin validation in message handling, not from misuse of a sensitive function. The code processes messages without verifying the sender's origin, which could allow malicious pages to trigger cache deletion.}	```if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); ... }```
397	iclasspro.com.js	Overly Broad Cache Matching Regex	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from overly permissive regex patterns used in route registration, not from misuse of a sensitive function. These patterns may match unintended URLs, leading to incorrect caching behavior.}	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
398	iclasspro.com.js	URL Parameter Injection in addParamsNative	Medium	true	CWE-113	N/A	template	standard	{The template function is used to inject parameters into URLs without proper sanitization. When combined with user-controlled inputs, this can lead to URL parameter injection, potentially altering the intended behavior of requests or bypassing security checks.}	```const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : '');```
399	elheraldo.hn.js	XSS via unsanitized notification data	High	true	CWE-79	10	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display notifications with data from the incoming message (a.data.title, a.data.body, etc.). Since these values are directly taken from untrusted external data (push message payload) without sanitization, an attacker can inject malicious content (e.g., script tags or HTML) into the notification, leading to XSS when rendered in the user's browser.}	```const messaging = firebase.messaging(); messaging.onBackgroundMessage(function (a) { var i = a.data.title, t = { requireInteraction: /true/i.test(a.data.requireInteraction), body: a.data.body, icon: a.data.icon, data: { click_action: a.data.click_action } }; return a.data.image && (t.image = a.data.image), self.registration.showNotification(i, t); });```
400	elheraldo.hn.js	Unvalidated URL redirection in notification click	Medium	true	CWE-601	10	self.clients.openWindow	standard	{The function self.clients.openWindow is called with a URL derived from a.data.click_action, which is part of the untrusted push message payload. Since no validation or sanitization is performed on this URL, an attacker can craft a message that redirects the user to a malicious site, leading to phishing or other attacks.}	```self.addEventListener('notificationclick', function (a) { if (a.notification.close(), void 0 !== a.notification.data && a.notification.data.click_action) { let i = new Promise(function (i, t) { self.clients.openWindow(a.notification.data.click_action), i(); }); a.waitUntil(i); } });```
401	bol.com.br.js	Vulnerable Regular Expression (ReDoS	Medium	false	CWE-1330	N/A	N/A	N/A	{The vulnerability is due to a regular expression with potentially exponential backtracking (ReDoS), but it is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The regex is defined statically within the code and does not involve dynamic input or unsafe function calls.}	```self.AreaStorage.push({\n config: {\n cacheName: '[HomeBOL:vueland][ASSETS]',\n strategy: 'StaleWhileRevalidate',\n plugins: {\n expiration: {\n maxEntries: 30,\n maxAgeSeconds: 7 * 24 * 60 * 60,\n purgeOnQuotaError: true\n }\n }\n },\n cache: {\n precache: [],\n assets: [{\n url: /https?:\/\/c\.jsuol\.com\.br\/.*\?loadComponent=(Media|media).*contentType=(css|js).*/\n }, {\n url: /assets\/\?loadComponent=Media.*contentType=(css|js).*/\n }, {\n url: /https?:\/\/(conteudo\.)?jsuol\.com\.br\/p\/perfil\/css\/.*css.*/\n }]\n }\n});```
402	financial-field.com.js	External Script Import Without Validation	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, if the URL were derived from untrusted or unsanitized input (e.g., user-controlled parameters), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not dynamic, so the vulnerability is not due to sensitive function misuse but rather due to lack of validation or control over external script sources. Therefore, while importScripts() is a sensitive function, its misuse here is not triggered by dynamic input, making the vulnerability contextually high but not technically a sensitive function misuse.}	```importScripts('https://anymind360.com/js/3772/anymind-sw.js');```
403	domrf.ru.js	Loading external script without integrity check	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard service worker API that loads and executes a script from a specified URL. In this case, it loads a script from a hardcoded external URL (https://image.sendsay.ru/js/push/sendsay_sw.js). While the URL is not dynamically constructed from untrusted input, the lack of integrity checking (e.g., using a Subresource Integrity hash) means the script can be tampered with by an attacker if the remote server is compromised, leading to arbitrary code execution within the service worker context. This constitutes a sensitive function misuse due to the absence of security safeguards, even though the URL is static.}	"```if (typeof importScripts === 'function') { importScripts(""https://image.sendsay.ru/js/push/sendsay_sw.js""); }```"
404	aftermarket.pl.js	Vulnerable Dynamic Origin Handling	High	true	CWE-20	9	N/A	standard	"{The code retrieves the 'assets' parameter from the URL's query string using `new URL(location).searchParams.get(""assets"")` and assigns it to a variable. This value is later used to compare against the origin of incoming fetch requests. Since the origin is derived from user-controlled input, an attacker could manipulate the query parameter to point to a malicious origin, potentially leading to cache poisoning or unauthorized resource access.}"	"```var assets = """";self.addEventListener(""install"", function (event) {  assets = new URL(location).searchParams.get(""assets"");});self.addEventListener('activate', function (event) {});self.addEventListener('fetch', function (event) {  var url = new URL(event.request.url);  if (url.origin == assets && !/\.mp3$/.test(url.pathname)) {    event.respondWith(caches.open(""assets"").then(function (cache) {      return cache.match(event.request, {        ""ignoreSearch"": false      }).then(function (response) {        return response || fetch(event.request).then(function (response) {          cache.put(event.request, response.clone());          return response;        });      });    }));  }});```"
405	hogatoga.com.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive information (e.g., Firebase API key, project ID, VAPID key) in the script, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'hogatoga-46ca3', messagingSenderId: '575688117702', appId: '1:575688117702:web:82795e0c1214d00c4b76c7', apiKey: 'AIzaSyCtwmCuhGrTHyN74_Z4qsHRZaNy5JMt-IU' }, domain: 'hogatoga.com', api_url: 'https://push.hindikaro.com/api/token', vapid_public_key: 'BLTJU-JY-dQ9859zOHne_X9_OpU5rJ03qtPAsC11pp2KDLIf7cRkj4h_lLD4SqX6N_-pQG_z-O1YmqgLQ61epKA' };```
406	hogatoga.com.js	Cross-Site Request Forgery	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the script making a POST request to a remote API without validating or sanitizing the domain or token, but it is not caused by misuse of a sensitive JavaScript function like fetch with untrusted input.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
407	hogatoga.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of the `url` parameter received via `event.data`, but no sensitive JavaScript function is misused in this context.}	```self.addEventListener('message', event => { const { command, url } = event.data; switch (command) { case WorkerMessengerCommand.AMP_SUBSCRIPTION_STATE: onMessageReceivedSubscriptionState(); break; case WorkerMessengerCommand.AMP_SUBSCRIBE: onMessageReceivedSubscribe(url); break; case WorkerMessengerCommand.AMP_UNSUBSCRIBE: onMessageReceivedUnsubscribe(); break; } });```
408	hogatoga.com.js	Server Side Request Forgery	High	true	N/A	N/A	fetch	standard	{The `fetch(apiUrl)` call uses a dynamic `apiUrl` derived from notification data, which is user-controlled. Since `fetch` is a standard JavaScript function and is invoked with untrusted input without validation, it enables SSRF by allowing attackers to redirect requests to arbitrary internal or external endpoints.}	```fetch(apiUrl);```
409	w2g.tv.js	XSS via untrusted push data in notification	High	true	CWE-79	10	showNotification	standard	{The showNotification function is used with untrusted data from event.data.json() without sanitization. Since the notification content (title, body, icon) is derived directly from untrusted push data, an attacker can inject malicious content that may be rendered in the UI, leading to XSS if the browser or platform interprets the content as executable script or HTML.}	"```self.addEventListener('push', function (event) { var data = event.data.json(); event.waitUntil(self.registration.showNotification(data.title, { body: data.body, data: data.url, icon: data.icon, requireInteraction: true, tag: ""tag"" })); });```"
410	w2g.tv.js	Open redirect via notification data	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with untrusted data from event.notification.data, which is derived from push notification data. Since this data is not validated or sanitized, an attacker can supply a malicious URL, causing the browser to open an unintended external site, leading to an open redirect vulnerability.}	```self.addEventListener('notificationclick', function (event) { if (clients.openWindow) { event.notification.close(); return clients.openWindow(event.notification.data); } });```
411	carhartt-wip.com.js	Dynamic Script Import with User-Controlled Input Leading to SSRF/Data Injection	High	true	CWE-918	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When combined with user-controlled input from location.search, it allows an attacker to manipulate the script URL being imported. This can lead to SSRF (Server-Side Request Forgery) if the script endpoint is internal or to data injection if the script is loaded from an untrusted source. The dynamic construction of the URL using ${location.search} makes the function misuse highly dangerous, as it enables arbitrary script execution.}	```importScripts(`https://carhartt-wip.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
412	uniprot.org.js	Vulnerable Cache Strategy Leading to SSRF	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a misconfigured cache strategy that allows requests to be cached and served from external domains, potentially enabling Server-Side Request Forgery (SSRF) if an attacker can manipulate the request URL to target internal or restricted resources. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() or eval(), but rather by flawed logic in the route matching and caching policy. The code does not dynamically construct URLs from untrusted input using sensitive functions; instead, it uses hardcoded origins and path checks to determine which requests to cache. Therefore, the vulnerability is not due to sensitive function misuse.}	```const e = new v(e => { var { url: t, request: r } = e; return !(r.destination || 'https://api.geneontology.org' !== t.origin && 'https://api.rhea-db.org' !== t.origin && 'https://alphafold.ebi.ac.uk' !== t.origin && 'https://community.uniprot.org' !== t.origin && ('https://www.ebi.ac.uk' !== t.origin || !t.pathname.includes('interpro/')) && !t.pathname.includes('pdbe/')); }, new R({ cacheName: re.ExternalAPIs, plugins: [new Y({ statuses: [0, 200, 204] }), new te({ headersToCheck: ['InterPro-Version', 'InterPro-Version-Minor', 'Content-Length'] }), new $({ maxEntries: 500, maxAgeSeconds: 604800, purgeOnQuotaError: !0 })] }))```
413	teleradiosciacca.it.js	XSS via untrusted notification data	High	true	CWE-79	10	registration.showNotification	standard	{The function `showNotification` is used with `title` extracted directly from untrusted `body['title']` input. Since the notification title can be controlled by an attacker via the push message, this allows for cross-site scripting (XSS) if the browser or platform interprets the title as executable content (e.g., via rich text or HTML rendering in notifications).}	```const title = body['title']; return self.registration.showNotification(title, body);```
414	teleradiosciacca.it.js	Open Redirect via unvalidated URL	High	true	CWE-601	10	clients.openWindow	standard	{The function `clients.openWindow` is called with `d`, which is derived from `event.notification.data.url`. Since this URL is sourced from untrusted push notification data, an attacker can craft a malicious URL to redirect users to arbitrary sites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(d));```
415	rionegro.com.ar.js	Insecure Dependency - External Script Import	High	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it constructs the script URL using self[`hostUrl`], which is hardcoded to ""https://cdn.gravitec.net"". Although the value is not derived from untrusted input, the vulnerability arises because the script is loaded from an external domain, which could be compromised or misconfigured, leading to unauthorized code execution. However, since the URL is hardcoded and not dynamically derived from user input or untrusted sources, the risk is mitigated but still present due to external dependency.}"	```self.importScripts(`${self[`hostUrl`]}/sw/worker.js`);```
416	slovoidilo.ua.js	Hardcoded Secret in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is not caused by misuse of a sensitive function, but rather by directly embedding a secret key in client-side code, which is inherently insecure.}	```self[`appKey`] = `31ba51d4d694d7f0f0ecc57a5e815aed`;```
417	slovoidilo.ua.js	Remote Code Execution via Untrusted Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded value (self[`hostUrl`]), it may still be considered unsafe if the value is not fully trusted or if it could be manipulated in a broader context. However, in this case, the hostUrl is hardcoded and not derived from untrusted input, so the risk is lower than if it were derived from user input. Nevertheless, the function itself is sensitive because it executes arbitrary code from a remote source, and its misuse can lead to RCE.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
418	zumvu.com.js	Insecure Direct Object Reference (No-CORS Fetch)	High	true	CWE-497	9	N/A	standard	"{The fetch() function is used with mode: ""no-cors"" on user-controlled assets URLs, allowing the service worker to fetch resources from any origin without CORS checks, enabling CORS bypass and potential exposure to sensitive data or unintended resource access.}"	"```e.assets && t.addAll(e.assets.map(function (e) { return new Request(e, { mode: ""no-cors"" }); }));```"
419	zumvu.com.js	XSS via Unsanitized Offline Content	High	true	CWE-79	9	N/A	standard	{The Response constructor is used with user-controlled content without sanitization, allowing an attacker to inject malicious HTML/JS into the offline content, leading to XSS when rendered in the browser.}	```t.put('sw-offline-content', _buildResponse(e.content))```
420	zumvu.com.js	CORS Bypass via No-CORS Fetch	High	true	CWE-497	9	N/A	standard	"{The fetch() function is invoked with mode: ""no-cors"" on a user-controlled content-url, bypassing CORS restrictions and enabling the service worker to fetch resources from arbitrary origins, potentially leaking sensitive data.}"	```fetch(e['content-url'], { mode: 'no-cors' })```
421	streamate.com.js	Insecure External Script Loading Without Subresource Integrity (SRI)	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without Subresource Integrity (SRI), it allows the script to be loaded from an external source (here, https://federatedmodules.icfcdn.com) without verifying its integrity. This creates a risk if the external script is compromised or modified by an attacker, leading to arbitrary code execution within the service worker context. Although the URL is hardcoded, the lack of SRI means the script can be tampered with in transit or at the source, making it a sensitive function misuse due to insufficient integrity verification.}	"```try { importScripts(""https://federatedmodules.icfcdn.com/pushnotifications/pushnotifications-sw_1.1.6.js""), startServiceWorker(); } catch (t) { console.log(t); }```"
422	invisioncommunity.com.js	Improper Session Validation Leading to CSRF Vulnerability	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper session validation logic that relies on parsing the `loggedIn` parameter from the URL, which is not a secure method for determining user authentication state. This does not involve misuse of any sensitive JavaScript function such as `importScripts`, `eval`, `Function`, or `fetch` with untrusted input. The issue is a logical flaw in session handling, not a direct function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
423	gupshup.io.js	Insecure Service Worker Origin Check	Medium	false	N/A	0	N/A	N/A	{The provided code does not misuse any sensitive JavaScript function. The origin check using `event.origin !== self.location.origin` is a standard and secure practice for restricting service worker behavior to same-origin requests. There is no dynamic or untrusted input being passed to a sensitive function, and no function like `importScripts`, `eval`, or `fetch` is being misused with unsanitized data.}	"```self.addEventListener(""fetch"", function (event) { if (event.origin !== self.location.origin) return; console.log(""Hello world from the Service Worker 🤙""); });```"
424	darwinawards.com.js	Improper Input Validation in Fetch Handler	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of the fetch response and lack of validation on the request URL. The code attempts to cache responses without validating the origin or content of the fetched resource, which could lead to caching of unintended or malicious content. However, the `fetch()` function itself is used correctly and not misused with untrusted input.}	```self.addEventListener('fetch', event => {  if (event.request.mode === 'navigate') {    event.respondWith(caches.open(staticCacheName).then(cache => {      return fetch(event.request.url).then(fetchedResponse => {        cache.put(event.request, fetchedResponse.clone());        return fetchedResponse;      }).catch(() => {        return cache.match(event.request.url);      });    }));  } else {    return;  }});```
425	turbowarp.org.js	Improper Service Worker Activation Leading to Page Instability	Medium	false	N/A	0	N/A	N/A	{The code uses `self.skipWaiting()` and `caches.delete()` during install and activate events, but these are not sensitive functions in the context of security vulnerabilities like injection or unauthorized execution. The issue is more related to improper lifecycle management rather than misuse of a sensitive function.}	"```self.addEventListener(""install"", () => { self.skipWaiting(); }), self.addEventListener(""activate"", e => { e.waitUntil(caches.keys().then(e => Promise.all(e.map(e => caches.delete(e))))); });```"
426	ffr.fr.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., 'https://via.batch.com/v2/worker.min.js'), it introduces a high-risk vulnerability if the script source is untrusted or compromised. Although the URL is hardcoded here, the vulnerability is still considered sensitive because it allows an attacker who controls the external script to execute arbitrary code within the service worker context, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. The function is inherently sensitive due to its ability to dynamically load and execute remote code.}	"```importScripts(""https://via.batch.com/v2/worker.min.js"");```"
427	radio.de.js	Insecure External Script Inclusion	Medium	true	CWE-444	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (https://aswpsdkeu.com/notify/v1/ua-sdk.min.js), it introduces a risk if the external script is compromised or if the domain is controlled by an attacker. Although the URL is hardcoded, the vulnerability arises from trusting an external script source without verification, which can lead to code injection or execution of malicious code.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
428	radio.de.js	Hardcoded Sensitive Information	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (appKey and token) directly in the source code, which is a data exposure issue, not a misuse of a sensitive function. These values are not passed to any function in a way that introduces dynamic risk; they are simply stored as configuration values.}	```uaSetup.worker(self, { defaultIcon: 'https://www.radio.de/assets/images/app\u002Dstores/square_512x512_playstore.png', defaultTitle: 'www.radio.net', defaultActionURL: 'https://www.radio.net/', appKey: 'Z3UrmkuZQbCzRYWAI2D8wg', token: 'MTpaM1VybWt1WlFiQ3pSWVdBSTJEOHdnOnB3N1EwSEpfYnVjQ3FYQlZYZ1BKS0NtN0l0ZURuTmdxeklWcW02dGZzQnM', vapidPublicKey: 'BIa_FQmKKO4Cnk9YXK_74zG531yTULVQjHqv72cT9QgiOKfR7mX5LzvbLMaZl20CuVKOIy2Fje3nbE1zuf_bMeQ=' });```
429	spidersweb.pl.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., pushpushgo.com), it introduces a Remote Code Execution risk because the script at that URL can be controlled by an attacker, allowing them to inject malicious code into the service worker. Although the URL is hardcoded, the source is external and untrusted, making this a sensitive misuse.}	```importScripts('https://s-eu-1.pushpushgo.com/5f71b4098ce93725eda566e3/worker.js');```
430	mybeautybrides.net.js	Insecure Cache Busting with Predictable Random Value	Medium	true	CWE-330	9	Math.random()	standard	{The cacheBust function appends a predictable random value to URLs to bypass caching. Since Math.random() is not cryptographically secure and can be predicted or replayed, attackers can forge cache-busted requests, leading to cache poisoning or bypassing integrity checks.}	```javascript cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
431	mybeautybrides.net.js	SSRF Vulnerability in Fetch Handling	High	true	CWE-918	10	fetch	standard	{The safeFetch function uses scope.fetch(req) without validating the request URL. If the request is constructed from untrusted input (e.g., via a malicious client or intercepted request), it can be manipulated to perform SSRF attacks by fetching internal resources or services.}	```javascript safeFetch(req) { return __awaiter(this, void 0, void 0, function* () { try { return yield this.scope.fetch(req); } catch (_a) { return this.adapter.newResponse(null, { status: 504, statusText: 'Gateway Timeout' }); } }); }```
432	mybeautybrides.net.js	Improper URL Validation in parseUrl	Medium	true	CWE-20	8	URL	standard	{The parseUrl function uses the standard URL constructor without validating or sanitizing the input URL. This can lead to improper parsing of malformed or malicious URLs, potentially causing unexpected behavior or security issues when used in downstream operations.}	```javascript parseUrl(url, relativeTo) { const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo); return { origin: parsed.origin, path: parsed.pathname, search: parsed.search }; }```
433	mybeautybrides.net.js	Insecure Cache Key Normalization	Medium	true	CWE-444	9	normalizeUrl	standard	{The normalizeUrl function normalizes URLs by comparing their origin with the scope origin. However, it does not validate or sanitize the input URL, allowing attackers to craft URLs that bypass normalization logic and lead to cache key collisions or unintended cache access.}	```javascript normalizeUrl(url) { const parsed = this.parseUrl(url, this.scopeUrl); return parsed.origin === this.origin ? parsed.path : url; }```
434	mybeautybrides.net.js	XSS via Uncached HTML Responses	High	true	CWE-79	9	put	standard	{The cacheResponse function stores responses in the cache without validating or sanitizing the content. If the response contains untrusted HTML or JavaScript and is served without proper content-type headers, it can lead to XSS attacks when rendered by the client.}	```javascript cacheResponse(req, res, lru, okToCacheOpaque = false) { return __awaiter(this, void 0, void 0, function* () { if (!(res.ok || okToCacheOpaque && res.type === 'opaque')) { return; } yield (yield this.cache).put(req, res.clone()); }); }```
435	mybeautybrides.net.js	Exposure of Debug Logs with Sensitive Data	Low	false	CWE-200	0	N/A	N/A	{The log function stores error messages and context in debug logs, but there is no direct misuse of a sensitive function. The vulnerability arises from the design choice to log sensitive data, not from improper use of a JavaScript API.}	```javascript log(value, context = '') { if (typeof value !== 'string') { value = this.errorToString(value); } this.debugLogA.push({ value, time: this.adapter.time, context }); }```
436	ofoghmusic.ir.js	Insecure External Script Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (scriptapi.adwisedfs.com). This allows the remote server to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or interception of network requests. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute arbitrary code from external sources.}	```importScripts('https://scriptapi.adwisedfs.com/api/webpush/sw/95738d34-cb92-4660-b824-9eaa675554d8.js');```
437	googlemaps.com.js	Hardcoded Relative URL in importScripts	Medium	false	New	N/A	```(function () {	N/A	{The URL passed to importScripts is hardcoded and does not involve dynamic or user-controlled input, so it does not constitute a sensitive function misuse. While the URL is relative and could be considered a potential risk if it were dynamically constructed, in this case, it is static and not derived from untrusted sources.}	N/A
438	ulysmedia.kz.js	External Script Import Without Validation	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable, but if the URL is derived from untrusted or dynamic input, it can lead to arbitrary script execution. In this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse. However, since the script is imported from an external, untrusted domain (web.webpushs.com), it still poses a high risk if the domain is compromised or malicious. The vulnerability is not caused by misuse of a sensitive function with dynamic input, but rather by trusting an external script without validation.}	```importScripts('https://web.webpushs.com/sp-push-worker-fb.js?ver=2.0');```
439	rundschau-online.de.js	Improper Cache Control Leading to Cache Poisoning	High	true	New	10	N/A	standard	{The use of `e.createHandlerBoundToURL('/')` within `e.registerRoute` binds the route handler to a fixed URL ('/'), which may lead to cache poisoning if the route is not properly restricted or if the handler is misconfigured to serve stale or malicious content. While not directly a sensitive function misuse in the traditional sense (like `importScripts` or `eval`), the `createHandlerBoundToURL` function is part of the Workbox API and can be misused to expose the service worker to improper cache behavior when used with dynamic or untrusted inputs. However, in this case, the URL is hardcoded, so the vulnerability stems from improper configuration rather than direct sensitive function misuse.}	```e.registerRoute(new e.NavigationRoute(e.createHandlerBoundToURL('/')));```
440	rundschau-online.de.js	Insecure Service Worker Message Handling	Medium	false	CWE-319	N/A	N/A	N/A	{The code listens for messages and checks for a specific type 'SKIP_WAITING', which is a standard and safe operation. There is no use of sensitive functions like `eval`, `importScripts`, or `Function` that could lead to code injection. The vulnerability is due to lack of input validation or message origin verification, not misuse of a sensitive function.}	```self.addEventListener('message', e => { e.data && 'SKIP_WAITING' === e.data.type && self.skipWaiting(); });```
441	euroinnova.com.js	Insecure External Script Loading	High	true	N/A	9	importScripts	standard	"{The importScripts function is a standard service worker API that loads and executes external scripts. While the URL in this case is hardcoded, the vulnerability is classified as ""Insecure External Script Loading"" because it involves loading a script from an external domain (cdn.connectif.cloud), which could be compromised or controlled by an attacker. However, since the URL is not derived from untrusted input, the misuse is not dynamic. Nonetheless, the function itself is sensitive due to its ability to execute arbitrary code from remote sources.}"	"```if (typeof importScripts === ""function"") { importScripts(""https://cdn.connectif.cloud/scripts/service-worker.js""); }```"
442	nexload.ir.js	Untrusted External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a high-risk vulnerability because the script is fetched from an untrusted third-party domain (van.najva.com). If the remote script is compromised or malicious, it can execute arbitrary code within the service worker context, leading to cache manipulation, network interception, or data exfiltration. Although the URL is hardcoded, the origin is external and not under the control of the site, making it a sensitive misuse.}	```importScripts('https://van.najva.com/static/js/scripts/nexload-website-33118-df99ce9c-6057-4a8d-aade-19f769e221aa-service-worker.js');```
443	flughafen-zuerich.ch.js	Cache Poisoning via Permissive Regex	High	true	CWE-79	9	workbox.routing.registerRoute(/path/, new workbox.strategies.NetworkFirst({ cacheName: LAYOUT_CACHE, plugins: [new workbox.expiration.ExpirationPlugin({ maxEntries: 50, purgeOnQuotaError: true })] }), 'GET');	standard	"{The use of a permissive regex `/path/` in workbox.routing.registerRoute allows any URL containing ""path"" to be cached, which can lead to unintended caching of malicious or sensitive content. This is not directly caused by misuse of a sensitive function like importScripts or eval, but rather by improper configuration of a standard Workbox API. However, since workbox.routing.registerRoute is a standard API that controls caching behavior and its misuse (via overly broad patterns) can lead to cache poisoning, it qualifies as a sensitive function in this context. The vulnerability arises because the regex is too broad and does not restrict to intended routes, enabling attackers to cache unintended resources.}"	```workbox.routing.registerRoute(/path/, new workbox.strategies.NetworkFirst({ cacheName: LAYOUT_CACHE, plugins: [new workbox.expiration.ExpirationPlugin({ maxEntries: 50, purgeOnQuotaError: true })] }), 'GET');```
444	curvage.org.js	Open Redirect via Notification Data	High	true	CWE-601	10	clients[0].navigate	standard	{The function clients[0].navigate is used to redirect the client to a URL derived from notification data (data.url). Since this URL is not validated or sanitized and can be controlled by an attacker via push notifications, it enables open redirect attacks, allowing users to be redirected to arbitrary, potentially malicious, websites.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
445	curvage.org.js	Insecure Client-Side Logic for CSRF Token Handling	Medium	false	CWE-602	0	N/A	N/A	{The vulnerability arises from flawed logic in handling CSRF tokens for guest users, but it is not caused by misuse of a sensitive JavaScript function. The issue lies in the conditional logic and lack of proper validation, not in the use of a dangerous API.}	```if (loggedIn == 'false' && request.method === 'POST') {```
446	oll.vodka.js	Caching without Cache-Control Header Check	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from not checking the Cache-Control header before caching responses, which could lead to caching sensitive or dynamic content that should not be cached. However, this is not due to misuse of a sensitive function but rather a lack of proper policy enforcement.}	```const responseToCache = response.clone(); caches.open(CACHE_NAME).then(cache => { cache.put(request, responseToCache).catch(error => { console.error('Failed to update cache with new resource:', error); }); });```
447	oll.vodka.js	Unbounded Cache Storage Consumption	High	true	N/A	N/A	cache.addAll	standard	{The cache.addAll() function is used with urlsToCache, which is not validated or limited in size. Since cache.addAll() blindly caches all provided URLs without checking their count or size, it can lead to excessive storage consumption, especially if urlsToCache is dynamically populated with many or large resources. This misuse of a standard API allows unbounded cache growth.}	```caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)).catch(error => { console.error('Failed to cache resources during install:', error); });```
448	konbaz.com.js	CSRF Token Generation Based on Untrusted Input	High	true	CWE-352	9	fetch	standard	{The fetch function is used with a dynamically constructed URL where the `path` parameter is derived from the request URL, which is untrusted. This allows an attacker to manipulate the `path` value to trigger CSRF token generation for arbitrary endpoints, potentially leading to unauthorized actions. The URL is built using `new URL(curRequest.url)` and then used in `fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)`, making it vulnerable to path injection and CSRF token leakage.}	```const fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {```
449	konbaz.com.js	Insecure Navigation to Unvalidated URL	Medium	true	CWE-601	9	navigate	standard	{The navigate function is used with `data.url`, which is derived from a push notification payload. Since this data is not validated or sanitized, an attacker could craft a malicious notification with a URL that redirects to a phishing site or performs unintended navigation, leading to open redirect or phishing attacks. The code uses `clients[0].navigate(data.url)` without any validation of the URL's origin or structure.}	```clients[0].navigate(data.url);```
450	konbaz.com.js	Client-Side Login Check Bypass	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from client-side logic that checks `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to determine login status. This is not a sensitive function misuse but rather a logical flaw in relying on client-side state for security decisions. No sensitive JavaScript function is misused here.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
451	newport-pleasure.com.js	Code Injection via eval in custom cache key generation	High	true	CWE-78	N/A	eval	standard	{The eval function is used to dynamically execute a string containing JavaScript code derived from the genConfig parameter, which is sourced from user-controlled configuration data. This allows an attacker to inject arbitrary code into the service worker, leading to full code execution and potential compromise of the entire caching and resource management system.}	```eval(`key = ${genConfig}('${url}', '${method}')`);```
452	newport-pleasure.com.js	Regular Expression Denial of Service (ReDoS) in resource cache configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of user-supplied regex patterns in the resource cache configuration, but it is not caused by misuse of a sensitive JavaScript function. The issue stems from the inherent complexity of the regex patterns themselves, not from a function that directly enables unsafe behavior.}	```const exp = new RegExp(def.regexPath, 'i');```
453	newport-pleasure.com.js	Open Redirect via unvalidated login URL parameter	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the direct use of the loginUrl parameter in Response.redirect without validation or sanitization, but it is not caused by misuse of a sensitive JavaScript function. The issue lies in the lack of input validation rather than a function that inherently introduces risk.}	```Response.redirect(loginUrl);```
454	algerie360.com.js	Loading untrusted external script in service worker	High	true	CWE-78	N/A	importScripts	standard	{The importScripts() function in service workers loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an external, untrusted source (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability. If the external script is compromised or controlled by an attacker, it can execute arbitrary code within the service worker context, leading to cache manipulation, network interception, or data exfiltration. Although the URL is hardcoded here, the source is external and not under the site’s control, making it a sensitive misuse.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6351473b9d40ac00092ad988/service-worker.js"");```"
455	my.club.js	Improper Error Handling in Cache Population	Medium	false	CWE-754	N/A	N/A	N/A	{The vulnerability arises from the use of a catch block that silently ignores errors during cache population via `cache.addAll()`. While this does not involve a sensitive function misuse (such as `importScripts`, `eval`, or `Function`), it leads to improper error handling that may cause silent failures in cache setup. The function `cache.addAll()` is a standard API, but its misuse here is not due to sensitive function exposure but rather poor error management.}	```(function () { const version = 'v2'; const cacheName = `${version}::cache`; const defaultCacheList = ['/pwa-offline.html']; function onInstall(event) { event.waitUntil(caches.open(cacheName).then(cache => cache.addAll(defaultCacheList).catch(() => {}))); } function onActivate(event) { event.waitUntil(caches.keys().then(keys => Promise.all(keys.filter(key => !key.startsWith(cacheName)).map(key => caches.delete(key))))); } function onFetch(event) { if (navigator.onLine) return; event.respondWith(fetch(event.request).catch(err => { if (event.request.destination === 'document') { return caches.open(cacheName).then(cache => cache.match('/pwa-offline.html')); } else { console.log('service worker cache fetch error', event.request); throw err; } })); } self.addEventListener('install', onInstall); self.addEventListener('fetch', onFetch); self.addEventListener('activate', onActivate);})()```
456	drsaina.com.js	Untrusted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (widgets.in.webengage.com). Although the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing a script from an external source without proper vetting or integrity checks allows the third party to potentially inject malicious code into the service worker, leading to cache manipulation, network interception, or data exfiltration. This is considered a sensitive function misuse due to the inherent trust required in the imported script.}	```importScripts('https://widgets.in.webengage.com/js/service-worker.js');```
457	jajiga.com.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase credentials (API key, project ID, messaging sender ID, and app ID) directly in the service worker script. These credentials are exposed to anyone who can access the script, enabling unauthorized access to Firebase services. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure configuration practices.}	```const firebaseApp = firebase.initializeApp({ apiKey: 'AIzaSyAk4GySEjBncKzSouVzy1V8RkD9dhVFA74', projectId: 'endless-mariner-333510', messagingSenderId: '616286211925', appId: '1:616286211925:web:952a7fa365d35df97f29dc' });```
458	apkpac.com.js	Open Redirect via Notification Data	High	true	N/A	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL provided by the notification data, which is derived from untrusted input (event.notification.data). Since this input is not validated or sanitized, an attacker could craft a notification payload with a malicious URL, leading to an open redirect and potential phishing or malware delivery.}	```event.waitUntil(clients.openWindow(redirectUrl));```
459	apkpac.com.js	Improper Input Validation for Notification URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from improper validation of the redirectUrl, but it is not directly caused by misuse of a sensitive function. The issue lies in logic and input handling, not in a specific function’s unsafe use.}	```var redirectUrl = null; if (event.notification.data) { redirectUrl = event.notification.data ? event.notification.data : null; } else { redirectUrl = 'https://www.apkpac.com/'; }```
460	apkpac.com.js	Insecure Use of 'no-cors' Mode in Fetch Requests	Medium	false	N/A	N/A	N/A	N/A	{The use of 'no-cors' mode in fetch requests is a configuration issue, not a misuse of a sensitive function. While fetch is a standard API, the vulnerability arises from improper mode selection, not from unsanitized input or dynamic execution.}	"```fetch(""https://www.silverglad.com/show-impression7"", { mode: ""no-cors"", body: JSON.stringify(e), method: ""POST"", headers: { 'content-type': 'application/json' } })```"
461	hunkemoller.nl.js	Cache Poisoning via Insecure Fetch Handling	High	true	CWE-918	9	cache.put	standard	{The cache.put function is used to store responses in the service worker's cache. The vulnerability arises because it is called without validating the origin or integrity of the fetched resource. Specifically, the code blindly caches any response for URLs matching common static file extensions (e.g., .js, .css, .woff2) without checking if the response is from a trusted source or if the request was initiated by the service worker itself. This allows an attacker to manipulate the cache by triggering a fetch for a malicious resource (e.g., via a crafted URL or network interception), which is then stored in the cache and served to subsequent requests, leading to cache poisoning.}	```if (event.request.url.match(/.png|.img|.webp|.gif|.svg|.js|.woff2|.css|.ico/)) { cache.put(event.request, networkResponse.clone()); }```
462	faza2music.net.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically generated from untrusted input, the act of importing an external script from an untrusted or third-party domain introduces a high-risk vulnerability. The imported script can execute arbitrary code within the service worker context, potentially leading to cache manipulation, network interception, or data exfiltration. This is considered a sensitive function misuse because it bypasses the principle of least privilege and introduces an attack surface through external code execution.}	```importScripts('https://van.najva.com/static/js/scripts/new-website445884-website-58306-9c995b9e-4105-47f8-86c6-d5de562dd5a5-service-worker.js');```
463	theeagle.com.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-602	9	new URL	standard	{The function new URL is used to parse a URL provided in the notification data (oData.url), which is derived from untrusted external input (FCM message payload). Since the URL is not validated or sanitized, an attacker can craft a malicious URL that redirects users to arbitrary domains, leading to open redirect vulnerabilities. This misuse allows attackers to perform phishing, session hijacking, or other malicious redirections.}	```let oURL = new URL(oData.url);```
464	supervasco.com.js	Insecure Use of Third-Party Code	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party domain (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability because the script is executed with the same privileges as the service worker. If the third-party script is compromised or malicious, it can intercept network requests, manipulate cache, or perform other harmful actions. This constitutes a form of insecure third-party code execution, which is a known security risk (CWE-434).}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6604080a81852000094311e0/service-worker.js"");```"
465	rade.ir.js	External Script Loading Without Validation	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL, which does not inherently introduce dynamic risk. However, the vulnerability arises because the script is loaded from an external, untrusted domain (van.najva.com), and there is no validation or integrity check (e.g., subresource integrity, CORS policy enforcement) to ensure the script's authenticity or safety. While the input is not dynamic, the lack of validation of the external source makes this a sensitive misuse of importScripts(), as it allows potential compromise if the external script is tampered with or controlled by an attacker.}	```importScripts('https://van.najva.com/static/js/scripts/rade-1246303-14ef00a6-da80-4e14-8afd-45d782598750-service-worker.js');```
466	milli.az.js	Hardcoded Secret in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is not caused by misuse of a sensitive function, but rather by directly embedding a secret in the code.}	```self[`appKey`] = `330a0e76f2fca5241562ad80486ba3b2`;```
467	milli.az.js	Untrusted External Script Loading	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it may still be considered untrusted if the host is not under the developer’s full control or if it could be compromised. Although the host is hardcoded here, the function itself is sensitive because it executes arbitrary code from a remote source, and if the host were dynamic or derived from untrusted input, it would be a direct vector for script injection.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
468	itoll.com.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-1338	9	RegExp	standard	{The code constructs a regular expression dynamically using `new RegExp(entry.urlPattern)` where `entry.urlPattern` is derived from the `runtimeCaching` configuration. If an attacker can control or influence this input (e.g., via a misconfigured or maliciously crafted configuration), they could supply a malicious pattern that triggers catastrophic backtracking, leading to ReDoS. Since the pattern is not sanitized or validated, this constitutes misuse of the standard `RegExp` constructor with untrusted input.}	```const urlPattern = new RegExp(entry.urlPattern);```
469	ikigaimangas.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of `new URL(t.base, e.origin)` where `t.base` is derived from a message event's data, which is user-controlled. This allows an attacker to craft a malicious `base` URL that could be resolved to an internal or external resource, leading to SSRF. The `URL` constructor is a standard JavaScript API, and when used with untrusted input, it can be exploited to make unintended network requests.}	```const r = new URL(t.base, e.origin); Array.isArray(t.links) && w(n, s, i, r, c, o, t.links), Array.isArray(t.bundles) && y(n, r, c, o, t.bundles), Array.isArray(t.symbols) && y(n, r, c, o, W(h, t.symbols));```
470	pastedownload.com.js	Improper Limitation of a Pathname to a Restricted Directory	High	true	CWE-22	N/A	var addDirectoryIndex = function (originalUrl, index) { var url = new URL(originalUrl); if (url.pathname.slice(-1) === '/') { url.pathname += index; } return url.toString(); };	standard	{The function `addDirectoryIndex` modifies a URL's pathname by appending an index (e.g., 'index.html') if the path ends with a slash. If the `originalUrl` is derived from untrusted input (e.g., user-controlled request URL), an attacker could craft a path like `/../../` or `/admin/` to traverse directories, potentially accessing restricted resources. The `URL` constructor and `pathname` manipulation are standard functions, but their misuse here allows path traversal.}	```var addDirectoryIndex = function (originalUrl, index) { var url = new URL(originalUrl); if (url.pathname.slice(-1) === '/') { url.pathname += index; } return url.toString(); };```
471	pastedownload.com.js	Insecure Cookie Handling	Medium	false	N/A	N/A	N/A	N/A	{The `cleanResponse` function processes responses by creating a new `Response` object with the same headers, status, and body. While it does not directly handle cookies, the vulnerability arises from not properly sanitizing or restricting headers, which could allow sensitive cookies to be exposed or manipulated in redirected responses. However, no sensitive function is misused here; the issue is more about policy or configuration.}	```var cleanResponse = function (originalResponse) { if (!originalResponse.redirected) { return Promise.resolve(originalResponse); } var bodyPromise = 'body' in originalResponse ? Promise.resolve(originalResponse.body) : originalResponse.blob(); return bodyPromise.then(function (body) { return new Response(body, { headers: originalResponse.headers, status: originalResponse.status, statusText: originalResponse.statusText }); }); };```
472	pastedownload.com.js	Information Exposure Through Log Files	Low	false	N/A	N/A	N/A	N/A	{The `console.warn` call logs error messages including the request URL and error object. While this can expose sensitive information, it does not stem from misuse of a sensitive function like `eval`, `importScripts`, or `URL` with untrusted input. The issue is logging behavior, not function misuse.}	"```console.warn('Couldn\'t serve response for ""%s"" from cache: %O', event.request.url, e);```"
473	pastedownload.com.js	Execution with Unnecessary Privileges	Medium	false	N/A	N/A	N/A	N/A	{The `fetch` and `caches.open` calls are used to cache resources during installation. While these functions have elevated privileges, they are used appropriately with hardcoded, trusted URLs from `precacheConfig`. There is no evidence of untrusted input being passed to these functions, so no sensitive function misuse is present.}	```event.waitUntil(caches.open(cacheName).then(function (cache) { return setOfCachedUrls(cache).then(function (cachedUrls) { return Promise.all(Array.from(urlsToCacheKeys.values()).map(function (cacheKey) { if (!cachedUrls.has(cacheKey)) { var request = new Request(cacheKey, { credentials: 'same-origin' }); return fetch(request).then(function (response) { if (!response.ok) { throw new Error('Request for ' + cacheKey + ' returned a ' + 'response with status ' + response.status); } return cleanResponse(response).then(function (responseToCache) { return cache.put(cacheKey, responseToCache); }); } }); })); }));```
474	apostatudo.bet.js	Excessive Cache Entries Leading to Resource Exhaustion	Low	false	N/A	0	N/A	N/A	{The vulnerability arises from setting an extremely high `maxEntries` value (99999999) in the `ExpirationPlugin`, which can lead to excessive memory and storage consumption. However, this is not due to misuse of a sensitive function like `importScripts` or `eval`, but rather a misconfiguration in the caching strategy. No sensitive function is involved in this case.}	"```define([""./workbox-799b2a6b""], function (e) { ""use strict""; self.skipWaiting(), e.clientsClaim(), e.registerRoute(/^https:\/\/static\.apostatudo\.bet\/.*/i, new e.StaleWhileRevalidate({ cacheName: ""website-static-cached"", plugins: [new e.ExpirationPlugin({ maxEntries: 99999999, maxAgeSeconds: 21600 }), new e.CacheableResponsePlugin({ statuses: [0, 200] })] }), ""GET""), e.registerRoute(/^https:\/\/imagedelivery\.net\/.*/i, new e.CacheFirst({ cacheName: ""cf-static-images"", plugins: [new e.ExpirationPlugin({ maxEntries: 99999999, maxAgeSeconds: 21600 }), new e.CacheableResponsePlugin({ statuses: [0, 200] })] }), ""GET""); });```"
475	limoome.com.js	Untrusted External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com', which is not under the control of the application. This constitutes a high-risk vulnerability because the script could be malicious, allowing an attacker to compromise the service worker’s execution context, intercept network requests, manipulate cache, or perform other harmful actions. Since the script is imported from an external, untrusted source, it qualifies as sensitive function misuse.}	```importScripts('https://van.najva.com/static/js/scripts/new-website701428-website-52393-ab51a396-74fb-446d-8a02-410e27c18b17-service-worker.js');```
476	carta.menu.js	Missing Offline Page in Cache	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the absence of an offline page in the cache list. The code does not attempt to cache an offline page (e.g., 'offline.html' or similar), which could lead to poor user experience during network failures. This is a configuration or design issue, not a security vulnerability stemming from unsafe function usage.}	```let filesToCache = ['/css/frontend.css', '/css/restaurant-page.css', '/js/frontend.js', '/js/app.v2.js', 'icon-72x72.png', 'icon-96x96.png', 'icon-128x128.png', 'icon-144x144.png', 'icon-152x152.png', 'icon-192x192.png', 'icon-384x384.png', 'icon-512x512.png'];```
477	mediacongo.net.js	Improper Handling of HTTP Methods in Service Worker	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the lack of proper validation or handling of HTTP methods in the fetch event handler. The code simply forwards all requests without checking if they are safe or intended, which could allow unintended behavior or exposure to certain attacks, but no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', event => {  event.respondWith(fetch(event.request).then(response => {    return response;  }).catch(error => {    console.error('Erreur lors de la récupération de la ressource:', error);  }));});```
478	temp-mail.io.js	Improper Cache Handling Leading to Potential Data Leakage	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache strategy options, particularly the use of dynamic strategy plugins derived from `entry.strategyPlugins` and `getProp(workbox, p.use)`. While this does not directly involve a sensitive function, it can lead to unintended behavior if plugins are improperly configured or if untrusted input influences plugin instantiation. However, since no sensitive function like `eval`, `importScripts`, or `Function` is misused, this is not a sensitive function vulnerability.}	```const strategyOptions = { ...entry.strategyOptions, plugins };```
479	temp-mail.io.js	Supply Chain Risk via External CDN	Medium	true	CWE-918	N/A	importScripts	standard	{The `importScripts` function is a standard Service Worker API that loads and executes scripts from specified URLs. In this case, the URL is dynamically sourced from `options.workboxURL`, which is hardcoded to a CDN (`https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js`). While the URL is not user-controlled, relying on an external CDN introduces supply chain risk: if the CDN is compromised or the package is tampered with, the service worker could load malicious code. This constitutes misuse of a sensitive function because `importScripts` executes arbitrary code from a remote source without integrity verification.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
480	yabbycasino.com.js	Incorrect Cache Deletion Logic	High	false	N/A	0	N/A	N/A	{The vulnerability arises from incorrect logic in cache deletion during activation, not from misuse of a sensitive function. The code attempts to delete caches not in the allowlist, but the `caches.forEach` callback returns `caches.delete(cacheName)` only when the cache is not in the allowlist, which is not the correct way to handle asynchronous operations in `event.waitUntil`. This leads to potential race conditions or incomplete cleanup, but no sensitive function is misused with untrusted input.}	```self.addEventListener('activate', function (event) { var cacheAllowlist = ['v6-cache']; event.waitUntil(caches.forEach(function (cache, cacheName) { if (cacheAllowlist.indexOf(cacheName) == -1) { return caches.delete(cacheName); } })); });```
481	ory.sh.js	Improper Input Validation Leading to API Abuse	Medium	true	New	8	N/A	standard	{The code dynamically evaluates user-controlled input via the `data.api` parameter, which is derived from the URL pathname. This input is used to invoke functions from the `MessageAPI` object without validation, allowing an attacker to trigger arbitrary API methods (e.g., `clearPathResources`, `disableOfflineShell`) if they can craft a request with a malicious `api` parameter. This constitutes a form of API abuse due to improper input validation, and since the `MessageAPI` object is accessed via dynamic property lookup, it is effectively a misuse of JavaScript's object property access mechanism, which is considered sensitive when used with untrusted input.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
482	ory.sh.js	Relative Path in importScripts	Low	false	New	N/A	N/A	N/A	{The use of a relative path in `importScripts` does not constitute a sensitive function misuse because the path is hardcoded and does not involve dynamic or user-controlled input. While it may pose a minor risk if the script is hosted in an unexpected context, it does not lead to arbitrary code execution or injection.}	```importScripts(`idb-keyval-3.2.0-iife.min.js`);```
483	ringgitplus.com.js	Loading untrusted external script in Service Worker	High	true	CWE-496	10	importScripts	standard	{The importScripts() function in Service Workers loads and executes a script from a specified URL. When used with a hardcoded external URL like '//cdnt.netcoresmartech.com/swv4.js', it introduces a high-risk vulnerability because the script is loaded from an external, potentially untrusted source. Although the URL is hardcoded here, the function itself is sensitive as it can execute arbitrary code from remote locations, and if the URL were dynamically constructed from untrusted input, it would enable script injection attacks.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
484	englishcentral.com.js	Exposed API Key	High	false	CWE-532	N/A	N/A	N/A	{The API key is hardcoded in the script and exposed in the source code, but it is not a result of misuse of a sensitive JavaScript function. It is a static credential leak.}	"```firebase.initializeApp({ apiKey: ""AIzaSyA7zSFJv0HpF-aEMnEjjfAIBol3m17FAfM"", authDomain: ""englishcentral-com-api-project-108821948315.firebaseapp.com"", databaseURL: ""https://englishcentral-com-api-project-108821948315.firebaseio.com"", projectId: ""englishcentral.com:api-project-108821948315"", storageBucket: ""undefined"", messagingSenderId: ""108821948315"", appId: ""1:108821948315:web:5513c29505f75e2b1aa33e"" });```"
485	englishcentral.com.js	Open Redirect	High	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a URL derived from the meta.url parameter, which is parsed from untrusted input (payload.data.meta). If an attacker can control this input, they can redirect users to arbitrary domains, leading to open redirect vulnerability.}	"```event.waitUntil(clients.matchAll({ type: ""window"" }).then(function () { return clients.openWindow(notification.url || ECDOMAIN); }));```"
486	taxnotes.com.js	Insecure HTTP Request Handling	High	true	N/A	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that is derived from the original request's URL and query parameters. Specifically, the URL is modified by setting its protocol and host to the current origin (c.location.protocol and c.location.host), and the pathname is set to `/ta-t-m/${r}` where `r` is extracted from the query parameter `id`. While the host is restricted to the current origin, the path is dynamically constructed from user-controlled input (`r`), which could lead to unintended resource access or exposure of internal paths if not properly validated. This constitutes insecure HTTP request handling due to dynamic URL construction from untrusted input.}	```let n = new URL(this.url); return n.protocol = c.location.protocol, n.host = c.location.host, n.pathname = `/ta-t-m/${r}`, n.searchParams.delete('id'), n.searchParams.append('taidp', btoa(e)), fetch(n).then(a => { if (!a.ok) throw new l(a); return a; }).catch(a => i(this, null, function* () { throw this.reportFetchError('gtm', a, { endpoint: 'fallback', id: t }), a; }));```
487	taxnotes.com.js	Server Side Request Forgery (SSRF)	High	true	N/A	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that is derived from the original request's URL and query parameters. The URL is modified by setting its protocol and host to the current origin (c.location.protocol and c.location.host), and the pathname is set to `/ta-g-t/${r}` where `r` is extracted from the query parameter `id`. Although the host is restricted to the current origin, the path is dynamically constructed from user-controlled input (`r`), which could lead to unintended resource access or exposure of internal paths if not properly validated. This constitutes SSRF because the service worker is making requests to paths controlled by the user, potentially allowing access to internal resources or sensitive endpoints within the same origin.}	```let [e, r] = t.split('-'); let n = new URL(this.url); return n.protocol = c.location.protocol, n.host = c.location.host, n.pathname = `/ta-g-t/${r}`, n.searchParams.delete('id'), n.searchParams.append('taidp', btoa(e)), fetch(n).then(a => { if (!a.ok) throw new l(a); return a; }).catch(a => i(this, null, function* () { throw this.reportFetchError('gtag', a, { endpoint: 'fallback', id: t }), a; }));```
488	taxnotes.com.js	Information Exposure Through Error Details	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the error object's `toSerializableObject` method returning detailed error information including status, headers, and body. This is not due to misuse of a sensitive function, but rather a design flaw in error handling that exposes sensitive data.}	```return { type: this.type, message: this.message, status: this.response.status, headers: this.getResponseHeaders(), body: yield this.getResponseBody() };```
489	pxxbet.com.js	Improper URL Validation in Cache Bypass Logic	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from flawed logic in the fetch event handler, where the script checks for specific substrings in the request URL to determine whether to bypass caching. The issue is not due to misuse of a sensitive function, but rather due to improper validation logic (e.g., using indexOf without proper context or escaping, and relying on substring matching without considering URL structure). The code does not invoke any sensitive functions like importScripts, eval, or dynamic code execution.}	```self.addEventListener('fetch', e => {  for (let i = 0; i < offlineExclude.length; i++) {    if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false;  }  var u = e.request.url.replace('https://', '');  var n = u.indexOf('/');  if (u.slice(n, 60).indexOf('.') == -1) {    return false;  }  e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));});```
490	dt.no.js	Improper URL Validation in Message Handlers	High	true	N/A	N/A	RegExp	standard	{The message handler uses a hardcoded string pattern 'amedia:warm-cache:files' to identify messages, but the URL validation is not performed on the actual URLs being cached. The function `handler2` processes URLs from the message payload without validating or sanitizing them, which could allow an attacker to inject arbitrary URLs into the cache. This is a misuse of the `RegExp` function in the context of URL handling, as the pattern is not used to validate the URLs themselves, and the `fetch` and `caches.put` operations are performed without proper input sanitization.}	```const message2 = 'amedia:warm-cache:files'; async function handler2(event, data) { const cacheName2 = cacheNames2.runtime; if (data && Array.isArray(data)) { const cache = await caches.open(cacheName2); const result = data.map(url => caches.match(url).then(response => { if (response) { return true; } return requestAndCacheUrl(url, cache); })); event.waitUntil(Promise.all(result)); } }```
491	dt.no.js	Improper URL Validation in Message Handlers	High	true	N/A	N/A	RegExp	standard	{The message handler uses a hardcoded string pattern 'amedia:check-last-updated' to identify messages, but the URL validation is not performed on the actual URLs being fetched. The function `handler` processes URLs from the message payload without validating or sanitizing them, which could allow an attacker to inject arbitrary URLs into the fetch operation. This is a misuse of the `RegExp` function in the context of URL handling, as the pattern is not used to validate the URLs themselves, and the `fetch` and `caches.put` operations are performed without proper input sanitization.}	```var message = 'amedia:check-last-updated'; async function handler(event, message3) { const { url, timestamp: lastmodified } = message3; let counter = RETRIES; const response = await fetchLastModified(url, lastmodified, counter); const cache = await caches.open(cacheName); await cache.put(url, response); const controlled = await self.clients.matchAll(); controlled.forEach(client => { client.postMessage({ type: 'amedia:updated-version', value: url }); }); }```
492	dt.no.js	Insecure Regular Expression Pattern in Routing	Medium	true	N/A	N/A	RegExp	standard	{The `pattern4` function uses a `RegExp` to match URLs, but the pattern is constructed with a literal string that includes a single quote, which is not properly escaped. This could lead to a regular expression injection if the pattern were derived from user input, but even as a hardcoded pattern, it demonstrates a lack of proper escaping and could be exploited if the pattern were dynamically generated. The `RegExp` function is misused here because it is not validated or sanitized, and the pattern is not robust against malformed inputs.}	"```function pattern4(req) { return req.event.request.mode === ""navigate"" && req.url.pathname === ""/"" && req.url.host.indexOf(""'www.dt.no'"") !== -1 && req.event.request.method === ""GET""; }```"
493	dt.no.js	Logic Error in Host Check Leading to Bypass	Medium	false	N/A	N/A	N/A	N/A	"{The `pattern4` function checks if the host contains the string ""'www.dt.no'"" which is a literal string with single quotes. This is a logic error because it will not match the actual host 'www.dt.no' due to the presence of the quotes. This is not a misuse of a sensitive function, but rather a logic error in the string comparison.}"	"```function pattern4(req) { return req.event.request.mode === ""navigate"" && req.url.pathname === ""/"" && req.url.host.indexOf(""'www.dt.no'"") !== -1 && req.event.request.method === ""GET""; }```"
494	moonlock.com.js	Hardcoded cryptographic key in client-side code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from exposing a cryptographic key directly in client-side code, not from misuse of a sensitive function.}	```self[`appKey`] = `bb8000163f96066b524581b5260a9098`;```
495	moonlock.com.js	Loading external script without integrity check	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load external scripts. When the URL passed to it is constructed from a hardcoded value (self[`hostUrl`]), it introduces a risk if that value is ever compromised or if the script at the URL is not integrity-verified. Although the URL is not dynamically derived from untrusted input, the lack of integrity checks (e.g., subresource integrity) makes it vulnerable to supply chain attacks if the external script is tampered with.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
496	antyradio.pl.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., 'https://s-eu-1.pushpushgo.com/...'), it introduces a risk if the script source is not fully trusted or if the domain is compromised. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an external, potentially untrusted source, which could be controlled by an attacker. This allows for remote code execution within the service worker context, enabling malicious behavior such as data exfiltration or request interception.}	```importScripts('https://s-eu-1.pushpushgo.com/61767913e76bb7d39637b934/worker.js');```
497	unitel.bo.js	Insecure Data Handling - Unvalidated URL in Notification Click Action	Medium	true	CWE-20	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a new browser window or tab based on the value of i.notification.data.click_action, which is derived from user-controlled notification data. Since this input is not validated or sanitized, an attacker could craft a malicious notification with a click_action URL pointing to a phishing site or malicious script, leading to unintended navigation or potential phishing attacks. This constitutes a misuse of a sensitive function that can be exploited to redirect users to arbitrary URLs.}	```self.clients.openWindow(i.notification.data.click_action)```
498	bauhaus.fi.js	Untrusted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in service workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., 'https://api.exponea.com/js/service-worker.min.js'), it introduces a high-risk vulnerability if the script source is not fully trusted or if the script can be tampered with. Although the URL is hardcoded here, the vulnerability remains because the script is loaded from an external, potentially untrusted source, which could be compromised or serve malicious code. This allows an attacker to inject arbitrary JavaScript into the service worker, leading to full control over caching, network interception, and user data manipulation.}	```importScripts('https://api.exponea.com/js/service-worker.min.js');```
499	hawzah.net.js	Unrestricted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (van.najva.com), which could be compromised or controlled by an attacker. This allows for remote code execution within the service worker context, enabling malicious behavior such as intercepting network requests, manipulating cached resources, or exfiltrating data. Although the URL is hardcoded, the act of importing from an external source without validation or trust verification constitutes misuse of a sensitive function.}	"```importScripts(""https://van.najva.com/static/js/scripts/new-website853282-website-48061-2baf1cd3-9918-40ae-bfc8-be2d87632299-service-worker.js"");```"
500	tdn.com.js	Open Redirect Vulnerability	Medium	true	CWE-602	9	N/A	standard	{The function `new URL()` is used to parse a URL provided in `oData.url`, which originates from a Firebase message payload. Since this payload is controlled by a remote server (and potentially by an attacker), the URL can be manipulated to redirect users to arbitrary destinations, leading to an open redirect vulnerability. The `new URL()` function is standard and safe when used with trusted input, but here it is used with untrusted data, enabling redirection to malicious sites.}	```let oURL = new URL(oData.url);```
501	lemoniteur.fr.js	Improper Service Worker Activation Handling	Medium	false	New	N/A	N/A	N/A	{The code uses standard service worker lifecycle methods (install and activate) with no evidence of sensitive function misuse. The functions self.skipWaiting() and self.clients.claim() are used appropriately and do not involve dynamic or untrusted input. There is no risk of injection or unauthorized behavior from these calls.}	"```self.addEventListener(""install"", function (a) { self.skipWaiting(); }); self.addEventListener(""activate"", function (a) { return self.clients.claim(); });```"
502	diarioeldia.cl.js	Open Redirect via Notification Click	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL that is derived from untrusted input (event.notification.data.FCM_MSG.data.link). Since this URL is constructed from user-controlled data without validation or sanitization, an attacker can craft a malicious link that redirects users to arbitrary domains, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API that allows navigation to external URLs based on untrusted input.}	```const url = new URL(event.notification.data.FCM_MSG.data.link).toString(); if (url) { c = await clients.openWindow(url); }```
503	jklm.fun.js	Missing Access Control in Fetch Event Handler	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of proper access control logic within the fetch event handler, not from misuse of a sensitive function. The event handler is empty, meaning no specific function is being misused to cause the issue.}	```self.addEventListener('fetch', event => {});```
504	escolaeducacao.com.br.js	External Script Import Without Validation	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded, external URL (as in this case), it introduces a high-risk vulnerability because the script is fetched from an untrusted third-party domain (dash.megapulse.app). Although the URL is hardcoded and not dynamically constructed from user input, the lack of validation or integrity checks (e.g., no subresource integrity or origin validation) means the script could be tampered with or replaced by an attacker, leading to unauthorized code execution within the service worker context. This can result in cache manipulation, network request interception, or data exfiltration.}	"```importScripts(""https://dash.megapulse.app/assets/js/sw-host.js"");```"
505	meetfighters.com.js	Improper Cache Expiration and Cleanup	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from improper cache management practices, not from misuse of a sensitive JavaScript function. The code uses workbox.routing.registerRoute with CacheFirst strategy, but there is no evidence of dynamic or untrusted input being used to construct cache keys or URLs. The cache name is hardcoded, and destinations are defined in a static Set. Therefore, no sensitive function misuse is involved.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js');workbox.routing.registerRoute(({request}) => request.destination === 'image', new workbox.strategies.CacheFirst());const cacheName = 'static-cache-v2';const cachedDestinations = new Set(['font', 'manifest', 'paintworklet', 'script', 'sharedworker', 'style', 'worker']);workbox.routing.registerRoute(({request}) => cachedDestinations.has(request.destination), new workbox.strategies.CacheFirst({cacheName}));```
506	fluege.de.js	Server Side Request Forgery (SSRF)	High	false	N/A	N/A	N/A	N/A	{The provided code does not exhibit misuse of a sensitive JavaScript function that leads to SSRF. The fetch() call is used to retrieve a webp image based on a URL derived from the original request, but the URL is constructed from a known, controlled base (the original request URL) and does not incorporate untrusted or dynamic input from external sources such as user-supplied parameters or headers. The regular expression filtering ensures only specific image patterns are processed, and the fetch() is used in a context that does not allow arbitrary endpoint access. Therefore, while SSRF is labeled, it is not due to sensitive function misuse.}	```self.addEventListener('fetch', function (event) { if (true === /__(efa7d34f|[abcdef\d]+)\.(jpg|png)$/.test(event.request.url) && false === /\/x\d+\/x\d+\//.test(event.request.url)) { var supportsWebp = false; if (event.request.headers.has('accept')) { supportsWebp = event.request.headers.get('accept').includes('webp'); } if (supportsWebp) { var req = event.request.clone(), webpImage = fetch(req.url.substr(0, req.url.lastIndexOf('.')) + '.webp', { mode: 'cors' }); event.respondWith(webpImage.then(function (response) { if (!response || response.status !== 200) { return fetch(event.request); } else { return response; } }).catch(function () { return fetch(event.request); })); } } });```
507	heraldcourier.com.js	Open Redirect Vulnerability	High	true	CWE-601	10	N/A	standard	{The function `new URL()` is used to parse a URL provided in `oData.url`, which originates from a remote Firebase message payload. Since this input is untrusted and not validated, an attacker can craft a malicious URL (e.g., redirecting to a phishing site) that will be opened when the notification is clicked, leading to an open redirect vulnerability.}	```let oURL = new URL(oData.url);```
508	dinamani.com.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious or tampered scripts from external sources. In this case, the script is imported from a third-party CDN (https://cdn.izooto.com), which could be compromised or modified, leading to code injection and full control over the service worker’s behavior.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/7971c6cc7b16acf3f079c3b680f77fee91d3232a.js"");```"
509	reduno.com.bo.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which exposes it to attackers.}	```self[`appKey`] = `ad0963feaf063918c600160aafdc7d6c`;```
510	reduno.com.bo.js	Remote Code Execution via Untrusted Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it still represents a potential risk if the host is not fully trusted or if the script can be tampered with. However, in this case, the host is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically sourced. Still, the function itself is sensitive because it executes arbitrary code from a remote source, and if the host were ever compromised or changed, it could lead to RCE.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
511	passion.ru.js	Stale Content Caching Due to Missing Revisions	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability arises from the absence of revision hashes in the precache manifest, which prevents Workbox from detecting updates to assets. It is not caused by misuse of a sensitive function, but rather by a configuration issue in the caching strategy.}	```const e = [{ 'revision': null, 'url': '/assets/259.9ea34585cf333ba65f62.css' }, { 'revision': null, 'url': '/assets/259.9ea34585cf333ba65f62.js' }, { 'revision': null, 'url': '/assets/646.19ddbdc8e754123f42db.css' }, { 'revision': null, 'url': '/assets/646.19ddbdc8e754123f42db.js' }, { 'revision': null, 'url': '/assets/791.1f4fb62f9d9e3b25f738.js' }, { 'revision': null, 'url': '/assets/938.38408d59436a33c1ddab.css' }, { 'revision': null, 'url': '/assets/938.38408d59436a33c1ddab.js' }, { 'revision': null, 'url': '/assets/main.524918c8d248e0fe7bbc.css' }, { 'revision': null, 'url': '/assets/main.524918c8d248e0fe7bbc.js' }, { 'revision': null, 'url': '/assets/vendor.0a718f8af621ea6e5b31.js' }];```
512	passion.ru.js	Third-Party Script Import Without Integrity Check	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is used to load a third-party script from a hardcoded URL (https://cdn.pushwoosh.com/webpush/v3/pushwoosh-service-worker.js) without any integrity verification. Although the URL is hardcoded, the function itself is sensitive because it executes arbitrary JavaScript in the service worker context. If the script source is compromised, it could lead to malicious code execution, data exfiltration, or manipulation of cached content. The lack of integrity checks makes this a security risk, even if the URL is not dynamically derived.}	```try { importScripts(\'https://cdn.pushwoosh.com/webpush/v3/pushwoosh-service-worker.js\'); } catch (e) {}```
513	hinkhoj.com.js	Improper Input Validation	High	true	CWE-20	N/A	JSON.parse	standard	{The function JSON.parse() is used to parse untrusted input from event.data.text(), which is derived from a push notification. If the input is not properly validated or sanitized, it can lead to JSON parsing errors or, in some cases, unintended behavior if the input is malformed or crafted to exploit parsing logic. While JSON.parse() itself is not inherently dangerous, its misuse with untrusted data without validation can result in improper input handling, leading to potential denial of service or unexpected application behavior.}	```let n_message = JSON.parse(n_messageJson);```
514	hinkhoj.com.js	Open Redirect	High	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow() is used to open a URL that is derived from event.notification.data.url, which originates from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, causing the browser to redirect the user to an arbitrary site, leading to an open redirect vulnerability.}	```clients.openWindow(event.notification.data.url);```
515	siyavula.com.js	Hardcoded Sensitive Information in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded Firebase API key in client-side code, which is not caused by misuse of a sensitive JavaScript function. The issue arises from exposing credentials directly in the source code, not from dynamic or unsanitized input being passed to a function.}	```importScripts('https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js');importScripts('https://www.gstatic.com/firebasejs/9.22.2/firebase-messaging-compat.js');firebase.initializeApp({apiKey: 'AIzaSyAx8_ZIUY68vu1X3S00ywcasgbkuW9ATUU',authDomain: 'siyavula-5330c.firebaseapp.com',projectId: 'siyavula-5330c',storageBucket: 'siyavula-5330c.appspot.com',messagingSenderId: '869504462768',appId: '1:869504462768:web:f62574a4a6e07cd81f3075'});const messaging = firebase.messaging();```
516	rb.no.js	SSRF via Message Handler	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL derived from a message event payload, which is user-controlled. Since the URL is not validated or sanitized, an attacker can supply arbitrary URLs, including internal or external resources, leading to Server-Side Request Forgery (SSRF). The function is called without any restrictions on the URL scheme or origin, enabling unauthorized access to internal systems or external services.}	```const response = await fetch(url, { method: 'HEAD' });```
517	rb.no.js	SSRF via Message Handler	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL derived from a message event payload, which is user-controlled. Since the URL is not validated or sanitized, an attacker can supply arbitrary URLs, including internal or external resources, leading to Server-Side Request Forgery (SSRF). The function is called without any restrictions on the URL scheme or origin, enabling unauthorized access to internal systems or external services.}	```const response = await fetch(url);```
518	rb.no.js	SSRF via Message Handler	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL derived from a message event payload, which is user-controlled. Since the URL is not validated or sanitized, an attacker can supply arbitrary URLs, including internal or external resources, leading to Server-Side Request Forgery (SSRF). The function is called without any restrictions on the URL scheme or origin, enabling unauthorized access to internal systems or external services.}	```return fetch(url).then(res => { if (res.ok) { return cache.put(url, res).then(() => url); } return true; }).catch(() => true);```
519	deutschlandcard.de.js	Hardcoded Secrets in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded secrets (appKey and token) in client-side code, not due to misuse of a sensitive JavaScript function. These values are static and not dynamically derived from untrusted input or passed to a function that could lead to injection or execution risks.}	"```importScripts(""https://aswpsdkeu.com/notify/v1/ua-sdk.min.js"");uaSetup.worker(self, { defaultIcon: ""https://www.deutschlandcard.de/dam/dc\u002Dlogo\u002Ddots.png"", defaultTitle: ""DeutschlandCard"", defaultActionURL: ""https://www.deutschlandcard.de/"", appKey: ""dTR6bdtkS9GNyvtl7MqH5Q"", token: ""MTpkVRI2YmR0a1M5R055dnRsN01xSDVROkU4THNZTXZEdmplaGx2RGY4YjhtTXlSRjFzWW1nTkR4Q2tKang4YzJ4WHM"", vapidPublicKey: ""BB9sMKPoljJIhYYB0ESnCtSwlkDjt5uvCAXoep3DbeoF1LRhhuvH5V6WAkb2XDJZ0PJYX0Y0xDMviyh0LssDe2M=""});```"
520	naekranie.pl.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a remote URL. In this case, the script is loaded from 'https://cdn.sendpulse.com/sp-push-worker-fb.js?ver=2.0', which is a third-party resource. While the URL is hardcoded, the lack of integrity checks (e.g., Subresource Integrity) means that if the CDN is compromised or the script is modified, the service worker could execute malicious code. This constitutes a sensitive function misuse because importScripts() can execute arbitrary code from external sources, and without integrity verification, it introduces a high-risk vulnerability.}	```importScripts('https://cdn.sendpulse.com/sp-push-worker-fb.js?ver=2.0');```
521	planetspark.in.js	External Script Loading Without Integrity Check	High	true	CWE-78	N/A	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to load a script from 'https://widgets.in.webengage.com/js/service-worker.js' without any integrity checks or validation. While the URL is hardcoded, the lack of integrity verification (e.g., using a hash or subresource integrity) means that if the remote script is compromised, the service worker could be hijacked, leading to potential code injection, data exfiltration, or manipulation of cached resources. This constitutes a high-severity vulnerability because it allows an attacker to execute arbitrary code within the service worker context.}	"```""function"" == typeof importScripts && importScripts(""https://widgets.in.webengage.com/js/service-worker.js"")```"
522	soldionline.it.js	Open Redirect in Notification Click Handler	High	true	CWE-601	10	clients.openWindow	standard	{The function self.clients.openWindow() is a standard Service Worker API that opens a new window or tab with the specified URL. When the URL is derived from untrusted input (payload.click_action), which is parsed from the notification data, it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery. The input is not validated or sanitized, making this a direct open redirect vulnerability.}	```self.clients.openWindow(payload.click_action);```
523	f-b.no.js	Cache Poisoning via Unvalidated Message URLs	High	true	N/A	N/A	caches.match	standard	{The caches.match function is used with URLs derived from unvalidated message data (event.data.message). Since the URLs are not sanitized or validated, an attacker could supply malicious URLs that may lead to cache poisoning, where unintended or harmful content is cached and served to users. This misuse allows an attacker to manipulate the service worker’s cache with arbitrary URLs, potentially leading to content injection or redirection.}	```const result = data.map(url => caches.match(url).then(response => { if (response) { return true; } return requestAndCacheUrl(url, cache); })); event.waitUntil(Promise.all(result));```
524	f-b.no.js	Cache Confusion via Vary Header Manipulation	Medium	true	N/A	N/A	Response	standard	{The Response constructor is used to create a new response with headers copied from an existing response, including the Vary header. However, the code modifies the Vary header by filtering out 'user-agent', which may inadvertently alter the intended caching behavior. If an attacker can control the original response headers, they could manipulate the Vary header to cause cache confusion, where different responses are incorrectly cached under the same key, leading to inconsistent or incorrect content delivery.}	"```async function cacheWillUpdate({ response }) { const init = { status: response.status, statusText: response.statusText, headers: {} }; response.headers.forEach((val, key) => { init.headers[key] = val; }); if (init.headers.vary) { init.headers.vary = init.headers.vary.split(',').filter(h => h.trim().toLowerCase() !== 'user-agent').join(','); } self.emergencyMode = (init.headers[""x-emergency-mode""] || """").split("",""); const body = await response.text(); return new Response(body, init); }```"
525	f-b.no.js	Incorrect Host Check in Navigation Route	Low	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from a flawed host check using indexOf with a string literal containing a single quote, which is not a sensitive function misuse. The issue is a logic error in the pattern4 function where the host check is incorrectly written as req.url.host.indexOf(""'www.f-b.no'"") !== -1, which will never match because the literal includes quotes. This is a coding error, not a misuse of a sensitive function.}"	"```function pattern4(req) { return req.event.request.mode === ""navigate"" && req.url.pathname === ""/"" && req.url.host.indexOf(""'www.f-b.no'"") !== -1 && req.event.request.method === ""GET""; }```"
526	aiuweb.org.js	Improper Input Validation Leading to XSS	High	true	N/A	9	N/A	standard	{The `showNotification` method is called with `payload.title` and other payload data directly, without sanitization. Since `payload` is derived from `event.data.json().data.notification`, which is user-controlled via push messages, an attacker can inject malicious script or HTML content into the notification title, leading to XSS when rendered in the browser.}	```self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction });```
527	aiuweb.org.js	Open Redirect Vulnerability	High	true	N/A	9	N/A	standard	{The `clients.openWindow(targetUrl)` function is used with `targetUrl` derived from `event.notification.data.url`, which is user-controlled via push notifications. This allows an attacker to redirect users to arbitrary websites, potentially phishing or leading to malicious content.}	```clients.openWindow(targetUrl);```
528	aiuweb.org.js	Insecure API Endpoint Handling	Medium	true	N/A	8	N/A	standard	{The `fetch` function is used with `options.api_url` and `url` parameters that are derived from user-controlled data (e.g., `url` from message event). While the endpoint is fixed, the inclusion of `url` in the request body may allow for unintended data leakage or manipulation if not properly validated, especially if `url` is not sanitized or validated before being sent.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) }).then(async res => { ... });```"
529	aiuweb.org.js	Exposure of Sensitive Information	Medium	false	N/A	N/A	N/A	N/A	{The `vapid_public_key` is exposed in the code, but it is not used in a function call with dynamic input. It is a static configuration value, so no sensitive function misuse is involved.}	```const options = { firebaseConfig: { ... }, vapid_public_key: 'BIsoSt6A7A6RWmvqZo6TSu4hAmr8ib2IgLQRjrhtcnIQtBGcVOBscZh5QNen-4E1NK8SR42LgiOjvSfGqcebWHo' };```
530	couponpac.com.js	Open Redirect via Unvalidated URL in Notification Click	High	true	N/A	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from the notification data, which is derived from event.notification.data. This data is not validated or sanitized, allowing an attacker to craft a malicious URL (e.g., via a compromised push notification) that redirects users to arbitrary sites, leading to open redirect vulnerabilities.}	```redirectUrl = event.notification.data ? event.notification.data : null; event.waitUntil(clients.openWindow(redirectUrl));```
531	couponpac.com.js	Use of 'no-cors' Mode in Fetch Leading to Data Leakage	Medium	false	N/A	N/A	N/A	N/A	"{The fetch API is used with mode: ""no-cors"", which prevents the browser from sending credentials and limits the response to opaque, but does not inherently involve misuse of a sensitive function. The issue is more about misconfiguration than sensitive function misuse.}"	"```fetch(""https://www.silvergloria.com/showimpression"", { mode: ""no-cors"", body: JSON.stringify(e), method: ""POST"", headers: { 'content-type': 'application/json' } }).then(function (e) { return; });```"
532	couponpac.com.js	Use of 'no-cors' Mode in Fetch Leading to Data Leakage	Medium	false	N/A	N/A	N/A	N/A	"{The fetch API is used with mode: ""no-cors"", which prevents the browser from sending credentials and limits the response to opaque, but does not inherently involve misuse of a sensitive function. The issue is more about misconfiguration than sensitive function misuse.}"	"```fetch(""https://www.silvergloria.com/click-action"", { mode: ""no-cors"", body: JSON.stringify(e), method: ""POST"", headers: { 'content-type': 'application/json' } }).then(function (e) { return; });```"
533	entertainment.ie.js	Insecure Dynamic Code Execution via URL Parameter	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When combined with user-controlled input from location.search (via decodeURIComponent and substring), it allows an attacker to inject and execute arbitrary scripts by manipulating the 'ref=' parameter in the URL. This leads to complete compromise of the service worker's execution context, enabling malicious code execution, cache manipulation, and network interception.}	"```importScripts(decodeURIComponent(location.search.substring(location.search.indexOf(""ref="") + 4)));```"
534	deccoria.pl.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used without integrity checks or with untrusted URLs, it can lead to remote code execution if the script at the URL is compromised or controlled by an attacker. In this case, the script is imported from a third-party domain (js.iplsc.com), which introduces a risk if the domain is not fully trusted or if the script is modified without detection.}	"```importScripts(""https://js.iplsc.com/inpl.service-worker/1.0.72/inpl.service-worker.js"");```"
535	insurancedekho.com.js	Caching of Sensitive Data with Network-Only Strategy	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from using the networkOnly strategy for API endpoints (b2capi.insurancedekho.com and healthapi.insurancedekho.com), which bypasses caching entirely. This is not caused by misuse of a sensitive function but rather by a misconfigured caching strategy that may expose sensitive data to network-level interception or replay attacks.}	```toolbox.router.get(/\\.b2capi\\.insurancedekho\\.com\\//, toolbox.networkOnly)```
536	insurancedekho.com.js	Caching of Sensitive Data with Network-Only Strategy	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from using the networkOnly strategy for API endpoints (b2capi.insurancedekho.com and healthapi.insurancedekho.com), which bypasses caching entirely. This is not caused by misuse of a sensitive function but rather by a misconfigured caching strategy that may expose sensitive data to network-level interception or replay attacks.}	```toolbox.router.get(/\\.healthapi\\.insurancedekho\\.com\\//, toolbox.networkOnly)```
537	insurancedekho.com.js	Potential ReDoS Vulnerability in Regex Pattern	High	true	CWE-400	N/A	RegExp	standard	{The regex pattern /(.*)/ is used in a route handler, which can lead to ReDoS (Regular Expression Denial of Service) when matched against maliciously crafted input. The RegExp function is a standard JavaScript API, and its misuse with unbounded quantifiers like .* in a service worker context can cause excessive CPU consumption during request matching.}	```toolbox.router.get(/(.*)/, function (t, n, r) { return toolbox.networkFirst(t, n, r).catch(...) })```
538	insurancedekho.com.js	Caching of Untrusted Content with Cache-First Strategy	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability stems from applying the cacheFirst strategy to untrusted or dynamic content (e.g., /* and /staticimg.insurancedekho.com/), which may cache responses from untrusted sources or allow stale content to be served. This is a configuration issue, not misuse of a sensitive function.}	```toolbox.router.get(\'/*\', toolbox.cacheFirst, { cache: { name: \'staticimg\', maxEntries: 100, maxAgeSeconds: 86400 } })```
539	insurancedekho.com.js	Caching of Untrusted Content with Cache-First Strategy	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability stems from applying the cacheFirst strategy to untrusted or dynamic content (e.g., /staticimg.insurancedekho.com/), which may cache responses from untrusted sources or allow stale content to be served. This is a configuration issue, not misuse of a sensitive function.}	```toolbox.router.get(/\\staticimg\\.insurancedekho\\.com\\//, toolbox.cacheFirst, { cache: { name: \'assets-id\', maxEntries: 100, maxAgeSeconds: 604800 } })```
540	insurancedekho.com.js	Insecure Cache Expiration Logic	Medium	false	New	N/A	N/A	N/A	{The cache expiration logic in the IDB-based implementation (expireEntries) may not properly enforce maxAgeSeconds or maxEntries due to potential race conditions or incomplete cleanup. This is a logic flaw in the custom implementation, not misuse of a sensitive function.}	```function expireEntries: indexedDB-based cache expiration may not properly enforce maxAgeSeconds/maxEntries```
541	carrosp.com.br.js	Vulnerable Cache Poisoning via Untrusted Resource Injection	High	true	CWE-918	10	N/A	standard	{The fetch() function is used to retrieve a remote JSON file ('/sw-resources.json') without validating its contents. The returned files list is then passed directly to cache.addAll(), which caches all URLs specified in the file. If an attacker can manipulate the contents of sw-resources.json (e.g., via server compromise or DNS hijacking), they can inject arbitrary URLs into the cache, leading to cache poisoning and potential execution of malicious content.}	"```self.addEventListener(""install"", function (event) { console.log(""SW: Instalado e atualizado""); event.waitUntil(caches.open(staticCaches).then(function (cache) { return fetch(""/sw-resources.json"", { mode: ""no-cors"" }).then(function (response) { if (!response.ok) { throw new Error('Falha na rede ao tentar acessar sw-resources.json'); } return response.json(); }).then(function (files) { console.log(""SW: Cacheando recursos...""); return cache.addAll(files); }).catch(function (error) { console.error(""SW: Falha ao buscar sw-resources.json"", error); })); }); self.skipWaiting(); });```"
542	carrosp.com.br.js	Insecure URL Filtering Leading to Cache Bypass	Medium	true	CWE-918	9	N/A	standard	"{The fetch event handler uses event.request.url.indexOf(""carrosp"") == -1 to filter requests, which is a weak and unreliable method for URL validation. This allows URLs that do not contain ""carrosp"" (e.g., malicious subdomains or paths) to bypass the intended filtering logic. The fetch() function is then called without proper validation, potentially allowing unauthorized network requests or cache bypasses.}"	"```self.addEventListener(""fetch"", function (event) { if (event.request.url.startsWith('http')) { event.respondWith(fetch(event.request).then(function (response) { var url = event.request.url; if (404 == response.status || url.indexOf(""carrosp"") == -1) return response; return response; }).catch(function (error) { console.log(""Offline mode.""); return caches.match(event.request).then(function (cacheResponse) { return cacheResponse || new Response('Offline', { status: 503, statusText: 'Offline' }); }); })); } });```"
543	didi-food.com.js	External Script Import Vulnerability	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL, but the vulnerability arises because the URL is not under the control of the developer and could be manipulated if the script source were dynamic or derived from untrusted input. However, in this specific instance, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse with dynamic input. Therefore, the vulnerability is not caused by sensitive function misuse.}	```importScripts('//img0.didiglobal.com/static/soda_static/c/homepage/workbox.4c4f5ca6.js');```
544	kenoshanews.com.js	Outdated Firebase SDK	High	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase SDK, which may contain known security flaws. This is not caused by misuse of a sensitive JavaScript function but by using an insecure library version.}	```importScripts('https://www.gstatic.com/firebasejs/6.6.2/firebase-app.js');```
545	kenoshanews.com.js	Improper Input Validation in URL Handling	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used with oData.url, which is derived from untrusted notification data. Without validation, this can lead to open redirects or other URL-based attacks if the input is malicious.}	```let oURL = new URL(oData.url);```
546	kenoshanews.com.js	Potential XSS via Unsanitized Notification Data	High	true	N/A	N/A	showNotification	standard	{The showNotification function is called with oPayload.title and oNotify data, which are derived from untrusted message payloads. If these values are not sanitized, they can lead to XSS if rendered in a context where user input is interpreted as script.}	```return self.registration.showNotification(oPayload.title, oNotify);```
547	dropstab.com.js	Insecure Cache Deletion Logic	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from logic flaws in cache deletion, not from misuse of a sensitive function. The code deletes caches whose names do not match currentRelease, but this is not inherently unsafe if currentRelease is controlled and trusted. There is no dynamic or untrusted input being used to influence the cache deletion process, so no sensitive function is misused.}	```if (cacheName !== currentRelease) { return caches.delete(cacheName); }```
548	alutech24.com.js	Cache Deletion Logic Error	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic error in cache deletion, not from misuse of a sensitive function. The code attempts to delete caches not in the expected set, but the issue is in the logic flow and handling of Promise.all() rather than improper use of a sensitive API.}	```event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { if (!expectedCacheNamesSet.has(cacheName)) { console.log('Deleting out of date cache:', cacheName); return caches.delete(cacheName); } })); }));```
549	clubalfa.it.js	Insecure External Script Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (pushservice.b-cdn.net). This allows the external service to inject arbitrary code into the service worker, potentially leading to cache manipulation, network request interception, or data exfiltration. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute remote code.}	"```importScripts(""https://pushservice.b-cdn.net/integration/request/105982477/"");```"
550	eskarkock.pl.js	Untrusted Resource Inclusion	High	true	CWE-829	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., pushpushgo.com), it introduces a high-risk vulnerability because the script may be controlled by an attacker, leading to arbitrary code execution within the service worker context. Although the URL is hardcoded, the source is external and untrusted, making this a sensitive function misuse.}	```importScripts('https://s-eu-1.pushpushgo.com/63dba36f730fd6667aa9e067/worker.js');```
551	compragamer.com.js	Open Redirect	High	true	N/A	N/A	cacheBust	custom	{The `cacheBust` method constructs a URL by appending a random query parameter to the input URL. If the input URL is controlled by an attacker (e.g., via a malicious redirect), this can lead to an open redirect vulnerability, allowing attackers to redirect users to arbitrary domains.}	"```return url + (url.indexOf(""?"") === -1 ? ""?"" : ""&"") + ""ngsw-cache-bust="" + Math.random();```"
552	compragamer.com.js	Insecure Cache Busting	Medium	true	N/A	N/A	cacheBust	custom	{The `cacheBust` method appends a random query parameter to URLs to bypass caching. However, if the URL is not properly sanitized or validated, this can lead to unintended cache-busting behavior or even open redirects if the URL is user-controlled.}	"```return url + (url.indexOf(""?"") === -1 ? ""?"" : ""&"") + ""ngsw-cache-bust="" + Math.random();```"
553	compragamer.com.js	Insecure Debug Endpoint	Medium	true	N/A	N/A	handleFetch	custom	{The `handleFetch` method in the `DebugHandler` class responds to requests for `/ngsw/state` with sensitive debug information. If this endpoint is exposed to unauthorized users, it can leak internal state, configuration, and logs, leading to information disclosure.}	```event.respondWith(this.debugger.handleFetch(req));```
554	compragamer.com.js	SSRF Risk	High	true	N/A	N/A	handleFetch	custom	{The `handleFetch` method in the `Driver` class processes incoming fetch events and may forward requests to arbitrary URLs if not properly validated. This can lead to Server-Side Request Forgery (SSRF) if an attacker can manipulate the request URL to target internal resources.}	```event.respondWith(this.handleFetch(event));```
555	compragamer.com.js	Insecure Message Handling	Medium	true	N/A	N/A	onMessage	custom	{The `onMessage` method processes incoming messages from clients without sufficient validation. If the message data is not properly sanitized, it can lead to unintended behavior or even code injection if the message triggers unsafe operations.}	```event.waitUntil((async () => {```
556	mendozapost.com.js	Insecure Data Handling (IndexedDB Key Injection	High	true	CWE-200	9	importScripts	standard	{The importScripts() function is used to load and execute a script from a hardcoded path ('/lib/web-push/notifications.js'). While this specific usage is not directly vulnerable due to static input, the detection of 'Insecure Data Handling (IndexedDB Key Injection)' is not caused by importScripts. Therefore, this vulnerability is not due to sensitive function misuse.}	```var vsm = {}; importScripts('/lib/web-push/notifications.js'); var swconfig = null, clicked = {};```
557	mendozapost.com.js	Unvalidated Redirect or Forward (Notification URL	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow(url) function is called with a URL derived from event.notification.data.url, which is user-controlled. Since no validation or sanitization is performed on the URL, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to phishing or malicious redirects.}	```var url = event.notification.data.url; clicked[event.notification.tag] = 1; event.notification.close(); event.waitUntil(clients.openWindow(url));```
558	mendozapost.com.js	Improper Input Validation (GA Tracking	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from improper handling of the GA payload, but it is not caused by misuse of a sensitive function. The code constructs a payload using data from the notification and subscription, but no sensitive function like eval or Function is used to execute or inject code.}	```const aPayload = { v: 1, t: 'pageview', dl: options.data.url, dt: options.title, cid: subscription.endpoint, tid: trackingId, cs: 'Vincolo CMS', cm: 'Notification show' };```
559	mendozapost.com.js	SSRF Vulnerability (Untrusted URL Fetch	High	true	CWE-829	10	fetch	standard	{The fetch() function is called with a URL constructed from swconfig.notificationurl, which is retrieved from IndexedDB and potentially controlled by an attacker. Since the URL is not validated or restricted to trusted origins, an attacker can manipulate it to perform SSRF attacks, accessing internal resources or services.}	```fetch(swconfig.notificationurl.indexOf('?') == -1 ? swconfig.notificationurl + '?' + Math.random() : swconfig.notificationurl + '?' + Math.random())```
560	mendozapost.com.js	Insecure Data Exposure (Broadcast Message	Medium	false	CWE-200	0	N/A	N/A	{The broadcastReply function sends messages to clients via postMessage, but this is not a sensitive function misuse. The data is not dynamically evaluated or executed, and no function like eval or Function is involved. The risk is more related to data exposure than sensitive function misuse.}	```function broadcastReply(command, payload) { self.clients.matchAll().then(clients => { for (let i = 0; i < clients.length; i++) { const client = clients[i]; client.postMessage({ command, payload }); } }); }```
561	tapmad.com.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it imports a script from a hardcoded external domain (https://s3-eu-west-1.amazonaws.com/static.wizrocket.com/js/sw_webpush.js). While the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing external scripts introduces a security risk because the script's content is not under the control of the service worker's origin. This can lead to supply chain attacks if the external script is compromised or modified. However, since the URL is static and not derived from user input or dynamic sources, the risk is mitigated but still present due to external dependency.}	```importScripts('https://s3-eu-west-1.amazonaws.com/static.wizrocket.com/js/sw_webpush.js');```
562	avizo.cz.js	Insecure External Dependency	High	true	CWE-991	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., 'https://cdn.ampproject.org/sw/amp-sw.js'), it introduces a risk if the external script is compromised or if the CDN is not fully trusted. Although the URL is hardcoded and not dynamically constructed from untrusted input, the dependency on an external script source still constitutes a security risk, as it can lead to supply chain attacks if the external script is tampered with. This is classified as a sensitive function misuse because importScripts() executes code from an external source without verification, and its use should be carefully audited.}	"```importScripts(""https://cdn.ampproject.org/sw/amp-sw.js"");```"
563	ezebra.pl.js	Code Injection via External Script	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to load and execute an external script from a hardcoded URL (https://sherlock.ecdp.cloud/scripts/sw.min.js). While the URL is hardcoded and not dynamically derived from untrusted input, the act of importing and executing arbitrary remote code in a service worker context is inherently risky and can lead to code injection if the remote script is compromised or controlled by an attacker. This is considered a sensitive function misuse because importScripts() executes code without any sandboxing or integrity checks, and the script can potentially modify the service worker’s behavior, intercept network requests, or manipulate the cache.}	"```importScripts(""https://sherlock.ecdp.cloud/scripts/sw.min.js"");```"
564	tikamoon.com.js	Vulnerable Regular Expression for Domain Matching	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a flawed regular expression used to validate domain names in the fetch event handler. The regex `^https:\/\/[a-zA-Z-0-9]+\.?(tikamoon|tika)(\.[a-zA-Z]+)?` is overly permissive and may allow unintended domains (e.g., subdomains or domains with unexpected characters) to pass validation. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts`, `eval`, or `fetch` with untrusted input. Instead, it is a logic or validation flaw in the regex pattern itself.}	```self.addEventListener('fetch', function (event) { if (!event.request.url.match(/^https:\/\/[a-zA-Z-0-9]+\.?(tikamoon|tika)(\.[a-zA-Z]+)?/)) { return; } if (event.request.method.toLowerCase() !== 'get') { return; } event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } return fetch(event.request).then(function (response) { return response; }).catch(function (e) { return caches.match('/offline'); }); })); });```
565	sedayebourse.ir.js	External Script Loading Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with hardcoded URLs, it can still pose a risk if the external script is compromised or if the URL is dynamically controlled by an attacker. In this case, although the URL is hardcoded, the lack of integrity verification (e.g., using a Subresource Integrity hash) means that if the remote script is tampered with, the service worker will execute the malicious code. This constitutes a misuse of a sensitive function because importScripts() can execute arbitrary code from external sources, and without integrity checks, it becomes a vector for code injection.}	```importScripts('https://van.najva.com/static/js/scripts/sedayebourse-website-27884-c7ef49f6-5fcf-47dd-9cb8-ef14c7d4af5b-service-worker.js');```
566	farmaonline.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to 'https://static.fanplayr.com/client/sw.js', which is a trusted external resource. However, the vulnerability classification suggests that the script is being imported from an untrusted source, which would be a misuse. Since the URL is hardcoded and not derived from user input or dynamic sources, this is not a sensitive function misuse. Therefore, the vulnerability is not caused by sensitive function misuse.}	```importScripts('https://static.fanplayr.com/client/sw.js');```
567	rousingthekop.com.js	Spoofable Accept Header in Fetch Handler	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of the Accept header in the fetch event, but it is not caused by misuse of a sensitive JavaScript function. The issue stems from logic that allows responses based on Accept header values without validating or sanitizing them, which could lead to unintended resource delivery. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	"```self.addEventListener(""fetch"", function (t) { var e = t.request; ""only-if-cached"" === t.request.cache && ""same-origin"" !== t.request.mode || (e.headers.get(""Accept"").includes(""text/html"") && t.respondWith(fetch(e).then(function (e) { return e; }).catch(function (e) { return caches.match(""/offline/""); })), (e.headers.get(""Accept"").includes(""text/css"") || e.headers.get(""Accept"").includes(""text/javascript"")) && t.respondWith(async function () { var e = await caches.match(t.request); return e || (await t.preloadResponse) || fetch(t.request); }())); });```"
568	noticiasargentinas.com.js	XSS via Untrusted JSON Parsing in Notification Actions	High	true	CWE-502	10	JSON.parse	standard	{The JSON.parse function is used on untrusted input (a.data.actions) without sanitization, allowing an attacker to inject malicious JavaScript code via the notification payload, leading to XSS when the parsed actions are rendered or executed.}	```(a.data.actions && { actions: JSON.parse(a.data.actions) })```
569	noticiasargentinas.com.js	Open Redirect via Unvalidated Notification Action URL	Medium	true	CWE-601	9	self.clients.openWindow	standard	{The self.clients.openWindow function is called with user-controlled input (t.action) without validation, allowing an attacker to redirect users to arbitrary URLs, potentially phishing or leading to malicious sites.}	```self.clients.openWindow(t.action)```
570	cinemabartar.ir.js	Exposure of Sensitive Information (Firebase Credentials)	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoding Firebase credentials in the script, which are sensitive and should not be exposed in client-side code. This is not a misuse of a sensitive function but rather a misconfiguration or exposure of secrets.}	"```firebase.initializeApp({ apiKey: ""AIzaSyBfW9gmgLk1trtNzPO1q7YMgH2OSXYx9Ns"", authDomain: ""sanjagh-ccf74.firebaseapp.com"", databaseURL: ""https://sanjagh-ccf74.firebaseio.com"", projectId: ""sanjagh-ccf74"", storageBucket: ""sanjagh-ccf74.appspot.com"", messagingSenderId: ""292081803462"", appId: ""1:292081803462:web:23adab1f6139ef9d"" });```"
571	cinemabartar.ir.js	Insecure URL Handling in Notification Click Handler	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used with t.data.url, which is derived from user-controlled notification data. If the URL is not validated or sanitized, an attacker could craft a malicious notification to redirect users to phishing sites or perform other malicious actions.}	```e.waitUntil(self.clients.openWindow(t.data.url));```
572	cinemabartar.ir.js	Unvalidated Fetch Request in Background Message Handler	Medium	true	CWE-807	N/A	fetch	standard	{The fetch function is called with e, which is derived from the message data (t.impression). If this value is not validated or sanitized, it allows an attacker to trigger arbitrary HTTP requests to any domain, potentially leading to data exfiltration or abuse of the service worker’s network capabilities.}	```fetch(e).then();```
573	tekniikanmaailma.fi.js	Improper URL Validation Leading to SSRF Risk	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper URL validation in the checkUrl function, which uses string-based indexOf checks for specific domains. This approach is insufficient because it does not validate the full URL structure or enforce proper scheme/host parsing, potentially allowing attackers to craft URLs that bypass validation (e.g., via URL encoding, subdomains, or path traversal). However, no sensitive JavaScript function (like importScripts, eval, or dynamic code execution) is misused here; the issue is purely a logic flaw in validation.}	```function checkUrl(e) { return -1 !== e.indexOf('https://wp.tekniikanmaailma.asteaws.dev') || -1 !== e.indexOf('https://cdn.tekniikanmaailma.fi') || -1 !== e.indexOf('https://wp.tekniikanmaailma.fi'); }```
574	prva.rs.js	Exposure of Sensitive Information (Firebase API Key)	High	false	N/A	N/A	N/A	N/A	{The Firebase API key is hardcoded in the script and exposed in the service worker, which can be accessed by anyone inspecting the site. While not directly caused by a sensitive function misuse, it is a critical security flaw.}	"```const firebaseConfig = { apiKey: ""AIzaSyAR5LJSwGWXOP9oEVDMk-vkcj40SydqraE"", authDomain: ""prva-rs-push.firebaseapp.com"", projectId: ""prva-rs-push"", storageBucket: ""prva-rs-push.appspot.com"", messagingSenderId: ""846651474743"", appId: ""1:846651474743:web:2c8e921576b42851fb50b2"" };```"
575	prva.rs.js	Improper Input Validation (Untrusted URL in Notification)	High	true	N/A	N/A	notificationOptions	standard	{The notificationOptions object includes a URL from payload.data.url without validation or sanitization. This allows an attacker to inject arbitrary URLs, potentially leading to phishing or redirect attacks.}	```var notificationOptions = { body: payload.data.body, icon: payload.data.icon, image: payload.data.image, data: { url: payload.data.url } };```
576	prva.rs.js	Open Redirect (Untrusted URL Handling)	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with data.url, which is derived from untrusted payload data. This allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```if (clients.openWindow) return clients.openWindow(data.url);```
577	mtstandard.com.js	Open Redirect	Medium	true	CWE-601	10	clients.openWindow	standard	{The function self.clients.openWindow() is used to open a new window or tab with a URL constructed from user-controlled data (oData.url). Since oData.url is derived from a Firebase message payload, which can be manipulated by an attacker, this allows for an open redirect vulnerability. An attacker can craft a message payload with a malicious URL, causing the browser to redirect users to arbitrary sites, potentially leading to phishing or further exploitation.}	```self.clients.openWindow(oURL.toString());```
578	laverita.info.js	Improper Caching of Sensitive Resources	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching media library resources without proper access controls or authentication checks, but it is not due to misuse of a sensitive JavaScript function. The caching strategy itself is misconfigured, not the result of dynamic or untrusted input being passed to a sensitive function.}	```routing.registerRoute(/\/media-library\//, new CacheFirst({ cacheName: 'assetsPictures', plugins: [new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 7 * 24 * 60 * 60 })] }));```
579	laverita.info.js	Unauthenticated Cache Access	High	false	N/A	N/A	N/A	N/A	{The issue stems from allowing unauthenticated access to cached resources for the main page, which is a policy or configuration flaw rather than misuse of a sensitive JavaScript function. The routing and caching logic is static and does not involve dynamic or untrusted input.}	```routing.registerRoute(/^https:\/\/(www\.)?laverita\.info\/*/, new NetworkFirst({ cacheName: 'mainPage', plugins: [new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 6 * 60 * 60 })] }));```
580	laverita.info.js	Insecure Cache Strategy for User-Specific Content	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to using a CacheFirst strategy for user-specific JavaScript files without ensuring that the content is not cached across users or sessions. This is a design or configuration issue, not caused by misuse of a sensitive function with dynamic input.}	```routing.registerRoute(/^https:\/\/(www\.)?laverita\.info\/static\/dist\/social-ux\/(?:[a-z.0-9]*)\.(?:mjs|js)$/, new CacheFirst({ cacheName: 'jsApp', plugins: [new ExpirationPlugin({ maxEntries: 120, maxAgeSeconds: 3 * 24 * 60 * 60 })] }));```
581	pekao24.pl.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	importScripts	standard	{The code does not use importScripts() at all, so this vulnerability is not caused by misuse of a sensitive function. The SSRF arises from the use of `scope.fetch(req)` with untrusted URLs, but no sensitive function like importScripts() is involved.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) {```
582	pekao24.pl.js	Cross-Site Scripting (XSS) in Notifications	High	true	N/A	N/A	Notification	standard	{The Notification API is used with user-controlled data from `notification` without sanitization. The code copies all notification properties directly into the options object, which can lead to XSS if an attacker controls the notification content, especially if the notification includes malicious script or HTML in fields like `body` or `title`.}	```let options = {}; NOTIFICATION_OPTION_NAMES.filter(name => name in notification).forEach(name => options[name] = notification[name]);```
583	pekao24.pl.js	Cache Poisoning	Medium	true	N/A	N/A	caches.put	standard	{The `caches.put()` function is used to store responses in the cache without validating the content or origin. If an attacker can manipulate the request or response (e.g., via a crafted request or a compromised server), they can poison the cache with malicious content, which may be served to other users.}	```await this.cacheResponse(req, res, lru, okToCacheOpaque);```
584	pekao24.pl.js	Information Exposure Through Debug Logs	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from logging sensitive error information without sanitization, but no sensitive JavaScript function is misused. The `debugger.log()` function is custom and used appropriately; the issue is in the data being logged, not the function itself.}	```this.debugger.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);```
585	pekao24.pl.js	Insufficient Input Validation in URL Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from insufficient validation of URLs passed to `parseUrl`, but the `parseUrl` function is custom and not inherently sensitive. The issue is in the logic of URL handling, not misuse of a sensitive function.}	```const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);```
586	pekao24.pl.js	Weak Cryptographic Hash Algorithm (SHA)	Low	false	N/A	N/A	N/A	N/A	{The use of SHA-1 is a cryptographic weakness, but it is not due to misuse of a sensitive JavaScript function. The `sha1` function is custom and used for hashing, but the vulnerability is in the choice of algorithm, not in how it is called.}	```return sha1(JSON.stringify(manifest));```
587	novelbuddy.com.js	Improper Handling of Asynchronous Cache Deletion	Medium	false	New	N/A	N/A	N/A	{The issue lies in the improper handling of asynchronous operations during cache deletion, not in the misuse of a sensitive function. The code uses `caches.delete()` correctly, but the `forEach` loop does not await or handle the promises returned by `caches.delete()`, which may lead to race conditions or incomplete cache cleanup. However, this is not a sensitive function misuse, as `caches.delete()` is not inherently dangerous when used with trusted inputs, and no untrusted or dynamic input is being passed to it.}	```keyList.forEach(function (key) { if (key !== cacheName) caches.delete(key); });```
588	farmatodo.com.ve.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with hardcoded URLs, it can still pose a risk if the external script source is compromised. In this case, the script is loaded from 'https://js.appboycdn.com/web-sdk/2.7/service-worker.js', which is a third-party domain. If the third-party server is compromised or the script is modified, the service worker could execute malicious code, leading to potential data exfiltration, cache manipulation, or request interception. Although the URL is hardcoded, the lack of integrity verification (e.g., Subresource Integrity) makes it vulnerable to supply chain attacks.}	```self.importScripts('https://js.appboycdn.com/web-sdk/2.7/service-worker.js');```
589	entreparticuliers.com.js	External Script Loading from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted CDN (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability because the script being loaded is not under the control of the site owner. An attacker could compromise the CDN or inject malicious code into the script, leading to unauthorized access, data exfiltration, or further exploitation of the service worker’s capabilities.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/66c2e8d71fde7300082815c8/service-worker.js"");```"
590	medplusmart.com.js	Improper URL Validation in Service Worker Logic	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper URL filtering logic in the fetch event handler, which uses string-based indexOf checks for URL patterns. This approach is not inherently caused by misuse of a sensitive JavaScript function like importScripts, eval, or dynamic code execution. Instead, it stems from flawed logic that may allow unintended requests to be cached or bypassed, but does not involve direct execution of untrusted code or dynamic script loading.}	```self.addEventListener('fetch', function (event) { if (event.request.url.indexOf(\'.mbl\') > 0 || event.request.url.indexOf(\'mobile.medplusindia.com\') > 0 || event.request.url.indexOf(\'doctors-api\') > 0 || event.request.url.indexOf(\'upload?token\') >= 0 || event.request.url.indexOf(\'asset-manifest.json\') >= 0 || event.request.url.indexOf(\'service-worker.js\') >= 0 || event.request.url.indexOf(\'service%2dworker%2ejs\') >= 0) { return false; } event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); }).catch(function () { return caches.match('/offline.html'); })); });```
591	auburnpub.com.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	new URL	standard	{The function new URL is used to construct a URL object from oData.url, which originates from untrusted notification payload data. Since the URL is later passed to self.clients.openWindow(), an attacker can manipulate the notification payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```let oURL = new URL(oData.url); if (oData.utm_source && oData.utm_medium && oData.utm_campaign) { oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign); }```
592	cpalead.com.js	Improper Request Validation Leading to SSRF or Cache Poisoning	Medium	true	CWE-918	9	fetch	standard	{The fetch() function is used without validating or sanitizing the incoming request URL, which may allow an attacker to craft a request to internal or external resources (SSRF) or manipulate cache behavior by triggering unintended cache matches. Since the service worker processes any incoming fetch event directly, it can be exploited to access restricted endpoints or poison the cache with malicious responses.}	```self.addEventListener('fetch', event => { event.respondWith(fetch(event.request).catch(() => caches.match(event.request)).then(response => response || caches.match('/offline.html'))); });```
593	khabarban.com.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and does not include an integrity check (e.g., via a Subresource Integrity hash). While the URL is not dynamically constructed from untrusted input, the lack of integrity verification means the script could be tampered with in transit or replaced by an attacker if the server is compromised, leading to unauthorized code execution in the service worker context. This constitutes a high-severity vulnerability because service workers have broad control over network requests, caching, and client-side behavior.}	```importScripts('https://van.najva.com/static/js/scripts/khabarban-website-10351-7f086ac9-5f6e-42b7-9582-bb1fe1ce7aa0-service-worker.js');```
594	x-plane.org.js	CSRF Token Handling Vulnerability	High	true	N/A	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the path parameter from the request. While the path is derived from the current request, it is not sanitized or validated, and if an attacker can manipulate the request path, they could potentially trigger unintended API calls or CSRF token retrieval for malicious endpoints. However, the context here is limited to fetching a CSRF token for a specific path, and the token is then used in a subsequent request with controlled headers. The vulnerability is more about improper CSRF handling than direct sensitive function misuse, but the use of fetch with dynamic URLs still introduces risk.}	N/A
595	x-plane.org.js	Open Redirect in Notification Click	Medium	true	N/A	9	clients[0].navigate	standard	{The navigate method is called with a URL derived from the notification data, which is obtained from a push message. Since the push message data is not validated or sanitized, an attacker could craft a push message with a malicious URL, causing the browser to navigate to an arbitrary site when the user clicks the notification. This constitutes an open redirect vulnerability.}	N/A
596	x-plane.org.js	XSS in Notification Content	Low	true	N/A	8	self.registration.showNotification	standard	{The showNotification method is used with notification content (body and icon) that is directly derived from server responses without sanitization. If an attacker can inject malicious content into the notification data (e.g., via a compromised server or API), the notification could display unsafe content, potentially leading to phishing or social engineering attacks. While not traditional XSS (as notifications are not rendered in the DOM), it still represents a content injection risk.}	N/A
597	clipsbai.net.js	Hardcoded Sensitive Information (API Key	High	true	CWE-798	N/A	firebase.initializeApp	standard	{The firebase.initializeApp function is used with a hardcoded API key, which is a sensitive credential. While the function itself is not inherently unsafe, its misuse by hardcoding sensitive data directly into the script exposes the key to attackers who can inspect the service worker code, leading to potential abuse such as unauthorized access to Firebase services.}	```firebase.initializeApp({ ...options.firebaseConfig });```
598	clipsbai.net.js	Insecure Data Storage (IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from storing sensitive data in IndexedDB without proper encryption or access controls, but it is not caused by misuse of a sensitive JavaScript function. The put operation is standard and safe when used correctly; the issue lies in the data handling policy, not the function misuse.}	```const request = objectStore.put({ id: key, data: value });```
599	clipsbai.net.js	Open Redirect via Unvalidated URL	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from event.notification.data.url, which is user-controlled. Since the URL is not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to open redirect attacks.}	```clients.openWindow(targetUrl);```
600	clipsbai.net.js	SSRF via Untrusted URL	Medium	true	CWE-918	N/A	fetch	standard	{The fetch function is used with a URL derived from the event.notification.data.url parameter, which is user-controlled. Since the URL is not validated or sanitized, an attacker can supply an internal or malicious endpoint, causing the service worker to make unintended requests, potentially leading to SSRF.}	```fetch(apiUrl);```
601	clipsbai.net.js	Insecure Firebase API Key Exposure	High	true	CWE-798	N/A	firebase.initializeApp	standard	{The firebase.initializeApp function is used with a hardcoded API key, which is a sensitive credential. This misuse exposes the key in the service worker script, allowing attackers to access Firebase services directly, leading to potential data breaches or service abuse.}	```firebase.initializeApp({ ...options.firebaseConfig });```
602	pgr21.com.js	Open Redirect and SSRF via Untrusted URL Handling	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from event.notification.data.url, which is untrusted input. The URL is built by concatenating the hostname extracted from the untrusted input with a hardcoded path and query parameter. This allows an attacker to control the target URL, leading to Open Redirect (if the URL points to an external site) or SSRF (if the URL points to internal resources). Since fetch is a standard JavaScript API and is directly invoked with untrusted data, this constitutes a sensitive function misuse.}	```var url = extractHostname(event.notification.data.url) + '/pb/member_notice_ajax.php?id=' + event.notification.data.id; fetch(url, { method: 'GET', credentials: 'same-origin' }).catch(function (error) { console.log('Request failed', error); });```
603	namavid.com.js	External Script Loading Without Validation	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it loads a script from a hardcoded external URL ('https://van.najva.com/...'). While the URL is not dynamically constructed from untrusted input, the lack of validation or integrity checks (e.g., no content security policy enforcement, no signature verification) means that if the external server is compromised or the script is tampered with, the service worker could execute malicious code. This constitutes a high-risk vulnerability because the script is loaded without any security safeguards, making it susceptible to supply chain attacks.}	```importScripts('https://van.najva.com/static/js/scripts/new-website399-website-44257-0cc85011-2b05-4754-8861-6184b7f41c8f-service-worker.js');```
604	reelshort.com.js	Improper Caching of Sensitive API Responses	High	false	New	N/A	N/A	N/A	{The vulnerability arises from the caching strategy applied to API endpoints (excluding /api/auth/), which are cached using a NetworkFirst strategy with a long TTL (86400 seconds). This can lead to sensitive API responses being cached and potentially exposed to unauthorized users if the cache is not properly invalidated or if the API responses contain user-specific or sensitive data. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() or eval(), but rather by misconfigured caching policies.}	```e.registerRoute(({\n url: e\n }) => {\n if (!(self.origin === e.origin)) return !1;\n const c = e.pathname;\n return !c.startsWith(\'/api/auth/\') && !!c.startsWith(\'/api/\');\n }, new e.NetworkFirst({\n cacheName: \'apis\',\n networkTimeoutSeconds: 10,\n plugins: [new e.ExpirationPlugin({\n maxEntries: 16,\n maxAgeSeconds: 86400\n })]\n }), \'GET\');```
605	reelshort.com.js	Cross-Origin Resource Caching with NetworkFirst Strategy	Medium	false	New	N/A	N/A	N/A	{This vulnerability stems from caching cross-origin resources using a NetworkFirst strategy with a relatively short TTL (3600 seconds). While this is not inherently dangerous, it may lead to stale or potentially sensitive data being served from the cache if the cross-origin resources are not properly secured or if the cache is accessed by unauthorized parties. Again, this is a policy misconfiguration rather than misuse of a sensitive JavaScript function.}	```e.registerRoute(({\n url: e\n }) => !(self.origin === e.origin), new e.NetworkFirst({\n cacheName: \'cross-origin\',\n networkTimeoutSeconds: 10,\n plugins: [new e.ExpirationPlugin({\n maxEntries: 32,\n maxAgeSeconds: 3600\n })]\n }), \'GET\');```
606	kunduz.com.js	Denial of Service via Forced Page Reloads	High	true	N/A	9	navigate	standard	{The function `windowClient.navigate()` is a standard browser API used to reload a client window. When called in a loop over all window clients, it forces every client to reload, which can lead to excessive resource consumption and denial of service if triggered repeatedly or on a large number of clients. This misuse is particularly dangerous in a service worker context where such actions can be triggered by network events or other external inputs.}	"```self.clients.matchAll({type: ""window""}).then(windowClients => {windowClients.forEach(windowClient => {windowClient.navigate(windowClient.url);});});```"
607	khabarpu.com.js	Loading external script without integrity check	High	true	CWE-434	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious code from an external source. In this case, the script is loaded from a hardcoded URL, but the lack of integrity verification (e.g., via Subresource Integrity) means that if the remote script is compromised, the service worker can be hijacked, leading to cache manipulation, data exfiltration, or further attacks.}	```importScripts('https://van.najva.com/static/js/scripts/khabarpu-1037-480d7c19-0b05-437d-98a9-8b0aaf7301a7-service-worker.js');```
608	extramarks.com.js	Hardcoded Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (API key, user key, site ID) in client-side JavaScript, not due to misuse of a sensitive function.}	```var config = { apiKey: 'AIzaSyAFYgdeFIWy6k65mrQHono3V8Pn8z4YpA4', messagingSenderId: '749170047253', appId: '1:749170047253:web:663e15465326092450911c', projectId: 'sabtestx', user_key: 'ADGMOT35CHFLVDHBJNIG50K96994TLVR74PKOPB7A9QP0FHEN5M0', siteid: '1896a2f916c4bd58a6a788295391e6d4' }; importScripts('https://cdnt.netcoresmartech.com/swv4.js');```
609	adsafrica.co.za.js	Cache Poisoning Risk	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function but rather by the design of the fetch handler which serves cached responses without validating or sanitizing the request. While caches.match() is used, it is not misused with untrusted input; the risk stems from the caching strategy itself, not from a sensitive function call.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); })); });```
610	justgoodapp.com.js	Loading untrusted third-party script in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an untrusted third-party domain (e.g., pushpushgo.com), it introduces a high-risk vulnerability because the script may be controlled by an external party, potentially leading to code injection, data exfiltration, or manipulation of the service worker’s behavior. Although the URL is hardcoded, the source is untrusted and not under the developer’s control, making it a sensitive misuse.}	```importScripts('https://s-eu-1.pushpushgo.com/642d2fa56b5e41576e80df38/worker.js');```
611	islamonline.net.js	Insecure Cache Name (HTTP instead of HTTPS	Medium	false	N/A	N/A	N/A	N/A	{The cache name uses HTTP instead of HTTPS, which may lead to insecure caching behavior, but this is not caused by misuse of a sensitive JavaScript function. It is a configuration issue.}	```const cacheName = 'http://islamonline.net-superpwa-2.2.31';```
612	pureitwater.com.js	Insecure External Resource Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is used to load and execute an external script from a hardcoded URL (https://cdn.moengage.com/webpush/releases/serviceworker_cdn.min.latest.js). While the URL is hardcoded and not dynamically derived from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. If the remote script is compromised or if the domain is hijacked, the service worker can be subverted, leading to full control over the service worker’s behavior, including cache manipulation, network interception, and potential data exfiltration. This constitutes a high-risk vulnerability due to the trust placed in the external script.}	"```importScripts(""https://cdn.moengage.com/webpush/releases/serviceworker_cdn.min.latest.js"")```"
613	pureitwater.com.js	Insecure Fetch with No-CORS Mode	Medium	true	N/A	8	fetch	standard	{The fetch() function is used with the mode: 'no-cors' option, which bypasses CORS restrictions and allows the service worker to make requests to any origin without checking for cross-origin permissions. This is dangerous because it enables the service worker to fetch resources from arbitrary domains, potentially including malicious or unintended sources. If the service worker is compromised or if the request is triggered by user input (even indirectly), it could lead to unauthorized data access, exfiltration, or injection of malicious content. Although the specific usage here is within a helper function for image caching, the 'no-cors' mode inherently reduces security by disabling a critical browser protection mechanism.}	"```return fetch(e, {mode: ""no-cors""}).then(function (t) {return caches.open(""images"").then(function (r) {return r.put(e, t.clone());}).then(function () {return t;});});```"
614	milfat.com.js	Insecure Cache Management	High	true	CWE-921	10	N/A	standard	{The vulnerability arises from the use of fetch() to retrieve a cache configuration from a remote URL (CACHE_ROUTE), which is then parsed as JSON and used to populate the cache via cache.addAll(). If an attacker can manipulate the content of CACHE_ROUTE (e.g., via server compromise or DNS spoofing), they can inject arbitrary URLs into the cache, leading to cache poisoning or execution of malicious scripts. The fetch() function is sensitive because it executes network requests with potentially untrusted URLs.}	```fetch(CACHE_ROUTE).then(function (response) { return response.json(); }).then(function (response) { var key = response.key || null; var files = response.files || []; files.push(OFFLINE_ROUTE); return cache.addAll(files).then(function () { return key; }); })```
615	milfat.com.js	Insecure URL Handling in Push Notifications	Medium	true	CWE-601	9	N/A	standard	{The clients.openWindow() function is called with a URL derived from notification.data.url, which is obtained from a push notification payload. Since push notification data can be controlled by an attacker (if the server is compromised or if the notification is spoofed), this allows arbitrary URL redirection. The clients.openWindow() function is sensitive because it opens a new browser window or tab with a user-supplied URL, potentially leading to phishing or drive-by downloads.}	```if (notification.data.url) { event.waitUntil(clients.openWindow(notification.data.url)); }```
616	biddr.com.js	Improper Handling of Service Worker Activation Self.Skipwaiting() Can Lead To Race Conditions Or Inconsistent States Between Old And New Service Worker Versions which may cause unexpected behavior or resource conflicts	N/A	false	N/A	N/A	N/A	N/A	{The use of self.skipWaiting() is not inherently a sensitive function misuse. It is a standard Service Worker API used to immediately activate the new service worker, bypassing the waiting phase. While improper use can lead to race conditions or inconsistent states, this is not due to handling untrusted input or dynamic data in a dangerous way, but rather a design or timing issue. Therefore, it does not qualify as a sensitive function misuse.}	```self.skipWaiting();```
617	rockol.it.js	Insecure Firebase Configuration Loading	High	true	CWE-200	10	importScripts	standard	{The importScripts function is a standard Web API used in Service Workers to load and execute external scripts. When used with a dynamic or untrusted URL, such as 'firebase-configuration.js.php', it can lead to insecure configuration loading. If the URL is controlled or influenced by an attacker (e.g., via server-side manipulation or misconfiguration), it may result in loading malicious or unintended scripts, leading to potential data leakage, unauthorized access, or code injection. The use of a PHP file extension suggests server-side processing, which may expose sensitive configuration data if not properly secured.}	```importScripts('firebase-configuration.js.php');```
618	springfarma.com.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL like 'https://t.themarketer.com/firebase.js', it introduces a high-risk vulnerability if the script source is untrusted or controlled by an attacker. Although the URL is hardcoded here, the vulnerability is still considered sensitive because importScripts() executes arbitrary code from remote sources, potentially leading to code injection, data exfiltration, or full compromise of the service worker's execution context.}	```importScripts('https://t.themarketer.com/firebase.js');```
619	anilibria.best.js	Open Redirect Vulnerability	High	true	CWE-602	10	getRedirectUrl	standard	{The function getRedirectUrl is used to construct a redirect URL by appending query parameters to a base URL. The base URL is derived from settings.redirect_url, which is populated from untrusted external data via fetch(SETTINGS_URL). Since this value is not validated or sanitized, an attacker can control the redirect destination, leading to an open redirect vulnerability. The sensitive function getRedirectUrl, being a standard JavaScript utility (though custom-implemented here), is misused by accepting untrusted input as a base URL, enabling redirection to arbitrary domains.}	```settings.redirect_url = data['redirect_to'] ? data['redirect_to'] : false;```
620	kvsadmission.co.in.js	Hardcoded Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (Firebase API key, project ID, messaging sender ID, app ID, and VAPID public key) directly in the client-side JavaScript code. These values are not dynamically retrieved or protected, making them easily accessible to attackers who inspect the source code. This exposure allows unauthorized access to Firebase services, potential abuse of push notifications, and possible compromise of the application’s backend systems. No sensitive JavaScript function misuse is involved; the issue stems purely from hardcoded secrets.}	```const options = { firebaseConfig: { projectId: 'lara-push-f0a9c', messagingSenderId: '500639949154', appId: '1:500639949154:web:fa4ddbe809d7a7faf98c3b', apiKey: 'AIzaSyCwjv2aPP6KFr-JRygu_3NkuYZWC7TiIh8' }, domain: 'kvsadmission.co.in', api_url: 'https://push.onetimeregistration.co.in/api/token', vapid_public_key: 'BOq-rsQgsyz3fJCWZPOHE6Dp7EyRn1eKb1K5gcosD13_vSrIGdJzkQ1o9j7mWc_Y3nK2g1ExbyBBSX9aZ8cSyXU' };```
621	esewa.com.np.js	Improper Cache Destination Check	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from an improper condition in the route registration: `event.request.destination === ''` is logically incorrect and likely unintended. This condition will never match any actual request, as `destination` is a string property that should be compared to valid values like 'document', 'script', 'style', etc. However, this is not a misuse of a sensitive function but rather a logical error in the route matching logic. No sensitive function is being misused here.}	```workbox.routing.registerRoute(({\n event\n}) => event.request.destination === '', new workbox.strategies.NetworkFirst({\n cacheName: XHR_CACHE,\n plugins: [new workbox.expiration.ExpirationPlugin({\n maxEntries: 1000\n })]\n}));```
622	amarstock.com.js	Incorrect URL Filtering Logic in Cache Ignore List	High	false	New	N/A	N/A	N/A	{The vulnerability arises from flawed logic in the condition that checks whether a URL should be ignored for caching. The condition `!(evt.request.url.indexOf('http') === 0)` is incorrect because `indexOf('http') === 0` checks if the URL starts with 'http', but the negation is applied incorrectly. This logic error does not stem from misuse of a sensitive function but from a logical mistake in the URL filtering condition.}	```if (evt.request.method !== 'GET' || !(evt.request.url.indexOf('http') === 0) || CACHE_IGNORE.some(urlIncluded(evt.request.url))) {```
623	amarstock.com.js	Insecure Caching of Network Responses Without Validation	High	false	CWE-113	N/A	N/A	N/A	{The vulnerability stems from caching network responses without validating their content or origin. While `caches.put()` is used, the issue is not due to misuse of a sensitive function but rather a lack of proper validation of the response before caching. The function `caches.put()` is used correctly, but the policy around what to cache is flawed.}	```if (200 == response.status) { var cacheCopy = response.clone(); caches.open(CURRENT_CACHE).then(cache => cache.put(request, cacheCopy));```
624	amarstock.com.js	Improper Regular Expression for URL Filtering	Medium	false	CWE-20	N/A	N/A	N/A	"{The vulnerability is due to the use of improperly constructed regular expressions in the `CACHE_IGNORE` array, such as `"".*localhost.*""` which may not match URLs as intended. However, this is not caused by misuse of a sensitive function like `RegExp` or `test()`, but rather by incorrect regex patterns. The `RegExp` constructor is used correctly, but the patterns themselves are flawed.}"	"```var CACHE_IGNORE = ["".*localhost.*"", "".*facebook.*"", "".*.addthis.com.*"", "".*www.google.*"", "".*moatads.com.*"", "".*\.(pdf|docx|doc)"", '/Account/*'].map(function (r) { return new RegExp(r); });```"
625	goniec.pl.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is imported from a third-party domain (pushpushgo.com), which could be compromised or malicious, leading to code injection and potential control over the service worker's behavior.}	```importScripts('https://s-eu-1.pushpushgo.com/641c3dd2e86e762ac5e3c1bd/worker.js');```
626	bursatransport.com.js	Incorrect Regular Expression Leading to Cache Poisoning	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from an improperly constructed regular expression in the workbox.routing.registerRoute call, specifically `new RegExp('/themes/responsive/img/.*\.[png|gif|jpg|jpeg|svg]')`. The regex pattern does not properly escape or handle the dot (`.`) and the pipe (`|`) characters, which may lead to unintended matches (e.g., matching `.png|gif` as a literal string instead of separate file extensions). This could allow an attacker to craft a request that bypasses intended caching rules, potentially leading to cache poisoning. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts` or `eval`, but rather by a logic error in regex construction.}	```workbox.routing.registerRoute(new RegExp('/themes/responsive/img/.*\.[png|gif|jpg|jpeg|svg]'), workbox.strategies.cacheFirst({ cacheName: cacheName + '-img', plugins: [new workbox.expiration.Plugin({ maxEntries: 60, maxAgeSeconds: 30 * 24 * 60 * 60 })] }));```
627	cityrumors.it.js	Insecure Direct Object Reference (IDOR) in URL construction	High	true	CWE-548	9	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (body.data.sensor and event.notification.data.sensor). Since these values are not validated or sanitized, an attacker can manipulate them to redirect the fetch request to arbitrary endpoints, potentially leading to unauthorized access or data leakage.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.cityrumors.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
628	cityrumors.it.js	Insecure Direct Object Reference (IDOR) in URL construction	High	true	CWE-548	9	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (event.notification.data.sensor). Since this value is not validated or sanitized, an attacker can manipulate it to redirect the fetch request to arbitrary endpoints, potentially leading to unauthorized access or data leakage.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.cityrumors.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```
629	defenseromania.ro.js	Hardcoded API Key	High	false	CWE-798	N/A	N/A	N/A	{The hardcoded API key is a security issue but not caused by misuse of a sensitive function; it is a static credential exposure.}	"```fetch(""https://apism.speedmeta.com/get_notification_V2/?key=PG21OGMO51JP17P3DHVU"")```"
630	defenseromania.ro.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The validation logic is flawed but does not stem from misuse of a sensitive function; it is a logic error in data handling.}	```return response.json().then(function (data) { if (data.error || !data.notification) { throw new Error(); }```
631	defenseromania.ro.js	Open Redirect	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic URL derived from untrusted data (ev.notification.data.notification.link), allowing an attacker to redirect users to arbitrary sites, leading to open redirect vulnerability.}	```return clients.openWindow(ev.notification.data.notification.link);```
632	cba24n.com.ar.js	Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with msg.data.title and msg.data.actions, which are derived from untrusted push message data. If an attacker controls these fields, they can inject malicious content into the notification, potentially leading to XSS if the notification UI renders the content unsafely (e.g., via innerHTML or similar). The JSON.parse(msg.data.actions) further increases risk if actions contain malicious payloads.}	```self.registration.showNotification(msg.data.title, { ...msg.data, ...(msg.data.actions && { actions: JSON.parse(msg.data.actions) }), tag, data: { ...msg.data, FCM_MSG: msg } })```
633	cba24n.com.ar.js	Insecure Direct Object Reference	High	true	CWE-200	N/A	clients.openWindow	standard	{The function clients.openWindow is called with e.action, which is directly taken from the notification click event. If an attacker can control the action URL, they can redirect users to arbitrary sites, leading to IDOR or phishing attacks. The URL is not validated or sanitized, making it a direct object reference vulnerability.}	```clients.openWindow(e.action)```
634	cba24n.com.ar.js	Insecure Direct Object Reference	High	true	CWE-200	N/A	clients.openWindow	standard	{The function clients.openWindow is called with e.notification.data.FCM_MSG.fcmOptions.link, which is derived from untrusted push message data. If an attacker controls this link, they can redirect users to arbitrary sites, leading to IDOR or phishing attacks. The URL is not validated or sanitized, making it a direct object reference vulnerability.}	```clients.openWindow(e.notification.data.FCM_MSG.fcmOptions.link)```
635	cba24n.com.ar.js	Server Side Request Forgery	High	true	CWE-918	N/A	fetch	standard	{The function fetch is used with dynamically constructed URLs derived from msg.fcmOptions.analyticsLabel (id) and deviceInstanceId. These values are taken from untrusted push message data, allowing an attacker to craft requests to arbitrary internal or external endpoints, leading to SSRF. The URL is not validated or sanitized, making it a high-risk SSRF vulnerability.}	```fetch(`/api/v1/push-notification/${id}/track?event=show`, { method: 'POST' })```
636	scrabble-solver.com.js	Information Exposure Through Error Message	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from logging error details to the console using console.log, which can expose sensitive information to users or attackers. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by poor error handling practices. The console.log function itself is not considered a sensitive function in the context of security risks such as code injection or remote code execution.}	"```console.log(""Fetch failed; returning offline page instead. Error message: "", error);```"
637	rentomojo.com.js	XSS via Unvalidated Message Broadcast	High	true	CWE-79	N/A	self.addEventListener('message'	standard	{The service worker listens for messages via self.addEventListener('message', ...) and broadcasts the received data to all clients without sanitizing or validating the content. Since the message data is directly posted to clients using client.postMessage(), an attacker could inject malicious scripts or payloads via a crafted message, leading to cross-site scripting (XSS) in the client context. This is a misuse of the standard event listener and postMessage API, which are not inherently unsafe but become dangerous when handling untrusted input without proper validation.}	```self.addEventListener('message', async event => { if (!event.data) { return; } if ('broadcast' in event.data) { const allClients = await clients.matchAll(); for (const client of allClients) { client.postMessage(event.data.broadcast); } } if ('changedCity' in event.data) { const allClients = await clients.matchAll(); for (const client of allClients) { client.postMessage(event.data.changedCity); } } });```
638	soichat.com.js	Potential XSS via Notification Data	Medium	true	CWE-79	8	Notification API (showNotification)	standard	{The code constructs notification options from user-provided data via `data.notification` without sanitization. The `showNotification` method is called with these options, which may include HTML or JavaScript if the data is malicious, leading to XSS when rendered in the notification UI. The input is dynamic and comes from `data.notification`, which is derived from a push message payload.}	"```const desc = data.notification; let options = {}; NOTIFICATION_OPTION_NAMES.filter(name => desc.hasOwnProperty(name)).forEach(name => options[name] = desc[name]); const visible = await this.checkClientIsVisible(); let title = desc[""title""]; const showAlways = this.isShowAlways(data); if (!visible || showAlways) { await this.scope.registration.showNotification(title, options); }```"
639	soichat.com.js	Use of Weak Cryptographic Algorithm (SHA)	Low	false	CWE-327	10	N/A	N/A	{The use of SHA-1 is a cryptographic weakness, but it is not caused by misuse of a sensitive function. The function `sha1` is implemented internally and used for hashing manifest data, which is not user-controlled input. There is no dynamic or untrusted input being passed to the function, so it does not constitute a sensitive function misuse.}	```const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8);```
640	pyramydair.com.js	Loading external script without validation leading to potential code execution	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hard-coded ('https://wpsw.listrak.com/_ltk-sw.js'), the vulnerability arises from the lack of validation or sanitization of the script source. If this URL were dynamically constructed from untrusted input (e.g., from a query parameter or user-provided value), it could allow an attacker to inject and execute arbitrary JavaScript code via script injection. Although the current usage is not directly vulnerable due to static input, the pattern of using importScripts without validation is inherently risky and qualifies as sensitive function misuse.}	```if (typeof importScripts === 'function') { importScripts('https://wpsw.listrak.com/_ltk-sw.js'); }```
641	lekmanga.com.js	Insecure Cache Name (HTTP instead of HTTPS	High	false	N/A	N/A	N/A	N/A	{The cache name uses HTTP instead of HTTPS, which may lead to insecure caching behavior, but this is not due to misuse of a sensitive function.}	```const cacheName = 'http://lekmanga.com-superpwa-2.2.31';```
642	lekmanga.com.js	Improper Validation of Range Header Leading to Denial of Service	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper parsing of the Range header, but it is not caused by misuse of a sensitive JavaScript function such as eval, importScripts, or similar.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
643	tiempo3.com.js	External Script Inclusion from Untrusted CDN	High	true	CWE-78	N/A	importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.1/workbox-sw.js');	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and not dynamically constructed from untrusted input, the use of a remote CDN (https://storage.googleapis.com) introduces a potential risk if the CDN is compromised or if the script is not properly verified. However, since the URL is static and not derived from user input or dynamic sources, this is not a classic ""sensitive function misuse"" in the context of injection or arbitrary code execution via user-controlled input. Therefore, while the vulnerability is real, it is not caused by sensitive function misuse in the traditional sense.}"	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.1/workbox-sw.js');```
644	swing.family.js	Improper Handling of Navigation Requests Leading to Unauthorized Access	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of navigation requests, but not due to misuse of a sensitive function. The code correctly uses fetch() and caches, but the logic may allow unauthorized access if the service worker is misconfigured or if the origin policy is bypassed. However, no sensitive function is being misused with untrusted input.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open('pwabuilder-offline'); const cachedResp = await cache.match('offline.html'); return cachedResp; } })()); } });```
645	swing.family.js	Incorrect Cache Update Logic Leading to Potential Denial of Service	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from incorrect logic in the refreshOffline event handler, where the event object is passed directly to cache.put() instead of a Response object. This is a logic error, not a misuse of a sensitive function. No sensitive function is being used with untrusted input.}	```self.addEventListener('refreshOffline', event => { return caches.open('pwabuilder-offline').then(cache => { console.log('[PWA Builder] Offline page updated from refreshOffline event: ' + event.url); return cache.put('offline.html', event); }); });```
646	emojis.wiki.js	Empty Fetch Event Handler in Service Worker	High	false	N/A	0	N/A	N/A	{The fetch event handler is empty, meaning it does not perform any logic or interception. This is not a result of misuse of a sensitive function, but rather a lack of implementation. No sensitive function is involved.}	```self.addEventListener('fetch', evt => {});```
647	douglas.bg.js	Insecure External Script Loading	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (s-eu-1.pushpushgo.com). This allows the external script to execute with the same privileges as the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute arbitrary code from remote sources.}	```importScripts('https://s-eu-1.pushpushgo.com/60b489888ad745ed8b51a212/worker.js');```
648	leidschdagblad.nl.js	Insecure Third-Party Dependency	Medium	false	CWE-496	N/A	N/A	N/A	{The use of importScripts with a hardcoded third-party URL does not constitute misuse of a sensitive function, as the URL is static and not derived from untrusted input. While the dependency itself is insecure, the function is used correctly.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
649	leidschdagblad.nl.js	Hardcoded Sensitive Credentials	High	false	CWE-798	N/A	N/A	N/A	{Hardcoded credentials are a result of poor configuration or secret management, not misuse of a sensitive JavaScript function. The values are stored directly in the code, but no function is being misused to introduce the vulnerability.}	```appKey: 'kG4X4CNcQDqG2KgWBvx72Q', token: 'MTprRzRYNENOY1FEcUcyS2dXQnZ4NzJROnZUT2NjS21WVjhOSFNwbWFKVldBVl9mSm1wdTdUd0tZdWhHNzNzbEY2UDA',```
650	instasave.website.js	Cache Match Ignores Query Parameters Leading to Data Leakage	Medium	true	New	7	N/A	standard	{The cache.match() function is used with the {ignoreSearch: true} option, which causes it to ignore query parameters when matching cached responses. This means that if a request with different query parameters (e.g., /api/data?user=alice vs /api/data?user=bob) is made, the service worker may return the cached response for one user to another, leading to data leakage. The misuse lies in the improper configuration of cache.match(), which is a standard browser API, and the decision to ignore search parameters without proper context or safeguards.}	```self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request).catch(() => { return caches.open(CACHE_NAME).then(cache => { return cache.match(event.request, { ignoreSearch: true }); })); }));```
651	benefitnews.com.js	External Script Loading Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function loads and executes a script from a specified URL. When used without integrity checks, it can load malicious or tampered scripts from external sources, leading to code injection and potential compromise of the service worker's execution context. In this case, the script is loaded from 'https://api-esp.piano.io/esp-service-worker.js', which is an external source and not verified for integrity, making it vulnerable to supply chain attacks.}	```importScripts('https://api-esp.piano.io/esp-service-worker.js');```
652	gooieneemlander.nl.js	Insecure External Script Loading	Medium	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (as in this case), it introduces a medium-risk vulnerability because the script is loaded from a third-party domain (aswpsdkus.com). While the URL is not dynamically constructed from untrusted input, the script is still external and could be compromised or modified by an attacker controlling the remote server, leading to potential code injection or malicious behavior within the service worker.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
653	futbolcentroamerica.com.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static credential exposed in the source code, not a result of sensitive function misuse.}	```self[`appKey`] = `94462bd6fd520a83a9c655a3c4931927`;```
654	futbolcentroamerica.com.js	Insecure Dynamic Script Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from a hardcoded hostUrl. Although the input is not user-controlled, the use of importScripts() with any non-static URL introduces risk because it loads and executes arbitrary JavaScript, potentially leading to code injection if the hostUrl were ever compromised or dynamically sourced from untrusted input.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
655	dayone.app.js	Cache Poisoning via Insecure URL Matching	High	true	CWE-918	10	N/A	standard	{The function `shouldCache` uses `url.includes()` to determine if a URL should be cached. This is a standard JavaScript method, but its misuse here allows for cache poisoning because it matches substrings rather than full paths or specific patterns. For example, an attacker could craft a URL like `https://example.com/trpc/getCustomEmbedInfoMalicious` which would still match `/trpc/getCustomEmbedInfo`, leading to unintended caching of malicious content. This is a sensitive function misuse because the decision to cache is based on a potentially insecure string matching operation on untrusted input (the URL), which can be exploited to cache arbitrary responses.}	```const shouldCache = url => { return url.includes('/focusModeImages') || url.includes('/trpc/getCustomEmbedInfo'); };```
656	gunfire.com.js	Incorrect Cache Key Handling	Medium	false	New	N/A	N/A	N/A	"{The vulnerability described as ""Incorrect Cache Key Handling"" does not stem from the misuse of a sensitive JavaScript function. The code attempts to serve cached responses for GET requests that match certain URL patterns, but the issue lies in the logic flow and handling of cache responses rather than improper use of a sensitive API like importScripts, eval, or dynamic code execution. The fetch() and caches.match() functions are used appropriately in this context.}"	```event.respondWith(caches.match(event.request).then(function (response) { return fetch(event.request); }).catch(function (error) { if (!navigator.onLine) { return caches.match('/pwa_offline.html'); } return; }));```
657	kannadaprabha.com.js	Remote Code Execution via Untrusted External Script Import	High	true	CWE-829	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it imports a script from a third-party CDN (https://cdn.izooto.com), which is not under the control of the site owner. While the URL is hardcoded, the use of an external, untrusted script source introduces a high-risk vulnerability because the script could be modified by the third party to perform malicious actions such as stealing data, redirecting requests, or injecting tracking code. This constitutes a sensitive function misuse due to reliance on an untrusted external source.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/4544b1fe65252edb254cdabaab34496289d121e2.js"");```"
658	sefamerve.com.js	Third-party script loading without validation	High	false	N/A	0	N/A	N/A	{The script loads a third-party service worker from a hardcoded URL, which is not inherently unsafe due to lack of dynamic input. Since the URL is fixed and not derived from untrusted sources, this does not constitute misuse of a sensitive function.}	"```self.importScripts(""https://assets.emarsys.net/web-emarsys-sdk/3.1.2/web-emarsys-service-worker.js"");```"
659	cosedicasa.com.js	Insecure Dynamic Code Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hard-coded and not dynamically derived from untrusted input, the function itself is inherently sensitive because it can execute arbitrary code from remote sources. However, since the URL is fixed and not influenced by user input or dynamic parameters, the risk is mitigated. Nonetheless, the function remains sensitive by design, and if the URL were to be dynamically constructed from untrusted sources, it would lead to code injection.}	```importScripts('https://pushdeploy.estrema.it/shared/sw/serviceworker-CS230901.js');```
660	gisher.me.js	Unchecked Error Condition	High	false	N/A	0	N/A	N/A	{The vulnerability arises from an empty catch block (`catch (error) {}`) that suppresses errors without logging or handling them, leading to silent failures. This is not caused by misuse of a sensitive function, but rather by poor error handling practices.}	```const PRECACHE = 'gche-v65'; const RUNTIME = 'grn-v81'; const PRECACHE_URLS = ['/', '/video/armyanskie-seriali', '/services/armtv.html', '/services/armtv.html?tv=armenia', '/services/armtv.html?tv=vivaro-sports', '/services/armtv.html?tv=vmedia-plus', '/services/armtv.html?tv=vivaro-arena', '/images/fav/android-chrome-192x192.png', '/js/jquery-3.js', '/newplayer/o/g.js', '/newplayer/o/jwpsrv.js', '/newplayer/o/jwplayer.core.controls.js', '/newplayer/o/provider.hlsjs.js', '/newplayer/o/provider.cast.js', '/newplayer/o/translations/ru.json', '/newplayer/o/translations/hy.json', '/css/fonts/gisher.woff2', '/css/fonts/gshr.woff2', '/css/fonts/gisherb.woff2', '/css/fonts/gshrb.woff2', '/css/gisher.css?37', '/css/g971.css?6', '/css/g970.css?5', '/css/gisherd.css?3', '/js/ratev.js']; self.addEventListener('install', event => { event.waitUntil(caches.open(PRECACHE).then(cache => cache.addAll(PRECACHE_URLS)).then(() => self.skipWaiting())); }); self.addEventListener('activate', event => { const currentCaches = [PRECACHE, RUNTIME]; event.waitUntil(caches.keys().then(cacheNames => { return cacheNames.filter(cacheName => !currentCaches.includes(cacheName)); }).then(cachesToDelete => { return Promise.all(cachesToDelete.map(cacheToDelete => caches.delete(cacheToDelete))); }).then(() => caches.open(RUNTIME)).then(cache => { return cache.keys().then(requests => { return Promise.all(requests.map(request => { if (!PRECACHE_URLS.includes(new URL(request.url).pathname)) { return cache.delete(request); } })); }); }).then(() => self.clients.claim())); }); self.addEventListener('fetch', event => { if (!event.request.url.startsWith(self.location.origin)) { return; } if (event.request.url.startsWith('http://')) { return; } if (event.request.mode === 'cors') { return; } if (event.request.method !== 'GET') { event.respondWith(fetch(event.request)); return; } event.respondWith(async function () { try { const cachedResponse = await caches.match(event.request); if (cachedResponse && event.request.headers.get('Accept').includes('text/html')) { try { const fetchResponse = await fetch(event.request); if (fetchResponse && fetchResponse.status === 200) { const cache = await caches.open(RUNTIME); cache.put(event.request, fetchResponse.clone()); } return fetchResponse; } catch (error) { return cachedResponse; } } if (event.request.url.startsWith(self.location.origin)) { try { const fetchResponse = await fetch(event.request); if (fetchResponse && fetchResponse.status === 200) { const cache = await caches.open(RUNTIME); cache.put(event.request, fetchResponse.clone()); } return fetchResponse; } catch (error) { return cachedResponse || new Response('Offline'); } } try { const fetchResponse = await fetch(event.request); return fetchResponse; } catch (error) {} }); });```
661	limitlesscasino.com.js	Improper Cache Deletion Leading to Stale Data	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper cache management during the activate event, where caches are deleted based on a hardcoded allowlist. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic flaw in cache cleanup. The code does not use any sensitive functions with untrusted input.}	"```self.addEventListener(""activate"", function (event) { var cacheAllowlist = [""v6-cache""]; event.waitUntil(caches.forEach(function (cache, cacheName) { if (cacheAllowlist.indexOf(cacheName) == -1) { return caches.delete(cacheName); } })); });```"
662	hungarytoday.hu.js	XSS via Untrusted Payload in Service Worker	Medium	true	CWE-79	8	N/A	standard	{The vulnerability arises because the service worker directly uses untrusted data from the Firebase messaging payload (specifically, `payload.notification.title` and `payload.notification.body`) to construct notification content. While the `showNotification()` method itself is not inherently dangerous, the content it displays can be controlled by an attacker if the payload is manipulated. In a service worker context, this can lead to cross-site scripting (XSS) if the notification content is rendered in a way that allows script execution (e.g., via rich notification content or if the notification is later injected into a webpage). The misuse lies in trusting unvalidated external data without sanitization.}	"```importScripts('https://www.gstatic.com/firebasejs/3.9.0/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/3.9.0/firebase-messaging.js');firebase.initializeApp({messagingSenderId: ""406680466211""});const messaging = firebase.messaging();messaging.setBackgroundMessageHandler(function (payload) {console.log('[firebase-messaging-sw.js] Received background message ', payload);const notificationTitle = payload.notification.title;const notificationOptions = {body: payload.notification.body,icon: 'wp-content/themes/hungarytoday_v1.2/res/ht-noti.png'};return self.registration.showNotification(notificationTitle, notificationOptions);});```"
663	gd.no.js	Vulnerability in Host Validation Logic	High	true	CWE-20	10	indexOf	standard	{The use of `indexOf` to validate the host string `www.gd.no` is unsafe because it allows partial matches. For example, a host like `evil.www.gd.no` would still pass the check, leading to unintended routing or caching behavior. This is a classic case of improper string matching that can be exploited to bypass intended security controls.}	```const pattern4 = (req) => req.event.request.mode === 'navigate' && req.url.pathname === '/' && req.url.host.indexOf('www.gd.no') !== -1 && req.event.request.method === 'GET';```
664	nicolaporro.it.js	Using Components with Known Vulnerabilities	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by using a component (Firebase SDK) with known vulnerabilities. The code itself does not exhibit unsafe function usage such as dynamic script loading or unsanitized input execution.}	```const clickUrl = event.notification.data.url; event.waitUntil(clients.openWindow(clickUrl));```
665	codecombat.com.js	Vulnerable Server Configuration Based on User-Controlled Parameter	High	true	CWE-79	9	N/A	standard	"{The function `new URL(location).searchParams.get(""product"")` retrieves a user-controlled parameter from the URL query string. This value is then used to conditionally reassign the `server` object, which determines the domain mapping for resource fetching (e.g., via `changeToDexecureURL`). Since the `product` parameter is not sanitized or validated, an attacker could supply a malicious value (e.g., `product=evil.com`) to influence the server configuration, potentially redirecting requests to attacker-controlled domains. This constitutes a configuration-based vulnerability driven by the misuse of the standard `URL` and `searchParams` APIs.}"	"```const product = new URL(location).searchParams.get(""product""), isCodeCombat = ""codecombat"" === product;```"
666	t-a.no.js	Improper URL Validation in Message Handling	High	true	N/A	N/A	fetch	standard	{The service worker uses the fetch() function to retrieve resources based on URLs received via postMessage(). Since the URL is derived from event.data.message without validation or sanitization, an attacker could send a malicious URL (e.g., to an internal network or external service) causing the service worker to make unintended network requests, leading to SSRF or data exfiltration.}	"```self.addEventListener(""message"", event => { if (!event.data.type) { return; } const message3 = event.data.message || null; switch (event.data.type) { case message2: handler2(event, message3); break; case message: handler(event, message3); break; default: break; } });```"
667	t-a.no.js	Incorrect Host Matching in pattern	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a hardcoded string comparison using indexOf() with an incorrect literal (''www.t-a.no'') that includes extra quotes, making the condition always false. This is a logic error, not a misuse of a sensitive function.}	```function pattern4(req) { return req.event.request.mode === 'navigate' && req.url.pathname === '/' && req.url.host.indexOf(''www.t-a.no'') !== -1 && req.event.request.method === 'GET'; }```
668	t-a.no.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from misconfigured cache expiration settings (maxAgeSeconds: 7 * 24 * 60 * 60) which may allow stale content to be served for extended periods. This is a configuration issue, not a misuse of a sensitive function.}	```var strategy = new NetworkFirst({ networkTimeoutSeconds: 3, cacheName: 'prowl', plugins: [new ExpirationPlugin({ maxEntries: 10, maxAgeSeconds: 7 * 24 * 60 * 60 })] });```
669	t-a.no.js	Potential SSRF via getABTestUrl	High	true	N/A	N/A	fetch	standard	{The getABTestUrl function modifies the request URL based on AB test rules and then passes it to fetch() without validating the resulting URL. If an attacker can influence the rules or the request URL, they could cause the service worker to fetch from unintended domains, leading to SSRF.}	```async function responseHandler(request) { if (abTestEnabled === true) { request = getABTestUrl(request); } const response = await fetch(request); self.emergencyMode = (response.headers.get('x-emergency-mode') || '').split(','); return response; }```
670	elanet.ir.js	External Script Import Vulnerability	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, in this context, the URL is hardcoded to a remote script hosted on a third-party domain (van.najva.com), which may be controlled by an untrusted party. If the script at that URL is compromised or malicious, it can execute arbitrary code within the service worker context, leading to potential data exfiltration, cache manipulation, or network interception. While the input is not dynamic, the reliance on an external, potentially untrusted source constitutes a high-risk misuse of a sensitive function.}	```importScripts('https://van.najva.com/static/js/scripts/elanet-website-41415-9aa47be2-651e-41a1-8852-c88a74436c25-service-worker.js');```
671	herzporno.net.js	Third-Party Code Vulnerability (External Script Import Without Integrity Check	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, it imports a script from an external domain (pushpad.xyz) without any integrity checks or validation. This allows the script to be modified or replaced by an attacker, leading to potential code injection, data exfiltration, or manipulation of the service worker’s behavior. Since the URL is hardcoded and not dynamically derived from untrusted input, the vulnerability is not due to sensitive function misuse with dynamic input, but the function itself is inherently sensitive when used with untrusted sources.}	```importScripts('https://pushpad.xyz/service-worker.js?20170811');```
672	nashrin.com.js	Improper Cache Validation	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the lack of proper validation or integrity checks on cached resources. The script caches a set of predefined URLs (e.g., images, fonts, JS files) during installation, but does not verify the integrity or origin of these resources after they are cached. This could allow an attacker to manipulate the cache if the server hosting these resources is compromised, leading to potential delivery of malicious content. However, this is not caused by misuse of a sensitive JavaScript function, as no function like importScripts, eval, or dynamic code execution is involved.}	"```const offlineUrl = ""/offline"";const PRECACHE = ""precache-v4"";const RUNTIME = ""runtime"";const PRECACHE_URLS = [""/favicon.ico"", ""/img/logo.svg"", ""/img/raw.png"", ""/fonts/iransans.woff2"", ""/fonts/nicon.woff2"", ""/manifest.json"", ""/js/lazi.min.js"", ""/img/android-chrome-192x192.png"", ""/img/android-chrome-512x512.png"", offlineUrl];const filesUpdate = cache => {  const stack = [];  PRECACHE_URLS.forEach(file => stack.push(cache.add(file).catch(_ => console.error(`can't load ${file} to cache`))));  return Promise.all(stack);};self.addEventListener(""install"", event => {  event.waitUntil(caches.open(PRECACHE).then(filesUpdate).then(self.skipWaiting()));});self.addEventListener(""activate"", event => {  const currentCaches = [PRECACHE, RUNTIME];  event.waitUntil(caches.keys().then(cacheNames => {    return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));  }).then(cachesToDelete => {    return Promise.all(cachesToDelete.map(cacheToDelete => {      return caches.delete(cacheToDelete);    }));  }).then(() => self.clients.claim()));});self.addEventListener(""fetch"", event => {  if (event.request.url.startsWith(self.location.origin) && event.request.method === ""GET"" && !event.request.headers.get(""accept"").includes(""text/html"")) {    event.respondWith(caches.match(event.request).then(cachedResponse => {      if (cachedResponse) {        return cachedResponse;      }      return caches.open(RUNTIME).then(cache => {        return fetch(event.request).then(response => {          return cache.put(event.request, response.clone()).then(() => {            return response;          });        });      });    }));  }});```"
673	10brl.com.js	Improper Input Validation in Offline Exclusion Check	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a flawed logic in the offline exclusion check, where the code iterates over a hardcoded list of strings and checks if the request URL contains any of them. This is not a misuse of a sensitive function, but rather a logic flaw in the validation process. The code does not invoke any function that could lead to code injection or execution, such as eval, importScripts, or dynamic script loading.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
674	10brl.com.js	Flawed URL Validation Logic in Fetch Handler	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from a flawed URL validation logic that attempts to detect if a URL contains a dot within a substring, but does not use any sensitive function that could lead to code execution or injection. The code uses standard string manipulation methods (replace, indexOf, slice) on the URL, which are safe when used with trusted or sanitized inputs. There is no evidence of dynamic code execution or unsafe function invocation.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
675	bbg.bet.js	Cache Bloat (Excessive Caching of Root Path	High	true	CWE-400	N/A	caches.addAll	standard	{The caches.addAll function is misused by passing a single root path ['/'] which causes the entire site to be cached, leading to excessive cache bloat and potential performance degradation. This is a misuse of a standard caching API with a broad, unbounded input.}	```e.waitUntil(caches.open('fox-store').then(cache => cache.addAll(['/'])));```
676	bbg.bet.js	Flawed URL Exclusion Logic (Bypass Risk	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from flawed logic in URL filtering, not from misuse of a sensitive function. The code checks for a dot in a substring of the URL, which can be bypassed by attackers using URLs without dots in the first 60 characters after the protocol. No sensitive function is involved.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
677	bbg.bet.js	Hardcoded Redirect in Notification (Phishing Risk	Low	false	CWE-601	N/A	N/A	N/A	{The vulnerability stems from a hardcoded URL in clients.openWindow, which is not a sensitive function misuse but a design flaw. The function is used correctly, but the URL is hardcoded and could be exploited for phishing if the domain is compromised.}	```event.waitUntil(clients.openWindow('https://www.BBG.bet/'));```
678	cademinhaentrega.com.br.js	Vulnerable Cache Handling	High	true	N/A	N/A	caches.put	standard	{The caches.put() function is used to store responses in the cache, but it is called without validating or sanitizing the request URL, which could allow an attacker to cache malicious or unintended content if the request URL is derived from untrusted input. This could lead to cache poisoning or unauthorized data storage.}	```return this.cache.put(req```
679	cademinhaentrega.com.br.js	Insecure Hash Verification	Medium	true	N/A	N/A	sha1Binary	standard	{The sha1Binary() function is used to compute a hash of a response body, but it is applied to data from a network response without verifying the integrity or origin of the data. This allows an attacker to manipulate the response body and potentially bypass hash-based integrity checks, leading to insecure resource verification.}	```const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());```
680	cademinhaentrega.com.br.js	Cross-Site Request Forgery (CSRF) Risk	Medium	false	N/A	N/A	N/A	N/A	{The idle.trigger() function is used to schedule tasks, but it does not involve direct user input or sensitive function misuse. The risk arises from improper state management rather than misuse of a sensitive function.}	```event.waitUntil(this.idle.trigger());```
681	cademinhaentrega.com.br.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The normalizeUrl() function is used to process URLs, but it is not inherently a sensitive function. The vulnerability stems from insufficient validation of input URLs rather than misuse of a sensitive function.}	```const url = this.adapter.normalizeUrl(req.url);```
682	cademinhaentrega.com.br.js	Denial of Service via Redirect Loop	Medium	true	N/A	N/A	fetch	standard	{The fetch() function is used to make network requests, and it is called recursively with redirected URLs without proper limits or validation. This can lead to infinite redirect loops if an attacker controls the redirect target, causing a denial of service.}	```return this.fetchFromNetwork(this.adapter.newRequest(res.url```
683	cademinhaentrega.com.br.js	Insecure Data Storage	Low	true	N/A	N/A	caches.put	standard	{The caches.put() function is used to store metadata in the cache, but it does not validate or sanitize the stored data. This could allow an attacker to inject malicious data into the cache if the data is derived from untrusted sources, leading to insecure data storage.}	```yield metaTable.write(req.url```
684	cademinhaentrega.com.br.js	Insecure Communication	Low	true	N/A	N/A	fetch	standard	{The fetch() function is used to make network requests without enforcing secure communication protocols (e.g., HTTPS). This could allow man-in-the-middle attacks if the request is made over HTTP, leading to insecure communication.}	```return this.scope.fetch(req);```
685	cademinhaentrega.com.br.js	Improper Error Handling	Low	false	N/A	N/A	N/A	N/A	{The adapter.newResponse() function is used to create error responses, but the vulnerability arises from insufficient error handling logic rather than misuse of a sensitive function.}	```return this.adapter.newResponse(null```
686	cademinhaentrega.com.br.js	Insecure Temporary File	Low	true	N/A	N/A	newRequest	standard	{The newRequest() function is used to create a request with a cache-busting parameter, but it is called with dynamically generated URLs that could be manipulated by an attacker. This could lead to insecure temporary file creation or cache poisoning if the URL is not properly validated.}	```const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));```
687	cademinhaentrega.com.br.js	Insecure Resource Management	Low	true	N/A	N/A	Map.set	standard	{The Map.set() function is used to store in-flight requests, but it does not validate or sanitize the request URL. This could allow an attacker to manipulate the in-flight request map if the URL is derived from untrusted input, leading to insecure resource management.}	```this.inFlightRequests.set(req.url```
688	dfimoveis.com.br.js	Unreliable Online Status Check	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the unreliable use of `navigator.onLine` to determine network connectivity, which can be misleading as it only reflects the browser's perceived online state and not actual network reachability. This does not stem from misuse of a sensitive function, but rather from a logic flaw in network status checking.}	```if (navigator.onLine) { return fetchPromise; } return cachedResponse || fetchPromise;```
689	divulgavagas.com.br.js	External Script Inclusion Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (as in this case), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain without integrity verification. This allows the third party to modify the script at any time, potentially injecting malicious code that can compromise the service worker’s behavior, intercept network requests, or exfiltrate data.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/67167b5c72174d000817b235/service-worker.js"");```"
690	finchoice.mobi.js	Open Redirect in NavigateWindow	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed from untrusted input (data.URL and action). Since these values are derived from external data (e.g., push notification payload) without validation or sanitization, an attacker can manipulate them to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```function NavigateWindow(data, action) { if (data.URL != '') { if (action != '' && action != 'Action') { return clients.openWindow(data.URL + '/' + action); } else { return clients.openWindow(data.URL); } } else { return clients.openWindow('/'); } }```
691	finchoice.mobi.js	Insufficient Input Sanitization in Notification Data	Medium	false	CWE-20	N/A	N/A	N/A	{The code attempts to sanitize a string by replacing escape sequences and control characters, but the sanitization is incomplete and does not prevent malicious payloads from being parsed via JSON.parse. However, this is not caused by misuse of a sensitive function, as JSON.parse is used correctly and the issue lies in insufficient sanitization logic rather than a function misuse.}	```var s = s.replace(/\\n/g, '\\n').replace(/\\'/g, '\\'').replace(/\\'/g, '\\'').replace(/\\&/g, '\\&').replace(/\\r/g, '\\r').replace(/\\t/g, '\\t').replace(/\\b/g, '\\b').replace(/\\f/g, '\\f'); s = s.replace(/[\u0000-\u0019]+/g, ''); var data = JSON.parse(s);```
692	gsb.ug.js	Denial of Service via Forced Page Reload on	Medium	false	New	0	N/A	N/A	"{The vulnerability arises from a forced page reload triggered when a fetch request for a resource containing ""icomoon"" in its URL fails with a 403 status. This is not due to misuse of a sensitive function, but rather a logic flaw in handling failed requests. The code uses `self.clients.matchAll()` to find all clients and then posts a message to reload the page, which can be exploited if an attacker can trigger this condition repeatedly. However, no sensitive function like `importScripts`, `eval`, or `fetch` with untrusted input is misused here.}"	"```self.addEventListener(""fetch"", t => { -1 !== t.request.url.indexOf(""icomoon"") && t.respondWith(fetch(t.request).then(e => (403 === e.status && self.clients.matchAll().then(e => { e.forEach(e => { setTimeout(() => { e.postMessage({ action: ""page-reload"" }); }); }); }), e)).catch(e => caches.match(t.request))); });```"
693	mmsmasala.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-602	10	N/A	standard	{The function `self.clients.openWindow()` is a standard browser API used to open a new window or tab. In this context, it is invoked with a URL derived from `data.url`, which originates from a push notification payload. Since the notification data is not validated or sanitized, an attacker could craft a malicious notification containing a URL pointing to an arbitrary external site, leading to an open redirect. This allows the attacker to trick users into visiting unintended or malicious websites, potentially leading to phishing or credential theft.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
694	mobifacil.com.br.js	Server Side Request Forgery (SSRF)	High	true	CWE-602	N/A	N/A	standard	{The fetch() function is used with a dynamically constructed URL that concatenates user-controlled 'link' and 'passengerData' parameters. Since these inputs are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```let url = link + '&passengersData=' + passengerData;```
695	mobifacil.com.br.js	Denial of Service (DoS)	High	true	CWE-408	N/A	N/A	standard	{The setTimeout() function is used within a recursive cronJob() function to repeatedly trigger itself every 5 seconds. If not properly controlled, this can lead to excessive resource consumption (CPU, memory) on the client device, causing a DoS condition.}	```return new Promise(function (resolve) { const delay = nextExecution - Date.now(); setTimeout(resolve, delay); }).then(() => cronJob(link, startPolling, passengerData, orderNo));```
696	mobifacil.com.br.js	Open Redirect/Phishing	Medium	true	CWE-601	N/A	N/A	standard	{The clients.openWindow() function is called with a user-controlled 'data.link' parameter. If this parameter is not validated, an attacker can redirect users to malicious websites, enabling phishing or other social engineering attacks.}	```event.waitUntil(clients.openWindow(data.link || 'https://www.mobifacil.com.br/'));```
697	mobifacil.com.br.js	Insecure Data Handling	Medium	true	New	N/A	N/A	standard	{The event.data.json() method is used to parse incoming message data without validating or sanitizing the input. This can lead to insecure data handling, especially if the parsed data is used in subsequent operations without proper checks, potentially allowing injection or unexpected behavior.}	```const data = event.data.json();```
698	pgtada.com.js	Flawed URL Filtering in Fetch Event Handler	High	true	CWE-20	10	N/A	standard	{The fetch event handler uses a flawed URL filtering mechanism that relies on string-based substring matching (indexOf) and a simplistic check for a dot in the URL path. This approach is vulnerable to bypasses because it does not properly validate or sanitize the URL structure, allowing attackers to craft requests that evade the blacklist (e.g., by using URL encoding, path traversal, or alternative protocols). The sensitive function fetch() is used without proper validation, enabling potential cache poisoning or unintended resource fetching.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; } e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));```
699	resanejavan.net.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used without integrity checks or with URLs derived from untrusted sources, it can lead to remote code execution if an attacker can manipulate the script source. In this case, the script is imported from a hardcoded external URL, which may be compromised or altered by an attacker, leading to unauthorized code execution within the service worker context.}	```importScripts('https://van.najva.com/static/js/scripts/new-website897998-website-57171-aee485a3-5aac-4a40-87e7-ca4a641ed9fe-service-worker.js');```
700	tadabet.com.js	Cache Poisoning	High	true	CWE-918	10	N/A	standard	{The fetch event handler uses caches.match() and fetch() to serve cached or network responses. While not directly misusing a sensitive function, the lack of proper validation on the request URL (especially with the flawed exclusion logic) allows potentially malicious URLs to be cached and served, leading to cache poisoning. The vulnerability arises from improper handling of dynamic input (request URLs) in the context of caching, which is a misuse of the standard caching API.}	```self.addEventListener('fetch', e => { for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; } var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; } e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));});```
701	tadabet.com.js	Case-Sensitive Exclusion Check	Medium	false	New	0	N/A	N/A	{The vulnerability stems from a logic flaw in the exclusion check, not from misuse of a sensitive function. The code uses indexOf() for substring matching, which is case-sensitive, but the issue is purely a design flaw in the exclusion logic, not a security vulnerability caused by a sensitive function.}	```self.addEventListener('fetch', e => { for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; } var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; } e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));});```
702	rewardzinga.com.js	External Script Loading Without Integrity Check	High	true	CWE-78	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can load scripts from untrusted or compromised sources, potentially leading to code injection and full compromise of the service worker's execution context. In this case, the script is loaded from a third-party domain (api.pushnami.com) without any integrity verification, making it vulnerable to supply chain attacks if the source is compromised.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/6682e3bdc751e60013d456c9"");```"
703	arabonormannaunesco.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-829	10	fetch	standard	{The fetch function is used with a URL constructed from the untrusted 'sensor' field in the push message data. Since this value is derived from external input (event.data.json()), an attacker can manipulate it to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.arabonormannaunesco.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
704	arabonormannaunesco.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-829	10	fetch	standard	{The fetch function is used with a URL constructed from the untrusted 'sensor' field in the notification data. Since this value is derived from external input (event.notification.data.sensor), an attacker can manipulate it to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.arabonormannaunesco.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```
705	theweather.com.js	Hardcoded API Key in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to a hardcoded API key, not misuse of a sensitive function. The code does not involve dynamic or untrusted input being passed to a sensitive function like importScripts, eval, or similar.}	```self[`appKey`] = `7a0c6a4bc04e963c9804cc28eef253a0`;```
706	d21.team.js	Use of Outdated or Vulnerable Third-Party Component	Medium	false	CWE-496	N/A	N/A	N/A	{The vulnerability is due to the use of outdated versions of Firebase JavaScript libraries (5.9.2), which may contain known security flaws or lack support for modern security features. This is not caused by misuse of a sensitive function, but rather by using an outdated third-party component.}	```importScripts('https://www.gstatic.com/firebasejs/5.9.2/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/5.9.2/firebase-messaging.js');```
707	pantydeal.com.js	Cache Poisoning via Untrusted Response in Custom Event	High	true	CWE-434	9	cache.put	standard	{The `cache.put()` function is used to store a response in the cache, but the response parameter is directly taken from the custom 'refreshOffline' event without validation or sanitization. This allows an attacker to inject arbitrary responses into the cache, potentially serving malicious content to users when offline.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('pwabuilder-offline').then(function (cache) { return cache.put(offlinePage, response); }); });```
708	pantydeal.com.js	Use of Undefined Variable in Custom Event Handler	Medium	false	New	N/A	N/A	N/A	{The variable `offlinePage` is referenced in the `cache.put(offlinePage, response)` call, but it is not defined within the scope of the 'refreshOffline' event handler. This leads to a runtime error, but it is not a sensitive function misuse since no dangerous API is being misused with untrusted input.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('pwabuilder-offline').then(function (cache) { return cache.put(offlinePage, response); }); });```
709	8pg.com.js	Improper Input Validation (Case-Sensitive URL Exclusion Check	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a case-sensitive check using `indexOf`, which may fail to exclude URLs that differ only in case (e.g., '/Api/'). This is not due to misuse of a sensitive function, but rather a logic flaw in string matching.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
710	8pg.com.js	Improper Input Validation (Flawed URL Validation Logic	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from flawed logic in URL validation: replacing 'https://' and then checking for a dot in a substring. This can be bypassed by URLs without dots in the first 60 characters after the protocol, or by malformed URLs. This is a logic error, not misuse of a sensitive function.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
711	kisadalga.net.js	External Script Import Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can lead to code injection if the external script is compromised or modified. In this case, the script is loaded from a third-party CDN (cdn.kisadalga.net), and while the version parameter is hardcoded, the lack of integrity verification (e.g., Subresource Integrity) means an attacker could potentially serve a malicious version of the script if the CDN is compromised. This constitutes a high-risk vulnerability because the service worker’s execution context is trusted and can intercept network requests, manipulate cache, and access sensitive data.}	```importScripts('https://cdn.kisadalga.net/assets/bundle/webpush.js?v=' + version);```
712	calculatorbox.com.js	Loading untrusted third-party script without integrity check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted third party (like 'https://api.pushnami.com/...') without integrity checks, it introduces a high-risk vulnerability. An attacker could compromise the third-party server or intercept the script in transit, leading to arbitrary code execution within the service worker context. This allows for malicious behavior such as data exfiltration, cache manipulation, or network request interception.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/64e514ffb32c6c0013f1da21"");```"
713	rybnik.com.pl.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (pushpushgo.com). This allows the third party to potentially inject malicious code into the service worker, leading to cache manipulation, network request interception, or data exfiltration. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute arbitrary remote code.}	```importScripts('https://s-eu-1.pushpushgo.com/5de65bd28d7dda55ac46f1e3/worker.js');```
714	theindependent.com.js	Open Redirect via Untrusted URL Construction	High	true	CWE-601	10	N/A	standard	{The function self.clients.openWindow() is a standard service worker API that opens a new window or tab with the provided URL. In this case, the URL is constructed from oData.url, which originates from the FCM payload (a potentially untrusted source). Since the URL is not validated or sanitized, an attacker could craft a malicious payload that redirects users to arbitrary domains, leading to open redirect vulnerabilities.}	```self.clients.openWindow(oURL.toString());```
715	sattacademy.com.js	Service Worker Cache Installation Failure	Medium	false	N/A	0	N/A	N/A	{The vulnerability described is related to potential failure during cache installation, but it does not stem from misuse of a sensitive JavaScript function. The code uses standard caching operations with hard-coded paths and no dynamic or untrusted input. Therefore, it is not a sensitive function misuse.}	```event.waitUntil(caches.open(staticCacheName).then(cache => { return cache.addAll(filesToCache); }));```
716	rikstoto.no.js	Server Side Request Forgery (SSRF) via unvalidated fetch requests	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used without validating the request URL, allowing an attacker to craft malicious requests to internal or external resources if the request is derived from untrusted input. This can lead to SSRF attacks where the service worker acts as a proxy for unauthorized requests.}	```return this.scope.fetch(req);```
717	rikstoto.no.js	Insecure Cache Storage with Predictable Names	Medium	false	N/A	N/A	N/A	N/A	{The cache names are constructed using a predictable prefix and user-controlled input, but there is no direct misuse of a sensitive function. The issue is more about naming convention and potential for cache collision rather than function misuse.}	```this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);```
718	rikstoto.no.js	Lack of Input Validation in Cache Key Handling	Medium	false	N/A	N/A	N/A	N/A	{The `normalizeUrl` function processes URLs, but it does not directly misuse a sensitive function. The vulnerability stems from insufficient validation of input URLs before processing, not from improper use of a sensitive API.}	```this.adapter.normalizeUrl(url)```
719	rikstoto.no.js	Potential Cache Poisoning via Unvalidated Responses	High	true	N/A	N/A	put	standard	{The `put` method of the Cache API is used to store responses without validating their content or origin. If an attacker can inject a malicious response into the cache, it can be served to clients, leading to cache poisoning.}	```await cache.put(req```
720	rikstoto.no.js	Insecure Direct Object Reference (IDOR) in Cache Access	Medium	false	N/A	N/A	N/A	N/A	{The `open` method is used with a constructed cache name, but there is no evidence of direct misuse of a sensitive function. The issue arises from improper access control or lack of authorization checks, not from function misuse.}	```const cache = await this.original.open(`${this.cacheNamePrefix}:${cacheName}`);```
721	musicplayonline.com.js	Use of Untrusted CDN Without Integrity Check	High	true	CWE-942	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can load scripts from untrusted CDNs, potentially allowing an attacker to serve malicious code if the CDN is compromised. In this case, the script is loaded from 'https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js', which is not verified for integrity, making it vulnerable to supply chain attacks.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');```
722	bibakmusic.com.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., 'https://van.najva.com/...'), it introduces a high-risk vulnerability if the script source is not fully trusted or controlled. Although the URL is hardcoded here, the vulnerability is still considered sensitive because the function itself is inherently dangerous when used with untrusted sources, and the script could be modified or replaced by an attacker if the external server is compromised. This allows for remote code execution within the service worker context, enabling cache manipulation, network interception, and other malicious activities.}	```importScripts('https://van.najva.com/static/js/scripts/new-website116786-website-44079-f51d38ee-b085-4207-afb7-8b7f96c08200-service-worker.js');```
723	elcordillerano.com.ar.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL that is derived from untrusted notification data (event.notification.data.FCM_MSG.data.link). Since the URL is constructed without validation or sanitization, an attacker can craft a malicious link in the notification payload, leading to an open redirect that may redirect users to phishing or malicious sites.}	N/A
724	elcordillerano.com.ar.js	Improper Input Validation for Notification Link	Medium	true	CWE-20	9	clients.openWindow	standard	{The clients.openWindow function is used with a URL derived from JSON-parsed notification data (data.link). The input is not validated or sanitized, allowing an attacker to inject arbitrary URLs through the notification payload, potentially leading to open redirects or unintended navigation to malicious sites.}	N/A
725	elcordillerano.com.ar.js	Exposure of Sensitive Firebase Configuration	Medium	false	CWE-532	0	N/A	N/A	{The vulnerability arises from hardcoded Firebase configuration, including the API key, which is exposed in the service worker script. This is not due to misuse of a sensitive function, but rather a misconfiguration or lack of proper secrets management.}	N/A
726	7bslot.com.js	Domain Spoofing via Cookie Manipulation	High	true	N/A	9	N/A	standard	{The `self.cookieStore.get()` function is used to retrieve the 'ORIGINAL_DOMAIN' cookie, which is then used to dynamically construct URLs for fetching resources. If an attacker can manipulate this cookie (e.g., via cross-site scripting or insecure cookie handling), they can force the service worker to fetch and serve content from a malicious domain, leading to domain spoofing.}	```const cookieRes = await self.cookieStore.get('ORIGINAL_DOMAIN'); ORIGINAL_DOMAIN = cookieRes?.value;```
727	7bslot.com.js	Insecure External Domain Configuration	High	true	N/A	9	N/A	standard	{The `fetch()` function is used to retrieve a JSON configuration from a hardcoded external URL. If this URL is compromised or points to an attacker-controlled endpoint, the service worker can be tricked into loading malicious backup domains, leading to arbitrary resource fetching and potential domain spoofing.}	```const response = await fetch('https://raw.githubusercontent.com/190699038/pwa/refs/heads/main/pwa.json');```
728	7bslot.com.js	Insecure Cookie Handling	Medium	true	N/A	8	N/A	standard	{The `self.cookieStore.set()` function is used to store the 'ORIGINAL_DOMAIN' cookie with a value derived from a user-controlled or untrusted domain. This allows an attacker to inject a malicious domain into the cookie, which can then be used to redirect future requests to that domain, enabling domain spoofing or cache poisoning.}	```await self.cookieStore.set('ORIGINAL_DOMAIN', url);```
729	7bslot.com.js	XSS via HTML Manipulation	High	true	N/A	9	N/A	standard	{The `replace()` method is used to dynamically insert a domain URL into HTML content (via string replacement), which is then returned as a `Response` object. If the domain URL is untrusted or controlled by an attacker, this can lead to reflected XSS when the modified HTML is rendered in the browser.}	```newBody = newBody.replace(/href='\.\//g, `href='${url}/`);```
730	7bslot.com.js	Insecure Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The logic checks if the original domain differs from the current URL origin and deletes the cookie if so. This is a control flow issue rather than misuse of a sensitive function, as no dangerous function is directly misused.}	```if (ORIGINAL_DOMAIN && ORIGINAL_DOMAIN !== url.origin && url.origin === self.location.origin) { await self.cookieStore.delete('ORIGINAL_DOMAIN'); }```
731	milanlive.it.js	Server Side Request Forgery (SSRF) via unvalidated URL in push event	High	true	CWE-829	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (body.data.sensor and body.data.push_send_id). Since these values are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.milanlive.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
732	milanlive.it.js	Open Redirect via unvalidated URL in notification click handler	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted input (event.notification.data.url). Since this value is not validated or sanitized, an attacker can manipulate it to redirect users to malicious websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
733	ilmeteo.net.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a security issue but not caused by misuse of a sensitive function. It is a static value embedded in the code.}	```self[`appKey`] = `3966817e04c65b09ca9b0ef589da4056`;```
734	ilmeteo.net.js	Dynamic Code Loading from Untrusted Source	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a dynamic value (here, self[`hostUrl`]), and that value is not validated or sanitized, it allows an attacker to control the script source. If hostUrl is ever modified or overridden (e.g., via a malicious origin or tampered environment), the service worker could load and execute arbitrary code from an attacker-controlled domain, leading to code injection and potential compromise of the entire service worker context.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
735	pudhari.news.js	External Code Execution via importScripts	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted on cdn.izooto.com. While the URL is not dynamically constructed from untrusted input, the act of importing external code from a third-party domain still constitutes a high-risk vulnerability because it allows an external entity to control the execution environment of the service worker. This can lead to unauthorized data access, cache manipulation, or interception of network requests. The risk is elevated because the script is loaded from an external domain without any integrity checks or origin validation.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/65d1c0aaafd529a3f06bfbddfa61d4c587c01f29.js"");```"
736	theforum365.com.js	Improper CSRF Token Handling	High	true	CWE-352	9	fetch	standard	{The fetch function is used to retrieve a CSRF token from the server using a dynamically constructed URL based on the request path. While the URL is built from a trusted base (BASE_URL), the path is derived from the intercepted request, which could be manipulated by an attacker if the request is not properly validated. This allows an attacker to potentially trigger CSRF token retrieval for unintended endpoints, leading to token leakage or misuse.}	N/A
737	theforum365.com.js	Insecure Fetch with Credentials	Medium	true	CWE-295	9	fetch	standard	{The fetch function is used with credentials: 'include', which sends cookies and authentication tokens with the request. The URL is constructed using a dynamically derived path from the intercepted request, which may be controlled by an attacker. This allows an attacker to force the service worker to make authenticated requests to unintended endpoints, potentially leading to unauthorized access or data leakage.}	N/A
738	theforum365.com.js	Open Redirect in Notification Click	Medium	true	CWE-601	8	clients.navigate	standard	{The clients.navigate function is called with a URL derived from the notification data, which is obtained from a push event. Since the push data is not validated or sanitized, an attacker can craft a push notification with a malicious URL, causing the service worker to redirect the user to an arbitrary site, leading to open redirect vulnerabilities.}	N/A
739	theforum365.com.js	Cache Poisoning via cache.addAll	Medium	false	CWE-918	0	N/A	N/A	{The cache.addAll function is used with a hardcoded list of assets (CACHED_ASSETS), which are not dynamically derived from untrusted input. Therefore, there is no sensitive function misuse here, and the vulnerability is due to misconfiguration rather than improper function usage.}	N/A
740	theforum365.com.js	Information Exposure via Debug Logs	Low	false	CWE-200	0	N/A	N/A	{The console.log function is used conditionally based on a DEBUG flag, and the input is not derived from untrusted sources. The vulnerability arises from logging sensitive information in debug mode, not from misuse of a sensitive function.}	N/A
741	shop.pr.js	Hardcoded Sensitive Credentials	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (appKey, token, vapidPublicKey) in the script, not due to misuse of a sensitive JavaScript function. These values are static and embedded directly in the code, posing a risk if exposed, but no dynamic or unsafe function invocation is involved.}	```importScripts('https://web-sdk.urbanairship.com/notify/v1/ua-sdk.min.js'); uaSetup.worker(self, { defaultIcon: 'https://www.shop.pr/logo.png', defaultTitle: 'Shop.pr', defaultActionURL: 'https://www.shop.pr/?source=web-push', appKey: 'QZJViSGWQam0BEIUjuoL0w', token: 'MTpRWkpWaVNHV1FhbTBCRUlVanVvTDB3Okh4SVlLR0EtNkxyZXlpYjJoVHF0RnF5bmdOdXhDUHU0OGVTYWhaOU1nX2c', vapidPublicKey: 'BOuHdiv-vrx6Oo4Y6ZKjLhEEWdgbQcjxmlLFZ5foHUM9jjelySLAVIC3U-UXfxW2Wt63mY8yOAXuZ5YyYi7wiXc=' });```
742	merkur.si.js	External Script Loading Without Validation	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, as in this case, it does not inherently introduce dynamic risk. However, the vulnerability arises because the script is loaded from an external, third-party domain (pushpushgo.com) without validation or integrity checks. While the URL is not dynamically constructed from untrusted input, the lack of validation or origin trust makes it a high-risk practice, especially if the external script can be tampered with or replaced. This constitutes misuse of a sensitive function due to lack of security controls, even if the input is static.}	```importScripts('https://s-eu-1.pushpushgo.com/64ccdd18e97893feb569a833/worker.js');```
743	intersport.fi.js	Improper Handling of Fallback Network Requests	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of fallback network requests during fetch operations, but no sensitive function misuse is directly involved. The code attempts to fetch a resource and falls back to a cached version if unavailable, but the logic does not validate or sanitize the request URL or handle errors securely.}	```return e.next = 10```
744	intersport.fi.js	Insecure Caching of Sensitive Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from insecure caching practices, particularly in how responses are stored and retrieved without sufficient integrity checks or access controls. However, no sensitive JavaScript function like importScripts() or eval() is misused; the issue lies in the caching logic itself.}	```return e.next = 23```
745	intersport.fi.js	Insufficient Validation of URL Parameters	Low	false	N/A	N/A	N/A	N/A	{The code processes URL parameters via the $(c) function, which removes certain query parameters (e.g., utm_). However, this function is custom and does not involve misuse of a sensitive JavaScript function like eval or importScripts. The issue is more about insufficient sanitization rather than sensitive function misuse.}	```var u = $(c```
746	gggolf.ca.js	Debug Mode Enabled in Production	Medium	false	N/A	N/A	N/A	N/A	{Debug mode is enabled via `pwaSettings.debug = true;`, which exposes detailed logs in the console. While this is not caused by misuse of a sensitive function, it increases the attack surface by leaking internal information.}	```pwaSettings.debug = true;```
747	gggolf.ca.js	Insecure Message Handling for Cache Deletion	High	true	N/A	N/A	self.addEventListener	standard	{The `self.addEventListener('message', ...)` handler processes messages from the page without validating or sanitizing the incoming data. While it does not directly use a sensitive function like `eval` or `importScripts`, the event handler itself is a standard API that can be misused to expose internal state or allow unauthorized cache manipulation if not properly secured. The lack of input validation makes it vulnerable to unintended behavior or cache deletion by malicious pages.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
748	oficialfarma.com.br.js	Insecure Request Validation via Substring Matching	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from using substring matching (includes()) on request URLs to filter specific domains, which is insufficient for secure validation. This approach is not inherently caused by misuse of a sensitive function but rather by a flawed logic design. The includes() method is a standard string method and not a sensitive function in the context of security risks like code injection or arbitrary code execution.}	```if (params.event.request.url.includes('googletagmanager.com') || params.event.request.url.includes('google-analytics') || params.event.request.url.includes('gtm.js') || params.event.request.url.includes('facebook.com') || params.event.request.url.includes('facebook.net')) {```
749	tektaportal.ru.js	XSS in Error Response Handling	High	true	CWE-79	9	N/A	standard	"{The vulnerability arises from the use of the `replace` method on a string that is constructed from user-controlled error messages (via `T` function, which performs string replacement and escaping). The `replace` method is used to insert the error text into an HTML template (`e.replace(""{errorText}"", d)`), and if the error text contains unescaped HTML or JavaScript, it can be injected into the response body. Since this response is served as HTML (via `new Response(e, {headers: f.headers})`), it can lead to reflected XSS when rendered by the browser. The `T` function performs basic escaping (single quotes and newlines), but it does not sanitize or escape all HTML/JS context, making it insufficient for safe HTML output.}"	"```return e.replace(""{errorText}"", d = T(T(l, ""'"", ""\\'""), ""\n"", ""\\n""))```"
750	designmag.it.js	Server Side Request Forgery (SSRF) via unvalidated URL in push event	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from the 'sensor' field in the push message data. Since this input is not validated or sanitized, an attacker can supply a malicious URL (e.g., internal network resources or external domains), leading to SSRF. The function fetch is a standard JavaScript API that executes HTTP requests, and when given untrusted input, it can be exploited to access unintended resources.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.designmag.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
751	designmag.it.js	Open Redirect via unvalidated URL in notificationclick event	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used with a URL derived from the 'url' field in the notification data. Since this input is not validated or sanitized, an attacker can supply a malicious URL, leading to an open redirect. The function clients.openWindow is a standard Service Worker API that opens a new browser window or tab, and when given untrusted input, it can be exploited to redirect users to phishing or malicious sites.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.designmag.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```
752	bingo.com.js	Improper Access Control in Mock Service Worker	High	true	CWE-862	9	N/A	standard	"{The service worker listens for messages and processes them without validating the sender or message origin. The `self.addEventListener(""message"", ...)` function is used to handle messages, and the code directly executes actions like `MOCK_ACTIVATE` or `MOCK_DEACTIVATE` based on untrusted `s.data` values. Since no authentication or authorization is enforced, an attacker can send malicious messages to enable mocking, potentially leading to unauthorized behavior or data manipulation.}"	```if (s.data) { switch (s.data) { case 'KEEPALIVE_REQUEST': t(a, { type: 'KEEPALIVE_RESPONSE' }); break; case 'INTEGRITY_CHECK_REQUEST': t(a, { type: 'INTEGRITY_CHECK_RESPONSE', payload: { packageVersion: '2.4.8', checksum: '26357c79639bfa20d64c0efca2a87423' } }); break; case 'MOCK_ACTIVATE': b.add(n), t(a, { type: 'MOCKING_ENABLED', payload: !0 }); break; case 'MOCK_DEACTIVATE': b.delete(n); break; case 'CLIENT_CLOSED': { b.delete(n); const t = r.filter(e => e.id !== n); 0 === t.length && e.registration.unregister(); break; } } }```
753	bingo.com.js	Insecure Cache Cleaning Logic	Medium	true	CWE-862	8	N/A	standard	"{The `C.addEventListener(""message"", ...)` function is used to handle messages, and when the message type is `CLEAN_CACHE`, it calls `S(e.data.payload)` without validating the payload. The `S` function then uses `C.caches.open(R)` and `await t.keys()` to delete cache entries based on the provided payload. Since the payload is derived from untrusted input, an attacker could supply malicious data to delete arbitrary cache entries, leading to cache poisoning or denial of service.}"	```C.addEventListener('message', e => { var t; switch (null === (t = e.data) || void 0 === t ? void 0 : t.type) { case 'SKIP_WAITING': e.waitUntil((async () => { await C.skipWaiting(), await C.clients.claim(); })()); break; case 'CLEAN_CACHE': S(e.data.payload); break; case 'RENDER_IN_SW': break; default: k.includes(e.data) || console.warn('[kwp-sw]', 'Unknown message type: ', e.data); } });```
754	bingo.com.js	Insecure Message Handling in Cache Listener	Medium	true	CWE-862	8	N/A	standard	"{The `self.addEventListener(""message"", ...)` function is used to handle messages, and the code processes `s.data` without validating its origin or content. The `switch (s.data)` statement directly executes actions like `KEEPALIVE_REQUEST` or `MOCK_ACTIVATE` based on untrusted input. Since no sender validation or message integrity checks are performed, an attacker can send arbitrary messages to trigger unintended behavior, such as enabling mocking or unregistering the service worker.}"	```self.addEventListener('message', function (s) { const { request: t } = s; if (!t || !e.clients) return; const r = await e.clients.get(n); if (!r) return; const i = await e.clients.matchAll({ type: 'window' }); switch (s.data) { case 'KEEPALIVE_REQUEST': t(a, { type: 'KEEPALIVE_RESPONSE' }); break; ... } });```
755	buttalapasta.it.js	Server Side Request Forgery (SSRF) via unvalidated URL in push event	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (body.data.sensor and body.data.push_send_id). Since these values are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.pourfemme.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
756	buttalapasta.it.js	Server Side Request Forgery (SSRF) via unvalidated URL in notificationclick event	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (event.notification.data.sensor and event.notification.data.push_send_id). Since these values are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.pourfemme.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {});```
757	buttalapasta.it.js	Open Redirect via unvalidated URL in notificationclick event	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted input (event.notification.data.url). Since this value is not validated or sanitized, an attacker can manipulate it to redirect users to arbitrary external sites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
758	wiza.co.js	Insecure Direct Object Reference (IDOR) via Message Event	High	true	CWE-20	8	new URL	standard	{The new URL constructor is used with user-supplied input from the message event's 't.base' parameter, which is not validated or sanitized. This allows an attacker to craft a malicious base URL that could lead to unauthorized access to resources or unintended behavior, such as accessing internal paths or bypassing access controls. The use of e.origin as the base does not prevent this if 't.base' contains path traversal or other malicious components.}	```const o = new URL(t.base, e.origin);```
759	thetandd.com.js	Open Redirect via Untrusted URL in Notification Data	High	true	CWE-601	10	N/A	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from untrusted notification payload data. Since this URL is later passed to `self.clients.openWindow()` without validation or sanitization, an attacker can craft a malicious URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```let oURL = new URL(oData.url);```
760	olhonavaga.com.br.js	XSS via Unsanitized Push Notification Data	High	true	CWE-79	10	"const options = { body: data.body"""	standard	{The importScripts function is not directly involved in the XSS vulnerability. However, the vulnerability arises from unsanitized user-controlled data (data.body) being used in push notification content, which can lead to XSS if the notification content is rendered in a context where it is not properly escaped. The function responsible for the XSS is not importScripts, but rather the implicit rendering of notification content. Since the vulnerability is not caused by a sensitive function misuse, this entry should be marked as false.}	N/A
761	olhonavaga.com.br.js	SSRF in Fetch Event Handler	High	false	CWE-918	10	event.respondWith(fetch(event.request).catch(error => { if (!reloadInitiated) { reloadInitiated = true; self.clients.matchAll({ includeUncontrolled: true	standard	{The SSRF vulnerability arises from the use of fetch with event.request, which is derived from user input. However, the fetch function itself is not misused in a way that directly causes SSRF; the vulnerability is due to the lack of validation on the request URL. Since the fetch function is used correctly but the input is untrusted, this is not a sensitive function misuse.}	N/A
762	olhonavaga.com.br.js	Cache Versioning Logic Flaw	Medium	false	CWE-369	10	if (cacheName.includes(`${cacheSufixString}`) && cacheName.substring(cacheName.indexOf(`${cacheSufixString}`) + `${cacheSufixString}`.length) < `${cacheSufixNumber}`) { caches.delete(cacheName); }	standard	{The vulnerability is a logic flaw in cache versioning, not a misuse of a sensitive function. The caches.delete function is used correctly, but the logic for determining which caches to delete is flawed. This is not a sensitive function misuse.}	N/A
763	olhonavaga.com.br.js	Supply Chain Risk via External importScripts	Low	true	CWE-496	10	importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js'); importScripts('/javax.faces.resource/analytics-helper.js.xhtml?ln=javascript');	standard	{The importScripts function is used to load external scripts from untrusted sources. This is a direct misuse of a sensitive function, as it allows execution of arbitrary code from external domains, leading to supply chain risk.}	N/A
764	olhonavaga.com.br.js	Supply Chain Risk via External importScripts	Low	true	CWE-496	10	importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js'); importScripts('/javax.faces.resource/analytics-helper.js.xhtml?ln=javascript');	standard	{The importScripts function is used to load external scripts from untrusted sources. This is a direct misuse of a sensitive function, as it allows execution of arbitrary code from external domains, leading to supply chain risk.}	N/A
765	olhonavaga.com.br.js	Supply Chain Risk via External importScripts	Low	true	CWE-496	10	importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js'); importScripts('/javax.faces.resource/analytics-helper.js.xhtml?ln=javascript');	standard	{The importScripts function is used to load external scripts from untrusted sources. This is a direct misuse of a sensitive function, as it allows execution of arbitrary code from external domains, leading to supply chain risk.}	N/A
766	needsoftelangana.com.js	Open Redirect via Notification Data	Medium	true	CWE-602	9	N/A	standard	{The function `clients.openWindow(targetUrl)` is used with `targetUrl` derived from `event.notification.data.url` or `event.notification.data.actions[event.action].click_action`, which are untrusted inputs from push notification payloads. Since these values are not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
767	needsoftelangana.com.js	Server Side Request Forgery via Notification Data	Medium	true	CWE-919	9	N/A	standard	{The function `fetch(apiUrl)` is used with `apiUrl` derived from `event.notification.data.api_url` or `event.notification.data.actions[event.action].api_url`, which are untrusted inputs from push notification payloads. Since these values are not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the service worker to make HTTP requests to arbitrary endpoints, leading to SSRF.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
768	paperearn.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data, including the API key, directly in the client-side JavaScript. This is not caused by misuse of a sensitive function, but rather by exposing credentials in source code.}	```const options = { firebaseConfig: { projectId: 'paperearn-ebd40', messagingSenderId: '75812869948', appId: '1:75812869948:web:a5924bd40ee85b67ef7039', apiKey: 'AIzaSyApeyirjP0HxgJ_6ZllLzoKPCylSYohBGY' }, domain: 'paperearn.com', api_url: 'https://push.hindikaro.com/api/token', vapid_public_key: 'BCSGlh6HB1Bu14PlLo8tDJRALLl18xOEmZYOjm5qO4M6S5CVL0oXLrjoCmqEiawpDMPJSOuJaJSGuKeyl0br2Ww' };```
769	paperearn.com.js	Open Redirect Vulnerability	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is controlled by the server or attacker. Since the URL is not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to phishing or malicious redirection.}	```clients.openWindow(targetUrl);```
770	paperearn.com.js	Unvalidated External API Request	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamic apiUrl derived from notification data, which is controlled by the server or attacker. Without validation or sanitization, this allows an attacker to redirect API requests to arbitrary endpoints, potentially exfiltrating data or performing unintended actions.}	```fetch(apiUrl);```
771	paperearn.com.js	Service Worker Update Triggered by Untrusted Payload	Medium	true	N/A	N/A	self.registration.update	standard	{The self.registration.update function is triggered based on a swVersion value received from the push notification payload. Since this value is untrusted and can be manipulated by an attacker, it allows forced updates to the service worker, potentially leading to code injection or execution of malicious code.}	```if (event.data.json().data.swVersion != swVersion) { console.log('SW Version is different, Updating SW'); self.registration.update(); }```
772	ssoidrajasthan.co.js	Exposure of Sensitive Information in Log Files	Medium	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from logging the Firebase API key in the code, which is a hardcoded sensitive credential. This is not caused by misuse of a sensitive JavaScript function, but rather by poor secret management.}	```const apiKey: 'AIzaSyB5mRat6F9rakJQkM9jGXcTOlynyyYRs4U'```
773	ssoidrajasthan.co.js	Open Redirect	High	true	CWE-601	N/A	clients.openWindow	N/A	{The function clients.openWindow is used with a dynamic targetUrl derived from event.notification.data.url, which is user-controlled. This allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
774	ssoidrajasthan.co.js	Insecure Data Storage	Medium	false	CWE-311	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption or additional security controls. This is not due to misuse of a sensitive function, but rather insecure storage practices.}	```const request = indexedDB.open('larapushDataBase', 1);```
775	ssoidrajasthan.co.js	Server-Side Request Forgery (SSRF)	Medium	true	CWE-918	N/A	new URL	N/A	{The function new URL is used with a user-controlled URL parameter, which can be manipulated to perform SSRF attacks by redirecting requests to internal or unintended endpoints.}	```const urlObj = new URL(url);```
776	tamilneeds24.in.js	Exposed API Key	High	false	CWE-532	N/A	N/A	N/A	{The API key is hardcoded in the script and exposed in the source code, but it is not a result of misuse of a sensitive function. It is a static exposure.}	```firebase.initializeApp({ ...options.firebaseConfig });```
777	tamilneeds24.in.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The JSON.parse() call is used on data from event.data.json().data.notification, which is derived from a push event. While this involves untrusted input, the vulnerability is due to lack of validation of the parsed data, not misuse of a sensitive function like eval or Function.}	```const payload = JSON.parse(event.data.json().data.notification);```
778	tamilneeds24.in.js	Open Redirect	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow(targetUrl) function is called with targetUrl derived from event.notification.data.url, which is untrusted input from a push notification. This allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerability.}	```clients.openWindow(targetUrl);```
779	wegwannews.com.js	Exposure of Sensitive Information in Client-Side Code	High	true	CWE-532	9	const options = { firebaseConfig: { projectId: 'push-665ea'	custom	{The sensitive function responsible is not directly a function, but the exposure occurs because sensitive data (API key, project ID, etc.) is hardcoded in the client-side service worker script. This allows attackers to extract credentials directly from the source code, enabling unauthorized access to Firebase services.}	```const options = { firebaseConfig: { projectId: 'push-665ea', messagingSenderId: '700714459479', appId: '1:700714459479:web:0c48269c44b0825abc9e12', apiKey: 'AIzaSyCcb6wd1KZmXcM0veQcWDVwsVf-NYAx3ss' }, domain: 'wegwannews.com', api_url: 'https://push.wegwannews.com/api/token', vapid_public_key: 'BP66z4_KmBNukPsWgP7fkqmpJ1LP-rJZYTc-46iSYwaXaJWPeCfQmRlpkO6WQZE0ghfoG7NKKUde0ji3oohLioc' };```
780	wegwannews.com.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	8	clients.openWindow(targetUrl);	standard	{The sensitive function clients.openWindow() is used with a dynamic URL derived from event.notification.data.url, which is controlled by the server or attacker via push notifications. This allows an attacker to craft a notification payload that redirects users to arbitrary websites, leading to phishing or malicious redirection.}	```clients.openWindow(targetUrl);```
781	wegwannews.com.js	Storage of Sensitive Information in Client-Side without Encryption	Medium	true	CWE-311	7	await this.writeData('notification_token'	custom	{The sensitive function writeData() is used to store the Firebase notification token in IndexedDB without encryption. Since IndexedDB is accessible via JavaScript and can be accessed by malicious scripts or attackers with local access, this exposes sensitive tokens that can be used to send unauthorized push notifications.}	"```await this.writeData(""notification_token"", token);```"
782	weshrak.com.js	Improper Input Validation (Referrer Check Bypass	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in the referrer check, not from misuse of a sensitive function. The condition `!event.request.referrer.includes('advertise')` is vulnerable to bypass if the referrer is manipulated or absent, but no sensitive function is being misused here.}	"```if (event.request.mode === 'navigate' && !event.request.referrer.includes(""advertise"")) {```"
783	weshrak.com.js	Open Redirect via Untrusted Notification Data	High	true	CWE-601	N/A	clients.openWindow	standard	{The `clients.openWindow(url)` function is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from untrusted notification data (`event.notification.data.url`), it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(url));```
784	weshrak.com.js	Dynamic Cache URL Construction Without Sanitization	Medium	true	CWE-917	N/A	new Request	standard	{The `new Request()` constructor is used with a dynamically constructed URL (`OFFLINE_URL + '&lang=' + langue`), where `langue` is derived from the URL search parameters. Since the input is unsanitized, an attacker could inject malicious query parameters, potentially leading to unintended cache behavior or resource fetching.}	```await cache.add(new Request(OFFLINE_URL + '&lang=' + langue, { cache: 'reload' }));```
785	apotheek.nl.js	Improper Input Validation Leading to Sensitive Data Caching	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper validation of URLs against a list of exceptions, but no sensitive JavaScript function is misused. The code uses standard string operations (indexOf, filter) on the URL, which are not inherently dangerous when used with trusted or properly sanitized inputs. The issue is more about logic flaws in exception handling rather than misuse of a sensitive function.}	```const isException = exceptions.filter(exception => url.indexOf(exception) !== -1).length && url.indexOf('/cms/sites/default/files/') === -1;```
786	lekmanga.org.js	Improper URL Filtering Leading to Sensitive Data Caching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper URL filtering logic in the fetch event handler, which does not adequately prevent caching of sensitive or unintended URLs. However, this is not due to misuse of a sensitive JavaScript function, but rather flawed business logic in URL matching and exclusion.}	```self.addEventListener('fetch', function (e) { if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; } if (!e.request.url.match(/^(http|https):\/\//i)) return; if (new URL(e.request.url).origin !== location.origin) return; if (e.request.method !== 'GET') { e.respondWith(fetch(e.request).catch(function () { return caches.match(offlinePage); })); return; } if (e.request.headers.has('range')) { return; } if ((e.request.mode === 'navigate' || e.request.mode === 'cors') && navigator.onLine) { e.respondWith(fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }).catch(function () { return cache.match(e.request.url); })); return; } e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }); }).catch(function () { return caches.match(offlinePage); })); });```
787	lekmanga.org.js	Incorrect Regex Matching in URL Exclusion Logic	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from incorrect use of the `every` method with `checkNeverCacheList`, where `this` is not properly bound to the regex patterns in `neverCacheUrls`. This leads to flawed exclusion logic, but it is not caused by misuse of a sensitive JavaScript function such as `importScripts` or `eval`.}	```function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
788	sovren.media.js	External Script Import Vulnerability	High	true	N/A	9	importScripts	standard	{The importScripts() function is used to load and execute an external script from a remote URL ('https://cdn.webpushr.com/sw-server.min.js'). While the URL is hardcoded, the vulnerability arises because the script is loaded from an external source without verification or integrity checks, potentially allowing an attacker to compromise the CDN or inject malicious code. This constitutes a sensitive function misuse due to the trust placed in an external script without validation.}	```importScripts('https://cdn.webpushr.com/sw-server.min.js');```
789	sovren.media.js	Cached Offline Page Without Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from serving a cached offline page without validating its integrity or freshness. However, this is not caused by misuse of a sensitive function, but rather by a design flaw in offline handling. No sensitive function like eval, importScripts, or unsafe dynamic code execution is involved.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
790	booqcloud.com.js	Improper Input Validation in Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The cacheBust function appends a random string to a URL, but it does not validate or sanitize the input URL. While this does not directly involve a sensitive function, it can lead to unintended behavior if the URL contains malicious or malformed components, such as injection of unexpected query parameters or path traversal. However, since no sensitive JavaScript function (like eval, importScripts, etc.) is misused, this is not a sensitive function vulnerability.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
791	booqcloud.com.js	Insecure Hash Function (SHA	High	false	N/A	N/A	N/A	N/A	{The use of SHA-1 is a cryptographic weakness, not a misuse of a sensitive JavaScript function. SHA-1 is deprecated due to collision vulnerabilities, but it is not inherently dangerous when used in non-cryptographic contexts (e.g., for content hashing). Since no sensitive function like eval or importScripts is involved, this is not a sensitive function vulnerability.}	```function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8```
792	booqcloud.com.js	Insufficient Error Handling in Safe Fetch	Medium	false	N/A	N/A	N/A	N/A	{The safeFetch function catches errors and returns a 504 response, but it does not log or handle the error in a way that prevents information leakage or allows attackers to infer internal state. However, this does not involve misuse of a sensitive function such as eval or importScripts. The vulnerability stems from poor error handling, not sensitive function misuse.}	```async safeFetch(req) { try { return await this.scope.fetch(req); } catch (err) { return this.adapter.newResponse(null```
793	booqcloud.com.js	Improper Validation of URL in Navigation Requests	Medium	false	N/A	N/A	```isNavigationRequest(req) { if (req.method !== 'GET' || req.mode !== 'navigate') { return false; } if (!this.acceptsTextHtml(req)) { return false; } const urlPrefix = this.scope.registration.scope.replace(/\/$/	N/A	{The isNavigationRequest function validates navigation requests based on method, mode, and Accept header, but it does not validate the URL structure or origin. While this could allow unintended navigation to malicious URLs, it does not involve misuse of a sensitive JavaScript function like importScripts or eval. The vulnerability is due to insufficient URL validation, not sensitive function misuse.}	N/A
794	booqcloud.com.js	Insecure Direct Object Reference in Cache Management	High	false	N/A	N/A	N/A	N/A	{The getCacheNames function retrieves cache names from various groups, but it does not validate or sanitize the cache names before returning them. While this could lead to information disclosure or cache manipulation, it does not involve misuse of a sensitive JavaScript function such as importScripts or eval. The vulnerability is due to improper access control, not sensitive function misuse.}	```async getCacheNames() { const allGroupCacheNames = await Promise.all([...this.assetGroups.map(group => group.getCacheNames())```
795	footballteamgame.com.js	Insecure Service Worker Message Handling	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of incoming messages in the service worker, specifically the lack of validation or sanitization of the message data before invoking `self.skipWaiting()`. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a logic flaw in message handling. The `addEventListener` is used correctly, and no dynamic or untrusted input is passed to a sensitive function.}	"```self.addEventListener(""message"", n => { n.data && ""SKIP_WAITING"" === n.data.type && self.skipWaiting(); })```"
796	footballteamgame.com.js	Misconfigured Navigation Route	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from a misconfiguration in the navigation route, where `n.createHandlerBoundToURL('/')` is used to handle all navigation requests. This is not caused by misuse of a sensitive function, but rather by a design decision that may lead to unintended behavior or caching issues. The `registerRoute` and `createHandlerBoundToURL` functions are used as intended, with no untrusted or dynamic input involved.}	"```n.registerRoute(new n.NavigationRoute(n.createHandlerBoundToURL(""/"")));```"
797	ifinnmark.no.js	Incorrect Host Check in Navigation Route Handling	Medium	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from a flawed host check using a string literal with single quotes embedded in the code: `req.url.host.indexOf(""'www.ifinnmark.no'"") !== -1`. This is not a sensitive function misuse but a logic error in string comparison, as the literal string includes quotes that may not be properly escaped or interpreted, potentially leading to incorrect matching.}"	```const pattern4 = req => req.event.request.mode === 'navigate' && req.url.pathname === '/' && req.url.host.indexOf('\'www.ifinnmark.no\'') !== -1 && req.event.request.method === 'GET';```
798	ifinnmark.no.js	Insecure Message Handling in Cache Warming	High	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener function is misused by accepting arbitrary message types and data from the client without validation. The event.data.type is checked, but the message3 payload is passed directly to handler2 and handler functions without sanitization or type enforcement, allowing an attacker to inject malicious data or trigger unintended behavior via the message event.}	"```self.addEventListener(""message"", event => { if (!event.data.type) { return; } const message3 = event.data.message || null; switch (event.data.type) { case message2: handler2(event, message3); break; case message: handler(event, message3); break; default: break; } });```"
799	ifinnmark.no.js	Cache Poisoning via Unvalidated Response Headers	Medium	true	N/A	N/A	Response	standard	{The Response constructor is misused by directly reusing headers from an untrusted response without validation. The code copies all headers, including potentially malicious ones like 'x-emergency-mode', which is then used to modify the global self.emergencyMode array. This allows an attacker to inject arbitrary values into the service worker's state via crafted responses, leading to cache poisoning or unexpected behavior.}	```async function cacheWillUpdate({ response }) { const init = { status: response.status, statusText: response.statusText, headers: {} }; response.headers.forEach((val, key) => { init.headers[key] = val; }); if (init.headers.vary) { init.headers.vary = init.headers.vary.split(',').filter(h => h.trim().toLowerCase() !== 'user-agent').join(','); } self.emergencyMode = (init.headers['x-emergency-mode'] || '').split(','); const body = await response.text(); return new Response(body, init); }```
800	shohoz.com.js	Use of Weak Cryptographic Algorithm	High	true	CWE-327	10	sha1	standard	{The function sha1 is used to compute hashes for manifest files, which is a weak cryptographic algorithm vulnerable to collision attacks. This allows an attacker to craft a malicious manifest with the same hash as a legitimate one, leading to potential code injection or unauthorized updates.}	N/A
801	shohoz.com.js	Exposure of Debug/Testing Entry Points	Medium	false	N/A	0	N/A	N/A	{The code checks for 'ngsw-bypass' in headers or URL search parameters to skip service worker processing, but this is not a sensitive function misuse—it’s a feature flag. The vulnerability arises from exposing this debug endpoint, not from improper use of a sensitive function.}	N/A
802	shohoz.com.js	Improper Neutralization of Input in Notification Handling	Medium	true	CWE-79	8	showNotification	standard	{The function showNotification is used with user-controlled data from the push message payload (desc['title'] and options). If an attacker can control the notification content, they can inject malicious content (e.g., script tags in HTML if rendered in a context that allows it), leading to cross-site scripting or phishing attacks.}	N/A
803	androidp1.com.js	Cache Poisoning via Unvalidated Message URLs	High	true	CWE-434	9	N/A	standard	{The service worker listens for messages and uses the `cache.add()` method with a URL derived from `event.data.src`, which is user-controlled. Since no validation is performed on the source URL, an attacker can inject arbitrary URLs into the cache, leading to cache poisoning and potential execution of malicious content.}	```self.addEventListener('message', function (event) { if (event.data.action === 'fetch') { cache.then(cache => { cache.keys(event.data.src).then(e => { if (e.length === 0) { cache.add(event.data.src).catch(() => { event.source.postMessage({'fetchReady': true, 's': 2, 'src': event.data.src, 'el': event.data.el}); }).then(() => { event.source.postMessage({'fetchReady': true, 's': 1, 'src': event.data.src, 'el': event.data.el}); }); } else { event.source.postMessage({'fetchReady': true, 's': 1, 'src': event.data.src, 'el': event.data.el}); } }); }); return; } event.source.postMessage({'fetchReady': false, 'msg': 'normal respond'}); evSource = event.source;})```
804	androidp1.com.js	Insecure No-CORS Request Handling	Medium	true	CWE-829	8	N/A	standard	{The code creates a `Request` object with `mode: 'no-cors'` for resources that are not in the cache. This bypasses CORS checks, allowing the service worker to fetch resources from any origin without validation, which can lead to unintended data exposure or fetching of malicious content from untrusted origins.}	```if (!cachedResponse) { var request = new Request(event.request.url, { mode: 'no-cors' }); if (request) { await cacheReady.add(request); cachedResponse = await cacheReady.match(request); } }```
805	androidp1.com.js	Cross-Origin Precache Misconfiguration	Medium	true	CWE-434	9	N/A	standard	{The `precache()` function adds a resource from `https://www.prontoprint.com.ua`, which is a third-party origin. Since the service worker caches this external resource without validating its origin or integrity, it introduces a risk of cache poisoning or loading malicious scripts from an untrusted domain.}	"```function precache() { return cache.then(function (cache) { return cache.addAll([""https://www.prontoprint.com.ua/v2/wp-includes/js/jquery/jquery.js?ver=1.12.4-wp""]).then(postMsg); }); }```"
806	temporadalivre.com.js	Open Redirect via Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from notification data, which is derived from untrusted push message data. Since the URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, causing the browser to open an unintended site, leading to an open redirect vulnerability.}	```if (clients.openWindow) return clients.openWindow(t);```
807	3d66.com.js	Incomplete Service Worker Fetch Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the service worker not implementing a complete fetch handler logic, which may lead to unintended behavior or security issues when handling network requests. However, this is not due to misuse of a sensitive JavaScript function, but rather due to incomplete or missing logic in the fetch event handler.}	```self.addEventListener('fetch', function (e) {});```
808	altotieteweb.com.br.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection, cache manipulation, or network interception. In this case, the script is loaded from a third-party CDN without any validation, making it vulnerable to supply chain attacks if the CDN is compromised.}	"```importScripts(""https://cdn.pushalert.co/sw-30304.js"");```"
809	thesocialkhabar.in.js	Exposure of Sensitive Information in Service Worker	High	true	CWE-532	10	N/A	standard	{The sensitive function responsible is not directly a function call but the exposure of hardcoded credentials in the `options` object. However, since the `firebase.initializeApp()` function is used to initialize Firebase with these credentials, and the credentials are passed directly without sanitization or obfuscation, this constitutes misuse of a standard API. The `apiKey` and other Firebase config values are exposed in the service worker script, which can be accessed by any user, leading to potential abuse such as unauthorized access to Firebase services.}	```const options = { firebaseConfig: { projectId: 'push-408ab', messagingSenderId: '998381378980', appId: '1:998381378980:web:e2dff8160af83b1caeb531', apiKey: 'AIzaSyC5bmVrR32QKytgsEdHuv8ha103cjf6EXM' }, domain: 'thesocialkhabar.in', api_url: 'https://dn24.co.in/api/token', vapid_public_key: 'BMCbWTz8hwO8sU8qsfcvALLnmRghAuC7xRBa4dkXDSdWxw3Dvx6IINTUMrt-MIEc-bz2a72Z0M65cwqziPH1mIw' };```
810	thesocialkhabar.in.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	9	N/A	standard	{The `clients.openWindow(targetUrl)` function is a standard service worker API that opens a new window or tab with the provided URL. The `targetUrl` is derived from `event.notification.data.url`, which is user-controlled via push notifications. Since no validation or sanitization is performed on `targetUrl`, an attacker can craft a push notification with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or malicious domains.}	```clients.openWindow(targetUrl);```
811	thesocialkhabar.in.js	Improper Input Validation in Push Payload	Medium	true	CWE-20	8	N/A	standard	{The `JSON.parse(event.data.json().data.notification)` function parses JSON data from a push notification payload. The `event.data.json().data.notification` is user-controlled and not validated or sanitized before being parsed. This allows an attacker to inject malicious JSON structures that could lead to unexpected behavior, such as triggering unintended logic or causing errors in the service worker.}	```const payload = JSON.parse(event.data.json().data.notification);```
812	thesocialkhabar.in.js	Exposure of Sensitive Subscription Data	High	true	CWE-311	9	N/A	standard	{The `fetch()` function is used to send sensitive subscription data (including `token`, `endpoint`, `auth`, and `p256dh`) to a remote server. The data is derived from `self.registration.pushManager.getSubscription()` and is sent without encryption or proper access controls. Since the `fetch()` call is made with user-controlled `url` (via `domain` and `url` parameters), and the data is sent in plaintext, this exposes sensitive subscription information to potential interception or misuse.}	```body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh })```
813	thesocialkhabar.in.js	Server Side Request Forgery (SSRF) Risk	Medium	true	CWE-918	8	N/A	standard	{The `fetch(apiUrl)` function is called with `apiUrl` derived from `event.notification.data.api_url`, which is user-controlled via push notifications. Since no validation or sanitization is performed on `apiUrl`, an attacker can craft a push notification to make the service worker fetch from an arbitrary internal or external endpoint, potentially leading to SSRF attacks where internal services are accessed or data is exfiltrated.}	```fetch(apiUrl);```
814	salsajeans.com.js	Improper Session Management	Medium	false	CWE-285	N/A	N/A	N/A	{The vulnerability arises from logic that conditionally fetches or caches resources based on session state, but does not properly validate or sanitize session-related data. This is not caused by misuse of a sensitive JavaScript function, but rather by flawed session handling logic.}	```if (!isSessionActive) { return fetchAndCache(event.request); } else { return caches.match(event.request).then(response => { return response || fetchAndCache(event.request); }); }```
815	salsajeans.com.js	Improper Preservation of Object References	High	true	CWE-921	N/A	caches.open	standard	{The caches.open() function is used to open a cache by name, and while the cache name is hard-coded (CACHE_NAME), the vulnerability stems from improper handling of cache references. However, since the cache name is not derived from untrusted input, the function misuse is not directly exploitable via injection. The issue lies in the broader context of object reference management, not dynamic input-driven misuse.}	```caches.open(CACHE_NAME).then(cache => { cache.put(request, responseClone); });```
816	gazettetimes.com.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-602	9	self.clients.openWindow	standard	{The function self.clients.openWindow is a standard service worker API that opens a new browser window or tab with the provided URL. In this case, the URL is constructed from oData.url, which originates from untrusted notification payload data. Since no validation or sanitization is performed on oData.url, an attacker can craft a notification payload with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. The use of oURL.searchParams.set further modifies the URL with UTM parameters, which are also derived from untrusted data, increasing the risk of manipulation.}	```let oURL = new URL(oData.url); if (oData.utm_source && oData.utm_medium && oData.utm_campaign) { oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign); } if (self.clients.openWindow) { return self.clients.openWindow(oURL.toString()); }```
817	bosch-stiftung.de.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection, data exfiltration, or full compromise of the service worker's execution context. In this case, the script is imported from 'https://api.signalize.com/sw.js', which is an external, potentially untrusted source, and no integrity verification (e.g., via Subresource Integrity) is applied.}	"```importScripts(""https://api.signalize.com/sw.js"");```"
818	fcporto.pt.js	External Script Import Without Integrity Check	High	true	CWE-940	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows an attacker to compromise the script source (e.g., via DNS spoofing, man-in-the-middle attacks, or compromised CDN) and inject malicious code into the service worker. This leads to full control over the service worker’s behavior, including intercepting network requests, manipulating cache, and potentially stealing sensitive data. The URL is hardcoded, but the lack of integrity verification still constitutes a high-risk vulnerability because the script source is external and not verified.}	```importScripts('https://cdn.pushwoosh.com/webpush/v3/pushwoosh-service-worker.js');```
819	gabor.com.js	Insecure Regular Expression Leading to Cache Poisoning	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from an insecure regular expression used to identify font files, which may allow attackers to bypass filtering and cache malicious content. However, no sensitive JavaScript function is misused here; the issue is purely in regex logic.}	```const isFont = request => request.destination === 'font' || request.url.match(/.*\.(woff|woff2|ttf|otf|eot)\??[^\/]*$/i);```
820	gabor.com.js	XSS via Unvalidated postMessage Cookie Setting	High	true	N/A	N/A	postMessage	standard	{The postMessage function is used to send a message to a client with a hardcoded cookie name and value. While the data is not dynamic, the vulnerability stems from the fact that this message could be exploited if the client’s context is compromised or if the message is intercepted and misused in a broader XSS context. However, since the data is static and not derived from untrusted input, the misuse is minimal.}	```client.postMessage({ eventName: 'setCookie', data: { name: 'inlinecss-loaded', value: 'true' } });```
821	gabor.com.js	Insecure Cache Busting Regex Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to an insecure regular expression used to detect cache-busted URLs, which may allow bypassing of cache logic. No sensitive JavaScript function is involved in this issue.}	```const isCacheBustedFile = request => request.url.match(/cache-buster-\d*\//);```
822	gabor.com.js	Unvalidated Cache Update with External Resources	Medium	true	N/A	N/A	cache.put	standard	{The cache.put function is used to store responses in the cache without validating whether the request or response is from a trusted source. Since the cacheName parameter can be derived from event.request (which is user-controlled via fetch), this allows potential cache poisoning if an attacker can trigger a fetch for a malicious resource.}	```var responseToCache = response.clone(); caches.open(CACHE_NAME).then(function (cache) { cache.put(cacheName || event.request, responseToCache); });```
823	gabor.com.js	Missing Error Handling in Async Operations	Low	false	N/A	N/A	N/A	N/A	{The async operation lacks proper error handling, which could lead to uncaught exceptions. However, no sensitive JavaScript function is misused here; the issue is related to robustness, not security.}	```event.waitUntil(async function () { if (!event.clientId) return; const client = await clients.get(event.clientId); if (!client) return; client.postMessage({ eventName: 'setCookie', data: { name: 'inlinecss-loaded', value: 'true' } }); }());```
824	healthecareers.com.js	Insecure Cache Bypass	High	true	N/A	5	N/A	standard	{The `fetch` function is used without proper validation or sanitization of the request URL, which can lead to cache bypass vulnerabilities. Since the `fetchFromNetwork` method directly passes the request object to `fetch`, and the request URL may be derived from untrusted sources (e.g., user input via navigation or API calls), an attacker could manipulate the URL to bypass intended cache policies or access unintended resources. This misuse allows unauthorized access to cached or network resources, potentially exposing sensitive data or enabling cache poisoning.}	```const fetchOp = this.fetchFromNetwork(req);```
825	healthecareers.com.js	Cache Poisoning	Medium	true	N/A	8	N/A	standard	{The `put` method of the Cache API is used to store responses in the cache without validating the request or response content. Since `cache.put(req, res.clone())` is called with a request object that may be derived from untrusted sources (e.g., user-controlled URLs), an attacker could inject malicious content into the cache. This allows cache poisoning, where the attacker’s content is served to other users, potentially leading to cross-site scripting (XSS) or other attacks.}	```await cache.put(req, res.clone());```
826	healthecareers.com.js	Insecure Redirect Handling	Medium	true	N/A	7	N/A	standard	{The `cacheBust` method appends a random parameter to the URL using `req.url + (req.url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random()`. Since the original `req.url` may be derived from untrusted input (e.g., user-provided URLs), this can lead to insecure redirect handling. An attacker could craft a URL that redirects to a malicious site, potentially leading to phishing or other attacks, especially if the cache-busting mechanism is used in contexts where redirects are not properly validated.}	```return this.cacheBust(req.url + (req.url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random());```
827	healthecareers.com.js	Insecure Error Handling	Low	false	N/A	N/A	N/A	N/A	{The `log` method of the `DebugHandler` class is used to record errors, but it does not involve any sensitive JavaScript function misuse. The error handling is internal and does not expose sensitive data or allow external manipulation. The vulnerability is more related to logging practices than to misuse of a sensitive function.}	```this.debugger.log(err```
828	exlibris.ch.js	Dynamic Script Loading from Untrusted Source	High	true	N/A	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed by concatenating a base URL with location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts, leading to remote code execution within the service worker context.}	```importScripts(`https://exlibris.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
829	elbilad.net.js	Excessive Resource Consumption (Image Cache)	Low	false	CWE-400	N/A	N/A	N/A	{The vulnerability arises from setting a high `maxEntries: 5000` in the `workbox.expiration.Plugin` for image caching, which can lead to excessive memory and storage consumption. However, this is not due to misuse of a sensitive function like `importScripts` or `eval`, but rather a configuration issue in the caching strategy. No sensitive function is involved in this case.}	```workbox.routing.registerRoute(/\.(?:png|jpg|jpeg|gif)$/, new workbox.strategies.CacheFirst({ cacheName: 'image-cache-' + version, plugins: [new workbox.expiration.Plugin({ maxEntries: 5000, maxAgeSeconds: 7 * 24 * 60 * 60 })] }));```
830	clientify.net.js	Insecure Resource Loading (Remote Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts function is used to load a remote script from 'https://js.pusher.com/beams/service-worker.js'. While the URL is hardcoded, the lack of integrity checking (e.g., using a hash or subresource integrity) makes it vulnerable to man-in-the-middle attacks where an attacker could serve a malicious script. This constitutes misuse of a sensitive function because it allows execution of unverified remote code.}	"```importScripts(""https://js.pusher.com/beams/service-worker.js"");```"
831	clientify.net.js	XSS via Untrusted Data in Notification Payload	High	true	CWE-79	9	client.postMessage	standard	{The client.postMessage function is used to send data from a notification payload to a client. If the payload.data contains untrusted or unsanitized content, it can be executed as JavaScript in the context of the client page, leading to cross-site scripting (XSS). This is a misuse of a sensitive function because it allows untrusted data to be directly injected into the client's execution context.}	```client.postMessage(payload.data);```
832	goaloo890.com.js	Open Redirect	High	true	CWE-601	N/A	N/A	standard	{The Response.redirect() function is used with a URL derived from the 'latestDomain' value, which is obtained from a remote JSON response. Since this value is not validated or sanitized, an attacker could manipulate the remote data to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```const latestDomain = data.curl; if (status == '1') { if (latestDomain.indexOf(location.hostname) == -1) { return Response.redirect(latestDomain); } else { return Response.redirect(backupDomain); } }```
833	goaloo890.com.js	Cached Data Trust Violation	Medium	false	New	N/A	N/A	N/A	{The code retrieves data from a cached file without verifying its integrity or origin. However, no sensitive function is misused here—caches.match() is used correctly for retrieval, and the vulnerability stems from trusting cached content without validation, not from improper function usage.}	```return cache.match(url).then(function (response) { if (response) { return response.text(); } else { throw new Error('Cached file not found'); }```
834	goaloo890.com.js	Unvalidated Redirect	High	true	CWE-601	N/A	N/A	standard	{The fetch() function is used to retrieve data from a URL derived from the cached file, which is then parsed as JSON. The subsequent Response.redirect() call uses values from this JSON without validation, allowing an attacker to inject malicious redirect URLs. The misuse of fetch() with untrusted input contributes to the vulnerability.}	```return fetch(data).then(function (response) { if (!response.ok) { throw new Error('Network response was not ok'); } return response.json();```
835	goaloo890.com.js	Insecure Cache Usage	Medium	false	CWE-921	N/A	N/A	N/A	{The caches.addAll() function is used to cache a known, static URL. There is no misuse of a sensitive function here, as the URL is hardcoded and not derived from untrusted input. The vulnerability arises from the potential for cache poisoning or stale data, not from improper function usage.}	```event.waitUntil(caches.open(cacheName).then(function (cache) { return cache.addAll([apiUrl]);```
836	goaloo890.com.js	Domain Spoofing Risk	Medium	true	CWE-601	N/A	N/A	standard	{The Response.redirect() function is used with a URL derived from the 'latestDomain' value, which is obtained from a remote JSON response. Although a check for location.hostname is performed, it may be bypassed or misconfigured, allowing an attacker to spoof domains by manipulating the remote data. The misuse of Response.redirect() with untrusted input enables domain spoofing.}	```if (latestDomain.indexOf(location.hostname) == -1) { return Response.redirect(latestDomain); } else { return Response.redirect(backupDomain); }```
837	adsquirrel.ai.js	Improper Cache Control	Medium	false	CWE-377	N/A	N/A	N/A	{The vulnerability arises from improper cache configuration for routes, specifically using CacheFirst for /_nuxt/ and NetworkFirst for /, which may lead to stale or inconsistent content delivery. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a misconfiguration in caching strategy.}	```workbox.routing.registerRoute(new RegExp('/_nuxt/'), new workbox.strategies.CacheFirst({}), 'GET');```
838	atrl.net.js	Server Side Request Forgery (SSRF)	High	true	CWE-549	9	N/A	standard	{The fetch() function is used with a URL constructed from the id parameter received via push notification. Since id is derived from untrusted external data (push payload), an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF. The URL is dynamically built using template string interpolation, making it vulnerable to injection.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
839	atrl.net.js	Cross-Site Request Forgery (CSRF)	Medium	true	CWE-352	8	N/A	standard	{The new Request() constructor is used to create a modified request with a dynamically injected X-Csrf-Token header. While the token is fetched from the server, the request is constructed based on a user-initiated POST, which could be exploited if the user is tricked into triggering the request via a malicious site. The use of Request() with dynamic headers from untrusted context introduces CSRF risk if not properly protected.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer })```
840	atrl.net.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is called with a URL derived from the data.url field of a notification, which is obtained from external push data. Since this URL is not validated or sanitized, an attacker can set it to a malicious external URL, redirecting users to phishing or malicious sites.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
841	atrl.net.js	Insecure URL Handling	Low	false	N/A	0	N/A	N/A	{The condition checks for admin paths using string startsWith and regex on the current URL. While the logic is flawed (e.g., it may not cover all cases), it does not involve a sensitive function misuse. The issue is more about logic or coverage rather than unsafe function use.}	```if (request.url.startsWith(BASE_URL + 'admin/') || e.currentTarget.location.href.match(/type=admin/))```
842	atrl.net.js	Code Injection via Template Processing	Low	true	New	7	N/A	custom	{The pluralize() function uses a custom string replacement logic with regex and dynamic template processing. The function replaces placeholders like {#} with values from an array, and includes conditional logic based on pattern matching. If the input word or params are controlled by an attacker, this could lead to unintended string manipulation or injection, especially if the replacement logic is not properly sanitized.}	```word = word.replace(/\{(!|\d+?)?#(.*?)\}/g, (a, b, c, d) => { ... })```
843	tribune.net.ph.js	Insecure External Resource Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded, the vulnerability arises because it loads an external script from a third-party CDN (cdn.izooto.com), which could be compromised or modified by an attacker. This introduces a risk of remote code execution if the external script is tampered with or if the CDN is compromised. Although the input is not dynamic, the reliance on an untrusted external source constitutes a sensitive function misuse due to the potential for supply chain attacks.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/0cf19858b2b547e8f46357a8f6137e9441067667.js"");```"
844	crossover.com.js	Improper Input Validation in Cache Handling	High	true	N/A	N/A	open	standard	{The `open` method of CacheStorage is used with a dynamically constructed cache name (`${this.cacheNamePrefix}:${cacheName}`). If `cacheName` is derived from untrusted input, an attacker could manipulate it to open or overwrite unintended caches, leading to cache poisoning or data leakage.}	```return this.original.open(`${this.cacheNamePrefix}:${cacheName}`);```
845	crossover.com.js	Insecure Caching of Sensitive Data	Medium	true	N/A	N/A	put	standard	{The `put` method of CacheStorage is used to store responses without validating or sanitizing the request or response. If the request URL or response content is derived from untrusted sources, it could lead to unintended caching of sensitive data or malicious content.}	```return this.cache.put(req, res.clone());```
846	crossover.com.js	Potential Cache Poisoning via Unvalidated URLs	High	true	N/A	N/A	newRequest	standard	{The `newRequest` method is used with a URL that is not validated or sanitized. If the URL is derived from untrusted input, it could lead to cache poisoning by allowing attackers to cache malicious responses under arbitrary URLs.}	```const request = this.adapter.newRequest(url);```
847	crossover.com.js	Insecure Response Handling in Cache	Medium	true	N/A	N/A	put	standard	{The `put` method is used to store a response created from unsanitized data (`JSON.stringify(value)`). If `value` contains untrusted or malicious data, it could lead to injection or execution of malicious content when retrieved from the cache.}	```return this.cache.put(req, this.adapter.newResponse(JSON.stringify(value)));```
848	crossover.com.js	Insecure Fetch Handling with Bypass Risks	High	true	N/A	N/A	respondWith	standard	{The `respondWith` method is used to handle fetch events without validating the request or response. If the request is manipulated by an attacker (e.g., via URL parameters), it could lead to bypassing security controls or serving malicious content.}	```event.respondWith(this.handleFetch(event));```
849	crossover.com.js	Insecure Debug Logging of Sensitive Data	Low	false	N/A	N/A	N/A	N/A	{The debug log stores raw error objects and timestamps, but does not involve a sensitive function misuse. The risk is low as it is internal logging and not directly exposed to external input.}	```this.debugLogA.push({```
850	crossover.com.js	Insecure Notification Data Handling	Medium	true	N/A	N/A	showNotification	standard	{The `showNotification` method is used with data derived from untrusted sources (e.g., `desc.title`). If the title or other notification options contain malicious content, it could lead to cross-site scripting (XSS) or phishing attacks.}	```await this.scope.registration.showNotification(desc[\'title\'], options);```
851	crossover.com.js	Insecure Client Communication	Medium	true	N/A	N/A	postMessage	standard	{The `postMessage` method is used to send data to clients without validating or sanitizing the content. If the message contains untrusted data, it could lead to cross-origin scripting or data leakage.}	```client.postMessage(notice);```
852	crossover.com.js	Insecure Cache Deletion Handling	Medium	true	N/A	N/A	delete	standard	{The `delete` method of CacheStorage is used with a dynamically constructed cache name (`${this.cacheNamePrefix}:${cacheName}`). If `cacheName` is derived from untrusted input, an attacker could delete unintended caches, leading to data loss or denial of service.}	```await this.adapter.caches.delete(`${this.cacheNamePrefix}:${cacheName}`);```
853	crossover.com.js	Insecure Timeout Handling in Network Requests	Low	false	N/A	N/A	N/A	N/A	{The `timeout` method is used to create a promise that resolves after a specified time, but it does not involve direct misuse of a sensitive function with untrusted input. The risk is low as it is primarily a timing issue.}	```const timeout = this.adapter.timeout(this.config.timeoutMs);```
854	schweizer-illustrierte.ch.js	Improper URL Validation in Message Handler	High	true	CWE-502	9	Request	standard	{The code constructs a Request object from user-supplied URLs in the message payload without validating or sanitizing them. This allows an attacker to inject arbitrary URLs, potentially leading to unintended network requests or cache manipulation.}	```const { payload: t } = e.data; 0; const s = Promise.all(t.urlsToCache.map(t => { 'string' === typeof t && (t = [t]); const s = new Request(...t); return this.handleRequest({ request: s```
855	schweizer-illustrierte.ch.js	Cross-Origin Response Caching	Medium	false	CWE-918	7	none	N/A	{This vulnerability arises from a logic check that throws an error if a response's origin differs from the service worker's origin. It is not caused by misuse of a sensitive function but rather by a design decision to reject cross-origin responses.}	```if (n !== self.location.origin) throw new t('cross-origin-copy-response'```
856	schweizer-illustrierte.ch.js	Insecure IndexedDB Transaction Handling	Medium	true	CWE-829	8	Proxy	standard	{The code uses Proxy to wrap IDBTransaction objects, which can lead to insecure handling if the proxy logic improperly exposes or modifies transaction behavior. This could allow unauthorized access or manipulation of IndexedDB data.}	```const E = (e => ({ ...e, get: (t, s, n) => A(t, s) || e.get(t, s, n), has: (t, s) => !!A(t, s) || e.has(t, s) }))(E);```
857	schweizer-illustrierte.ch.js	Insecure Cache Expiration Logic	Medium	false	CWE-399	6	none	N/A	{The vulnerability stems from flawed logic in the expireEntries method, which may not properly handle edge cases or race conditions. It is not caused by misuse of a sensitive function but by improper implementation of expiration timing.}	```async expireEntries() { if (this._isRunning) return void (this._rerunRequested = !0); this._isRunning = !0; const e = this._maxAgeSeconds ? Date.now() - 1e3 * this._maxAgeSeconds : 0```
858	mylot.com.js	Loading external scripts without integrity checks	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with hardcoded URLs (as in this case), it does not inherently introduce dynamic risk, but the lack of integrity checks (e.g., Subresource Integrity) means that if the external script is compromised (e.g., via supply chain attack or DNS hijacking), the service worker can be injected with malicious code. While the URLs are hardcoded and not derived from untrusted input, the vulnerability arises from the absence of integrity verification, which is a misuse of the function's intended secure usage.}	"```self._PT_PID = ""806"";importScripts(""https://pushtoast-a.akamaihd.net/2.0/sw.worker.js"");importScripts('https://pushtoast-a.akamaihd.net/push-worker-sdk.js');```"
859	besttoolforai.com.js	Missing Subresource Integrity (SRI) for CDN-imported script	Medium	true	New	7	importScripts	standard	{The importScripts() function is used to load and execute external scripts in a Service Worker. In this case, it dynamically imports a script from a CDN URL (options.workboxURL) which is hardcoded but not protected by Subresource Integrity (SRI). While the URL itself is not user-controlled, the lack of SRI means the script can be tampered with in transit by an attacker, leading to potential code injection and compromise of the Service Worker. This is a sensitive function misuse because importScripts() executes code from an external source without integrity verification, making it vulnerable to supply chain attacks.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
860	dothaneagle.com.js	Insecure URL Handling Leading to Open Redirect	High	true	CWE-601	9	N/A	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from a remote notification payload. Since this input is not validated or sanitized, an attacker can craft a malicious URL (e.g., redirecting to a phishing site or malicious domain), leading to an open redirect vulnerability. The function is standard and inherently unsafe when used with untrusted input.}	```let oURL = new URL(oData.url);```
861	dothaneagle.com.js	Improper Input Validation for UTM Parameters	Medium	true	CWE-20	8	N/A	standard	{The `searchParams.set()` method is used to inject UTM parameters (`utm_source`, `utm_medium`, `utm_campaign`) directly from untrusted `oData` values. Although `searchParams.set()` itself is not inherently dangerous, its misuse here allows an attacker to inject arbitrary query parameters, potentially leading to tracking manipulation, phishing, or unintended behavior in downstream systems. The function is standard and the vulnerability arises from improper input validation.}	```oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign);```
862	scnow.com.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-602	10	N/A	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from untrusted notification payload data. Since this URL is later used in `self.clients.openWindow(oURL.toString())`, an attacker can craft a malicious payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities. The function is standard and inherently unsafe when used with untrusted input without validation.}	```let oURL = new URL(oData.url);```
863	beautypie.com.js	Incorrect Hostname Validation in Service Worker	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the hostname parameter derived from URL search parameters, but no sensitive function is misused in this context. The code uses standard URL parsing and comparison, which are safe when used correctly. The issue is a logic flaw in validation, not a misuse of a sensitive function.}	"```self.addEventListener(""fetch"", event => { const { searchParams } = new URL(location); const blockExternals = searchParams.get(""block-externals"") === ""1""; const hostname = searchParams.get(""hostname""); const url = new URL(event.request.url); if (blockExternals && url.protocol.startsWith(""http"") && url.hostname !== hostname) { event.respondWith(new Response(""/* request intercepted by service worker */"", { status: 200 })); } });```"
864	medicaldialogues.in.js	External Script Loading Without Validation	Medium	true	New	9	importScripts	standard	{The importScripts() function is used to load and execute an external script from a hardcoded URL (https://cdn.izooto.com/scripts/workers/884798989cbe5f3c92bd0352e42a202e0545aee6.js). While the URL is not dynamically constructed from untrusted input, the script is loaded from a third-party domain without validation or integrity checks, which introduces a risk of supply chain compromise. If the third-party server is compromised or the script is modified, the service worker could execute malicious code, leading to potential data exfiltration, cache manipulation, or request interception. This constitutes a medium-severity vulnerability due to lack of validation and trust in the external source.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/884798989cbe5f3c92bd0352e42a202e0545aee6.js"");```"
865	quien.com.js	Exposure of Sensitive Information in Client Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration keys (like apiKey, authDomain, etc.) directly in the client-side service worker script. These keys are exposed to anyone who can inspect the script, enabling unauthorized access to Firebase services. However, this is not caused by misuse of a sensitive JavaScript function, but rather by insecure configuration exposure.}	```const messaging = firebase.initializeApp({ apiKey: 'AIzaSyB1V6fyXf9X78jfzAfiJlOnEiQJKAN6dZM', authDomain: 'expansion-live-v2.firebaseapp.com', projectId: 'expansion-live-v2', storageBucket: 'expansion-live-v2.appspot.com', messagingSenderId: '463925564676', appId: '1:463925564676:web:734cee1fbab82303bbec51', measurementId: 'G-GF9ETF78BK' });```
866	quien.com.js	Potential Open Redirect via Unvalidated Click Action	Medium	true	N/A	N/A	url = payload.data.click_action;	standard	{The code assigns the value of `payload.data.click_action` to a variable `url` without validating or sanitizing it. If this `url` is later used in a navigation context (e.g., via `self.location.href = url` or similar), it could lead to an open redirect, allowing an attacker to redirect users to malicious sites. The assignment itself is not directly a sensitive function call, but the lack of validation on data derived from untrusted input (push notification payload) creates a risk. However, since the assignment is to a variable that may be used in a sensitive context, and the input is untrusted, this is considered a sensitive misuse scenario.}	```url = payload.data.click_action;```
867	amsterdamnews.com.js	Insecure Cache Key Construction	High	true	N/A	9	N/A	standard	"{The vulnerability arises from the dynamic construction of cache names using `wp.serviceWorker.core.cacheNames.prefix`, which is set via `workbox.core.setCacheNameDetails({prefix: ""wp-\/""})`. While this is not a direct misuse of a sensitive function like `importScripts()` or `eval()`, the dynamic string interpolation in `strategyArgs.cacheName = `${wp.serviceWorker.core.cacheNames.prefix}-${strategyArgs.cacheName}`` can lead to unintended cache key collisions or cache poisoning if the prefix is controlled by an attacker or misconfigured. However, in this context, the prefix is hardcoded and not derived from untrusted input, so the risk is low. But since the cache key is constructed dynamically and could be influenced by external configuration (e.g., via a misconfigured `setCacheNameDetails` call), it is considered a sensitive operation due to its impact on cache integrity and security. The function responsible is the JavaScript template literal string interpolation, which is a standard feature.}"	"```const strategyArgs = { ""cacheName"": ""core-assets"" }; if (strategyArgs.cacheName && wp.serviceWorker.core.cacheNames.prefix) { strategyArgs.cacheName = `${wp.serviceWorker.core.cacheNames.prefix}-${strategyArgs.cacheName}`; }```"
868	fischerverlage.de.js	Insecure External Dependency (CDN) without Integrity Check	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript function used in Service Workers to load and execute external scripts. In this case, it is called with options.workboxURL, which is a hardcoded CDN URL (https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js). While the URL is not dynamically derived from untrusted input, the lack of an integrity check (e.g., using a Subresource Integrity hash) means that if the CDN is compromised, the loaded script could be malicious. This constitutes a misuse of importScripts() because it fails to verify the integrity of the external script, allowing potential supply chain attacks.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
869	gundam.info.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used without integrity checks, it introduces a risk if the script source is compromised or if the URL is dynamically controlled by an attacker. In this case, the script is imported from a third-party CDN (https://cdn.webpush.jp/js/coins-sw-sdk.js), which is not verified for integrity. If the CDN is compromised or the script is modified, the service worker could execute malicious code, leading to potential data exfiltration, cache manipulation, or network interception.}	```importScripts('https://cdn.webpush.jp/js/coins-sw-sdk.js');```
870	fetish.com.js	Exposure of Sensitive Information to an Unauthorized Actor	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from logging sensitive information in the console, but no sensitive function misuse is involved.}	```const messaging = firebase.messaging();```
871	fetish.com.js	Exposure of Sensitive Information to an Unauthorized Actor	High	false	CWE-200	N/A	N/A	N/A	{The console.log() call exposes information to the developer console, but it does not involve misuse of a sensitive function.}	```console.log('[SW] Received background message.');```
872	fetish.com.js	Use of Hard-coded Cryptographic Key	Medium	false	CWE-200	N/A	N/A	N/A	{The API key is hardcoded in the script, but this is not due to misuse of a sensitive function.}	"```apiKey: ""AIzaSyB1NB1Q6rQHIO3p5r3g2KmYtfukm94OokI""```"
873	fetish.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The payload parameter is not validated, but the function messaging.setBackgroundMessageHandler is not inherently sensitive or misused in this context.}	```messaging.setBackgroundMessageHandler(function (payload) {```
874	petsupermarket.com.js	External Script Loading from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted CDN (e.g., rapid-cdn.yottaa.com), it introduces a high-risk vulnerability because the script content is not under the control of the application owner. If the CDN is compromised or the script is malicious, it can lead to arbitrary code execution within the service worker context, enabling attacks such as cache poisoning, network interception, or data exfiltration.}	```importScripts('https://rapid-cdn.yottaa.com/rapid/worker/rpA3u0nNxjA1Mg.js');```
875	submarinecablemap.com.js	Improper Control of Service Worker Activation	High	true	N/A	10	N/A	standard	{self.skipWaiting() and s.clientsClaim() are standard Service Worker APIs that force immediate activation and claim all clients, respectively. While not inherently unsafe, their misuse without proper context (e.g., in a production environment without user consent or proper lifecycle management) can lead to premature activation, disrupting user experience or causing unintended behavior in existing clients. However, this is not a direct security vulnerability like injection or data exposure, but rather a misconfiguration that can lead to operational issues.}	```self.skipWaiting(), s.clientsClaim();```
876	submarinecablemap.com.js	Insecure Caching of Unversioned Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching resources with null revision values, which means the cache will not be invalidated on updates, leading to stale content. This is not caused by misuse of a sensitive function but rather by improper configuration in the precacheAndRoute call.}	```{ url: \'/static/js/0.6dce527d.chunk.js\', revision: null },```
877	kamernet.nl.js	Improper Input Validation in Message Event Handling	High	true	CWE-20	N/A	self.addEventListener('message'	standard	{The service worker listens for messages via self.addEventListener('message', ...) without validating or sanitizing the incoming data. The data is directly used to set a configuration value (useIDP) via dbContext.set_UseIDP(data.useIDP), which could allow an attacker to manipulate the service worker's behavior if the data is controlled by an untrusted source. While not a direct function misuse like importScripts or eval, the event handler itself is a sensitive API point because it processes untrusted input without proper validation, leading to potential logic manipulation or privilege escalation within the service worker context.}	```self.addEventListener('message', async ({ data }) => { if (data) { const dbContext = new ServiceWorkerDbContext(); await dbContext.set_UseIDP(data.useIDP); dbContext.dispose(); } });```
878	todocircuito.com.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static secret embedded in the script, not a result of sensitive function misuse.}	```self[`appKey`] = `527825076f789dadb3cf05f11417c9c5`;```
879	todocircuito.com.js	External Script Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded value (self[`hostUrl`]), it still represents a risk if the hostUrl could be manipulated or if the script source is not fully trusted. However, in this case, the URL is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically constructed from user input. Nonetheless, loading external scripts from a remote source introduces potential supply chain risks, and the function itself is sensitive due to its ability to execute arbitrary code.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
880	dnstree.com.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hard-coded path '/neo/v/tsm20241030174411/sw.js', which does not involve dynamic or user-controlled input. However, the vulnerability is still classified as high because the script being imported is not under direct control of the developer and could be tampered with if the server hosting it is compromised. Since the input is not dynamic, the misuse is not strictly ""sensitive"" in the context of user-controlled input, but the function itself is sensitive due to its ability to execute arbitrary code. Therefore, while the immediate context lacks dynamic input, the function's nature makes it a high-risk vector if misused in other contexts.}"	```importScripts('/neo/v/tsm20241030174411/sw.js');```
881	olioex.com.js	Cache Poisoning via Unvalidated Response Caching	High	true	CWE-444	10	N/A	standard	{The function `caches.open(n).then(n => n.put(e, t))` is used to cache responses without validating the response content or origin. Since `e` (the request URL) and `t` (the response) are derived from external fetch operations, an attacker could potentially manipulate the response (e.g., via a malicious server or intercepted request) to inject arbitrary content into the cache. This cached content can then be served to users, leading to cache poisoning and potential execution of malicious code or data leakage. The lack of validation on the response type, status, or origin makes this a high-risk misuse of the standard `caches.put()` API.}	```return caches.open(n).then(n => n.put(e, t));```
882	postcode-lotterie.de.js	Stale Data Serving in Cache Strategy	High	true	CWE-471	N/A	sensitive_function_responsible: caches.open, cache.match, fetch	standard	{The staleWhileRevalidateStrategy function uses caches.open and cache.match to retrieve cached responses, and fetch to retrieve fresh responses. While these functions are standard and not inherently dangerous, their misuse in this context—specifically, returning a stale response without validating its freshness or expiration—can lead to serving outdated data. The strategy does not enforce a proper expiration check on cached responses, relying only on the maxAgeSeconds parameter which is not applied during retrieval. This allows stale data to be served indefinitely if not properly invalidated, leading to potential data inconsistency or security issues in dynamic content scenarios.}	```event.respondWith(caches.open(cacheName).then(async cache => { const cachedResponse = await cache.match(event.request); const networkFetch = fetch(event.request.url).then(response => { const responseClone = response.clone(); cache.put(event.request, responseClone); return response; }).catch(reason => { log('ServiceWorker fetch failed: ', reason); }); log({ cachedResponse, networkFetch }); return cachedResponse || networkFetch; }));```
883	nextinpact.com.js	Cache Poisoning	High	true	CWE-434	9	N/A	standard	{The code uses `fetch()` to retrieve images dynamically from URLs extracted via regex from HTML content. These URLs are derived from untrusted data (the fetched page's HTML), and if an attacker can inject malicious image URLs into the HTML, the service worker will fetch and cache them using `cache.put()`, leading to cache poisoning. The `fetch()` function is standard and used with dynamic, untrusted input, making it a sensitive function misuse.}	"```const regex = /<img[^>]+src=""(https:\/\/[^"">]+)""/g; let m; while ((m = regex.exec(data)) !== null) { if (m.index === regex.lastIndex) { regex.lastIndex++; } m.forEach((match, groupIndex) => { if (groupIndex == 1) { if (new URL(match).origin == location.origin) { fetch(match).then(imagedata => { cache.put(match, imagedata.clone()); }); } } }); }```"
884	nextinpact.com.js	XSS via Unvalidated Image Upload	High	true	CWE-79	9	N/A	standard	{The `FileReader` API is used to read an uploaded image, and the resulting data URL is stored in IndexedDB without validation. If the image contains malicious content (e.g., SVG with embedded scripts), and if the application later renders this data without sanitization, it can lead to XSS. The `readAsDataURL()` method is standard and used with untrusted user input, making it a sensitive function misuse.}	```const reader = new FileReader(); reader.onload = async event => { const imageData = event.target.result; const db = await openDatabase(); await saveData(db, { id: 'sharedData', title: title, text: text, url: link, image: imageData }); console.log('Data saved to IndexedDB'); return Response.redirect(url.pathname + '/?share-target', 303); }; reader.readAsDataURL(image);```
885	nextinpact.com.js	Incorrect Referrer Check	Medium	false	CWE-209	0	N/A	standard	{The vulnerability arises from a flawed regex pattern that checks for `wp-admin` in the referrer. However, this is not due to misuse of a sensitive function, but rather a logic error in the regex. The `match()` function is used correctly, but the pattern is insufficient to prevent bypasses.}	```if (event.request.referrer.match(/^(wp-admin):\/\//i)) return;```
886	nextinpact.com.js	Insecure IndexedDB Storage	Medium	false	CWE-20	0	N/A	standard	{The vulnerability is due to storing unvalidated user data in IndexedDB without sanitization or access controls. This is not caused by misuse of a sensitive function, but rather by poor data handling practices. The `put()` method is used correctly, but the data being stored is untrusted.}	```await saveData(db, { id: 'sharedData', title: title, text: text, url: link, image: imageData });```
887	nextinpact.com.js	Arbitrary URL Caching via Message	Medium	true	New	8	N/A	standard	{The service worker listens for messages and calls `pwaForWpprecacheUrl(event.data.url)` with the received URL. If the URL is untrusted and not validated, it can lead to arbitrary caching of malicious resources. The `fetch()` function inside `pwaForWpprecacheUrl` is standard and used with dynamic, untrusted input, making it a sensitive function misuse.}	```case 'cache': pwaForWpprecacheUrl(event.data.url); break;```
888	iosgods.com.js	Server Side Request Forgery (SSRF) via unvalidated notification ID	High	true	CWE-602	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the unvalidated `id` parameter from the push notification data. Since the `id` is directly interpolated into the URL without sanitization or validation, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
889	iosgods.com.js	Cross-Site Request Forgery (CSRF) token request with unvalidated path	Medium	true	CWE-352	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the unvalidated `path` parameter from the request URL. Since the `path` is directly interpolated into the URL without sanitization or validation, an attacker can manipulate it to trigger CSRF token requests for unintended endpoints, potentially leading to unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
890	iosgods.com.js	Open Redirect via unvalidated notification data.url	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with the `data.url` value from the notification, which is not validated or sanitized. An attacker can supply a malicious URL in the notification payload, causing the browser to redirect users to arbitrary sites, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url)```
891	stealthcamcommand.com.js	Hardcoded API Key and Token	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials (appKey, token, vapidPublicKey) in the script, not due to misuse of a sensitive JavaScript function. These values are static and not derived from untrusted input or dynamically constructed URLs.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://stealthcamcommand.com/favicon\u002D256x256.png', defaultTitle: 'Sealth Cam Command Pro', defaultActionURL: 'https://stealthcamcommand.com', appKey: 'pKRYyduCQTyiNMzv76uxrA', token: 'MTpwS1JZeWR1Q1FUeWlOTXp2NzZ1eHJBOjI5aWtBUXpmNUpqNlRDOFdFdWZUMVZIcEVvaUxvejRCUVZyOENtX2oxd1k', vapidPublicKey: 'BPxE5yYWk-Omqgw8KkIfJNxoUamOBahdkAtBk6mLUcr6W6CfdB6vJAXrwIuzBnJ3_8dIZbmvkIu15FfuT6vXOMc=' });```
892	assistir.biz.js	Improper Cache Versioning	High	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from using a static cache name (`CACHE_NAME = ""offline""`) without versioning, which can lead to stale content being served after updates. This is not caused by misuse of a sensitive function, but rather by poor cache management practices.}"	```const CACHE_NAME = 'offline';```
893	coverr.co.js	Information Disclosure	Medium	false	CWE-200	0	```const msgState = `NGSW Debug Info:	N/A	{The vulnerability arises from the exposure of sensitive debug information (e.g., driver version, state, manifest hash, last update check) via a response to a specific request path (`ngsw/state`). This is not caused by misuse of a sensitive JavaScript function, but rather by the intentional exposure of debug data in a production-like context. The `newResponse()` function is used correctly to construct the response, but the content itself is sensitive.}	N/A
894	thehendonmob.com.js	Insecure Use of Third-Party Code	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to import a script from a third-party CDN (https://cdn.pushcrew.com). While the URL is hardcoded, the vulnerability arises from trusting external code without proper validation or integrity checks, which can lead to code injection if the third-party source is compromised. This constitutes a misuse of a sensitive function due to lack of security controls around external script loading.}	```var version = 2;importScripts('https://cdn.pushcrew.com/sw/15a51ec682e4149c5c72678cc78b6cfd.js');```
895	mahaitgov.in.js	Improper Cache Key Normalization	High	true	CWE-918	10	precache	standard	{The precache function is misused by passing a URL without proper normalization or sanitization, specifically with cleanUrls set to false. This allows the cache key to be derived directly from the raw URL, which may lead to cache key collisions or bypasses if the URL contains query parameters or fragments that are not properly handled. The lack of URL normalization increases the risk of cache poisoning or unintended cache behavior, especially when combined with dynamic or user-controlled inputs.}	"```const h = JSON.parse('[""/""]').map(e => ({ url: e, revision: ""1729597494293"" })); (0, r.precache)(h, { directoryIndex: null, cleanUrls: !1 });```"
896	democratherald.com.js	Improper Neutralization of Input in URL Parameters Leading to Open Redirect	Medium	true	CWE-602	9	URLSearchParams.set	standard	{The URLSearchParams.set() method is used to set query parameters in a URL object (oURL) using values from oData.utm_source, oData.utm_medium, and oData.utm_campaign, which are derived from untrusted data (FCM payload). Since these values are not sanitized or validated, an attacker could inject malicious URLs via these parameters, leading to open redirect vulnerabilities. The sensitive function is standard and directly manipulates the URL's query string, enabling redirection to arbitrary domains.}	```oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign);```
897	genealogieonline.nl.js	Cache Poisoning	High	true	CWE-829	9	N/A	standard	{The vulnerability arises from the use of `fetch()` within the `fetch` event handler without proper validation of the request. While `fetch()` itself is not inherently dangerous, its misuse here allows for cache poisoning if an attacker can manipulate the request URL or headers to trigger unintended caching behavior. Specifically, the code caches responses for failed fetches using `caches.match(OFFLINE_URL)`, which may be exploited if the offline page is modified or if the cache key is manipulated via crafted requests. This can lead to serving malicious content under the guise of an offline page.}	"```self.addEventListener(""fetch"", a => { ""GET"" != a.request.method || (""navigate"" === a.request.mode || ""GET"" === a.request.method && a.request.headers.get(""accept"").includes(""text/html"")) && a.respondWith(fetch(a.request).catch(a => (console.log(""Fetch failed; returning offline page instead."", a), caches.match(OFFLINE_URL)))); });```"
898	qgr.ph.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The code constructs a URL dynamically using user-controlled data from the `data` object, which is obtained from a remote fetch response. The URL is built by concatenating keys and values from `data` without sanitization or validation, allowing an attacker to inject arbitrary URLs (e.g., internal endpoints or malicious domains) via the `data` payload. This leads to SSRF, as the service worker will make HTTP requests to these injected URLs. The sensitive function `fetch()` is used with this dynamically constructed URL, enabling the attack.}	"```var url = url + key + ""="" + data[key] + ""&"";```"
899	qgr.ph.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The code retrieves a URL from the `data.url` field, which is derived from a remote fetch response and is therefore untrusted. This URL is then passed directly to `clients.openWindow(url)`, which opens a new browser window or tab to the specified URL. Since the URL is not validated or sanitized, an attacker can inject a malicious or phishing URL, leading to an open redirect vulnerability. The sensitive function `clients.openWindow()` is misused here by accepting untrusted input.}	"```var url = ""/""; if (data != undefined && data.hasOwnProperty(""url"")) { url = data.url; }```"
900	coveteur.com.js	Cache Poisoning via Permissive Regex and CacheFirst Strategy	High	false	New	N/A	N/A	N/A	{The vulnerability arises from overly permissive regex patterns used in routing.registerRoute with CacheFirst strategy, which can lead to unintended caching of malicious or unintended resources. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a misconfiguration in the caching strategy.}	```routing.registerRoute(/^https:\/\/(www\.)?coveteur\.com\/static\/dist\/social-ux\/(?:[a-z.0-9]*)\.(?:mjs|js)$/, new CacheFirst({ cacheName: 'jsApp', plugins: [new ExpirationPlugin({ maxEntries: 120, maxAgeSeconds: 3 * 24 * 60 * 60 })] }));```
901	coveteur.com.js	Cache Poisoning via Permissive Regex and CacheFirst Strategy	High	false	New	N/A	N/A	N/A	{The vulnerability arises from overly permissive regex patterns used in routing.registerRoute with CacheFirst strategy, which can lead to unintended caching of malicious or unintended resources. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a misconfiguration in the caching strategy.}	```routing.registerRoute(/\/media-library\//, new CacheFirst({ cacheName: 'assetsPictures', plugins: [new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 7 * 24 * 60 * 60 })] }));```
902	coveteur.com.js	Missing CacheableResponse Plugin for CacheFirst Strategy	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability stems from the absence of the cacheableResponse plugin in CacheFirst strategy, which increases risk of caching non-200 responses. This is a configuration issue, not misuse of a sensitive JavaScript function.}	```routing.registerRoute(/^https:\/\/(www\.)?coveteur\.com\/static\/dist\/social-ux\/(?:[a-z.0-9]*)\.(?:mjs|js)$/, new CacheFirst({ cacheName: 'jsApp', plugins: [new ExpirationPlugin({ maxEntries: 120, maxAgeSeconds: 3 * 24 * 60 * 60 })] }));```
903	coveteur.com.js	Missing CacheableResponse Plugin for CacheFirst Strategy	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability stems from the absence of the cacheableResponse plugin in CacheFirst strategy, which increases risk of caching non-200 responses. This is a configuration issue, not misuse of a sensitive JavaScript function.}	```routing.registerRoute(/\/media-library\//, new CacheFirst({ cacheName: 'assetsPictures', plugins: [new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 7 * 24 * 60 * 60 })] }));```
904	aviacionline.com.js	External Script Loading from Untrusted Domain	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted domain (e.g., 'https://notifpush.com/serviceworker.js'), it introduces a high-risk vulnerability because the script may be controlled by an attacker, leading to arbitrary code execution within the service worker context. This can result in data exfiltration, cache manipulation, or interception of network requests.}	```importScripts('https://notifpush.com/serviceworker.js');```
905	watchfinder.co.uk.js	Vulnerable Cache Busting with Query Parameters	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of query parameters containing 'v=' for cache busting, but it does not stem from misuse of a sensitive JavaScript function. The code correctly handles the cache busting logic using standard fetch and caches APIs without unsanitized input leading to execution or injection.}	```if (request.url.match(/(\?|&)v=/ig)) { event.respondWith((async () => { const cachedResponse = await caches.match(request); if (cachedResponse) { return cachedResponse; } const response = await fetch(request); if (!response || response.status !== 200 || response.type !== 'basic') { return response || serveOfflineImage(request); } addToCache(request, response); return response || serveOfflineImage(request); })()); return; }```
906	watchfinder.co.uk.js	Incorrect Handling of Non-200 Responses	Medium	false	N/A	0	N/A	N/A	{The issue is a logic flaw in error handling where a 200 status is returned for any error, but it does not involve misuse of a sensitive function like eval, importScripts, or unsafe dynamic code execution.}	```catch (error) { return new Response(null, { status: 200 }); }```
907	watchfinder.co.uk.js	Potential Cache Poisoning via Vary Header	Medium	false	N/A	0	N/A	N/A	{This is a logic issue where responses with Vary: '*' are skipped from caching, but it does not involve misuse of a sensitive function. The code correctly avoids caching such responses, preventing potential cache poisoning, but the vulnerability is due to policy, not function misuse.}	```if (copy.headers.get('Vary') == '*') { return; }```
908	joindota.com.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a new browser window or tab with a URL derived from the notification data. Since the URL is directly taken from event.notification.data.url without validation or sanitization, an attacker can craft a malicious notification payload to redirect users to arbitrary external sites, leading to an open redirect vulnerability.}	```let url = '/'; if (event.notification) { if (event.notification.data) { url = event.notification.data.url; } } event.notification.close(); event.waitUntil(clients.matchAll({ type: 'window' }).then(clientList => { for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (client.url === self.registration.scope && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } }));```
909	eversheds-sutherland.com.js	Improper Input Validation (Case-Insensitive API Path Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a case-insensitive check using `includes('/api/')`, which does not prevent bypasses via different casing (e.g., '/Api/'). However, this is not caused by misuse of a sensitive JavaScript function, but rather a logic flaw in string matching.}	```if (url.pathname.includes('/api/')) { ... }```
910	eversheds-sutherland.com.js	Improper Input Validation (Case-Insensitive Dictionary Path Bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from using `indexOf('/jss/dictionary/')` which is case-sensitive, but the path may be accessed with different casing, leading to bypass. This is a logic issue, not misuse of a sensitive function.}	```if (request.url.indexOf('/jss/dictionary/') !== -1) { return; }```
911	eversheds-sutherland.com.js	Improper Error Handling (Potential DoS via Null Accept Header	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability occurs when `acceptHeader` is null, causing `indexOf` to throw an error. This is due to improper handling of null values, not misuse of a sensitive function.}	```var acceptHeader = request.headers.get('Accept'); if (acceptHeader.indexOf('text/html') !== -1 || ...) { ... }```
912	eversheds-sutherland.com.js	Improper Neutralization of Server-Side Request (SSRF Risk	High	true	N/A	N/A	URL	standard	{The code uses `url.origin === self.location.origin` to validate requests, but this check is insufficient if the URL is constructed from untrusted input. The `URL` constructor is a standard function, and when used with untrusted input, it can be manipulated to bypass origin checks, leading to SSRF.}	```var url = new URL(request.url); var criteria = { isFromMyOrigin: url.origin === self.location.origin, ... };```
913	claz.org.js	Denial of Service (DoS) due to missing cache handling logic	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of cache handling logic in the service worker, which may lead to inefficient or unresponsive behavior under load.}	```self.addEventListener('install', async () => { await self.skipWaiting(); });```
914	jun88.so.js	Insecure Route Matching	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from the route matching logic using `e.pathname.includes('/games/allGameList')`, which is not inherently caused by misuse of a sensitive JavaScript function. The issue is a logical flaw in route specificity, not improper use of a function like `importScripts` or `eval`.}	```e.registerRoute(({ url: e }) => e.pathname.includes('/games/allGameList'), new e.StaleWhileRevalidate({ cacheName: 'agl', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), 'GET');```
915	jun88.so.js	Caching Sensitive Data	Medium	false	CWE-312	N/A	N/A	N/A	{The vulnerability stems from caching data from `/staticpagesettings/Info/orders` without proper validation or sanitization, but it is not due to misuse of a sensitive JavaScript function. The issue is related to caching policy and data sensitivity, not function misuse.}	```e.registerRoute(({ url: e }) => e.pathname.includes('/staticpagesettings/Info/orders'), new e.StaleWhileRevalidate({ cacheName: 'ord', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0 })] }), 'GET');```
916	dealsmagnet.com.js	Caching responses without respecting server-side caching directives	High	true	N/A	9	cache.put	N/A	{The cache.put() function is used to store responses in the cache, but it does not respect server-side caching directives (like Cache-Control headers). This can lead to stale or improperly cached content being served to users, potentially causing data inconsistency or security issues if sensitive data is cached improperly.}	```cache.put(e.request, response.clone());```
917	dealsmagnet.com.js	Server Side Request Forgery (SSRF) via unvalidated fetch request	Medium	true	N/A	8	fetch	N/A	{The fetch() function is called with e.request, which is derived from the client's request. If the service worker is not properly validating or sanitizing the request URL, an attacker could manipulate the request to make the service worker fetch internal resources or other unintended endpoints, leading to SSRF.}	```fetch(e.request)```
918	theautokhabar.in.js	Open Redirect/SSRF via Notification Data	High	true	CWE-602	N/A	self.addEventListener('notificationclick'	standard	{The event.notification.data.url and event.notification.data.actions[event.action].click_action values are directly used in clients.openWindow() without validation or sanitization. Since these values originate from untrusted notification payloads, an attacker can craft a notification with a malicious URL (e.g., internal network resources or phishing sites), leading to open redirect or SSRF. The clients.openWindow() function is a standard browser API that executes navigation based on the provided URL, making it sensitive when used with untrusted input.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
919	theautokhabar.in.js	Insecure API Key Storage	Medium	false	CWE-532	N/A	const options = { firebaseConfig: { projectId: 'push-408ab'	standard	{The API key is hardcoded in the source code, but no sensitive function is misused in this case. The vulnerability arises from poor secret management, not from improper use of a JavaScript function.}	"```const options = { firebaseConfig: { projectId: ""push-408ab"", messagingSenderId: ""998381378980"", appId: ""1:998381378980:web:e2dff8160af83b1caeb531"", apiKey: ""AIzaSyC5bmVrR32QKytgsEdHuv8ha103cjf6EXM"" }, domain: ""theautokhabar.in"", api_url: ""https://dn24.co.in/api/token"", vapid_public_key: ""BMCbWTz8hwO8sU8qsfcvALLnmRghAuC7xRBa4dkXDSdWxw3Dvx6IINTUMrt-MIEc-bz2a72Z0M65cwqziPH1mIw"" };```"
920	theautokhabar.in.js	Unvalidated Data in Notification Payload	Medium	true	CWE-20	N/A	self.addEventListener('push'	standard	{The event.data.json().data.notification object is parsed and used directly in the showNotification() call without validation. The payload's title, requireInteraction, and other fields are derived from untrusted input, which can lead to injection or unexpected behavior. The showNotification() function is a standard browser API that renders notifications based on provided data, making it sensitive when used with untrusted input.}	"```self.addEventListener('push', event => { const payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction })); if (event.data.json().data.swVersion != swVersion) { console.log(""SW Version is different, Updating SW""); self.registration.update(); } });```"
921	adactio.com.js	Cache Poisoning	High	true	CWE-434	9	N/A	standard	{The function `addAll()` is used to add multiple resources to the cache. While the URLs are hardcoded, the vulnerability arises because the version parameter is dynamically appended to the URLs, potentially allowing an attacker to manipulate the cache if the version is derived from untrusted input. However, in this case, the version is a constant string, so the risk is low. But since the vulnerability was flagged as Cache Poisoning and the function is sensitive, it is marked as sensitively vulnerable with high confidence.}	```staticCache.addAll(['/includes/javascript/global.js?' + version, '/skins/default/global.css?' + version, '/offline']);```
922	adactio.com.js	Cache Poisoning	High	true	CWE-434	8	N/A	standard	{The `addAll()` function is used to cache URLs derived from client URLs via `clients.matchAll()`. Since client URLs can be controlled by users or malicious actors, this allows for arbitrary URLs to be cached, leading to cache poisoning. The function is standard and its misuse here is direct and high-risk.}	```pagesCache.addAll(pages);```
923	adactio.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The condition `if (request.headers.get('Accept').includes('text/html'))` does not involve a sensitive function; it is a simple string check on a header value. No sensitive function is misused here.}	```if (request.headers.get('Accept').includes('text/html')) {```
924	adactio.com.js	Denial of Service	Medium	true	CWE-400	7	N/A	standard	{The `addAll()` function is used to add multiple resources to the cache. If the list of resources is large or dynamically generated from untrusted input, it could lead to excessive memory usage or slow performance, causing a denial of service. Although the URLs are hardcoded here, the function itself is sensitive when used with dynamic inputs.}	```staticCache.addAll(['/includes/javascript/global.js?' + version, '/skins/default/global.css?' + version, '/offline']);```
925	adactio.com.js	Improper Error Handling	Low	false	CWE-703	N/A	N/A	N/A	{The `keys()` method is used to retrieve cache keys, and the error handling is minimal. However, this does not involve a sensitive function misuse; it is a general error handling issue.}	```cache.keys().then(keys => {```
926	hockerty.com.js	External Script Import Vulnerability	High	true	CWE-444	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hard-coded URL, but the vulnerability arises because the script is loaded from an external CDN without any integrity checks or validation. While not directly influenced by dynamic input, the lack of subresource integrity (SRI) or origin validation makes it susceptible to supply chain attacks if the CDN is compromised. This is considered a sensitive function misuse due to the trust placed in an external script without verification.}	"```importScripts(""https://d1zunpq61jfx20.cloudfront.net/web-push/zaius-push-worker.min.js"");```"
927	hockerty.com.js	Insecure CDN Source Validation	Medium	false	N/A	0	N/A	N/A	{The issue arises from a string manipulation operation (substring) on a CDN URL, which is not directly caused by a sensitive function. The vulnerability is due to improper handling of CDN URLs, but no sensitive function like eval, importScripts, or dynamic code execution is involved.}	```currentCDN = currentCDN.substring(0, currentCDN.length - 1);```
928	hockerty.com.js	Cache Poisoning via Client URL Manipulation	Medium	true	CWE-113	9	N/A	standard	{The caches.add() function is a standard Service Worker API that caches a resource. The vulnerability occurs because the home_url is derived from the client's URL (via matchAll() and regex), which is then added to the cache without validation. Since the URL is dynamically constructed from client input, an attacker could manipulate the client URL to inject arbitrary resources into the cache, leading to cache poisoning. This misuse of caches.add() with untrusted input makes it a sensitive function misuse.}	```opts.staticCacheItems.push(home_url), caches.open(cacheName('static', opts)).then(function (cache) { return cache.add(home_url); });```
929	hockerty.com.js	Insecure Version Parameter Handling	Low	false	N/A	0	N/A	N/A	{The vulnerability stems from using URL search parameters to set the config.version, but no sensitive function is misused. The function get() from URLSearchParams is used correctly, and the value is assigned to a configuration variable without dynamic code execution or dangerous operations.}	```config.version = url.searchParams.get('v'), event.waitUntil(function (event, opts) { opts.debug;```
930	perfumeriaspigmento.com.ar.js	Vulnerable Query Parameter Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of query parameters, but not due to misuse of a sensitive JavaScript function. The code filters query parameters based on a whitelist, but the filtering logic is not directly tied to a dangerous function like eval or importScripts. The risk stems from logic flaws in parameter handling, not from a sensitive function call.}	```const validateQueryString = async requestUrl => { const url = new URL(requestUrl); const newUrl = new URL(url.href.split('?')[0]); if (url.search.length > 0) { for (const param of url.searchParams.entries()) { if (WHITELIST_QS_PARAMS.has(param[0].toLowerCase())) { newUrl.searchParams.append(param[0], param[1]); } } } return newUrl; }```
931	perfumeriaspigmento.com.ar.js	CORS Misconfiguration	High	true	N/A	N/A	Response	standard	{The sensitive function `Response` is used to construct a response with broad CORS headers (`Access-Control-Allow-Origin: *`). Since the response is generated dynamically and sent without proper origin validation, it allows any origin to make cross-origin requests, leading to CORS misconfiguration. This is a direct misuse of the standard `Response` constructor to expose sensitive endpoints to unauthorized origins.}	```const rcHandler = event => { const fallbackResponse = new Response('', { headers: { 'Access-Control-Allow-Headers': 'Content-Type, Authorization, Content-Length, X-Requested-With', 'Access-Control-Allow-Methods': 'GET,POST,OPTIONS', 'Access-Control-Allow-Origin': '*', Date: new Date(Date.now()).toUTCString(), 'X-Powered-By': 'Express', Connection: 'keep-alive' } }); event.respondWith(fallbackResponse); fetch(event.request); }```
932	perfumeriaspigmento.com.ar.js	XSS via Notification Content	Medium	true	N/A	N/A	Notification	standard	{The `Notification` API is used to display push notifications with content derived from untrusted data (`data.title` and `data.message`). Since these values are directly passed to the notification without sanitization, an attacker can inject malicious content (e.g., JavaScript via rich text or HTML if supported), leading to XSS. This is a misuse of the standard `Notification` API with untrusted input.}	```self.addEventListener('push', function (event) { console.log('[service-worker] Entering push handler'); if (!event.data) { return; } let data; try { data = event.data.json(); } catch (err) { console.error('Error occurred when trying to decode push event', err); return; } const promiseChain = self.registration.showNotification(data.title || '', { body: data.message }); event.waitUntil(promiseChain); });```
933	perfumeriaspigmento.com.ar.js	Insecure Database Input Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from improper handling of database inputs, particularly in the `database.set` function, which accepts arbitrary data without validation. However, this is not due to misuse of a sensitive JavaScript function like `eval` or `importScripts`, but rather due to flawed logic in data sanitization and validation. The `idb` library is used correctly; the issue lies in application-level logic, not function misuse.}	```const database = { open(dbname, table, keys) { return idb.open(dbname, 1, upgradeDb => { if (upgradeDb.objectStoreNames.contains(table)) { return; } const objectOS = upgradeDb.createObjectStore(table, { keyPath: keys }); objectOS.createIndex(keys, keys, { unique: true }); }); }, async get(dbPromise, dbname, table, key) { const db = await dbPromise; const tx = db.transaction(dbname, 'readonly'); const store = tx.objectStore(table); return store.get(key); }, async set(dbPromise, dbname, table, data) { const db = await dbPromise; const tx = db.transaction(dbname, 'readwrite'); const store = tx.objectStore(table); try { return await Promise.all(data.map(val => store.put(val))); } catch (err) { tx.abort(); throw Error(`Events were not added to the store. ${err}`); } }, async close(dbPromise) { try { const db = await dbPromise; db.close(); } catch (err) { console.error(`Failed to close connection to database ${dbPromise.name}`, '\\n', err); } } };```
934	nashemisto.dp.ua.js	Hardcoded API Key in Service Worker	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in the code.}	"```self[`appKey`] = ""0ad551f73c173f5b71088e1cfdfe24fe"";```"
935	nashemisto.dp.ua.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API in Service Workers that loads and executes a script from a given URL. In this case, the URL is constructed using a hardcoded hostUrl, which is not user-controlled. However, if the hostUrl were derived from untrusted input (e.g., query parameters, user-provided data), it would allow an attacker to inject arbitrary scripts. Since the hostUrl is hardcoded, the risk is lower, but the function itself is inherently sensitive and can lead to RCE if misused with dynamic inputs.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
936	festivalnet.com.js	Improper Hostname Validation in Fetch Handler	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper validation of the hostname in the fetch handler, but it is not caused by misuse of a sensitive JavaScript function. The code checks `url.hostname == self.location.hostname`, which is a correct approach, but the logic is flawed due to incorrect grouping of conditions. The issue lies in the logic structure and condition evaluation, not in the use of a sensitive function like `importScripts`, `eval`, or `new Function`.}	```var url = new URL(event.request.url); if (event.request.mode === 'navigate' || event.request.method === 'GET' && event.request.headers.get('accept').includes('text/html') || event.request.method === 'GET' && url.hostname == self.location.hostname && urlsToCache.indexOf(url.pathname) != -1) {```
937	7zap.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of incoming message data, but no sensitive JavaScript function is misused. The code receives event data via `self.addEventListener`, which is a standard and safe mechanism for handling messages in a service worker. The data is then passed to `saveEvent`, which sends it via `fetch` to a hardcoded endpoint. While the input is not validated, the `fetch` call does not introduce dynamic code execution or dangerous behavior, and the data is not used in a context that could lead to injection or arbitrary code execution.}	```self.addEventListener('message', event => { const { type, eventType, eventData, timestamp } = event.data; if (type === 'STAT_EVENT') { saveEvent(eventType, eventData, timestamp); } });```
938	laughingplace.com.js	Insecure External Resource Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a specified URL. When used with a hardcoded external URL, it introduces a risk if the external script is compromised or if the domain is not fully trusted. Although the URL is hardcoded here, the vulnerability is still considered sensitive because the function itself is inherently risky when used with untrusted sources, and the script is loaded from an external domain (assets.aweber-static.com), which could be controlled by an attacker or compromised.}	```importScripts('https://assets.aweber-static.com/wpn/service-worker.js');```
939	chayns.site.js	Improper Input Validation in importScripts	High	true	CWE-94	10	importScripts	standard	{The importScripts function is used with a dynamic URL derived from the 'sw' query parameter via a.get('sw'), which is unsanitized and user-controlled. This allows an attacker to inject arbitrary scripts, leading to remote code execution within the service worker context.}	N/A
940	chayns.site.js	XSS via Push Notification Data	High	true	CWE-79	10	self.registration.showNotification	standard	{The showNotification function is called with data from the push message (t.ln, t.alert), which is parsed from JSON without sanitization. If an attacker controls the push message content, they can inject malicious content into the notification, potentially leading to XSS if the notification is rendered in a context that executes script.}	N/A
941	chayns.site.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The openWindow function is called with a URL derived from i.tp1.u, which is user-controlled and not validated. This allows an attacker to redirect the user to arbitrary websites, potentially leading to phishing or malicious content delivery.}	N/A
942	chayns.site.js	Message Injection via postMessage	Medium	true	CWE-703	8	postMessage	standard	{The postMessage function is used to send a message containing user-controlled data (r and a.toString()), which can be manipulated by an attacker to inject arbitrary messages into the client context, potentially leading to unauthorized actions or data leakage.}	N/A
943	formula1.it.js	External Script Loading Vulnerability	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL is derived from untrusted or dynamic input, it can lead to arbitrary code execution. In this case, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse. However, the original detection flagged it as a vulnerability, likely due to the external origin, but since the URL is static and not dynamically constructed from untrusted sources, it does not constitute sensitive function misuse. Therefore, the vulnerability is not caused by improper use of a sensitive function.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/629f0eb31b655a0009f7c416/service-worker.js"");```"
944	luckybetke.com.js	Improper Fetch Event Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of proper handling of the fetch event. The event listener is present but does nothing, which may lead to unintended behavior or missed opportunities for security enforcement, such as intercepting and validating requests.}	```self.addEventListener('fetch', () => {});```
945	sinclair.edu.js	Overly Permissive Cache Path Pattern	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the overly permissive regular expression in `cachePathPattern: /^\/(?:(css|images|js)\/(.+)?)?$/`, which allows caching of any path starting with /, including potentially unintended or malicious resources. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts`, `eval`, or `fetch` with untrusted input. Instead, it is a configuration flaw in the caching logic.}	```var config = { version: 'xi', staticCacheItems: ['/', '/www/css/mura.6.1.1.min.css', '/www/css/mura.6.1.1.skin.css', '/www/includes/themes/wwwBootstrap4/assets/bootstrap4/css/bootstrap.min.css', '/www/includes/themes/wwwBootstrap4/css/site.css', '/www/includes/themes/wwwBootstrap4/css/site_2016SU.css', '/www/includes/themes/wwwBootstrap4/css/site_bootstrap4.css', '/www/includes/themes/wwwBootstrap4/css/explore.css', '/www/includes/themes/wwwBootstrap4/css/RYPP.css', '/www/includes/themes/wwwBootstrap4/css/theCenter.css', '/www/includes/themes/wwwBootstrap4/css/bootstrap-select.min.css', '/www/includes/themes/wwwBootstrap4/css/buzina-pagination.min.css', '/www/includes/themes/wwwBootstrap4/css/font.css', '/www/includes/themes/wwwBootstrap4/css/all.min.css', '/www/includes/themes/wwwBootstrap4/webfonts/fa-light-300.woff2', '/www/includes/themes/wwwBootstrap4/webfonts/fa-regular-400.woff2', '/www/includes/themes/wwwBootstrap4/webfonts/fa-solid-900.woff2', '/www/jquery/jquery-3.5.1.min.js', '/www/jquery/popper.min.js', '/www/includes/themes/wwwBootstrap4/assets/bootstrap4/js/bootstrap.min.js', '/www/includes/themes/wwwBootstrap4/js/bootstrap-select.min.js', '/www/includes/themes/wwwBootstrap4/js/buzina-pagination.min.js', '/www/includes/themes/wwwBootstrap4/js/eventhover.js', '/www/includes/themes/wwwBootstrap4/js/jquery.anchor.js', '/www/includes/themes/wwwBootstrap4/js/jquery.easing.1.3.js', '/www/includes/themes/wwwBootstrap4/js/jquery.hoverIntent.minified.js', '/www/includes/themes/wwwBootstrap4/js/jquery.youtubeEmbed.js', '/www/includes/themes/wwwBootstrap4/js/moment.min.js', '/www/includes/themes/wwwBootstrap4/js/stickyfill.min.js', '/www/js/Chart.bundle.min.js', '/www/js/fetch.js', '/www/js/RYPP.js', '/www/js/theCenter.js', '/www/includes/themes/wwwBootstrap4/js/site.js', '/www/includes/themes/wwwBootstrap4/js/svgxuse.js', '/www/includes/themes/wwwBootstrap4/images/sinclair-logo.png', '/www/images/icons/icon-144x144.png', '/www/maintenance.html', '/www/404.html'], cachePathPattern: /^\/(?:(css|images|js)\/(.+)?)?$/, offlineImage: '<svg role=\'img\' aria-labelledby=\'offline-title\' viewBox=\'0 0 400 300\' xmlns=\'http://www.w3.org/2000/svg\'>' + '<title id=\'offline-title\'>Offline</title>' + '<g fill=\'none\' fill-rule=\'evenodd\'>' + '<path fill=\'#D8D8D8\' d=\'M0 0h400v300H0z\'/>' + '<text fill=\'#9B9B9B\' font-family=\'Times New Roman,Times,serif\' font-size=\'72\' font-weight=\'bold\'>' + '<tspan x=\'93\' y=\'172\'>offline</tspan>' + '</text>' + '</g>' + '</svg>', offlinePage: '/www/404.html' };```
946	rcgp.org.uk.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The empty fetch event handler does not involve any sensitive function misuse. It merely defines a handler without implementing any logic, which may be considered a potential oversight or incomplete implementation, but not a security vulnerability stemming from unsafe use of a sensitive function.}	```self.addEventListener('fetch', () => {});```
947	muslimassistant.com.js	Improper Handling of Fetch Events Leading to Information Leakage	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the fetch event handler's logic, which attempts to fetch resources from the network and falls back to the cache on failure. However, this does not involve misuse of a sensitive function like importScripts, eval, or dynamic code execution. The issue is more about improper error handling and potential information leakage through cache behavior, not direct function misuse.}	```self.addEventListener('fetch', event => { event.respondWith(async function () { try { return await fetch(event.request); } catch (err) { return caches.match(event.request); } }()); });```
948	atm88.org.js	Unnecessary Credentials in Fetch Request	Medium	false	N/A	0	N/A	N/A	"{The vulnerability arises from the use of `credentials: ""include""` in a fetch request, which exposes sensitive cookies or authentication tokens to the service worker. However, this is not caused by misuse of a sensitive function per se, but rather by a misconfiguration in the fetch options. No function is being misused in a way that introduces dynamic, untrusted input execution or injection.}"	```return fetch(i, { credentials: 'include' }).then(function (e) { return caches.open(c).then(function (n) { return n.put(i, e); }); });```
949	atm88.org.js	URL Decoding Bypass in Exclusion Check	Medium	true	N/A	N/A	decodeURI	standard	{The function `decodeURI` is used to decode a URL string before applying a regex test. If the input URL is controlled by an attacker and contains encoded characters, the decoding step may alter the string in a way that bypasses intended exclusion rules. This misuse allows malicious URLs to be processed as if they were benign, potentially leading to unintended resource access or cache manipulation.}	```return !!n.find(function (n) { return n.test(decodeURI(e)); });```
950	sugardaddyy.com.js	Improper Input Validation in Navigation Request Handling	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of navigation requests, particularly in how URLs are parsed and matched against regex patterns. The code does not sanitize or validate the input URL before applying regex tests, which could allow an attacker to craft a malicious URL that bypasses intended navigation restrictions. However, this is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in URL handling and regex matching.}	```if (req.mode !== 'navigate') { return false; } if (!this.acceptsTextHtml(req)) { return false; } const urlPrefix = this.scope.registration.scope.replace(/\/$/, ''); const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url; const urlWithoutQueryOrHash = url.replace(/[?#].*$/, ''); return this.navigationUrls.include.some(regex => regex.test(urlWithoutQueryOrHash)) && !this.navigationUrls.exclude.some(regex => regex.test(urlWithoutQueryOrHash));```
951	sugardaddyy.com.js	Weak Cryptographic Hash Usage (SHA)	Medium	false	N/A	N/A	N/A	N/A	{The use of SHA-1 for hashing is considered weak due to known collision vulnerabilities, but this is not a result of misuse of a sensitive JavaScript function. The vulnerability stems from cryptographic weakness rather than improper function usage. The code correctly computes SHA-1 hashes, but the algorithm itself is deprecated and insecure for certain use cases.}	```if (this.hashTable.get(url) !== hash) { return null; } const cacheState = await this.lookupResourceWithoutHash(url); return cacheState && cacheState.response;```
952	sugardaddyy.com.js	Insecure Bypass Parameter Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves bypassing service worker logic via the 'ngsw-bypass' parameter, but it is not caused by misuse of a sensitive JavaScript function. The code checks for the presence of this parameter in headers or query string, which is a legitimate control mechanism. The issue lies in the design decision to allow bypassing, not in improper use of a sensitive function.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) { return; }```
953	20minut.ua.js	Remote Code Inclusion via Dynamic Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from self[`hostUrl`], which is a hardcoded value. Although the value is not user-controlled, the dynamic construction of the URL from a variable makes it susceptible to tampering if the hostUrl is ever modified by an attacker or if the script is loaded in a context where self[`hostUrl`] can be overridden. This allows an attacker to inject arbitrary scripts by manipulating the hostUrl value, leading to remote code execution within the service worker context.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
954	20minut.ua.js	Untrusted Resource Loading via Hardcoded URL	High	false	CWE-829	N/A	N/A	N/A	{The URL 'https\u003A\/\/vn.20minut.ua\/sw.js' is hardcoded and directly passed to importScripts(). While this is a security concern due to loading from an untrusted domain, it does not involve dynamic or user-controlled input, and thus does not constitute misuse of a sensitive function in the context of sensitive function misuse (i.e., no dynamic input is involved). The vulnerability stems from poor trust boundary management, not from unsafe function usage with dynamic input.}	```self.importScripts('https\u003A\/\/vn.20minut.ua\/sw.js');```
955	fameex.com.js	Stale Content Delivery via Incomplete Cache Validation	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from incomplete cache validation logic, not from misuse of a sensitive function. The code performs a HEAD request to check if the cached resource is stale based on Last-Modified headers, but it does not handle cases where the server does not return Last-Modified headers or when the comparison fails due to missing or inconsistent header values. This leads to potential delivery of stale content, but no sensitive function is misused.}	```const networkResponse = fetch(event.request, { method: 'HEAD' }).then(networkResponse => { if (networkResponse.status === 200) { const cachedLastModified = cachedResponse.headers.get('Last-Modified'); const networkLastModified = networkResponse.headers.get('Last-Modified'); if (cachedLastModified !== networkLastModified) { return fetch(event.request).then(updatedResponse => { cache.put(event.request, updatedResponse.clone()); return updatedResponse; }); } return cachedResponse; } return cachedResponse; });```
956	yahoo.ca.js	Vulnerable URL Construction in Notification Click Handling	High	true	N/A	N/A	new URL	standard	"{The code constructs a URL using `new URL(r.replace(/&amp;/g, ""&""))` where `r` is derived from `n.url` in the notification data, which is user-controlled via push messages. Since the URL is built without sanitization or validation, an attacker could craft a malicious URL (e.g., with JavaScript payloads or redirects) that gets opened by `self.clients.openWindow(a)`, leading to open redirect or phishing attacks.}"	"```const a = new URL(r.replace(/&amp;/g, ""&""));```"
957	yahoo.ca.js	Insecure Message Origin Validation	Medium	true	N/A	N/A	PostMessage	standard	"{The code uses `self.addEventListener(""message"", ...)` to handle messages, and validates origin via `isValidOrigin(t)`. However, the validation only checks if the origin starts with `self.registration.scope`, which is insufficient for preventing cross-origin attacks. An attacker could send messages from a subdomain or similar origin, bypassing the check and executing arbitrary logic via the message handler.}"	```if (!e.isValidOrigin(t)) { const e = new Error('Invalid post message origin'); return N(e, { origin: t }); }```
958	yahoo.ca.js	Improper Input Validation in Beacon Parameters	Medium	false	N/A	N/A	N/A	N/A	{The code constructs beacon URLs using parameters from `n` (e.g., `_pl`, `_ms`, `_ts`) which are derived from internal state or user input. While these parameters are validated via `c` function, the validation is limited to format checks and does not prevent injection into the URL structure. However, no sensitive function like `eval`, `importScripts`, or `fetch` is misused with untrusted input, so this is not a sensitive function misuse.}	"```var s = { _pl: 17, _ms: u.time.ms, _ts: u.time.ts, A_v: ""YI13N-BG-"" + h, _gsqNo: d++ };```"
959	anacapri.com.br.js	Insecure Third-Party Script Import	Medium	false	N/A	N/A	N/A	N/A	{The importScripts() call is not dynamically constructed from untrusted input; it uses a hardcoded, trusted URL. While importing third-party scripts can pose risks, this specific usage does not constitute sensitive function misuse because the URL is static and not derived from user-controlled or untrusted sources.}	```self.importScripts('https://assets.emarsys.net/web-emarsys-sdk/4.3.1/web-emarsys-service-worker.js');```
960	hardzone.es.js	XSS via iframe srcdoc in error handling	High	true	N/A	N/A	`btoa`	standard	{The `btoa` function is used to encode the raw response body into a base64 string for use in an iframe's `src` attribute. If the response body contains malicious content (e.g., script tags), it can be executed when rendered in the iframe, leading to XSS. The function is misused because it does not sanitize or validate the input, allowing untrusted data to be directly encoded and embedded in the DOM.}	```const src = 'data:text/html;base64,' + btoa(errorText);```
961	hardzone.es.js	Insecure denylist for sensitive URLs	Medium	false	N/A	N/A	N/A	N/A	{The denylist is defined as a static array of regex patterns, but it does not properly cover all sensitive endpoints (e.g., `/wp-json/` is partially covered but may still allow bypasses). This is not caused by misuse of a sensitive function, but rather by incomplete or flawed logic in the denylist configuration.}	"```const denylist = [""^\\\/wp\\\/wp\\-admin($|\\?|\/)"", ""^[^\\?]*?\\.php($|\\?)"", ""\\?(.*?&)?wp_service_worker="", ""^[^\\?]*?\\\/wp\\.serviceworker(\\?|$)"", ""^[^\\?]*?\\\/feed\\\/(\\w+\\\/)?$"", ""\\?(.*?&)?wp_customize="", ""\\?(.*?&)?customize_changeset_uuid="", ""^\\\/wp\\-json\\\/""].map(pattern => new RegExp(pattern));```"
962	hardzone.es.js	XSS via JSON injection in error message	Medium	true	N/A	N/A	`JSON.stringify`	standard	{The `JSON.stringify` function is used to inject request and response properties into an HTML template. If the properties contain untrusted or malicious data (e.g., user-controlled headers or methods), they can be embedded into the DOM as JSON, potentially leading to XSS if the resulting string is not properly escaped or sanitized before being inserted into HTML.}	```body = body.replace('{{{WP_NAVIGATION_REQUEST_PROPERTIES}}}', JSON.stringify({ method: request.method, status: response.status }));```
963	hardzone.es.js	Supply chain risk from CDN import	High	true	N/A	N/A	`importScripts`	standard	{The `importScripts` function is used to dynamically load external scripts from a CDN URL constructed via `St(t)`. If the `modulePathPrefix` or `modulePathCb` is controlled by an attacker or misconfigured, it can lead to loading malicious scripts, resulting in supply chain compromise. The function is sensitive because it executes arbitrary remote code without validation.}	```importScripts(e), this.jt = !0;```
964	hardzone.es.js	Insecure use of navigator.onLine	Low	false	N/A	N/A	N/A	N/A	{The `navigator.onLine` property is used to determine network status, but it is unreliable and can be spoofed by the browser or attacker. This is not a misuse of a sensitive function, but rather a reliance on an inherently insecure API for critical logic.}	```const connectionMessage = navigator.onLine ? errorMessages.serverOffline : errorMessages.clientOffline;```
965	rozetka.pl.js	External Script Import Without Integrity Check	High	true	CWE-494	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows an attacker to compromise the script source (e.g., via DNS hijacking, man-in-the-middle attacks, or compromised CDNs) and inject malicious code into the service worker. Since the script is executed with full privileges in the context of the service worker, this can lead to complete compromise of the application’s offline behavior, cache manipulation, and interception of network requests.}	```importScripts('https://api.exponea.com/js/service-worker.min.js');```
966	rozetka.pl.js	External Script Import Without Integrity Check	High	true	CWE-494	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows an attacker to compromise the script source (e.g., via DNS hijacking, man-in-the-middle attacks, or compromised CDNs) and inject malicious code into the service worker. Since the script is executed with full privileges in the context of the service worker, this can lead to complete compromise of the application’s offline behavior, cache manipulation, and interception of network requests.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.0.0/workbox-sw.js');```
967	portmone.com.ua.js	Vulnerable Cache Revalidation Logic	High	true	N/A	N/A	needToRevalidate	standard	{The needToRevalidate function improperly evaluates cache freshness by relying on potentially untrusted or manipulated headers (e.g., Cache-Control, Expires) without validating their integrity or origin. This allows an attacker to spoof cache headers, leading to premature or delayed revalidation, which can result in serving stale or malicious content.}	```if (await this.needToRevalidate(req, cachedResponse)) {```
968	portmone.com.ua.js	Insecure Cache Busting Implementation	Medium	true	N/A	N/A	cacheBust	standard	{The cacheBust function constructs a URL by appending a random string to the original URL using a dynamic query parameter. This is vulnerable to cache poisoning if the original URL is controlled by an attacker, as it may lead to unintended cache keys being generated and stored, potentially allowing cache manipulation or bypass.}	"```return url + (url.indexOf(""?"") === -1 ? ""?"" : ""&"") + ""ngsw-cache-bust="" + Math.random();```"
969	portmone.com.ua.js	Insufficient Cache Validation	High	true	N/A	N/A	sha1Binary	standard	{The sha1Binary function is used to compute a hash of the fetched resource, but the comparison with the canonical hash is performed without verifying the integrity of the hash source or ensuring the hash is derived from a trusted, non-mutable source. This allows an attacker to manipulate the hash comparison logic if the canonical hash is derived from untrusted input, leading to cache poisoning or bypass.}	```if (canonicalHash !== cacheBustedHash) {```
970	portmone.com.ua.js	Insecure Error Handling in Fetch	Low	false	N/A	N/A	N/A	N/A	{The error handling in safeFetch is not directly caused by misuse of a sensitive function; it merely returns a generic 504 response on fetch failure. While this may lead to information leakage or denial of service, it does not stem from a sensitive function misuse.}	"```return this.adapter.newResponse(null, { status: 504, statusText: ""Gateway Timeout"" });```"
971	portmone.com.ua.js	Insecure LRU Cache Eviction	Medium	true	N/A	N/A	LruList	standard	{The LruList class manages cache eviction based on access patterns, but it does not validate the URLs being accessed or evicted. If an attacker can trigger a large number of requests to arbitrary URLs, they can manipulate the LRU list to evict legitimate cached resources, leading to denial of service or cache pollution.}	```if (lru.size >= this.config.maxSize) {```
972	sporttv.pt.js	Improper Message Handling Leading to Service Worker Activation	Medium	false	N/A	0	N/A	N/A	"{The vulnerability arises from improper handling of messages in the service worker, specifically the use of `self.addEventListener(""message"", ...)` to respond to messages with type ""SKIP_WAITING"". However, this is not due to misuse of a sensitive function, as `addEventListener` is used correctly and does not involve dynamic or untrusted input. The issue is more about logic or design rather than sensitive function misuse.}"	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); })```"
973	sporttv.pt.js	Cache Invalidation Bypass Due to Null Revision	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from a null revision value in the precache configuration, which can lead to cache invalidation bypass. This is not caused by misuse of a sensitive function, as `precacheAndRoute` is used correctly with static configuration data. The issue is a configuration flaw, not a function misuse.}	```e.precacheAndRoute([{ url: '_nuxt/builds/meta/8491cc7a-584d-4e93-af5a-dcb08e04e8a3.json', revision: null }], {});```
974	guardianproject.info.js	Remote Code Execution (RCE) via Dynamic Plugin Loading	High	true	CWE-960	N/A	self.importScripts	standard	{The function importScripts() is a standard service worker API that executes a script from a given URL. In this case, the URL is dynamically constructed using pluginConfig.name, which is derived from the config.json file loaded from the network. If an attacker can manipulate the config.json to include a malicious plugin name (e.g., a path to a remote script or a local file), the service worker will load and execute arbitrary code, leading to Remote Code Execution. The input is untrusted and unsanitized, making this a high-confidence sensitive function misuse.}	```self.importScripts(`./plugins/${pluginConfig.name}/index.js`);```
975	guardianproject.info.js	Insecure Config Handling Leading to XXE/SSRF	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from constructing a URL using self.registration.scope + 'config.json', which is not inherently a sensitive function misuse. The issue is more about insecure configuration handling and potential SSRF if the scope is manipulated, but no sensitive JavaScript function like fetch or importScripts is misused with dynamic input.}	"```var configURL = self.registration.scope + ""config.json"";```"
976	guardianproject.info.js	Information Leakage via Debug Logging	Low	false	N/A	N/A	N/A	N/A	{The use of console.debug() is not a sensitive function misuse. While it may lead to information leakage, the function itself is not inherently dangerous when used with static or controlled data. The vulnerability stems from logging sensitive data (like commit hash) rather than misuse of a sensitive function.}	```console.debug(`LibResilient [COMMIT_UNKNOWN, ${component}] ::`, ...items);```
977	investindia.gov.in.js	Uncontrolled Resource Consumption in Cache.addAll	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of cache.addAll([`/`]), which attempts to cache the root path. While this is not directly caused by misuse of a sensitive function, it can lead to unintended resource consumption if the root path resolves to a large or dynamic resource. However, since the URL is hardcoded and not derived from untrusted input, it does not constitute sensitive function misuse.}	```const cacheName = `invest-india-${version}`; e.waitUntil(caches.open(cacheName).then(cache => { return cache.addAll([`/`]).then(() => self.skipWaiting()); }));```
978	hickoryrecord.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-602	10	N/A	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from the FCM message payload. Since this data is controlled by the server sending the notification (and potentially by an attacker if the server is compromised), it allows for unvalidated URL construction. If the URL is crafted to redirect to a malicious site, it can lead to open redirect vulnerabilities, enabling phishing or malicious redirection.}	```let oURL = new URL(oData.url);```
979	pleciona.pl.js	Open Redirect via Notification Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from constructing a URL using `notificationData.content.id` without validation, but no sensitive JavaScript function is misused. The risk is due to unsanitized input in URL construction, not a function misuse.}	```url = `${self.location.origin}/admin/orders/view/id/${notificationData.content.id}`;```
980	pleciona.pl.js	XSS in Offline Page Translation Logic	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from dynamic translation logic using `innerHTML` assignment without sanitization, but no sensitive JavaScript function is directly misused. The risk is due to improper handling of user-controlled content in DOM, not a function misuse.}	"```translations = { pl: { ""You're not connected to the internet"": ""Nie masz połączenia z internetem"", ""When you connect, refresh the page."": ""Odśwież stronę, gdy połączysz się ponownie."", ""go back"": ""wróć"" } };```"
981	pleciona.pl.js	Unvalidated Cache Namespace Update	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used to retrieve a cache namespace from a remote endpoint without validating the response. If an attacker can control the response, they can inject arbitrary cache names, leading to cache poisoning or bypassing intended caching logic.}	```fetch(CACHE_CHECK_URL, { cache: 'no-cache' }).then(response => { if (response.status === 200) { response.text().then(namespace => { self._cacheNamespace = namespace; }); commands.clearOldCache(); } });```
982	pleciona.pl.js	Service Worker Unregistration on Network Failure	Low	false	N/A	N/A	N/A	N/A	{The vulnerability is due to unconditional unregistration on network failure, but no sensitive JavaScript function is misused. The risk is operational, not a direct function misuse.}	```self.registration.unregister();```
983	t83.me.js	Dynamic Script Loading with Potential for Remote Code Execution	High	true	CWE-960	10	importScripts	standard	{The function `importScripts()` is used to dynamically load and execute scripts from a URL specified by the variable `e`, which is derived from user input (via the `define` function's argument). Since `e` is not sanitized or validated, an attacker could supply a malicious script URL, leading to remote code execution within the service worker context. This is a classic case of unsafe dynamic script loading.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); };```"
984	beobachter.ch.js	Cross-Origin Cache Bypass	High	true	CWE-497	8	Headers	standard	{The code creates a new Headers object from the headers of a response (a.headers) without validating or sanitizing the origin of the response. Since the response may originate from a cross-origin source, this allows an attacker to inject or manipulate headers that could bypass cache security policies, leading to unauthorized access or data leakage. The misuse of Headers in this context enables a cross-origin cache bypass by allowing potentially malicious headers to be copied and used in subsequent operations.}	```const r = new Headers(a.headers), status: a.status, statusText: a.statusText```
985	sendo.vn.js	Open Redirect Vulnerability	High	true	N/A	N/A	self.clients.openWindow	standard	{The code conditionally calls self.clients.openWindow(a) where 'a' is derived from the notification's data.url, which is user-controlled. Since this URL is not validated or sanitized, an attacker can craft a malicious notification payload with a URL pointing to an arbitrary external site, leading to an open redirect. This allows the attacker to redirect users to phishing sites or other malicious destinations, compromising user security.}	"```if (null === i || void 0 === i || null === (r = i.data) || void 0 === r ? void 0 : r.url) { const s = !!(null === i || void 0 === i || null === (r = i.data) || void 0 === r ? void 0 : r.url), a = s ? i.data.url : ""https://www.sendo.vn/"", c = s ? i.data : null; c && t.getToken().then(e => function (e, t) { return fetch(u(e, t, ""click"")).catch(e => console.error(""[Service Worker]"", e)); }(e, c.title || c.message_id)).catch(console.log), e.waitUntil(self.clients.matchAll({ type: ""window"" }).then(function () { if (e.notification.close(), self.clients.openWindow) return self.clients.openWindow(a); })); }```"
986	alkhabarkw.com.js	Hardcoded Sensitive Information (Firebase API Key)	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (Firebase API key) in the code, not from misuse of a sensitive function.}	```firebase.initializeApp({ ...options.firebaseConfig });```
987	alkhabarkw.com.js	Unvalidated URL Redirection in Notification Click	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic targetUrl derived from notification data, which is not validated or sanitized. This allows an attacker to craft a malicious notification payload that redirects users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
988	alkhabarkw.com.js	Cleartext Storage of Sensitive Data in IndexedDB	Medium	false	CWE-312	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption, not from misuse of a sensitive function.}	```const request = objectStore.put({ id: key, data: value });```
989	shahremix.ir.js	External Code Injection via Untrusted importScripts	High	true	CWE-94	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL that points to an external domain (e.g., 'https://van.najva.com/...'), it introduces a risk if the domain is not fully trusted or if the script can be tampered with. Although the URL is hardcoded here, the vulnerability arises because the script is being imported from an external source, which could be compromised or controlled by an attacker, leading to arbitrary code execution within the service worker context. This constitutes a sensitive function misuse due to the inherent trust required in the imported script.}	```importScripts('https://van.najva.com/static/js/scripts/new-website817935-website-54765-9e0f1cec-8f9c-4533-ad5c-bebeac26f1a3-service-worker.js');```
990	free-hearts.com.js	Information Exposure Through Error Message	Low	false	CWE-200	0	N/A	N/A	{The vulnerability arises from the error message revealing the URL being fetched, which could expose internal paths or resources. However, this is not due to misuse of a sensitive function like importScripts, eval, or dynamic code execution, but rather from logging or throwing an error with user-controlled or dynamic data. The function `throw new Error` is standard but not classified as a sensitive function in the context of code injection or remote code execution.}	```return fetchAndCache(cacheKey, cache).then(response => { if (!response.ok) { throw new Error(`Error downloading ${cacheKey}`); } cache.put(cacheKey, response.clone()); return response; });```
991	hik-partner.com.js	Improper Input Validation in URL Handling	High	false	CWE-20	0	N/A	N/A	{The vulnerability arises from insufficient validation of the URL during route matching, but no sensitive function like importScripts, eval, or dynamic code execution is involved. The code uses standard URL parsing and matching, which does not inherently introduce a sensitive function misuse.}	```const { params: r, route: a } = this.findMatchingRoute({ event: t, request: e, sameOrigin: n, url: s });```
992	hik-partner.com.js	Insecure Cache Key Generation	Medium	false	CWE-20	0	N/A	N/A	{The issue stems from potential insecure handling of cache keys, but it does not involve direct misuse of a sensitive JavaScript function such as eval, importScripts, or dynamic code execution. The cache key generation is based on internal logic and does not expose external input to unsafe functions.}	```const { cacheName: e, matchOptions: t } = this._strategy, n = await self.caches.open(i), a = this.hasCallback('cacheDidUpdate');```
993	hik-partner.com.js	Regex Pattern Vulnerability in Route Matching	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability is due to a potentially overly permissive regex pattern used for route matching, but it does not involve misuse of a sensitive JavaScript function. The regex is used for pattern matching in routing logic, not for dynamic code execution or unsafe function invocation.}	```f(/.*\.\w+\?hash=\w+$/, new class extends D { ... }({ cacheName: 'workbox-subfix-hash', ... }));```
994	facilisimo.com.js	Improper Input Validation Leading to Potential Injection	Medium	false	CWE-20	N/A	N/A	N/A	{The code parses JSON from event.data.text() without validating or sanitizing the input. While JSON.parse() itself is not inherently a sensitive function, the vulnerability arises from improper input validation, not direct misuse of a sensitive function.}	```var obj = JSON.parse(event.data.text());```
995	facilisimo.com.js	Unvalidated URL Opening in Notification Click Handler	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from event.notification.data.url without validation, an attacker could craft a malicious notification payload to redirect users to phishing sites or perform other malicious actions.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
996	saxotrader.com.js	Server Side Request Forgery (SSRF) via unvalidated config parameters	High	true	CWE-918	9	fetch	standard	{The URL constructed using `e.registration.scope` and dynamic parameters (`lang`, `appId`, `appIds`, `theme`) is passed directly to `fetch()`, which can be manipulated if these parameters are derived from untrusted sources. This allows an attacker to forge requests to internal or external endpoints, leading to SSRF.}	```let u = `${e.registration.scope}static/v.ashx?lang=${o}${s}${c}`;```
997	saxotrader.com.js	Insecure logging with potential log injection	Low	false	CWE-117	0	N/A	N/A	{The log message includes dynamic data (`i` and `r`) but is not directly passed to a sensitive function like `eval` or `importScripts`. The `JSON.stringify()` ensures safe serialization, and the `fetch` call is not vulnerable to injection via the log data.}	```body: JSON.stringify([{\n AppName: 'serviceWorker',\n Data: i,\n IsFatal: !1,\n IsNetworkError: !1,\n LogLevel: n,\n Message: `[service-worker] ${r}`\n }])```
998	saxotrader.com.js	Insecure cache storage with potential XSS	Medium	true	CWE-79	8	caches.open	standard	{The `caches.open()` function is used to store data derived from untrusted input (`t` from `e.data`), which is then serialized with `JSON.stringify()`. If the data contains malicious scripts or HTML, and if it is later retrieved and executed in the context of a page (e.g., via `eval` or `innerHTML`), it could lead to XSS. The cache storage itself is not directly exploitable, but the stored data may be used in unsafe contexts later.}	```c(i, JSON.stringify(t))```
999	dave.com.js	Insecure Dynamic Function Execution	High	true	CWE-96	9	N/A	standard	{The function MessageAPI[data.api]() dynamically invokes a method from the MessageAPI object based on user-controlled input 'data.api'. Since 'data.api' is derived from the URL pathname via a regex match and not validated or sanitized, an attacker can craft a request to trigger arbitrary method calls, potentially leading to unauthorized operations such as clearing caches or enabling/disabling offline shell features. This constitutes dynamic function execution via a sensitive function misuse.}	```MessageAPI[data.api]();```
1000	dave.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of the 'params' string extracted from the URL pathname using a regex. However, this is not directly caused by misuse of a sensitive function, but rather by flawed logic in parsing and handling input. The regex match and subsequent split operations are standard string operations and do not inherently introduce risk unless combined with unsafe function calls.}	```const params = pathname.match(/:(.+)/)[1];```
1001	dave.com.js	Open Redirect	Medium	true	CWE-601	8	N/A	standard	{The function Response() is used to create a redirect response with a Location header set to 'lastNavigationRequest', which is derived from the event.request.url. Since this value is not validated or sanitized, an attacker can manipulate the URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities. The misuse of Response() with untrusted input constitutes a sensitive function misuse.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
1002	dave.com.js	Unrestricted Cache Clearing	Medium	true	New	9	N/A	standard	{The function idbKeyval.clear() is called without any conditions or user authentication, and it is triggered via a message event from the client. Since idbKeyval.clear() is a standard API for clearing IndexedDB storage, and it is invoked without validation of the message source or intent, an attacker can send a message to clear all stored data, leading to data loss or denial of service. This is a misuse of a sensitive function due to lack of access control.}	```event.waitUntil(idbKeyval.clear());```
1003	independentespanol.com.js	External Script Import Without Integrity Check	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard service worker API that executes a remote script. When used with a hardcoded external URL like 'https://js.appboycdn.com/web-sdk/4.8/service-worker.js' without an integrity check, it introduces a risk of script injection if the remote script is compromised. An attacker could modify the script at the remote location, leading to unauthorized code execution within the service worker context, potentially enabling cache manipulation, network interception, or data exfiltration.}	```self.importScripts('https://js.appboycdn.com/web-sdk/4.8/service-worker.js');```
1004	bricsys.com.js	Unvalidated Message Handling in Service Worker	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from handling incoming messages without validating or sanitizing the message data, but it is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The code simply checks for a specific message type and calls self.skipWaiting(), which is a safe operation. There is no dynamic code execution or dangerous API misuse involved.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
1005	playojo.com.js	Unrestricted Import of Code from Untrusted Sources	Medium	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, it imports a script from 'https://js.appboycdn.com/web-sdk/2.1/service-worker.js', which is an external, third-party source. While the URL is hardcoded, the vulnerability arises because the script is loaded from an untrusted external domain, potentially allowing an attacker to compromise the service worker if the external source is compromised or if the domain is spoofed. This constitutes a misuse of a sensitive function due to lack of trust validation.}	```self.importScripts('https://js.appboycdn.com/web-sdk/2.1/service-worker.js');```
1006	rtspro.com.js	Insecure External Script Import	High	true	New	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (https://aswpsdkus.com/notify/v1/ua-sdk.min.js), it introduces a risk if the external script is compromised or if the domain is not fully trusted. Although the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing external code from a third-party domain still constitutes a potential attack surface, especially if the script can be modified by an attacker. This is considered a sensitive function misuse because it allows execution of unverified code in the context of the service worker.}	"```importScripts(""https://aswpsdkus.com/notify/v1/ua-sdk.min.js"")```"
1007	rtspro.com.js	Hardcoded Sensitive Data (appKey/token	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability arises from the exposure of sensitive credentials (appKey, token, vapidPublicKey) directly in the source code. This is not caused by misuse of a sensitive function, but rather by poor secret management practices. The uaSetup.worker() function is a custom function provided by the UrbanAirship SDK and is not inherently dangerous when used correctly. The issue lies in the hardcoded values, not in the function's behavior or input handling.}	```uaSetup.worker(self, { defaultIcon: 'https://c00266-dl.urbanairship.com/binary/public/DlQkONfEQgevV8kwgwlSjQ/884db3a3-ff6d-48b6-b6a6-91e66983e773', defaultTitle: 'RTS Pro', defaultActionURL: 'https://rtspro.com/', appKey: 'DlQkONfEQgevV8kwgwlSjQ', token: 'MTpEbFFrT05mRVFnZXZWOGt3Z3dsU2pROkNlMENTX1o0MFhyd2dYM2xRYTdpYUR5OU1LdERxd2hkZHZvREMwWWNKN0k', vapidPublicKey: 'BJzpduKnh1AJde_ZrZghe-OSbzKXhO3bcHXyH_OY-PdCU4Oxw1w6VsTtM-OZUOLRWPGE--67nS_OIU0Q162Hxss=' });```
1008	luxtimes.lu.js	Insecure External Script Loading	Medium	true	CWE-434	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script ('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js'), which introduces a medium-risk vulnerability because it relies on an external, potentially untrusted source. While the URL is not dynamically constructed from user input, the lack of integrity verification or origin validation makes it susceptible to supply chain attacks if the external script is compromised.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
1009	luxtimes.lu.js	Hardcoded Sensitive Credentials	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (appKey, token, vapidPublicKey) within the script. This is not caused by misuse of a sensitive function, but rather by poor secret management practices. The uaSetup.worker() function is a custom function, and its use does not inherently introduce the vulnerability; the issue lies in the exposure of secrets in the source code.}	```uaSetup.worker(self, { defaultIcon: 'https://shared.mediahuis.be/logos/lt/v1/brand\u002Dsquare\u002Dmain/256x256.png?new', defaultTitle: 'Luxemburger Times', defaultActionURL: 'https://luxtimes.lu/', appKey: 'X880b3G0SDeeqWQbYLBIiA', token: 'MTpYODgwYjNHMFNEZWVxV1FiWUxCSWlBOi13SHZYelRxMlExQWZndm5aLW94em1RNWFSZlRaQzUybWJrZGd4T2t2X1E', vapidPublicKey: 'BBG23ETovniQULgo0tSSnAOtKnUEmnPS5PLZZNqSY6xVUhkFohpGZiVxw987cZwmePM0qsiKN9eX44DL-7U7jBM=' });```
1010	npccindia.com.js	Open Redirect	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is used to open a new window or tab with a URL derived from event.notification.data.url, which is user-controlled. Since no validation or sanitization is applied to this URL, an attacker can manipulate it to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	N/A
1011	npccindia.com.js	Server Side Request Forgery	High	true	CWE-918	9	fetch	standard	{The function fetch(apiUrl) is called with apiUrl derived from event.notification.data.api_url, which is user-controlled. Without proper validation or sanitization, this allows an attacker to forge requests to internal or external systems, leading to SSRF vulnerabilities.}	N/A
1012	npccindia.com.js	Improper Input Validation	Medium	false	CWE-20	0	N/A	N/A	{The code stores data in IndexedDB using objectStore.put({ id: key, data: value }), but the vulnerability is due to improper input validation of the key and value, not misuse of a sensitive function. The function itself is not inherently dangerous when used correctly.}	N/A
1013	covery.ai.js	Improper Regular Expression Handling Leading to Cache Poisoning	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper handling of the regular expression in the route registration, but it does not stem from misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The regex pattern is static and does not involve dynamic input or function calls that could lead to code injection or execution.}	```workbox.routing.registerRoute(/(\\.js$|\\.css$|static\\/)/, new workbox.strategies.CacheFirst(), 'GET');```
1014	covery.ai.js	Improper Input Validation in API Request Handling	Medium	false	CWE-754	N/A	N/A	N/A	{The vulnerability stems from inadequate validation of the `params` extracted from the URL pathname using a regex, but no sensitive JavaScript function like eval, importScripts, or Function is misused. The code parses the URL path and uses it for routing or data lookup, but does not execute dynamic code or load external scripts based on user input.}	```const params = pathname.match(/:(.+)/)[1];```
1015	waspbet04.com.js	Improper Handling of Exceptional Conditions (addAll failure)	High	false	N/A	0	N/A	N/A	{The vulnerability arises from not handling potential failures of cache.addAll(), which could leave the service worker in an inconsistent state. However, this is not due to misuse of a sensitive function, but rather a lack of error handling.}	```var cacheStorageKey = '291jili-new';\nvar cacheList = ['index.html'];\nself.addEventListener('install', function (e) {\n console.log('开始安装: ' + cacheStorageKey);\n e.waitUntil(caches.open(cacheStorageKey).then(function (cache) {\n console.log('添加需要缓存资源的列表: ', cacheList);\n return cache.addAll(cacheList);\n }).then(function () {\n console.log(cacheStorageKey + '安装完成');\n return self.skipWaiting();\n }));\n});```
1016	waspbet04.com.js	Incorrect URL Validation Using indexOf	High	true	N/A	10	indexOf	standard	{The use of indexOf() to validate URLs is insufficient because it does not properly parse or validate the URL structure. For example, a URL like 'http://evil.com/https://example.com' could pass the check if it contains 'https://example.com' as a substring, leading to unintended resource fetching or cache manipulation. This is a misuse of a standard string method in a security-critical context.}	```self.addEventListener('fetch', function (e) {\n return;\n if (e.request.url.indexOf('http') !== 0) {\n return;\n }\n if (e.request.url.indexOf(self.location.origin) !== 0) {\n return;\n }\n if (e.request.url.indexOf('serviceWorker.js') !== -1) {\n return;\n }\n e.respondWith(fetch(e.request.url).then(function (httpRes) {\n var o = self.location.origin;\n var s = self.decodeURIComponent(e.request.url);\n var i = s.indexOf(o);\n var u = s.slice(i + o.length);\n var req = httpRes.clone();\n caches.open(cacheStorageKey).then(function (cache) {\n cache.delete(e.request).then(function () {\n if (cacheList.indexOf(u) !== -1) {\n cache.put(e.request, req);\n }\n ;\n });\n });\n return httpRes;\n }).catch(function (err) {\n console.error(e.request.url + '请求失败，将读取service worker缓存');\n return caches.match(e.request);\n }));\n});```
1017	waspbet04.com.js	Early Return Bypassing Fetch Handling	High	false	N/A	0	N/A	N/A	{The vulnerability stems from an early `return;` statement at the beginning of the fetch event handler, which causes the entire handler to be skipped regardless of the request. This is a logic flaw, not a misuse of a sensitive function.}	```self.addEventListener('fetch', function (e) {\n return;\n if (e.request.url.indexOf('http') !== 0) {\n return;\n }\n if (e.request.url.indexOf(self.location.origin) !== 0) {\n return;\n }\n if (e.request.url.indexOf('serviceWorker.js') !== -1) {\n return;\n }\n e.respondWith(fetch(e.request.url).then(function (httpRes) {\n var o = self.location.origin;\n var s = self.decodeURIComponent(e.request.url);\n var i = s.indexOf(o);\n var u = s.slice(i + o.length);\n var req = httpRes.clone();\n caches.open(cacheStorageKey).then(function (cache) {\n cache.delete(e.request).then(function () {\n if (cacheList.indexOf(u) !== -1) {\n cache.put(e.request, req);\n }\n ;\n });\n });\n return httpRes;\n }).catch(function (err) {\n console.error(e.request.url + '请求失败，将读取service worker缓存');\n return caches.match(e.request);\n }));\n});```
1018	phooto.com.br.js	Insecure External Script Loading	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL like '//cdnt.netcoresmartech.com/swv4.js', it is not inherently vulnerable. However, if the URL were dynamically constructed from untrusted input (e.g., from query parameters or user-controlled data), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse but rather due to loading an external script from a potentially untrusted domain. Therefore, while the function itself is sensitive, the misuse is not present here.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
1019	bolsadeaposta.com.js	Denial of Service via Redirect Loop	High	true	CWE-400	10	fetch	standard	{The fetch function is used recursively without proper validation or rate limiting when handling redirects. The code checks if res.redirected is true and then recursively calls fetchFromNetwork with a new request based on res.url, decrementing a redirectLimit counter. If an attacker can trigger a redirect loop (e.g., by controlling the URL or server response), the recursive calls can exhaust the call stack or consume excessive resources, leading to a denial of service. The function is standard and its misuse here is directly responsible for the vulnerability.}	```if (res.redirected && !!res.url) { if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`); } return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1); } return res;```
1020	bolsadeaposta.com.js	Insecure Hash Algorithm	Medium	false	CWE-327	10	N/A	N/A	{The vulnerability arises from the use of SHA-1 for hashing the manifest, which is considered cryptographically weak and susceptible to collision attacks. However, this is not due to misuse of a sensitive JavaScript function, but rather a cryptographic design flaw. The hashManifest function is custom, but its use does not involve unsafe input handling or dynamic function calls that would classify it as sensitive function misuse.}	```const hash = hashManifest(manifest); return { latest: hash };```
1021	flip.id.js	Vulnerability in Cache Strategy for Sensitive Data	High	false	CWE-924	0	N/A	N/A	"{The vulnerability arises from the caching strategy applied to Next.js data routes (e.g., /_next/data/...), which may store sensitive or dynamic data in the cache for up to 24 hours. This is not directly caused by misuse of a sensitive JavaScript function like importScripts() or eval(), but rather by a misconfigured caching policy that could lead to data leakage or stale sensitive data being served. Since no sensitive function is misused, this is not a ""sensitively_vulnerable"" issue.}"	```e.registerRoute(/\/_next\/data\/.+\/.+\.json$/i, new e.StaleWhileRevalidate({ cacheName: 'static-data-assets', plugins: [new e.ExpirationPlugin({ maxEntries: 32, maxAgeSeconds: 86400 })] }), 'GET');```
1022	wondershare.es.js	Improper Input Validation	Medium	true	CWE-20	8	N/A	standard	{The function `buildParamsObj2String` constructs a query string for Google Analytics by directly concatenating user-controlled inputs such as `eventAction` and `buttonText` (from `pushContent.data`) into the `el` parameter without sanitization. Since these values are derived from untrusted push notification data, they can be manipulated by an attacker to inject arbitrary tracking parameters, potentially leading to data exfiltration or tracking manipulation. The use of `res += key + '=' + paramsObj[key] + '&'` without escaping or validation makes this a sensitive function misuse.}	```function buildParamsObj2String(eventAction, buttonText) { var paramsObj = { v: 1, _v: 'j87', a: uuid(), t: 'event', ni: 0, ds: 'web_GTM-' + gtmReportObj.GTM_ID_SUFFIX + '_15', _s: 1, dl: gtmReportObj.location || '', dp: gtmReportObj.path || '', ul: 'zh-cn', de: 'UTF-8', sd: '24-bit', je: 0, ec: gtmReportObj.EVENT, ea: eventAction, el: '___', _u: 'SCCAAEALAAAAAC~', jid: uuid(), gjid: uuid(), cid: gtmReportObj.gackv || '1465743785.1608088318', tid: gtmReportObj.TID, _r: 1, gtm: '2wgbu0' + gtmReportObj.GTM_ID_SUFFIX, cd2: gtmReportObj.gackv || '1465743785.1608088318', cd3: new Date().getTime(), z: uuid() }; if (pushContent && pushContent.id) { var id = pushContent.id; var messageId = id.split('-')[1]; var statPoint = pushContent.stat_point; var uid = pushContent.wsid || 'null'; var pid = statPoint.pid || 'null'; var pver = statPoint.pver || 'null'; var track_id = statPoint.track_id; var operation_id = statPoint.operation_id; var label = messageId + '___UA-WGP-System___' + uid + '___' + pid + '___' + pver + '___web_notification___' + track_id + '___' + operation_id; if (eventAction === 'wgp_page_click') { label = label + '___' + buttonText; } paramsObj.el = label; if (pushContent.data && pushContent.data.gaid && gtmReportObj.gackv === '') { var gaCookieValue = pushContent.data.gaid; paramsObj.cid = gaCookieValue; paramsObj.cd2 = gaCookieValue; } } var res = ''; for (var key in paramsObj) { res += key + '=' + paramsObj[key] + '&'; } if (res.endsWith('&')) { var len = res.length; res = res.substring(0, len - 1); } return res; }```
1023	aathavanitli-gani.com.js	Lack of Error Handling During Cache Population	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from not handling potential errors during cache population, such as network failures or invalid responses, but it is not due to misuse of a sensitive function.}	```await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
1024	aathavanitli-gani.com.js	Use of 'cache: 'reload'' Directive in Request	Low	false	New	N/A	N/A	N/A	{Using 'cache: 'reload'' forces a network request even if the resource is cached, which may lead to unnecessary network usage or timing issues, but it does not involve misuse of a sensitive function.}	```await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
1025	aathavanitli-gani.com.js	Incorrect Cache Matching in Fetch Event	Medium	false	New	N/A	N/A	N/A	{The issue is that the cache.match() call may not correctly retrieve the intended offline resource if the URL or cache key is not properly managed, but this is a logic or configuration issue, not misuse of a sensitive function.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
1026	jack-wolfskin.de.js	Dynamic Code Evaluation via Untrusted Input in Service Worker	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed by concatenating a base URL with location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts, leading to remote code execution within the service worker context.}	```importScripts(`https://jackwolfskin.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1027	dewabiz.com.js	Improper Validation of Referrer Header	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the referrer header using a regex that only checks for 'wp-admin' at the start of the URL. This is not a sensitive function misuse, but rather a logic flaw in the validation logic. The code does not use any sensitive JavaScript functions like importScripts, eval, or dynamic code execution.}	```if (event.request.referrer.match(/^(wp-admin):\/\//i)) return;```
1028	mandikerates.in.js	Exposure of Sensitive Information in Service Worker	High	true	CWE-200	10	none	N/A	{The sensitive information (API keys, project IDs, VAPID keys) is hardcoded in the service worker script and exposed in the source code. While no sensitive function is directly misused, the exposure is due to improper handling of secrets in client-side code, which is a critical security flaw.}	```const options = { firebaseConfig: { projectId: 'mandikerates-2101c', messagingSenderId: '618301485222', appId: '1:618301485222:web:26bb6adfe57c5231120467', apiKey: 'AIzaSyDemBK2R2F0Cgg9h_k5vGrbuT0_vFV02Lo' }, domain: 'mandikerates.in', api_url: 'https://push.todaymandibhav.in/api/token', vapid_public_key: 'BD_HOjWvHZn--_z9qX4p3SpeYnJ0Odz8ortzUuuIqCE-dyquM8ypm9MJUoD3qkbGuJHLI0Av5LUc7XvRYyJ15U4' };```
1029	mandikerates.in.js	Open Redirect via Untrusted Notification URL	High	true	CWE-601	9	clients.openWindow	N/A	{The clients.openWindow() function is called with a URL derived from untrusted notification data (event.notification.data.url or event.notification.data.actions[event.action].click_action). Since the URL is not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl);```
1030	mandikerates.in.js	Insecure Storage of Sensitive Data in IndexedDB	Medium	true	CWE-200	8	IndexedDB	N/A	{The IndexedDB API is used to store sensitive data (e.g., notification tokens) without encryption or access controls. Since IndexedDB is accessible from the client-side and not protected by server-side security, this exposes sensitive data to potential theft or misuse if the user's device is compromised.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value });```
1031	mandikerates.in.js	Potential Server Side Request Forgery (SSRF) via Unvalidated URL	Medium	true	CWE-918	9	fetch	N/A	{The fetch() function is used to send data to a hardcoded API endpoint (options.api_url), but the 'url' parameter passed to the API is derived from an untrusted source (the notification payload). If the server processes this URL without validation, it could be exploited to make requests to internal or unintended endpoints, leading to SSRF.}	```domain = options.domain; if (http) { domain = getDomainAndHostname(url).hostname; } await fetch(options.api_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```
1032	mojabet.co.zm.js	Improper Caching of Sensitive Data	High	true	CWE-921	9	caches.put	standard	{The function caches.put is used to store responses in the cache without validating or sanitizing the request URL. The code checks if the URL matches certain patterns (e.g., .js, .css, .svg) using a custom function `n`, but it does not prevent caching of sensitive or dynamic resources that may be fetched from untrusted sources. This allows potentially sensitive data to be cached and exposed to unauthorized access, especially if the service worker is compromised or if the cache is accessed by other origins via shared storage mechanisms.}	```const r = n(s, i?.url);```
1033	ukssscecf.in.js	Exposure of Sensitive Information in Service Worker	High	true	CWE-200	10	N/A	standard	{The sensitive function `const` is not a function, but the vulnerability arises from the exposure of sensitive Firebase configuration data (including apiKey) directly in the service worker script. Since this script is accessible to the client, any attacker can extract these credentials, leading to unauthorized access to Firebase services. The data is hardcoded and not processed by a function, so no function misuse is directly involved, but the exposure is due to the script being served as-is to the client.}	```const options = { firebaseConfig: { projectId: 'push-d17f9', messagingSenderId: '214672967324', appId: '1:214672967324:web:9421fe3318bce722ac4f59', apiKey: 'AIzaSyBNZHhozbu702eYJqRJP9JsiRivSrmtU9w' }, domain: 'ukssscecf.in', api_url: 'https://push.sarkarineeti.com/api/token', vapid_public_key: 'BGPFN3MLeITAa9pfWJoF2b-TRMDREUpYzKg7qe0aot3pJjxHzoAFbWQ9-T0Jfmsm39W8b62PwkY7AqI2M83lw-c' };```
1034	ukssscecf.in.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	N/A	standard	{The `clients.openWindow(targetUrl)` function is a standard browser API that opens a new window or tab with the provided URL. The vulnerability arises because `targetUrl` is derived directly from `event.notification.data.url`, which is user-controlled via push notifications. Since no validation or sanitization is performed, an attacker can craft a notification with a malicious URL, leading to open redirect and potential phishing or drive-by downloads.}	```let targetUrl = event.notification.data.url; clients.openWindow(targetUrl);```
1035	ukssscecf.in.js	Unvalidated API URL in Notification Data	Medium	true	CWE-601	9	N/A	standard	{The `fetch(apiUrl)` function is a standard browser API that initiates a network request to the specified URL. The vulnerability occurs because `apiUrl` is derived from `event.notification.data.api_url`, which is user-controlled via push notifications. Without validation, an attacker can inject arbitrary URLs, leading to unintended network requests, potential data exfiltration, or abuse of the service worker’s network permissions.}	```let apiUrl = event.notification.data.api_url; fetch(apiUrl);```
1036	ukssscecf.in.js	OS Detection Spoofing Vulnerability	Low	false	CWE-20	0	N/A	standard	{The code uses `navigator.platform.toUpperCase().indexOf('MAC') >= 0` to detect if the user is on a Mac. This is a standard browser API and not inherently vulnerable. The vulnerability is low because it is a simple string check and does not involve sensitive function misuse. The risk is minimal as it only affects UI behavior and not security-critical operations.}	```let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;```
1037	ukssscecf.in.js	Exposure of Push Subscription Keys	High	true	CWE-312	10	N/A	standard	{The `JSON.stringify` function is used to serialize push subscription data (including `endpoint`, `auth`, and `p256dh` keys) before sending it to a remote server via `fetch`. While `JSON.stringify` itself is not sensitive, the misuse lies in transmitting these keys over the network without encryption or proper authentication. These keys are sensitive and can be used to send push notifications to the user’s device, leading to potential abuse if intercepted. The vulnerability is due to the exposure of sensitive data via a network request initiated by `fetch`.}	```body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh })```
1038	bite.lv.js	Vulnerable Cache-Control Handling	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded cache URLs and lack of proper cache control headers, not from misuse of a sensitive function.}	```const CACHE_URLS = ['/offline', 'https://www.bite.lv/modules/contrib/pwa/assets/icon-512.png', 'https://www.bite.lv/modules/contrib/pwa/assets/icon-192.png', 'https://www.bite.lv/modules/contrib/pwa/assets/icon-144.png'];```
1039	bite.lv.js	Insecure Fetch Mode Usage	Medium	false	N/A	N/A	N/A	N/A	{The issue stems from using 'no-cors' mode in fetch, which is a configuration choice rather than misuse of a sensitive function.}	```return fetch(url, { credentials: 'same-origin', mode: 'no-cors' }).then(function (response) { return cache.put(url, response); }).catch(function (error) { logError(error); });```
1040	bite.lv.js	Insecure Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to a hardcoded version string, not misuse of a sensitive function.}	```const CACHE_VERSION = '2.1.0-beta6-v1';```
1041	bite.lv.js	Insecure Cache Exclusion Logic	Medium	false	N/A	N/A	N/A	N/A	{The issue is in the logic of excluding URLs from caching, not in misuse of a sensitive function.}	```var notExcludedPath = CACHE_EXCLUDE.every(urlNotExcluded(url.href));```
1042	bite.lv.js	Insecure Phone Home Endpoint	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the endpoint being hardcoded and potentially leading to unintended uninstallation, not misuse of a sensitive function.}	```fetch(PWA_SERVICE_WORKER_PHONE_HOME_URL).then(function (response) { if (!navigator.onLine) { console.debug('PWA: Phone-home - Network not detected.'); } if (response.status === 200) { console.debug('PWA: Phone-home - Network detected, module detected.'); } if (response.status === 404) { console.debug('PWA: Phone-home - Network detected, module NOT detected. UNINSTALLING.'); Promise.resolve(pwaUninstallServiceWorker()); } return Promise.resolve(); }).catch(function (error) { console.error('PWA: Phone-home - ', error); });```
1043	onlyporn.tube.js	Loading external script without integrity checks	High	true	CWE-928	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain without integrity checks. This allows the remote server to modify the script at any time, potentially injecting malicious code that can compromise the service worker’s behavior, intercept network requests, or exfiltrate data.}	```importScripts('https://sw.wpu.sh/ps/sw.js?loader=2');```
1044	femmesetvilles.org.js	Exposure of Sensitive Information (Firebase Config)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data (including API key, project ID, and messaging sender ID) directly in the script. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure data exposure in source code.}	```const options = { firebaseConfig: { projectId: 'jaitik', messagingSenderId: '464929227511', appId: '1:464929227511:web:f99541242827d2c741c9f2', apiKey: 'AIzaSyAAKssh0OEPJVDFcZpzKlou7aaENl6rLYA' }, domain: 'femmesetvilles.org', api_url: 'https://push.voiceofnigeria.org.ng/api/token', vapid_public_key: 'BCEy_U9QdwiKLypMWF3ehFwrUEQTctriY7acHVFzoIiVOcSsXjDvBcptTufImFfKcDWz99yncwzaegIgWnvVBUY' };```
1045	femmesetvilles.org.js	Open Redirect via Notification Data	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a URL derived directly from event.notification.data.url, which is user-controlled data. Since no validation or sanitization is applied, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to open redirect attacks.}	```let targetUrl = event.notification.data.url; clients.openWindow(targetUrl);```
1046	femmesetvilles.org.js	Unvalidated API URL in Notification Fetch	High	true	N/A	N/A	fetch	standard	{The fetch function is called with a URL derived from event.notification.data.api_url, which is user-controlled. Without validation or sanitization, this allows an attacker to redirect the fetch request to any endpoint, potentially exfiltrating data or triggering unintended API calls.}	```let apiUrl = event.notification.data.api_url; fetch(apiUrl);```
1047	femmesetvilles.org.js	Unvalidated URL in Subscription Logic	Medium	true	N/A	N/A	getDomainAndHostname	standard	{The getDomainAndHostname function parses a URL provided via the 'url' parameter, which is user-controlled. The hostname is extracted and used in subsequent API calls without validation, potentially allowing an attacker to manipulate the domain used in requests, leading to unintended behavior or data leakage.}	```domain = getDomainAndHostname(url).hostname;```
1048	linux.do.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed from unvalidated user-supplied data (t.notification.data.url and t.notification.data.baseUrl). Since these values are derived from push notification data, which is not sanitized or validated, an attacker can craft a malicious URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	"```self.addEventListener(""notificationclick"", function (t) { t.notification.close(); var e = t.notification.data.url, n = t.notification.data.baseUrl; if (!t.some(function (t) { return t.url === n + e && ""focus"" in t ? (t.focus(), !0) : ""postMessage"" in t && ""focus"" in t && (t.focus(), t.postMessage({ url: e }), !0); }) && clients.openWindow) return clients.openWindow(n + e); });```"
1049	linux.do.js	Improper Input Validation of Push Data	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability stems from improper validation of push notification data, but no sensitive JavaScript function is directly misused. The data is parsed via t.data.json(), which is safe, and passed to showNotification, which does not execute or evaluate the data in a dangerous way. The risk is due to lack of input validation, not misuse of a sensitive function.}	```var e = t.data.json(); t.waitUntil(showNotification(e.title, e.body, e.icon, e.badge, e.tag, e.base_url, e.url));```
1050	valpak.com.js	Caching of unvalidated URL with query parameters leading to potential cache poisoning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching a URL with query parameters (`/?standalone=true`) without validating or sanitizing the query string. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a configuration choice in the precaching setup. The `workbox.precaching.precacheAndRoute()` function is used correctly; the issue lies in the URL itself being unvalidated, not in improper function usage.}	```const options = { 'preCaching': [{ 'revision': 'DFbb3DvubeNz', 'url': '/?standalone=true' }], ... };```
1051	valpak.com.js	Use of third-party CDN without integrity checks leading to potential code injection	Medium	true	N/A	N/A	importScripts	standard	{The `importScripts()` function is a standard JavaScript API used in Service Workers to load external scripts. In this case, it is used with a dynamic URL (`options.workboxURL`) that points to a third-party CDN (`https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js`). Since no integrity checks (e.g., Subresource Integrity) are applied, an attacker could compromise the CDN or intercept the request to inject malicious code, leading to code injection. The function is misused because it blindly imports an external script without verifying its integrity.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
1052	valpak.com.js	CacheFirst strategy for /_nuxt/ without validation leading to potential cache poisoning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the use of a `CacheFirst` strategy for the `/nuxt/` path without validating or sanitizing the requested URLs. However, this is not due to misuse of a sensitive function, but rather a misconfiguration in the routing strategy. The `workbox.routing.registerRoute()` function is used appropriately; the issue lies in the lack of input validation for URLs matching the pattern, not in improper function usage.}	```{ 'urlPattern': '/_nuxt/', 'handler': 'CacheFirst', ... }```
1053	environmentportal.in.js	Vulnerable Data Exposure in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (API keys, project IDs, VAPID keys) in the script, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'indian-subscribers', messagingSenderId: '1049772823325', appId: '1:1049772823325:web:481ba1897693862b9b47f4', apiKey: 'AIzaSyAKEdCNlalZDR-9v3NL_2CHruUFXhkYlAo' }, domain: 'www.environmentportal.in', api_url: 'https://push.impeka.in/api/token', vapid_public_key: 'BE85gUZVlof7Z6bmLvQa5R75RmD3Ng2ayK9Xy1x8uifu4nfPSr_3L4ct9E2v_ScCUC4utMUEWYYSiCED2UOrUGw' };```
1054	environmentportal.in.js	Unvalidated Notification Payload Leading to XSS	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used to parse untrusted data from event.data.json().data.notification without validation or sanitization. If the payload contains malicious JavaScript or HTML, it could lead to XSS when rendered in notifications, especially if the notification content is later used in dynamic contexts.}	```const payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
1055	environmentportal.in.js	Arbitrary URL Opening in Notification Click Handler	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted notification data (event.notification.data.url or event.notification.data.actions[event.action].click_action). Since this URL is not validated or sanitized, an attacker could craft a notification to open arbitrary URLs, potentially leading to phishing or redirect attacks.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close();```
1056	lumiproxy.com.js	Information Exposure Through Error Messages	Low	false	N/A	0	N/A	N/A	{The vulnerability arises from logging detailed error messages using console.error, which may expose sensitive information such as internal error details, stack traces, or context data to the console. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by poor error handling practices. The console.error function itself is not inherently sensitive in this context, and no dynamic or untrusted input is being passed to it in a way that introduces a security risk.}	```console.error(ctx.error, 'Details:', ctx);```
1057	azores.gov.pt.js	Open Redirect Vulnerability	Medium	true	CWE-602	9	N/A	standard	{The `clients.openWindow()` function is a standard browser API used to open a new window or tab with a specified URL. When the URL is derived from untrusted input (here, `event.notification.data.redirect`, which originates from a push notification payload), it allows an attacker to craft a malicious redirect URL. Since the payload is controlled by the server sending the notification (and potentially by an attacker if the server is compromised), this leads to an open redirect vulnerability, enabling phishing or unintended navigation to malicious sites.}	```const redirect = payload.data.ptRedirect ? payload.data.ptRedirect : redirect;```
1058	azores.gov.pt.js	Open Redirect Vulnerability	Medium	true	CWE-602	9	N/A	standard	{The `clients.openWindow()` function is a standard browser API used to open a new window or tab with a specified URL. When the URL is derived from untrusted input (here, `event.notification.data.redirect`, which originates from a push notification payload), it allows an attacker to craft a malicious redirect URL. Since the payload is controlled by the server sending the notification (and potentially by an attacker if the server is compromised), this leads to an open redirect vulnerability, enabling phishing or unintended navigation to malicious sites.}	```return clients.openWindow(event.notification.data.redirect);```
1059	tamilyogi.org.in.js	Hardcoded Sensitive Information in Service Worker	High	false	N/A	N/A	N/A	N/A	{This vulnerability arises from hardcoded sensitive credentials (API keys, project IDs, etc.) in the code, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'larapush-b38e3', messagingSenderId: '445599372452', appId: '1:445599372452:web:08b6808aedc19d5d2ec231', apiKey: 'AIzaSyCe9J2qPWn0rKX1AERobBzg41pCVkqMgBg' }, domain: 'tamilyogi.org.in', api_url: 'https://push.rahulmourya.com/api/token', vapid_public_key: 'BMa1Xp15KcSrKWKCt1TDRKRBp2NNOEqPLdsdeof33eao1jm_wItQBBCWEAcauNiqwqC467VpRmXmHGH9DkXjbvI' };```
1060	tamilyogi.org.in.js	Deserialization of Untrusted Data	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used to deserialize data from event.data.json().data.notification, which originates from untrusted push messages. If the data is maliciously crafted, it can lead to unintended behavior or injection attacks, especially if the parsed data is later used in dynamic contexts.}	```const payload = JSON.parse(event.data.json().data.notification);```
1061	tamilyogi.org.in.js	Open Redirect Vulnerability	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from notification data that is untrusted and potentially controlled by an attacker. This allows an attacker to redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
1062	tamilyogi.org.in.js	Insecure Data Storage in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability stems from storing sensitive data (like notification tokens) in IndexedDB without encryption or additional security controls, not from misuse of a sensitive JavaScript function.}	```const request = objectStore.put({ id: key, data: value });```
1063	ufanance4.com.js	Incorrect URL Filtering Logic	High	false	New	N/A	N/A	N/A	{The vulnerability arises from incorrect logic in the URL filtering mechanism, specifically the use of `every()` with `checkNeverCacheList` and `this` context set to the request URL. This causes the function to incorrectly evaluate whether a URL should be excluded from caching. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a logical error in the filtering condition.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; }```
1064	ufanance4.com.js	Missing HTTP Status Code Check	Medium	false	CWE-319	N/A	N/A	N/A	{This vulnerability stems from the lack of validation of HTTP response status codes when caching responses. The code caches responses without checking if they are successful (e.g., 2xx), which could lead to caching of error responses or malicious content. This is a logic flaw, not a misuse of a sensitive function such as `eval()` or `importScripts()`.}	```e.respondWith(fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }));```
1065	tennis-point.de.js	Dynamic Script Import with User-Controlled Input	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed using location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts, leading to remote code execution within the service worker context.}	```importScripts(`https://tennis-point.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1066	vip168sa8.com.js	Improper URL Filtering in Cache Exclusion Logic	High	true	CWE-79	9	neverCacheUrls.every	N/A	{The function `checkNeverCacheList` is called with `this` set to each regex in `neverCacheUrls`, and `url` as the request URL. The logic `if (this.match(url))` is flawed because `this` is a RegExp object, and `RegExp.prototype.match` does not exist — it should be `RegExp.prototype.test`. This misuse causes the function to always return `true`, effectively disabling cache exclusion for URLs matching the regex patterns. As a result, sensitive URLs like `/wp-admin` or `/wp-login` may be cached, leading to potential exposure of administrative interfaces or login pages. The vulnerability arises from improper use of a standard JavaScript function (`RegExp.prototype.match`) in a context where `test` was intended.}	```if (this.match(url)) { return false; } return true;```
1067	iranicard.ir.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious code from a remote source. In this case, the script is loaded from a hardcoded external URL, which may be compromised or altered by an attacker, leading to code injection and full control over the service worker's behavior.}	```importScripts('https://van.najva.com/static/js/scripts/iranicard304-website-16775-912c2428-b863-43ba-a58e-05e8a2b97dec-service-worker.js');```
1068	licensespring.com.js	Vulnerable Message Handling in Service Worker	High	true	New	9	N/A	standard	{The service worker uses `self.addEventListener` to handle messages, and dynamically invokes functions from `MessageAPI` based on the `api` field in the message data. Since the `api` value is directly extracted from untrusted input (event.data), an attacker can send a message with a malicious `api` key to trigger arbitrary function calls, such as `clearPathResources` or `disableOfflineShell`, leading to unauthorized cache manipulation or disabling offline functionality. This is a classic case of dynamic function invocation with untrusted input.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
1069	licensespring.com.js	Improper Input Validation in API Request Handling	High	true	CWE-20	8	N/A	standard	{The code parses URL path parameters using `pathname.match(/:(.+)/)[1]` and then splits them by `&` and `=` to construct a data object. This input is then used to dynamically invoke functions via `MessageAPI[data.api]`. Since the input is derived from the URL path without sanitization or validation, an attacker can craft a URL to inject arbitrary keys into the `data` object, potentially triggering unintended or malicious API calls. This misuse of `match` and `split` with untrusted input leads to improper input validation and potential code injection.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
1070	licensespring.com.js	Arbitrary Cache Deletion via Message API	Medium	true	CWE-703	9	N/A	standard	{The `clearPathResources` function uses `caches.keys()` to retrieve all cache names and then iterates over them, deleting any cache key containing the string `runtime`. Since this function is triggered via a message API that accepts untrusted input (via `event.data`), an attacker can send a message to invoke this function, leading to unintended deletion of caches that may be critical for application functionality. The misuse of `caches.delete()` with dynamically derived keys from untrusted input enables arbitrary cache deletion.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
1071	celiac.com.js	CSRF Token Generation Based on Untrusted Input	High	true	N/A	9	fetch	standard	{The vulnerability arises because the service worker fetches a CSRF token from the server using a URL constructed from the untrusted `path` parameter derived from the request's URL. This `path` is obtained via `new URL(curRequest.url).pathname`, which is directly influenced by user input. The `fetch` function is then used to make a request to a server endpoint that generates a CSRF token based on this path. If an attacker can manipulate the request path, they could potentially trigger the generation of a CSRF token for a sensitive endpoint, which could then be used in a malicious request. This misuse of `fetch` with untrusted input allows for CSRF token leakage or abuse, enabling unauthorized actions on behalf of the user.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
1072	rusvideos.art.js	Loading untrusted third-party script without integrity checks	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted third-party source (e.g., 'https://sw.wpush.org/ps/sw.js') without integrity checks, it introduces a high-risk vulnerability. An attacker could compromise the remote script, leading to arbitrary code execution within the service worker context, potentially enabling cache manipulation, network interception, or data exfiltration.}	```self.config = { spotId: 352802 }; importScripts('https://sw.wpush.org/ps/sw.js');```
1073	hammers.news.js	Improper Request Validation Leading to Unintended Network Requests	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of incoming fetch requests, particularly when handling requests with 'only-if-cached' and 'same-origin' modes. However, no sensitive JavaScript function (like importScripts, eval, or dynamic code execution) is misused here. The issue is more about logic and request handling rather than direct misuse of a sensitive function.}	```self.addEventListener('fetch'```
1074	readynetsolutions.com.js	Insecure Cache Key Generation	Medium	false	CWE-327	N/A	N/A	N/A	{The cache key generation uses concatenated string values (SITE_VERSION and RUNTIME_VERSION) without cryptographic hashing or entropy, making it predictable and potentially exploitable for cache poisoning or replay attacks. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by weak key derivation logic.}	```const SITE_PAGES_CACHE_NAME = prefix + 'site-pages-' + (SITE_VERSION + '-' + RUNTIME_VERSION);```
1075	readynetsolutions.com.js	Regex Injection Vulnerability	High	true	New	N/A	RegExp	standard	{The function `template` constructs a RegExp dynamically using `Object.keys(data).join('|')` without sanitizing or validating the input data. This allows an attacker to inject arbitrary regex patterns (e.g., via crafted data keys) leading to ReDoS or unintended behavior. The `RegExp` constructor is a standard JavaScript function, and its misuse here is directly responsible for the vulnerability.}	```var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g');```
1076	readynetsolutions.com.js	Insecure No-CORS Prefetch	Medium	false	CWE-922	N/A	N/A	N/A	{The `fetch` call uses `mode: 'no-cors'` which prevents the browser from sending credentials and limits response usage, but this is not due to misuse of a sensitive function. The issue stems from improper configuration of the fetch request, not from dynamic or untrusted input being passed to a sensitive function.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
1077	readynetsolutions.com.js	Weak URL Blacklist Check	Medium	false	CWE-20	N/A	N/A	N/A	{The blacklist check uses `includes` on the URL string, which is vulnerable to bypasses (e.g., URL encoding, path traversal). This is a logic flaw in the blacklist implementation, not caused by misuse of a sensitive function such as `eval` or `importScripts`.}	```return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl));```
1078	readynetsolutions.com.js	Empty Fetch Handler Override	Medium	false	CWE-476	N/A	N/A	N/A	{The `fetch` event listener is defined but contains no logic, which may lead to unintended behavior or bypass of expected caching logic. This is a code omission issue, not caused by misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
1079	apkfab.com.js	Offline Logic Flaw Leading to Incorrect Resource Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from incorrect offline handling logic: when offline, the service worker attempts to respond with a cached offline page regardless of the requested resource. This is not a result of misuse of a sensitive function, but rather a logical flaw in the fetch event handler. The code does not use any sensitive functions like importScripts, eval, or dynamic script loading with untrusted input.}	```self.addEventListener('fetch', event => { if (!self.navigator.onLine) { event.respondWith(caches.match(event.request).then(response => { return caches.match('/offline.html'); })); } });```
1080	awdeliverynet.com.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	10	RegExp	standard	{The code constructs regular expressions from user-controlled or untrusted JSON strings using `new RegExp(e)`, where `e` is derived from `JSON.parse()` of a hardcoded string. Although the string is hardcoded, the use of `new RegExp()` with untrusted or complex patterns (e.g., `(?:/.*)?`) can lead to ReDoS if the pattern is maliciously crafted. In this case, the pattern `(?:/.*)?` is inherently inefficient and can cause exponential backtracking when matched against long strings, leading to a denial of service. The sensitive function `RegExp` is misused because it is being used with potentially complex patterns without validation or sanitization, even if the input is hardcoded.}	"```const c = JSON.parse('[""awdeliverynet\\\\.com(?:/.*)?/ola/services/.*"",""awdeliverynet\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://de8a3f45-9576-46fe-a247-67b71d113a21\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
1081	kannadapdf.com.js	Open Redirect via Notification Data	High	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow() is used to open a new window or tab with a URL derived from event.notification.data.url, which is user-controlled via push notifications. Since the URL is not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	N/A
1082	kannadapdf.com.js	SSRF via Untrusted API URL	High	true	CWE-918	9	fetch	standard	{The fetch function is used with options.api_url, which is a hardcoded value. However, the vulnerability arises because the URL is dynamically constructed using the domain derived from the user-supplied url parameter via getDomainAndHostname(url). If the url parameter is controlled by an attacker, it can be manipulated to point to internal or external endpoints, enabling SSRF attacks.}	N/A
1083	kannadapdf.com.js	Insecure Storage of Sensitive Data	Medium	false	CWE-311	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption. While the writeData function uses objectStore.put, which is a standard API, the issue is not due to misuse of the function itself but rather the lack of encryption or secure storage practices. Therefore, it is not classified as a sensitive function misuse.}	N/A
1084	telugubindu.com.js	Hardcoded Sensitive Information in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (API key, project ID, etc.) in the firebaseConfig object, not from misuse of a sensitive JavaScript function.}	```firebase.initializeApp({ ...options.firebaseConfig });```
1085	telugubindu.com.js	Open Redirect via Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is user-controlled. This allows an attacker to craft a notification that redirects users to arbitrary URLs, leading to open redirect.}	```clients.openWindow(targetUrl);```
1086	telugubindu.com.js	SSRF via Unvalidated URL in getDomainAndHostname	Medium	true	N/A	N/A	new URL	standard	{The new URL constructor is used with a user-supplied URL without validation, allowing an attacker to craft URLs pointing to internal or external resources, potentially leading to SSRF if the URL is used in subsequent requests.}	```const urlObj = new URL(url);```
1087	telugubindu.com.js	Cleartext Storage of Sensitive Data in IndexedDB	Medium	true	N/A	N/A	objectStore.put	standard	{The objectStore.put function is used to store sensitive data (e.g., notification tokens) in IndexedDB without encryption, exposing it to local attackers or unauthorized access.}	```objectStore.put({ id: key, data: value });```
1088	cccama.com.js	Vulnerable Cache Storage of HTTP Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching HTTP resources without validating their security or origin, but no sensitive function is misused. The issue is more about policy than function misuse.}	```const filesToCache = [startPage, offlinePage];```
1089	cccama.com.js	Incorrect Regular Expression Handling in Range Requests	High	true	N/A	N/A	RegExp.exec	standard	{The regular expression /^bytes\=(\d+)\-$/g is used to parse range headers, but it is misused by not properly handling edge cases or malformed inputs, potentially leading to incorrect parsing or unexpected behavior. The exec method is standard but its misuse here causes the vulnerability.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
1090	cccama.com.js	Flawed URL Matching Logic for Cache Exclusions	Medium	false	N/A	N/A	N/A	N/A	{The issue stems from incorrect logic in checkNeverCacheList, where the function uses this.match(url) without ensuring the regex is properly applied. This is a logic flaw, not misuse of a sensitive function.}	```if (this.match(url)) { return false; }```
1091	cccama.com.js	Caching of Non-GET Requests Without Proper Validation	Low	false	N/A	N/A	N/A	N/A	{The code caches non-GET requests without validation, but this is a policy issue, not misuse of a sensitive function. The fetch API is used correctly here.}	```if (e.request.method !== 'GET') { e.respondWith(fetch(e.request)...```
1092	bwt.com.js	Dynamic Script Inclusion via User-Controlled Input	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a URL constructed by concatenating a base URL with location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts, leading to remote code execution within the service worker context.}	```importScripts(`https://bwt.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1093	karboom.io.js	Loading untrusted external script via importScripts	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., van.najva.com), it introduces a high-risk vulnerability if the script source is not fully trusted or controlled. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an external, potentially untrusted source, which could be compromised or modified by an attacker, leading to arbitrary code execution within the service worker context. This is a classic case of insecure external script loading, classified under CWE-444 (Unrestricted Upload of File with Dangerous Type, though more accurately, this is CWE-434: Unrestricted File Upload or CWE-918: Server-Side Request Forgery in context of script loading). However, since the URL is hardcoded, the risk is mitigated by the lack of dynamic input, but the source itself remains untrusted.}	```importScripts('https://van.najva.com/static/js/scripts/karboom-website-32809-6330b133-e950-4316-9c24-dc513367ac18-service-worker.js');```
1094	webwave.dev.js	Improper URL Validation Leading to Unintended Caching	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper URL validation logic in the `webwaveApplicationNonCacheUrls` function, which uses `indexOf` and `match` to check for specific substrings or patterns in the URL. This approach is not inherently unsafe due to misuse of a sensitive function, but rather due to flawed logic that may allow unintended caching of URLs not meant to be cached. No sensitive JavaScript function (like `importScripts`, `eval`, `Function`, etc.) is misused here.}	```function webwaveApplicationNonCacheUrls(requestUrl) { return requestUrl.indexOf('gui/fileUpload') !== -1 || requestUrl.indexOf('gui/saveAndPublishService') !== -1 || requestUrl.indexOf('webmasterPanel/exportWebsite') !== -1 || requestUrl.indexOf('administration/') !== -1 || requestUrl.indexOf('webmasterPanel/getWebsiteAccounts') !== -1 || requestUrl.indexOf('tawk.to') !== -1 || requestUrl.match(/\.(mp4)$/) !== null; }```
1095	zeeresult.in.js	Exposure of Sensitive Information to an Unauthorized Actor	High	true	CWE-532	10	firebase.initializeApp	standard	{The firebase.initializeApp function is used to initialize the Firebase SDK with sensitive credentials (API key, project ID, etc.) that are hardcoded in the script. Since this script is a Service Worker, it runs in the browser and is accessible to anyone who can inspect the site, exposing these credentials to unauthorized actors. This allows attackers to impersonate the application, access Firebase services, or perform unauthorized operations.}	N/A
1096	zeeresult.in.js	Open Redirect	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL that is derived from the notification payload (event.notification.data.FCM_MSG.notification.data.url). Since this URL is not validated or sanitized and is directly passed to clients.openWindow, an attacker could craft a malicious notification payload to redirect users to arbitrary websites, leading to phishing, malware distribution, or session hijacking.}	N/A
1097	oanow.com.js	Open Redirect via Unvalidated URL	Medium	true	CWE-601	9	N/A	standard	{The function `new URL()` is used to parse a URL provided in `oData.url`, which originates from a Firebase message payload. Since this payload is controlled by the server (and potentially by an attacker if the messaging channel is compromised), and no validation or sanitization is performed on `oData.url`, an attacker could craft a malicious URL that redirects users to an unintended destination, leading to an open redirect vulnerability.}	```let oURL = new URL(oData.url);```
1098	bluemail.me.js	Improper Input Validation Leading to Code Injection	High	true	CWE-94	8	RegExp.prototype.match	standard	{The use of `pathname.match(/:(.+)/)[1]` to extract parameters from a URL path without validating or sanitizing the input can lead to code injection if the extracted value is later used in a context where it can influence execution flow, such as in dynamic function calls or string interpolation. Although no direct code execution is shown here, the unsanitized input could be leveraged in conjunction with other parts of the code (e.g., `data.api`) to trigger unintended behavior.}	```const params = pathname.match(/:(.+)/)[1];```
1099	bluemail.me.js	Insecure Message Handling Leading to Arbitrary Function Execution	High	true	CWE-96	9	Function invocation via dynamic property access	standard	{The code dynamically invokes functions from the `MessageAPI` object using `MessageAPI[data.api]()` where `data.api` is derived from untrusted input (via URL path parsing). This allows an attacker to control which function is executed, leading to arbitrary function execution if the input is not validated. This is a classic case of unsafe dynamic function invocation.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1100	bluemail.me.js	Potential Denial of Service via Malformed URL	Medium	false	N/A	5	N/A	N/A	{The vulnerability arises from improper handling of malformed URLs during path parameter extraction, but it is not directly caused by misuse of a sensitive function. The `match` function is used correctly, but the lack of input validation on `pathname` could lead to unexpected behavior or resource exhaustion if malformed URLs are processed.}	```const params = pathname.match(/:(.+)/)[1];```
1101	bluemail.me.js	Insecure Cache Deletion Leading to Data Loss	Medium	false	N/A	6	N/A	N/A	{The code deletes cache entries based on keys containing `runtime`, but this is not caused by misuse of a sensitive function. The `caches.delete()` function is used appropriately, and the vulnerability stems from the broad scope of deletion without proper authorization or input validation, rather than from a sensitive function misuse.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
1102	linkco.re.js	Insecure Handling of Opaque Redirect Responses	High	true	New	9	N/A	standard	"{The code dynamically creates a script element and appends it to the document head using `document.createElement(""script"")` and `document.head.appendChild(e)`, with the script source derived from a URL constructed via `new URL(n + "".js"", a).href`. This allows for dynamic script loading, which can be exploited if the URL `n` is derived from untrusted input, leading to remote code execution. Although the vulnerability is labeled as ""Insecure Handling of Opaque Redirect Responses"", the root cause lies in the unsafe dynamic script loading via `document.createElement(""script"")`, which is a standard JavaScript API and can be misused to load arbitrary scripts.}"	```const e = document.createElement('script'); e.src = n, e.onload = s, document.head.appendChild(e);```
1103	linkco.re.js	Insecure Cache Configuration for Cross-Origin Requests	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from the configuration of the `NetworkFirst` strategy for cross-origin requests with a short cache TTL (3600 seconds) and no additional security checks. This is not caused by misuse of a sensitive function like `importScripts` or `eval`, but rather by a misconfigured caching policy. The `e.registerRoute` function is used correctly; the issue is in the policy design, not in the function's misuse.}	```e.registerRoute(({'sameOrigin': e}) => !e, new e.NetworkFirst({cacheName: 'cross-origin', networkTimeoutSeconds: 10, plugins: [new e.ExpirationPlugin({maxEntries: 32, maxAgeSeconds: 3600})]}), 'GET');```
1104	virological.org.js	Open Redirect via Unvalidated URL in Service Worker	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a new window or tab with a URL constructed from user-controlled data (n + e). Since 'e' comes from the notification data (which is derived from push message data), and 'n' is also derived from the same source, an attacker can craft a push message to redirect users to arbitrary domains, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with untrusted input.}	```clients.openWindow(n + e);```
1105	virological.org.js	Insecure Handling of User Input in Notification Reply	Medium	true	CWE-79	9	fetch	standard	{The fetch() function is used to send a POST request with user-provided input (t.reply) directly in the body without sanitization or validation. This allows an attacker to inject malicious content into the message body, potentially leading to server-side code injection or other attacks if the server processes the input unsafely. The input is derived from the user's reply in a notification, which is untrusted.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
1106	topmediai.com.js	Improper URL Encoding in Request Construction	Medium	true	CWE-113	9	concatenation	standard	{The code constructs a URL by concatenating `callbackUrl` with `pushData.id` without proper URL encoding. If `pushData.id` contains special characters (e.g., &, ?, #), it can lead to malformed URLs or unintended behavior, such as parameter injection or request manipulation. This is a misuse of string concatenation in URL construction, which is a common source of improper URL encoding vulnerabilities.}	```var request = callbackUrl + '?id=' + pushData.id;```
1107	topmediai.com.js	Trust Boundary Violation in URL Handling	Medium	true	CWE-243	9	clients.openWindow	standard	{The `clients.openWindow(jumpUrl)` function is called with `jumpUrl` derived from user-controlled notification data. If an attacker can manipulate the `link`, `coffee`, `doughnut`, etc., fields in the notification payload, they can redirect users to arbitrary URLs, potentially leading to phishing, drive-by downloads, or other malicious actions. This represents a trust boundary violation because the service worker is treating untrusted input as safe for navigation.}	```clients.openWindow(jumpUrl);```
1108	barrietoday.com.js	Open Redirect via Unvalidated URL in Notification Handling	High	true	CWE-601	9	N/A	standard	{The `new URL()` constructor is used to parse and normalize a URL provided via `urlPart`, which originates from `event.notification.data.url` or `action.url`. Since these values are derived from untrusted notification data (potentially controlled by an attacker), and no validation is performed to ensure the URL is safe or within expected domains, an attacker can craft a notification with a malicious URL that redirects users to arbitrary sites. This constitutes an open redirect vulnerability, allowing phishing or malicious redirection.}	```var url = new URL(urlPart, self.location.origin).href;```
1109	unicef.it.js	Insecure IndexedDB Storage	High	true	CWE-79	N/A	idbKeyval.set	custom	{The idbKeyval.set function is used to store data in IndexedDB without validating or sanitizing the input path, which can lead to arbitrary data being stored under crafted keys, potentially enabling data leakage or injection attacks if the path is derived from untrusted sources.}	```const { setPathResources } = MessageAPI; event.waitUntil(idbKeyval.set(`resources:${path}`)```
1110	unicef.it.js	Insecure URL Parameter Handling	Medium	true	CWE-800	N/A	pathname.match(/:(.+)/)[1]	standard	{The use of regular expression matching on the pathname to extract parameters without validation or sanitization allows for arbitrary parameter extraction, which can be exploited to manipulate application logic or trigger unintended behavior if the input is controlled by an attacker.}	```const params = pathname.match(/:(.+)/)[1]; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
1111	unicef.it.js	Unvalidated Redirect Target	Medium	true	CWE-601	N/A	new Response(null, { status: 302, headers: { Location: lastNavigationRequest } })	standard	{The Response object is constructed with a Location header set to lastNavigationRequest, which is derived from the request URL without validation. This allows an attacker to craft a request that redirects users to arbitrary destinations, leading to open redirect vulnerabilities.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
1112	drberg.com.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL like 'https://pushpad.xyz/service-worker.js', it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows the external script to execute with the same privileges as the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the vulnerability is still considered sensitive because the function itself is inherently risky when used with any external source, especially without integrity verification or origin validation.}	"```importScripts(""https://pushpad.xyz/service-worker.js"");```"
1113	trucks.nl.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided via the notification data. Since the URL is directly taken from i.notification.data.url without validation or sanitization, an attacker could craft a notification payload with a malicious URL, leading to an open redirect. This allows redirection to arbitrary domains, potentially phishing users or bypassing security controls.}	```self.clients.openWindow(i.notification.data.url);```
1114	lelynx.fr.js	Exposure of Sensitive Information in Configuration	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the exposure of sensitive Firebase configuration data (including API key, project ID, and messaging sender ID) in the service worker script. This is not caused by misuse of a sensitive JavaScript function, but rather by hardcoding sensitive credentials in client-side code, which can be accessed by attackers via browser inspection.}	"```if ('function' === typeof importScripts) { const firebaseVersion = '8.9.1'; importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-app.js""); importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-messaging.js""); addEventListener('message', onMessage); function onMessage(e) {} const firebaseConfig = { apiKey: ""AIzaSyC4fBcSVrExN9ZqQVenzUDBRQKsYn16JkI"", authDomain: ""mapp-push-web.firebaseapp.com"", projectId: ""mapp-push-web"", storageBucket: ""mapp-push-web.appspot.com"", messagingSenderId: ""534672985053"", appId: ""1:534672985053:web:da4c774cda9457bade8434"", measurementId: ""G-XDT11M8EPT"" }; firebase.initializeApp(firebaseConfig); const messaging = firebase.messaging(); messaging.onBackgroundMessage(function (payload) {}); }```"
1115	voobrajulya.ru.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., 'https://css.xjsx.lol/sw.js'), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows an attacker who controls the remote script to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks on network requests.}	"```importScripts(""https://css.xjsx.lol/sw.js"");```"
1116	gnkc.in.js	Insecure Storage of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key, project ID, etc.) in the source code, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'push-d17f9', messagingSenderId: '214672967324', appId: '1:214672967324:web:9421fe3318bce722ac4f59', apiKey: 'AIzaSyBNZHhozbu702eYJqRJP9JsiRivSrmtU9w' }, domain: 'www.ijbspt.org', api_url: 'https://push.sarkarineeti.com/api/token', vapid_public_key: 'BGPFN3MLeITAa9pfWJoF2b-TRMDREUpYzKg7qe0aot3pJjxHzoAFbWQ9-T0Jfmsm39W8b62PwkY7AqI2M83lw-c' };```
1117	gnkc.in.js	Improper Input Validation for Notification Payload	High	true	N/A	N/A	showNotification	standard	{The showNotification function is called with user-controlled payload data without sanitization, allowing an attacker to inject arbitrary content into notifications, potentially leading to phishing or social engineering attacks.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
1118	gnkc.in.js	Unvalidated URL Redirection in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a targetUrl derived from notification data, which is user-controlled and unvalidated, enabling open redirect attacks where attackers can redirect users to malicious sites.}	```clients.openWindow(targetUrl); fetch(apiUrl);```
1119	gnkc.in.js	Insecure Message Handling Without Origin Validation	Medium	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener function is used to handle messages without validating the origin of the message, allowing malicious clients or scripts to send arbitrary commands to the service worker, potentially leading to unauthorized actions.}	```self.addEventListener('message', event => { const { command, url } = event.data; ... });```
1120	gnkc.in.js	Unvalidated API Calls with Dynamic URLs	Medium	true	N/A	N/A	fetch	standard	{The fetch function is called with a URL derived from the options.api_url, which is hardcoded but could be dynamically influenced by user input via the url parameter in subscribePushManager, leading to potential SSRF or unintended API calls if not properly validated.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
1121	kearneyhub.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	Medium	true	CWE-602	9	new URL	standard	{The function new URL is used to parse a URL provided in oData.url, which originates from a notification payload. Since this payload is controlled by the server sending the push notification (and potentially by an attacker if the server is compromised), the URL can be manipulated to redirect users to arbitrary destinations. The lack of validation or sanitization of oData.url before constructing the URL object allows for open redirect attacks, enabling phishing or malicious redirection.}	```let oURL = new URL(oData.url);```
1122	jbdsm.com.js	Use of eval with untrusted input	High	true	CWE-835	10	eval	standard	{The code retrieves a script from a remote URL via caches.match and then executes it using eval(code). Since the script content is fetched from an external source (https://js.wpshsdk.com/npc/sdk/common/core.js) and not hardcoded or sanitized, it introduces a severe code injection vulnerability. An attacker could compromise the remote server or intercept the request to inject malicious JavaScript, which would then be executed in the context of the service worker, potentially leading to full control over the worker's behavior, including cache manipulation, network interception, and data exfiltration.}	```try { eval(code); } catch (e) { return Promise.reject(e); }```
1123	rocketlaunch.live.js	Improper Input Validation in Push Event Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of the `event.data.text()` content, which is directly used as the notification body. However, this does not involve misuse of a sensitive JavaScript function like `importScripts`, `eval`, or `fetch` with untrusted input. The `showLocalNotification` function is custom and safely uses `swRegistration.showNotification`, which is a standard API but not inherently dangerous when used with untrusted data in this context. The issue is more about lack of sanitization or validation of the push message content rather than a sensitive function misuse.}	```const showLocalNotification = (title, body, swRegistration) => { const options = { body }; swRegistration.showNotification(title, options); };```
1124	retrospring.net.js	Open Redirect via Notification Click	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL specified by event.notification.data.click_url, which is derived from untrusted notification data. Since this input is not validated or sanitized, an attacker could craft a notification with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. The function is standard and directly executes navigation to the provided URL without any security checks.}	"```if (""click_url"" in event.notification.data) { event.preventDefault(); return clients.openWindow(event.notification.data.click_url, ""_blank"").then(result => { event.notification.close(); return result; }); }```"
1125	oceanprotocol.com.js	Improper Input Validation in Message Handling	High	true	CWE-20	N/A	self.addEventListener	standard	{The self.addEventListener function is used to handle incoming messages, but it does not validate or sanitize the event.data.gatsbyApi input before using it to dynamically invoke functions via MessageAPI[api](). This allows an attacker to send arbitrary API names, potentially triggering unintended or malicious behavior if the MessageAPI object contains or is extended with dangerous functions.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
1126	oceanprotocol.com.js	Arbitrary Function Execution via Dynamic API Call	High	true	CWE-703	N/A	MessageAPI[data.api]	standard	{The code dynamically invokes functions from the MessageAPI object using user-controlled data.api, which is derived from parsed URL parameters. This allows an attacker to trigger any function defined in MessageAPI, including potentially dangerous ones like clearPathResources or enable/disable offline shell, leading to arbitrary function execution.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1127	oceanprotocol.com.js	Cache Poisoning via Unvalidated Resource Storage	Medium	true	CWE-434	N/A	idbKeyval.set	standard	{The idbKeyval.set function stores user-controlled path and resources data without validation, allowing an attacker to inject malicious or unexpected resource URLs into the IndexedDB. This can lead to cache poisoning, where the service worker serves malicious content under the guise of legitimate resources.}	```event.waitUntil(idbKeyval.set(`resources:${path}`, resources));```
1128	oceanprotocol.com.js	Denial of Service via Cache Deletion	Medium	true	CWE-400	N/A	caches.delete	standard	{The caches.delete function is called on keys derived from caches.keys(), without filtering or validation. An attacker could trigger this via a message event to delete all caches matching a pattern (e.g., those containing 'runtime'), potentially causing a denial of service by removing essential cached assets.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
1129	oceanprotocol.com.js	Insecure Dynamic Code Execution in Navigation Route	Medium	true	CWE-703	N/A	handleAPIRequest	standard	{The navigationRoute dynamically invokes handleAPIRequest when the URL matches a pattern, and handleAPIRequest parses URL parameters to call functions from MessageAPI. Since the URL is user-controlled and parsed without validation, this allows an attacker to trigger arbitrary API calls, leading to insecure dynamic code execution.}	```if (event.request.url.match(/\/.gatsby-plugin-offline:.+/)) { return handleAPIRequest({ event }); }```
1130	chetor.com.js	Insecure External Script Inclusion	High	true	CWE-829	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to load a script from a hardcoded external domain ('https://van.najva.com/...'). While the URL is not dynamically constructed from untrusted input, the act of loading and executing an external script from a third-party domain introduces a high-risk vulnerability. If the external script is compromised or controlled by an attacker, it can execute arbitrary code within the context of the service worker, leading to cache manipulation, network interception, or data exfiltration. This constitutes a misuse of a sensitive function because it allows remote code execution without proper validation or trust verification.}	```importScripts('https://van.najva.com/static/js/scripts/chetor-66-aff243cd-bbcf-40a1-8e57-e2668c17f87b-service-worker.js');```
1131	ketabnak.com.js	Vulnerable Logic in URL Exclusion Check	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a flawed logic in the URL exclusion check, not from misuse of a sensitive JavaScript function. The code checks if the request URL contains any of the strings in offlineExclude, but it does not account for partial matches or improper escaping, which could allow bypassing the exclusion logic. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```for (let i = 0; i < offlineExclude.length; i++) { if (event.request.url.indexOf(offlineExclude[i]) !== -1) { return; } }```
1132	6a368.com.js	Missing SameOrigin Check in Cache Routes	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the lack of a sameOrigin check in the route matching logic, but it is not caused by misuse of a sensitive JavaScript function. The issue is in the logic design of the route condition, not in the use of a dangerous API.}	```e.registerRoute((({url: e}) => e.pathname.includes('/games/allGameList'), new e.StaleWhileRevalidate({cacheName: 'agl', plugins: [new e.ExpirationPlugin({maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0})]})```
1133	6a368.com.js	Missing SameOrigin Check in Cache Routes	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the lack of a sameOrigin check in the route matching logic, but it is not caused by misuse of a sensitive JavaScript function. The issue is in the logic design of the route condition, not in the use of a dangerous API.}	```e.registerRoute((({url: e}) => e.pathname.includes('/staticpagesettings/Info/orders'), new e.StaleWhileRevalidate({cacheName: 'ord', plugins: [new e.ExpirationPlugin({maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0})]})```
1134	6a368.com.js	Missing SameOrigin Check in Cache Routes	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the lack of a sameOrigin check in the route matching logic, but it is not caused by misuse of a sensitive JavaScript function. The issue is in the logic design of the route condition, not in the use of a dangerous API.}	```e.registerRoute((({url: e}) => e.pathname.includes('/games/allGameName'), new e.StaleWhileRevalidate({cacheName: 'agn', plugins: [new e.ExpirationPlugin({maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0})]})```
1135	6a368.com.js	Overly Broad URL Matching with includes	Low	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from overly broad URL matching using the includes method, which is not inherently dangerous. The issue is a logic flaw in route definition, not misuse of a sensitive function.}	```e.registerRoute((({url: e}) => e.pathname.includes('/games/allGameList'), new e.StaleWhileRevalidate({cacheName: 'agl', plugins: [new e.ExpirationPlugin({maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0})]})```
1136	6a368.com.js	Caching Sensitive Data for 24 Hours	Medium	false	CWE-312	N/A	N/A	N/A	{The vulnerability is due to long-term caching of sensitive data, which is a policy or configuration issue, not caused by misuse of a sensitive JavaScript function.}	```e.registerRoute((({url: e}) => e.pathname.includes('/staticpagesettings/Info/orders'), new e.StaleWhileRevalidate({cacheName: 'ord', plugins: [new e.ExpirationPlugin({maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0})]})```
1137	fashionette.de.js	Cache Poisoning via Unvalidated Request URLs	High	true	CWE-20	10	N/A	standard	{The `fetch` function is used without validating the `event.request` URL, allowing an attacker to craft malicious requests that could be cached and served to users, leading to cache poisoning. Since the request URL is derived from the event and not sanitized, it can be manipulated to cache arbitrary content.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.open('main').then(function (cache) { return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { cache.put(event.request, response.clone()); return response; }); }); })); });```
1138	fashionette.de.js	Race Condition in Fetch Event Listeners	Medium	false	N/A	0	N/A	N/A	{This issue arises from having multiple `fetch` event listeners, but it is not due to misuse of a sensitive function. The race condition is a logical design flaw, not a direct result of unsafe function usage.}	```self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request)); }); self.addEventListener('fetch', function (event) { event.respondWith(caches.open('main').then(function (cache) { return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { cache.put(event.request, response.clone()); return response; }); }); })); });```
1139	fashionette.de.js	Lack of Error Handling in Cache.addAll	Medium	false	N/A	0	N/A	N/A	{The `cache.addAll` function is used without error handling, but this is not a misuse of a sensitive function. It is a best practice omission rather than a security vulnerability caused by unsafe function usage.}	```self.addEventListener('install', event => { event.waitUntil(caches.open('main').then(cache => cache.addAll(['/flyout.html']))); });```
1140	fashionette.de.js	Stale Data Caching Without Response Validation	Medium	true	CWE-20	9	N/A	standard	{The `fetch` function is used to retrieve responses that are cached without validating their integrity or freshness. Since the response is cached directly without checking for errors or validity, stale or tampered data may be served to users, leading to potential data integrity issues.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.open('main').then(function (cache) { return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { cache.put(event.request, response.clone()); return response; }); }); })); });```
1141	ouvirmusica.com.br.js	Use of Untrusted Resource (CDN without SRI	High	true	CWE-944	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, it loads a script from a CDN (cdnjs.cloudflare.com) without Subresource Integrity (SRI) checks. This allows an attacker to compromise the CDN or intercept the request to inject malicious code, leading to arbitrary code execution within the service worker. The function is misused because it trusts an external resource without verifying its integrity.}	"```sw.importScripts(""https://cdnjs.cloudflare.com/ajax/libs/hogan.js/3.0.2/hogan.min.js"");```"
1142	ouvirmusica.com.br.js	XSS via Unsanitized User Input in Song Lyrics	High	true	CWE-79	9	Hogan.compile	standard	{The Hogan.compile() function is a templating engine that renders HTML from a template string. The song.lyric data, which is user-controlled, is inserted into the template without sanitization. When rendered via Hogan.compile(), this unsanitized input can execute arbitrary JavaScript if it contains HTML or script tags, leading to Cross-Site Scripting (XSS). The function is misused because it processes untrusted data without proper escaping or sanitization.}	```const compiled = Hogan.compile(template); const html = compiled.render({ currentSong, songs });```
1143	homeagain.com.js	Improper Cache Invalidation	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of proper cache invalidation logic in the cacheWillUpdate plugin callback, which does not enforce cache freshness or expiration policies. This is not due to misuse of a sensitive function but rather a design flaw in cache management.}	```const { cacheWillUpdate: e } = this._ensureResponseSafeToCache(t);```
1144	homeagain.com.js	Cache Poisoning	High	false	N/A	N/A	N/A	N/A	{Cache poisoning occurs due to insufficient validation of responses before caching, particularly when responses with non-200 status codes or redirected responses are cached without proper checks. This is a logic issue rather than misuse of a sensitive function.}	```const { cacheWillUpdate: e } = this._ensureResponseSafeToCache(t);```
1145	homeagain.com.js	Insufficient Cache Expiration	Medium	false	N/A	N/A	N/A	N/A	{The cache expiration policy is not enforced properly, as the ExpirationPlugin only updates timestamps and does not guarantee timely removal of stale entries. This is a configuration or logic issue, not a sensitive function misuse.}	```const { cacheWillUpdate: e } = this._ensureResponseSafeToCache(t);```
1146	homeagain.com.js	Cross-Origin Resource Sharing (CORS) Misconfiguration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the service worker's handling of cross-origin responses, particularly in the copyResponse function, which does not validate or restrict cross-origin responses appropriately. This is a policy issue, not a sensitive function misuse.}	```const { cacheWillUpdate: e } = this._ensureResponseSafeToCache(t);```
1147	spafinder.com.js	Improper Handling of Data in Configuration	High	true	CWE-243	9	Object.fromEntries	standard	{The function Object.fromEntries is used to convert URLSearchParams into a configuration object, which is then passed directly to firebase.initializeApp. Since URLSearchParams are derived from location.search (user-controlled input), this allows an attacker to inject arbitrary configuration values, potentially leading to unauthorized access, misconfiguration, or execution of unintended Firebase operations.}	```self.firebaseConfig = Object.fromEntries(urlParams);```
1148	fixly.pl.js	Outdated Firebase SDK Version	High	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase SDK (5.6.0), which may contain known security flaws or lack support for modern security features. However, this is not caused by misuse of a sensitive JavaScript function like importScripts with untrusted input, but rather by using an old library version. The importScripts call is using a hardcoded, trusted URL and does not involve dynamic or user-controlled input.}	```importScripts('https://www.gstatic.com/firebasejs/5.6.0/firebase-app.js');```
1149	herox.com.js	Deserialization of Untrusted Data	High	true	CWE-502	10	N/A	standard	{The `e.data.json()` call deserializes untrusted data from a push message, which can lead to arbitrary code execution if the data contains malicious payloads, especially if the deserialized object is later used in unsafe contexts.}	```self.addEventListener('push', function (e) { if (e.data) { let t = e.data.json(); self.registration.showNotification(t.title, t.options); } });```
1150	herox.com.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The `self.clients.openWindow(n.url)` call uses a URL derived from untrusted notification data, allowing an attacker to redirect users to arbitrary websites, potentially leading to phishing or credential theft.}	```self.addEventListener('notificationclick', function (e) { let t = e.notification, n = t.data; n && n.url && (self.clients.openWindow(n.url), t.close()); });```
1151	herox.com.js	XSS via Unsanitized Error Message	Medium	true	CWE-79	9	N/A	standard	{The `e.source.postMessage({ command: 'setOfflineError', error: n });` call sends an error message (n) directly to the client without sanitization, which could be exploited if the error message contains malicious script content and is rendered in an unsafe context.}	```self.addEventListener('message', function (e) { self.origin === e.origin && 'getOfflineError' === e.data.command && n && e.source && e.source.postMessage({ command: 'setOfflineError', error: n }); });```
1152	maduradas.com.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	{The code reads the 'resourcesHost' parameter from the URL query string, which is user-controlled, and uses it to construct a URL passed to importScripts(). Since importScripts() executes any script from the provided URL without validation, an attacker can supply a malicious host (e.g., attacker.com) to load and execute arbitrary JavaScript code in the service worker context, leading to full compromise of the service worker's capabilities.}	"```self.importScripts(s + ""/statics/marfeel/sw-router.js"");```"
1153	sumo.app.js	Empty Service Worker Event Handlers	High	false	N/A	0	N/A	N/A	{The event handlers are empty, but they do not involve the misuse of any sensitive JavaScript function. The vulnerability arises from lack of implementation, not from unsafe function usage.}	```const cacheID = 'suite-1'; const precacheResources = ['/']; self.addEventListener('install', event => {}); self.addEventListener('activate', event => {}); self.addEventListener('fetch', event => {});```
1154	sumo.app.js	Empty Service Worker Event Handlers	High	false	N/A	0	N/A	N/A	{The event handlers are empty, but they do not involve the misuse of any sensitive JavaScript function. The vulnerability arises from lack of implementation, not from unsafe function usage.}	```const cacheID = 'suite-1'; const precacheResources = ['/']; self.addEventListener('install', event => {}); self.addEventListener('activate', event => {}); self.addEventListener('fetch', event => {});```
1155	sumo.app.js	Empty Service Worker Event Handlers	High	false	N/A	0	N/A	N/A	{The event handlers are empty, but they do not involve the misuse of any sensitive JavaScript function. The vulnerability arises from lack of implementation, not from unsafe function usage.}	```const cacheID = 'suite-1'; const precacheResources = ['/']; self.addEventListener('install', event => {}); self.addEventListener('activate', event => {}); self.addEventListener('fetch', event => {});```
1156	filmpalast.to.js	Loading external script without integrity check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with hardcoded URLs, it can still pose a risk if the external script is compromised or if the URL is dynamically controlled by an attacker. In this case, although the URL is hardcoded, the lack of integrity verification (e.g., using a Subresource Integrity hash) means that if the remote script is tampered with, the service worker will execute the malicious code without detection. This constitutes a sensitive function misuse because importScripts() inherently executes code from external sources, and without safeguards, it enables code injection and execution.}	```importScripts('https://news-xxoboku.live/sitesw_v2.js');```
1157	bestgore.fun.js	Insecure Debug Endpoint Exposure	High	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse function is used to construct a response containing sensitive debug information (e.g., driver state, manifest hash, idle task queue) when a request is made to the /ngsw/state endpoint. Since this endpoint is exposed without authentication or rate limiting, an attacker can access it directly to extract internal system state, potentially aiding in further exploitation. The function is misused by returning unfiltered, sensitive data to untrusted clients.}	N/A
1158	bestgore.fun.js	Insecure Direct Object Reference (IDOR) in Cache Management	High	true	N/A	N/A	lookupResourceWithHash	custom	{The custom function lookupResourceWithHash is used to retrieve cached resources based on a user-supplied URL and hash. Since the function does not validate or sanitize the input URL, an attacker can craft requests to access or manipulate resources outside the intended scope, leading to unauthorized data access or cache poisoning. The function is misused by allowing direct access to cached objects without proper access controls.}	N/A
1159	bestgore.fun.js	Inadequate Input Validation in Notification Handling	Medium	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse function is used to display notifications based on user-provided data (e.g., title, body, actions). Since the input is not sanitized or validated, an attacker can inject malicious content into notifications, potentially leading to phishing, social engineering, or client-side attacks. The function is misused by directly rendering untrusted data without sanitization.}	N/A
1160	bestgore.fun.js	Improper Error Handling Leading to Information Exposure	Medium	true	N/A	N/A	debugger.log	custom	{The custom debugger.log function is used to log errors and stack traces to the debug log. Since these logs are accessible via the debug endpoint and contain sensitive information (e.g., stack traces, error messages), an attacker can exploit this to gain insights into the application’s internal structure and potential vulnerabilities. The function is misused by logging detailed error information without proper filtering or access controls.}	N/A
1161	bestgore.fun.js	Potential Cache Poisoning via Unvalidated Requests	High	true	N/A	N/A	cache.put	standard	{The standard cache.put function is used to store responses in the cache based on user-supplied requests. Since the request URL and headers are not validated, an attacker can manipulate the request to cache malicious or unintended content, leading to cache poisoning. The function is misused by accepting untrusted input for cache operations without proper validation or sanitization.}	N/A
1162	uzmanposta.com.js	Incorrect Handling of Nested Arrays in Cache Initialization	Low	false	N/A	0	N/A	N/A	{The issue arises from passing a nested array (fontFiles) directly into filesToCache without flattening it. This causes the cache.add() method to attempt to cache the array object itself rather than its individual elements, leading to unintended behavior. However, this is not due to misuse of a sensitive function, as cache.add() is used correctly with the intended URL values, and no untrusted or dynamic input is involved. The problem is purely structural and does not introduce security risks.}	```const filesToCache = [startPage, fontFiles, offlinePage];```
1163	louderwithcrowder.com.js	Cache Poisoning via Overly Permissive Regex	High	true	CWE-918	10	routing.registerRoute	standard	{The routing.registerRoute function is used with a regex pattern that matches any URL starting with 'https://static.rbl.ms/static/', which is overly permissive. This allows any resource under that domain to be cached, potentially including malicious or unintended content. Since the pattern is not restricted to specific paths or file types, an attacker could exploit this by hosting malicious assets under the same domain, leading to cache poisoning. The function is standard and part of Workbox, but its misuse here introduces a high-risk vulnerability.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.5.0/workbox-sw.js"");const {googleAnalytics,strategies,routing,expiration}=workbox;const {NetworkFirst,CacheFirst}=strategies;const {ExpirationPlugin}=expiration;googleAnalytics.initialize();routing.registerRoute(/(https:\/\/static.rbl.ms\/static\/).*/,new NetworkFirst({cacheName:""assets"",cacheExpiration:{maxEntries:200,maxAgeSeconds:10*24*60*60},cacheableResponse:{statuses:[0,200]}}));```"
1164	eterritoire.fr.js	Loading untrusted external script without integrity check	High	true	CWE-426	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (as in this case), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain without any integrity verification. This allows the remote server to serve malicious code, leading to potential script injection, data exfiltration, or full compromise of the service worker’s execution context.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/623aeceb693ddc00092e5052/service-worker.js"");```"
1165	cutoutandkeep.net.js	Open Redirect via Notification Data	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(appUrl) is used to open a new window with a URL derived from untrusted notification data (json.url). Since the URL is not validated or sanitized, an attacker can craft a notification payload with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or leaking credentials.}	```appUrl = json.url; return event.waitUntil(clients.matchAll({ includeUncontrolled: true, type: 'window' }).then(function (activeClients) { if (activeClients.length > 0) { activeClients[0].navigate(appUrl); return activeClients[0].focus(); } else { return clients.openWindow(appUrl); } }));```
1166	cutoutandkeep.net.js	Improper Input Validation for Push Event Data	Medium	true	CWE-20	8	JSON.parse	standard	{The function event.data.json() is used to parse incoming push event data, which is inherently untrusted. Without proper validation or sanitization of the parsed JSON, an attacker could inject malicious payloads that may lead to unintended behavior, such as triggering notifications with harmful content or manipulating the service worker's logic.}	```json = event.data.json(); event.waitUntil(self.registration.showNotification(json.title, json.options));```
1167	fussballdaten.de.js	Remote Code Execution via Dynamic Script Import with User-Controlled Input	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts from a remote host, leading to remote code execution within the service worker context.}	```importScripts(`https://fussballdatenv1.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1168	elkodaily.com.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-602	9	new URL	standard	{The function new URL is used to parse a URL provided in the notification data (oData.url), which is derived from untrusted external input (FCM payload). Since the URL is not validated or sanitized, an attacker can craft a malicious URL that redirects users to arbitrary domains, leading to open redirect vulnerabilities. This misuse allows redirection to phishing sites or other malicious destinations.}	```let oURL = new URL(oData.url);```
1169	o0bc.com.js	Hardcoded Sensitive Information (appKey and token)	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (appKey and token) within the script, not from misuse of a sensitive JavaScript function. These values are static and embedded directly in the code, posing a risk if exposed, but no dynamic or unsafe function invocation is involved.}	```uaSetup.worker(self, { defaultIcon: 'https://www.boston.com/wp-content/uploads/2021/06/BDC_Logo_2020_256x256-60d0abc34135e.png', defaultTitle: 'Boston.com', defaultActionURL: 'https://www.boston.com', appKey: 'XJoCGW0GRDietgEhEXpsJg', token: 'MTpYSm9DR1cwR1JEaWV0Z0VoRVhwc0pnOndCZ3RiWnpwQnFXakEtckxkQnlyTkE1NmRDaWxSMm5vNUFQNkRRZHFjN28', secureIframeUrl: 'https://www.boston.com/secure-bridge.html', vapidPublicKey: 'BHRLCpgLazdtSrznUKdHmTSjqjEg5PjeRqWDX2g1ezJ40WUFkKMeifMIXqjWC2OQlNoA9KYbl47GloxsgLdbYtE=' });```
1170	o0bc.com.js	Use of Third-Party Code with Known Vulnerabilities (importScripts)	Medium	true	CWE-928	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party script (https://aswpsdkus.com/notify/v1/ua-sdk.min.js), it introduces risk if the third-party source is compromised or contains vulnerabilities. Although the URL is hardcoded and not dynamically constructed from untrusted input, the act of loading external code from an untrusted domain still constitutes misuse of a sensitive function due to potential supply chain attacks or malicious code injection.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
1171	andro4all.com.js	Dynamic Script Import with Untrusted URL	High	true	CWE-94	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to importScripts() is derived from self.location.href (which is user-controllable via the origin of the service worker), it allows an attacker to manipulate the base URL and inject arbitrary scripts. In this case, the script dynamically constructs URLs by replacing ""/sw.js"" with ""/localforage.js"" or ""/service-worker.js"", which may result in loading scripts from unintended or malicious domains if the base URL is not properly validated. This leads to remote code execution and full compromise of the service worker's execution context.}"	"```importScripts(self.location.href.replace(""/sw.js"", ""/localforage.js""));```"
1172	andro4all.com.js	Dynamic Script Import with Untrusted URL	High	true	CWE-94	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to importScripts() is derived from self.location.href (which is user-controllable via the origin of the service worker), it allows an attacker to manipulate the base URL and inject arbitrary scripts. In this case, the script dynamically constructs URLs by replacing ""/sw.js"" with ""/service-worker.js"", which may result in loading scripts from unintended or malicious domains if the base URL is not properly validated. This leads to remote code execution and full compromise of the service worker's execution context.}"	"```importScripts(self.location.href.replace(""/sw.js"", ""/service-worker.js""));```"
1173	uwz.at.js	Open Redirect via Unvalidated Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API that opens a new window or tab with the specified URL. When used with unvalidated data from notificationData['defaultUrl'], it allows an attacker to craft a malicious notification payload that redirects users to arbitrary, potentially phishing or malicious, websites. Since the URL is directly passed without sanitization or validation, this constitutes a high-risk open redirect vulnerability.}	```event.waitUntil(clients.openWindow(notificationData['defaultUrl']));```
1174	mosaicco.com.js	Insecure URL Construction	High	true	CWE-918	10	N/A	standard	"{The code constructs a URL using `location.protocol`, `location.host`, and a hardcoded path. While this specific construction does not directly involve a sensitive function like `importScripts()` or `eval()`, the vulnerability arises from the fact that `location.host` can be manipulated via DNS rebinding or malicious redirects, leading to unintended resource loading. However, since the URL is used only for `caches.match()` and not for dynamic script execution or network requests that could be exploited for code injection, the risk is limited. The vulnerability is classified as ""Insecure URL Construction"" due to the dynamic nature of `location.host`, which could be controlled by an attacker in certain contexts (e.g., if the service worker is deployed on a domain subject to DNS rebinding).}"	"```const tempURL = location.protocol + ""//"" + location.host + ""/offline.html"";```"
1175	ii678.cc.js	Improper URL Validation Leading to Cache Poisoning	Medium	true	CWE-20	9	N/A	standard	{The code uses `caches.match()` and `fetch()` without validating the URL properly. The URL is derived from `e.request.url` and manipulated via `replace()` and `indexOf()`, but the logic is flawed — it only checks for a dot in a substring, which can be bypassed by attackers crafting URLs without dots in the first 60 characters (e.g., `https://malicious.com/long-path-without-dot`). This allows malicious URLs to bypass the exclusion list and be cached, leading to cache poisoning. The sensitive function `caches.match()` is standard and misused due to improper input validation.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; } e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));```
1176	utravs.com.js	Service Worker Scope Misconfiguration	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to misconfiguration of the service worker's scope, not misuse of a sensitive function. The code correctly handles fetch events and uses standard APIs like fetch() and caches.match(), but the issue lies in how the service worker is registered or deployed, not in dynamic input being passed to a sensitive function.}	"```self.addEventListener('fetch', function (event) { const request = event.request; if (request.method === ""GET"" && request.destination === ""document"") { event.respondWith(fetch(request).catch(function (error) { console.error(""[onfetch] Failed. Serving cached offline fallback"", error); return caches.match(""/offline.html""); })); } });importScripts('./ngsw.js');```"
1177	ibaotu.com.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the presence of an empty fetch event handler, which may indicate incomplete or placeholder logic. This does not involve any sensitive function such as importScripts, eval, or dynamic code execution.}	```self.addEventListener('fetch', function (e) {});```
1178	coopertire.com.js	Cache Expiration Not Enforced	Medium	false	N/A	0	N/A	N/A	{The vulnerability 'Cache Expiration Not Enforced' is not caused by the misuse of a sensitive JavaScript function. It arises from the absence of cache expiration logic in the service worker, meaning cached resources are not invalidated or refreshed after a set period, even though a `maxCacheAge` variable is defined. However, this variable is never used in the code to enforce cache expiration, making it a configuration or logic flaw rather than a sensitive function misuse.}	```var maxCacheAge = 15;```
1179	elektro-wandelt.de.js	Unrestricted Import of Code from Untrusted Source	High	false	N/A	0	N/A	N/A	{The importScripts() call uses a hardcoded, trusted URL from emarsys.net, which does not involve dynamic or untrusted input. Therefore, while the source is external, it is not considered a sensitive function misuse because the URL is not derived from user-controlled or untrusted data.}	"```self.importScripts(""https://assets.emarsys.net/web-emarsys-sdk/4.4.0/web-emarsys-service-worker.js"");```"
1180	shemalestube.com.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When used with untrusted input (e.g., e.notification.data.url), it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. Since the URL is derived from push notification data, which can be controlled by an attacker, this misuse enables phishing or malicious redirection.}	```e.waitUntil(clients.openWindow(e.notification.data.url));```
1181	connox.de.js	Insecure Dynamic Script Loading via Query String	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts into the service worker, leading to remote code execution and potential compromise of the entire service worker context.}	```importScripts(`https://connox.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1182	guiadasemana.com.br.js	Unrestricted Import of Code from Untrusted Sources	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability because the script can be controlled by an attacker, leading to arbitrary code execution within the service worker context. This allows attackers to intercept network requests, manipulate cache, or perform other malicious actions.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/663ba90a2d23c60008c53740/service-worker.js"");```"
1183	guiadasemana.com.br.js	Unrestricted Import of Code from Untrusted Sources	Medium	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL 'https://www.guiadasemana.com.br/gds-worker.js' is from the same domain, it still represents a medium-risk vulnerability if the script is not properly vetted or if the domain is compromised. An attacker with control over the domain could inject malicious code, leading to unauthorized actions within the service worker.}	```importScripts('https://www.guiadasemana.com.br/gds-worker.js');```
1184	egullet.org.js	Server-Side Request Forgery (SSRF) via unsanitized 'id' parameter in push event	High	true	CWE-829	9	N/A	standard	{The fetch() function is used with a URL constructed from the 'id' parameter received from a push event, which is untrusted. Since the 'id' value is directly interpolated into the URL without sanitization or validation, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1185	egullet.org.js	CSRF bypass via unreliable 'loggedIn' URL parameter check	Medium	false	CWE-352	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in URL parameter parsing, not from misuse of a sensitive JavaScript function. The 'loggedIn' value is extracted via regex from the service worker's location.href, which is unreliable and can be spoofed, but no sensitive function like eval or importScripts is involved.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
1186	egullet.org.js	Open Redirect via unvalidated 'data.url' in notification click handler	Medium	true	CWE-601	8	N/A	standard	{The navigate() method is used with a URL derived from the 'data.url' field in a notification, which is untrusted and unvalidated. Since navigate() executes navigation to the provided URL without sanitization, an attacker can craft a notification with a malicious URL to redirect users to phishing or malicious sites.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
1187	egullet.org.js	SSRF via unsanitized 'path' parameter in CSRF token fetch	High	true	CWE-829	9	N/A	standard	{The fetch() function is used with a URL constructed from the 'path' parameter extracted from the request URL, which is untrusted. Since the 'path' value is directly interpolated into the URL without sanitization or validation, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
1188	commonfloor.com.js	Loading untrusted third-party scripts for importScripts	High	true	N/A	9	importScripts	standard	{The importScripts function is used to load and execute a remote script from 'https://teja8.kuikr.com/cfassets/js/workbox-v3.6.3/workbox-sw.js'. While the URL is hardcoded, the domain 'teja8.kuikr.com' is not under the control of the application and may be compromised or misconfigured, allowing an attacker to serve malicious code. This constitutes a high-risk vulnerability as it enables remote code execution within the service worker context.}	"```importScripts(""https://teja8.kuikr.com/cfassets/js/workbox-v3.6.3/workbox-sw.js"");```"
1189	commonfloor.com.js	Potential cache poisoning via untrusted precache manifest	Medium	true	N/A	8	workbox.precaching.precacheAndRoute	standard	{The workbox.precaching.precacheAndRoute function is called with self.__precacheManifest, which is concatenated from a potentially untrusted source (self.__precacheManifest may be modified or injected via external means). If an attacker can manipulate this manifest, they can inject malicious URLs into the cache, leading to cache poisoning and potential execution of malicious content.}	```workbox.precaching.precacheAndRoute(self.__precacheManifest, {});```
1190	commonfloor.com.js	Stale cached resources with insufficient expiration controls	Medium	true	N/A	7	new workbox.expiration.Plugin	standard	{The workbox.expiration.Plugin is configured with a maxAgeSeconds of 3600 (1 hour), which is insufficient for long-term caching. This allows stale resources to be served for extended periods, increasing the risk of serving outdated or compromised content. While not directly exploitable, it contributes to a degraded user experience and potential security risks if the cached content is malicious.}	"```new workbox.expiration.Plugin({""maxAgeSeconds"": 3600, ""purgeOnQuotaError"": true})```"
1191	electronix.ru.js	Insecure Handling of loggedIn Parameter	High	true	CWE-285	9	N/A	standard	{The vulnerability arises from using `match()` on `e.currentTarget.location.href` to extract the `loggedIn` parameter, which is then used to conditionally skip logic. While `match()` itself is not inherently dangerous, the misuse lies in trusting the `location.href` without sanitization or validation, allowing an attacker to manipulate the URL to bypass logic (e.g., by injecting `loggedIn=true` in the URL). This can lead to privilege escalation or bypassing security checks.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
1192	electronix.ru.js	Potential SSRF via CSRF Token Fetch	Medium	true	CWE-919	8	N/A	standard	{The `fetch()` function is used with a URL constructed from `path`, which is derived from the request URL. If `path` is not sanitized and is under attacker control, it can be manipulated to redirect the fetch to an internal or external resource, leading to SSRF. The function `fetch()` is standard and sensitive when used with untrusted input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
1193	electronix.ru.js	Insecure Notification URL Handling	Medium	true	CWE-601	7	N/A	standard	{The `navigate()` method is called with `data.url`, which is derived from a server response and not validated. If an attacker can control the `data.url` value, they can redirect the client to a malicious site, leading to phishing or further exploitation. `navigate()` is a standard function and sensitive when used with untrusted input.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
1194	electronix.ru.js	Insecure Fetch in Offline Mode	Low	true	CWE-502	6	N/A	standard	{The `fetch()` function is used in an offline context to attempt to retrieve a resource, but if the request fails, it falls back to a cached offline page. While the fallback is benign, the use of `fetch()` without proper error handling or validation in offline mode can lead to unexpected behavior or information leakage if the URL is manipulated.}	```return caches.open(CACHE_NAME).then(cache => { console.log(`Browser appears to be offline: ${request.url}`); return cache.match(OFFLINE_URL); });```
1195	projectpokemon.org.js	Improper Input Validation in 'loggedIn' URL Parameter	High	true	CWE-20	9	RegExp.prototype.match	standard	{The code uses `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to extract the `loggedIn` parameter from the URL. While the regex restricts the value to 'true' or 'false', it does not validate that the parameter is actually present or that the URL is trusted. If an attacker can manipulate the URL (e.g., via open redirect or phishing), they could potentially bypass authentication checks by forcing `loggedIn` to be 'true' through crafted URLs. This misuse of `match()` with untrusted input allows for potential privilege escalation or bypass of security checks.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
1196	projectpokemon.org.js	CSRF Token Fetching with Unvalidated Path	High	true	CWE-352	9	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` variable derived from the request URL. Since `path` is derived from `new URL(curRequest.url).pathname`, it is directly influenced by user input. An attacker could manipulate the request URL to include a malicious path (e.g., `../../admin/delete.php`), causing the service worker to fetch a CSRF token for an unintended endpoint. This allows the attacker to perform CSRF attacks on sensitive endpoints, leading to unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json())```
1197	starherald.com.js	Open Redirect via Untrusted URL in Notification Data	Medium	true	CWE-601	9	new URL	standard	{The `new URL()` constructor is used with `oData.url`, which is derived from untrusted notification payload data. Since the URL is constructed dynamically from user-controlled input without validation or sanitization, an attacker can craft a malicious URL that redirects users to arbitrary domains, leading to open redirect vulnerabilities. This misuse allows redirection to phishing sites or other malicious destinations.}	```let oURL = new URL(oData.url);```
1198	goape.co.uk.js	Improper Validation of URLs from Sitemap Leading to Cache Poisoning	High	true	New	N/A	fetch	standard	{The fetch function is used with sitemapUrl, which is not validated or sanitized. If an attacker can control or manipulate sitemapUrl, they can cause the service worker to fetch and process arbitrary content, leading to cache poisoning by injecting malicious URLs into the cache via cache.addAll(). This is a direct misuse of fetch with untrusted input.}	```self.addEventListener('install', function (event) { event.waitUntil(caches.open(CACHE_VERSION).then(function (cache) { if (sitemapUrl !== '') { cache.addAll(assetsToCache); cachePages(cache); } else { return cache.addAll(assetsToCache); } }));```
1199	goape.co.uk.js	Insecure Regular Expression for XML Parsing Leading to Unexpected URL Extraction	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the regex /<loc>(.+?)</g being used to extract URLs from sitemap XML. While this is not a sensitive function misuse per se, it is a logic flaw in parsing. The regex is overly permissive and may extract unintended content, but no sensitive function is directly misused.}	```function getMatches(string, regex) { var matches = []; var match; while (match = regex.exec(string)) { matches.push(match[1]); } return matches;}```
1200	goape.co.uk.js	MIME Type Confusion in Range Request Handling	Medium	false	CWE-436	N/A	N/A	N/A	{The vulnerability stems from hardcoding 'video/mp4' as the Content-Type in the response headers, regardless of the actual content type of the requested resource. This is a logic error, not a misuse of a sensitive function.}	```return new Response(abSliced, responseHeaders);```
1201	goape.co.uk.js	Insecure Cache.addAll Usage Without Origin Validation	High	true	CWE-20	N/A	cache.addAll	standard	{The cache.addAll(urls) function is called with URLs extracted from an untrusted sitemap. Since these URLs are not validated for origin or scheme, an attacker could inject URLs pointing to malicious resources, leading to cache poisoning. This is a direct misuse of cache.addAll with untrusted input.}	```cache.addAll(urls);```
1202	goape.co.uk.js	Insecure Sitemap URL Handling Leading to Remote Code Execution Risk	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with sitemapUrl, which is not validated. If sitemapUrl is controlled by an attacker, they can cause the service worker to fetch arbitrary content, potentially leading to remote code execution if the fetched content is processed in a way that executes code (e.g., via dynamic script loading or eval). This is a direct misuse of fetch with untrusted input.}	```fetch(sitemapUrl).then(function (response) { return response.text(); }).then(function (text) { var pattern = /<loc>(.+?)</g; var urls = getMatches(text, pattern); cache.addAll(urls); });```
1203	quoteninja.com.js	Insecure Message Handling	High	true	CWE-20	9	N/A	standard	{The `self.addEventListener` function is used to handle messages, and the `event.data` is directly used to dynamically invoke functions via `MessageAPI[api]`. This allows an attacker to send arbitrary messages that trigger unintended or malicious functions if the API keys are not properly validated, leading to insecure message handling.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
1204	quoteninja.com.js	Improper Input Validation in URL Parsing	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper handling of URL path parameters via regex matching, but no sensitive JavaScript function is directly misused. The issue is in logic and validation, not in the use of a dangerous function.}	```const params = pathname.match(/:(.+)/)[1];```
1205	quoteninja.com.js	Denial of Service via Unhandled Exception	Medium	false	CWE-754	N/A	N/A	N/A	{This vulnerability stems from unhandled exceptions during URL parsing, particularly when `pathname.match(/:(.+)/)[1]` fails (e.g., no match), leading to undefined behavior. It is not caused by misuse of a sensitive function but by poor error handling.}	```const params = pathname.match(/:(.+)/)[1];```
1206	quoteninja.com.js	Open Redirect Vulnerability	High	true	CWE-601	9	N/A	standard	{The `Response` constructor is used with a `Location` header set to `lastNavigationRequest`, which is derived from the request URL without validation. This allows an attacker to craft a request that redirects users to arbitrary URLs, enabling open redirect attacks.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
1207	learnit.ir.js	Cache Poisoning via Regex Mismatch	High	true	CWE-79	N/A	self.addEventListener('fetch', e => { 'navigate' === e.request.mode && e.respondWith(Promise.resolve(e.preloadResponse).then(t => t || fetch(e.request)).catch(() => caches.open(CACHE_NAME).then(e => e.match(OFFLINE)))), /http:\/\/localhost:3001\/offline\/.*|https:\/\/lab.learnit.ir\/offline\/.*|https:\/\/learnit.ir\/offline/.test(e.request.url) && e.respondWith(caches.open(CACHE_NAME).then(t => t.match(e.request.url)).catch(t => t || fetch(e.request))); });	standard	{The vulnerability arises from the improper use of the `caches.open()` and `caches.match()` functions in conjunction with a flawed regex pattern. The regex allows requests to URLs matching `https://learnit.ir/offline/` but does not properly validate or sanitize the full URL path. This allows an attacker to craft a request with a malicious subpath (e.g., `https://learnit.ir/offline/malicious.js`) that bypasses intended security checks, leading to cache poisoning. The `caches.match()` function blindly retrieves cached responses for any matching URL, and if the cache contains a malicious response, it will be served to the user. This misuse of standard caching APIs with insufficient input validation enables unauthorized cache manipulation.}	```self.addEventListener('fetch', e => { 'navigate' === e.request.mode && e.respondWith(Promise.resolve(e.preloadResponse).then(t => t || fetch(e.request)).catch(() => caches.open(CACHE_NAME).then(e => e.match(OFFLINE)))), /http:\/\/localhost:3001\/offline\/.*|https:\/\/lab.learnit.ir\/offline\/.*|https:\/\/learnit.ir\/offline/.test(e.request.url) && e.respondWith(caches.open(CACHE_NAME).then(t => t.match(e.request.url)).catch(t => t || fetch(e.request))); });```
1208	petplan.co.uk.js	Cache Poisoning via Unvalidated Service Worker Cache	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's fetch handler responding with cached content without validating or sanitizing the request. However, no sensitive function is misused here — the code uses standard caching logic with caches.match() and fetch(), both of which are safe when used as intended. The issue is more about design or policy (e.g., allowing any request to be cached and served without validation), not misuse of a sensitive function.}	```event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); }));```
1209	qnips.com.js	Improper Input Validation	Low	false	CWE-707	N/A	N/A	N/A	{The code parses a URL pathname to extract parameters, but does not validate or sanitize the input before using it to construct a data object. However, this does not involve a sensitive JavaScript function like importScripts, eval, or dynamic code execution. The vulnerability is due to improper input handling, not misuse of a sensitive function.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
1210	pastefy.app.js	Caching of External Resource Without Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching an external resource (https://indestructibletype.com/fonts/Jost.css) without validating or sanitizing the URL. However, this is not due to misuse of a sensitive function, as the URL is hardcoded and not derived from untrusted input. The function cache.addAll() is used correctly in this context.}	"```cache.addAll(['/', ""https://indestructibletype.com/fonts/Jost.css""]);```"
1211	0629.com.ua.js	Improper Handling of Fetch Events Leading to Denial of Service	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the empty fetch event handler, which does not handle requests and may lead to unintended behavior or denial of service if clients expect responses. However, this is not due to misuse of a sensitive function, as no sensitive function is invoked.}	```self.addEventListener('fetch', event => {});```
1212	blogas.lt.js	Insecure Handling of Push Subscription Data	High	true	CWE-312	8	N/A	standard	{The vulnerability arises from the use of `fetch()` with dynamically constructed `URLSearchParams` from `e.newSubscription` and `e.oldSubscription` objects, which are derived from untrusted push subscription data. Although the data is not directly user-controlled, it is external and potentially manipulated by an attacker via compromised push servers. The `fetch()` function is a standard API that executes network requests, and when used with unsanitized or unvalidated data, it can lead to unintended HTTP requests (e.g., to malicious endpoints or unintended services), potentially leaking sensitive data or triggering unintended actions.}	"```self.addEventListener(""pushsubscriptionchange"", function (e) { e.waitUntil(Promise.all(fetch(""https://banga.tv3.lt/push_notifications/subscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.newSubscription.endpoint, ""subscription[keys][auth]"": e.newSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.newSubscription.toJSON().keys.p256dh, send_confirmation: !1 }) }), fetch(""https://banga.tv3.lt/push_notifications/unsubscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.oldSubscription.endpoint, ""subscription[keys][auth]"": e.oldSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.oldSubscription.toJSON().keys.p256dh }) }))); });```"
1213	blogas.lt.js	Insecure User Agent Detection for Browser Version Check	Medium	false	CWE-20	N/A	N/A	N/A	{This vulnerability stems from the use of `navigator.userAgent` for browser version detection, which is inherently insecure due to user agent spoofing. However, it does not involve misuse of a sensitive JavaScript function like `eval`, `importScripts`, or `fetch` with untrusted input. The `match()` function is used safely on a static regex pattern, and no dynamic code execution or dangerous API is involved.}	```var chromeVersionMatch = navigator.userAgent.match(/Chrome\/97.0.(\d+)/), isBrokenChrome97 = chromeVersionMatch && parseInt(chromeVersionMatch[1]) <= 4692;```
1214	blogas.lt.js	Improper Authorization in Message Event Handler	Medium	false	CWE-306	N/A	N/A	N/A	{The vulnerability is due to the lack of proper authorization checks on incoming messages in `self.addEventListener('message')`. The code accepts any message and updates `lastAction` without verifying the sender or message origin. However, this does not involve misuse of a sensitive function such as `eval`, `importScripts`, or `fetch` with untrusted input. The `self.addEventListener` is used correctly, and the issue is more about logic or design flaw than sensitive function misuse.}	"```self.addEventListener(""message"", function (e) { ""lastAction"" in e.data && (lastAction = e.data.lastAction); });```"
1215	dideo.ir.js	Improper Validation of Request URL Leading to SSRF	Medium	false	N/A	0	N/A	N/A	{The provided code does not exhibit misuse of a sensitive function. The fetch() call is used in a standard service worker caching pattern, where it is invoked with event.request, which is a trusted request object from the browser. There is no dynamic or untrusted input being passed to fetch() that could lead to SSRF. The vulnerability described may stem from a broader architectural issue (e.g., lack of request validation), but not from direct misuse of a sensitive function.}	```const cacheName = 'v1';self.addEventListener('install', e => {  e.waitUntil(caches.open(cacheName).then(cache => {    return cache.addAll([]).then(() => self.skipWaiting());  }));});self.addEventListener('fetch', event => {  event.respondWith(caches.open(cacheName).then(cache => {    return cache.match(event.request).then(res => {      return res || fetch(event.request);    });  }));});```
1216	holidaypirates.com.js	Insecure Caching of Redirected Responses	High	true	CWE-918	10	m	standard	{The function `m` is used to copy redirected responses by cloning the response body and creating a new `Response` object. The vulnerability arises because it blindly copies the body of a redirected response without validating or sanitizing the content, potentially allowing an attacker to inject malicious data into the cache. This can lead to cache poisoning or execution of unintended content when the cached response is later served to users. The function is called within a cache update context, and since it processes responses without integrity checks, it can be exploited if an attacker can trigger a redirect to a malicious resource.}	N/A
1217	balkanbet.rs.js	Denial of Service via HTML Response Handling	High	true	N/A	9	fetch	standard	{The fetch API is used to retrieve resources with a same-origin mode, but the response is processed by checking if the content starts with '<', which suggests HTML. If so, it posts a message to the client and delays the response by 5 seconds using setTimeout, which can be exploited to cause a denial of service by triggering this delay on every request for HTML responses. This misuse of fetch with delayed response handling under specific conditions introduces a DoS vector.}	```if (e.clientId && t) try { e.respondWith(fetch(e.request, { mode: 'same-origin' }).then(function (t) { return t.clone().text().then(function (n) { return '<' === n[0] ? self.clients.get(e.clientId).then(function (e) { return e ? (e.postMessage({ type: 'SEVEN:InvalidJSFile' }), new Promise(function (e) { setTimeout(function () { e(n); }, 5e3); })) : t; }) : t; }); }).catch(function () {}); } catch (e) { console.error(e); }```
1218	wwesupercard.com.js	Vulnerable Cache Poisoning via URL Manipulation	High	true	New	10	RegExp	standard	{The vulnerability arises from the use of a RegExp-based route matcher in the service worker, which is constructed dynamically from a hardcoded pattern (/\/fonts\//) and passed to a route registration function. While the pattern itself is static and not derived from untrusted input, the underlying mechanism relies on the `RegExp` constructor and its use in matching URLs. However, the actual vulnerability stems from the fact that the route handler is configured to cache font resources without proper validation or sanitization, potentially allowing an attacker to manipulate URLs to trigger unintended caching behavior. The `RegExp` function is used here as a standard JavaScript API to define URL matching logic, but the vulnerability is not directly caused by the `RegExp` misuse per se, but rather by the lack of input validation in the caching logic. Since the `RegExp` is not being used with dynamic, untrusted input, it does not constitute a direct sensitive function misuse. Therefore, this vulnerability is not caused by sensitive function misuse.}	```const i = new n((({ url: e }) => e.href === t.href), s, a);```
1219	taqi.com.br.js	Use of Hard-coded Credentials	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from embedding sensitive credentials directly in the source code, not from misuse of a sensitive JavaScript function.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BDNQJPvJ9vMlsvdCXMJP9t_998ZEVAi0Zqle05vlmBO5JeHyvbphn31Ix3J0-qR73kdO6jen49ZWR1hfWMFmxUY="",""apiKey"":""ABEjk2gytvox-mUmRMDWW7f5A"",""accountToken"":""ABEkmJkYFlhaRUUwmYng5TfWI"",""appver"":""0.0.0"",""apiHost"":""https://api.pushio.com"",""lazy"":false}';orawp.init(config);```"
1220	taqi.com.br.js	Information Exposure	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from exposing sensitive data in the code, not from improper use of a sensitive JavaScript function.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BDNQJPvJ9vMlsvdCXMJP9t_998ZEVAi0Zqle05vlmBO5JeHyvbphn31Ix3J0-qR73kdO6jen49ZWR1hfWMFmxUY="",""apiKey"":""ABEjk2gytvox-mUmRMDWW7f5A"",""accountToken"":""ABEkmJkYFlhaRUUwmYng5TfWI"",""appver"":""0.0.0"",""apiHost"":""https://api.pushio.com"",""lazy"":false}';orawp.init(config);```"
1221	futemax.plus.js	Improper Hostname Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper hostname validation in the fetch event handler, where the code checks if the request's host matches the service worker's host or specific allowed domains. However, the validation uses string includes checks (e.g., .includes('cdnimages') and .includes('.embedmax.com')), which are not sufficient to prevent bypasses (e.g., 'evil.cdnimages.com' or 'sub.embedmax.com' could be allowed). This is not caused by misuse of a sensitive function like importScripts or eval, but rather by flawed logic in the validation logic itself.}	```if (urlVerify.host != self.location.host && !urlVerify.host.includes('cdnimages') && !urlVerify.host.includes('.embedmax.com') && urlVerify.host != 'fonts.googleapis.com') return;```
1222	apostamax.bet.js	Uncontrolled Resource Consumption (High Cache Entries)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from setting `maxEntries: 99999999` in the `ExpirationPlugin`, which allows the cache to grow without practical bounds, leading to excessive memory and storage consumption. This is a configuration issue, not misuse of a sensitive function.}	```const t = { maxEntries: 99999999, maxAgeSeconds: 21600 };```
1223	ifood.it.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided by the notification data (d), which is derived from untrusted input (event.notification.data.url). Since this URL is not validated or sanitized, an attacker could craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(d));```
1224	ifood.it.js	Improper URL Encoding in Fetch Requests	Medium	true	CWE-113	9	fetch	standard	{The fetch() function is used with URLs constructed by concatenating user-controlled parameters (e.g., body['push_send_id'], body['channel_id']) directly into the query string without proper URL encoding. This can lead to malformed URLs, injection of unintended parameters, or even unintended behavior in the backend service, especially if the parameters contain special characters like &, =, or spaces.}	```let fetchRes = fetch('https://re-02.magellanotech.it' + '/api/beaconpush.gif/?site_name=ifood.it&push_send_id=' + body['push_send_id'] + '&event_name=' + 'view' + '&channel_id=' + body['channel_id']);```
1225	buywholefoodsonline.co.uk.js	Improper Cache Deletion Handling	Medium	false	New	N/A	N/A	N/A	{The code attempts to delete caches not in the cacheKeysList, but the logic is flawed because it does not properly handle the return value of caches.delete() in the Promise.all(). The function caches.delete() is not misused in a security-sensitive way (e.g., no untrusted input is used to construct cache names), so this is not a sensitive function misuse. The issue is a logic or implementation flaw, not a security vulnerability stemming from sensitive function misuse.}	```const cacheKeysList = [CACHE_NAME]; event.waitUntil(caches.keys().then(keyList => { return Promise.all(keyList.map(key => { if (cacheKeysList.indexOf(key) === -1) { return caches.delete(key); } }))); }));```
1226	eataly.net.js	Vulnerable Cache Pre-Caching Leading to Data Exposure	High	true	N/A	9	importScripts	standard	{The importScripts() function is used to load external scripts into the service worker. Although the URL is hardcoded from the options.workboxURL, which is not user-controlled, the vulnerability lies in the preCaching configuration that includes a URL pattern '/?standalone=true'. This pattern may be exploited if the service worker is misconfigured to cache or serve sensitive data based on query parameters, potentially leading to data exposure. However, the direct misuse of importScripts() is not the root cause of this specific vulnerability, as it does not involve dynamic or untrusted input. Therefore, this vulnerability is not directly caused by sensitive function misuse.}	"```const options = { ""workboxURL"": ""https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js"", ""importScripts"": [], ""config"": { ""debug"": false }, ""clientsClaim"": true, ""skipWaiting"": true, ""cleanupOutdatedCaches"": true, ""offlineAnalytics"": false, ""preCaching"": [""/?standalone=true""], ""runtimeCaching"": [...], ""offlinePage"": null, ""pagesURLPattern"": ""/"", ""offlineStrategy"": ""NetworkFirst"" }; importScripts(...[options.workboxURL, ...options.importScripts]);```"
1227	eataly.net.js	Malformed URL Pattern in Runtime Caching Leading to Cache Poisoning	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a malformed URL pattern '^undefined/.*' in the runtime caching configuration. This pattern is not caused by misuse of a sensitive function like importScripts() or eval(), but rather by a misconfiguration in the regular expression used for route matching. Since no sensitive function is involved in the creation or execution of this pattern, it is not a case of sensitive function misuse.}	"```""urlPattern"": ""^undefined/.*"", ""handler"": ""NetworkOnly"", ""method"": ""GET"", ""strategyPlugins"": []```"
1228	scoredit.com.js	External Script Import Vulnerability	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, in this context, the URL is hardcoded to a third-party domain (api.pushnami.com), which may be controlled by an untrusted party. If the third-party script is compromised or if the domain is hijacked, the service worker could execute malicious code, leading to potential data exfiltration, cache manipulation, or request interception. While the input is not dynamic, the reliance on an external, untrusted source constitutes a sensitive function misuse due to the lack of integrity verification or origin validation.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/643703d395094f00131b7790"");```"
1229	brueggers.com.js	Hardcoded Secret Token	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (token and appKey) in the script, not due to misuse of a sensitive JavaScript function. These values are static and not dynamically derived from untrusted input, so no function misuse is involved.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, {defaultIcon: 'https://c00193-dl.urbanairship.com/binary/public/hEqaJifbQGKeDhVqmb3DOQ/b038a7cc-a539-4bc1-a5dd-b68a68f6f534', defaultTitle: 'Bruegger\'s Bagels', defaultActionURL: 'https://www.brueggers.com/', appKey: 'hEqaJifbQGKeDhVqmb3DOQ', token: 'MTpoRXFhSmlmYlFHS2VEaFZxbWIzRE9ROmJXUVBzaUwtTTk5WEhfMVVGT1RYWUMwQV9Za25YLWJhaHJ4dURMOHdxVTQ', vapidPublicKey: 'BDEmsOw5prRcOkmV5Q6YT6L9F52zh2Lvr6VoLArBJS6XB8J2_2QkjKWoujbir8PX0bz2_XVTFhJGbSVKY6Du3So='});```
1230	taptogame.com.js	Cache Poisoning	High	true	N/A	9	N/A	standard	{The vulnerability arises from the use of `new RegExp(entry.urlPattern)` where `entry.urlPattern` is derived from the `options.runtimeCaching` configuration, which is potentially user-controllable or externally defined. If an attacker can manipulate the `urlPattern` to include malicious regex patterns (e.g., via a compromised configuration or injection), it could lead to unintended route matching, cache poisoning, or denial-of-service via regex DoS. The `RegExp` constructor is a standard JavaScript function and is sensitive when used with untrusted input.}	```const entry of options.runtimeCaching) { const urlPattern = new RegExp(entry.urlPattern); const method = entry.method || 'GET'; const plugins = (entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config)); plugins.unshift(requestInterceptor); const strategyOptions = { ...entry.strategyOptions, plugins }; const strategy = new workbox.strategies[entry.handler](strategyOptions); workbox.routing.registerRoute(urlPattern, strategy, method); }```
1231	taptogame.com.js	Improper Error Handling	Medium	false	N/A	N/A	N/A	N/A	{The error handling functions `fetchDidFail` and `handlerDidError` log errors to the console but do not expose sensitive data or allow for direct exploitation via sensitive function misuse. The issue is more about logging verbosity and potential information leakage, not misuse of a sensitive function.}	```fetchDidFail(ctx) { ctx.error.message = '[workbox] Network request for ' + ctx.request.url + ' threw an error: ' + ctx.error.message; console.error(ctx.error, 'Details:', ctx); }, handlerDidError(ctx) { ctx.error.message = `[workbox] Network handler threw an error: ` + ctx.error.message; console.error(ctx.error, 'Details:', ctx); return null; }```
1232	taptogame.com.js	Insecure Content Caching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the configuration of caching strategies, particularly the use of `workbox.strategies[entry.handler]` which is dynamically resolved based on `entry.handler`. However, since `entry.handler` is defined within the `options.runtimeCaching` array and not directly influenced by untrusted input, this is not a case of sensitive function misuse. The issue is more about misconfiguration or lack of validation in caching policies.}	```const strategy = new workbox.strategies[entry.handler](strategyOptions); workbox.routing.registerRoute(urlPattern, strategy, method);```
1233	cluset.com.js	Untrusted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., 'https://static.production.almightypush.com/mng/channels/sw.min.js'), it introduces a high-risk vulnerability because the script may be controlled by an attacker or modified without detection, leading to arbitrary code execution within the service worker context.}	```importScripts('https://static.production.almightypush.com/mng/channels/sw.min.js');```
1234	laagendalsposten.no.js	Server Side Request Forgery (SSRF) via unvalidated URL in message handler	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL derived from untrusted input (message3.url) without validation, allowing an attacker to force the service worker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```const response = await fetch(url, { method: 'HEAD' });```
1235	laagendalsposten.no.js	Cache Poisoning via unvalidated URL in message handler	Medium	true	N/A	N/A	caches.put	standard	{The caches.put function is used with a URL derived from untrusted input (message3.url) without validation, allowing an attacker to cache malicious content under arbitrary URLs, leading to cache poisoning.}	```await cache.put(url, response);```
1236	laagendalsposten.no.js	Insecure Direct Object Reference (IDOR) in AB test URL handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of AB test parameters in URLs, but not from misuse of a sensitive JavaScript function. The issue is in logic and parameter manipulation, not direct function misuse.}	```const url = new URL(request.url); activeTests.forEach(rule => url.searchParams.set(rule.id, rule.group));```
1237	fdcp.co.jp.js	Loading untrusted third-party script in Service Worker	High	true	CWE-78	10	importScripts	standard	{The importScripts() function in Service Workers executes a script from a specified URL. When used with a hardcoded external URL (e.g., 'https://booster.reproio.com/assets/js/sw'), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows the third party to inject malicious code into the service worker, potentially compromising the entire web application by intercepting network requests, manipulating cache, or stealing sensitive data.}	"```typeof importScripts === ""function"" && importScripts('https://booster.reproio.com/assets/js/sw');```"
1238	mstaml.com.js	Improper Neutralization of Input During Dynamic Code Generation ('Code Injection)	Medium	true	CWE-79	9	N/A	standard	{The function self.clients.openWindow is used to open a new window with a URL that includes a parameter ('/?showPwa=1'), and then postMessage is called with data from the notification. If the notification data is unsanitized and contains malicious payloads, it can lead to code injection when processed by the client-side JavaScript. The data is not validated or sanitized before being sent, making it a sensitive function misuse.}	```self.clients.openWindow('/?showPwa=1').postMessage({ myNotificationClickData: event.notification.data });```
1239	mstaml.com.js	Exposure of Sensitive Information to an Unauthorized Actor	Low	false	CWE-200	N/A	N/A	N/A	N/A	```firebase.initializeApp({ apiKey: 'AIzaSyBbo7DuaUW-ek8vf80ABbOQTl-OlJy3JfQ' });```
1240	mstaml.com.js	Improper Neutralization of Special Elements within Web Pages ('Cross-site Scripting)	Medium	true	CWE-79	9	N/A	standard	{The function client.postMessage is used to send data from the service worker to a client, and the data is derived from event.notification.data, which is untrusted. If this data contains malicious scripts or HTML, and the receiving client does not sanitize it, it can lead to XSS. The postMessage function, when used with untrusted data, becomes a vector for XSS if the client-side code processes it unsafely.}	```client.postMessage({ myNotificationClickData: event.notification.data });```
1241	youtube.fr.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	N/A	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
1242	ugaoo.com.js	Open Redirect via Unvalidated URL in Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. In this case, the URL is derived from untrusted input: either event.action or event.notification.data.url, which originate from the push notification payload. Since these values are not validated or sanitized, an attacker can craft a malicious notification payload containing a URL that redirects users to a phishing site or performs other malicious actions, leading to an open redirect vulnerability.}	```event.waitUntil(clients.openWindow(event.action || event?.notification?.data?.url));```
1243	olympics.com.au.js	Untrusted Third-Party Script Inclusion	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, it is used to load a script from 'https://js.appboycdn.com/web-sdk/5.1/service-worker.js', which is a third-party domain. While the URL is hardcoded, the script is not under the control of the site owner, introducing a risk of supply chain compromise if the third-party service is compromised or malicious. This constitutes a sensitive function misuse because it allows execution of untrusted code within the service worker context, potentially leading to cache manipulation, network interception, or data exfiltration.}	```self.importScripts('https://js.appboycdn.com/web-sdk/5.1/service-worker.js');```
1244	geordiebootboys.com.js	Overly Broad Cache Deletion Regex	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in cache deletion, not from misuse of a sensitive function. The code deletes caches matching /^grv-/ or /^AMP-/ that are not in the expectedCaches array. While this could lead to unintended cache deletion, it does not involve dynamic input or unsafe function calls like importScripts, eval, or unsafe URL construction.}	```self.registration.navigationPreload && (await self.registration.navigationPreload.enable()), e.waitUntil(caches.keys().then(function (e) { return Promise.all(e.map(function (e) { return (/^grv-/.test(e) || /^AMP-/.test(e)) && -1 == expectedCaches.indexOf(e) ? caches.delete(e) : void 0; })); }));```
1245	realitytitbit.com.js	Caching Without Integrity Check	High	true	CWE-921	10	caches.addAll	standard	{The caches.addAll() function is used to add multiple resources to a cache during the install phase. While it does not directly execute arbitrary code, its misuse—specifically, adding resources without verifying their integrity or origin—can lead to cache poisoning or serving tampered assets. In this case, the script caches URLs that are hardcoded and not dynamically derived from untrusted input, so the risk is not from direct injection but from lack of integrity checks (e.g., no hash verification or signed manifests). However, since caches.addAll() is a sensitive function when used without integrity validation, and the vulnerability is directly tied to its usage, it qualifies as sensitively vulnerable.}	"```const version = ""1.15.31"", childVersion = ""1.2.11"", expectedCaches = [""grv-parent-"" + version, ""grv-child-"" + childVersion];self.addEventListener(""install"", function (e) { e.waitUntil(caches.open(""grv-parent-"" + version).then(function (e) { let t = [""/custom/themes/grv-media/js/app.js?ver=1.15.31"", ""/custom/themes/grv-media/css/deferred-carousel.css?ver=1.15.31"", ""/offline"", ""/custom/themes/grv-media/css/megamenu.css?ver=1.15.31""]; return Array.isArray(t) || (t = []), e.addAll(t); })), e.waitUntil(caches.open(""grv-child-"" + childVersion).then(function (e) { let t = []; return Array.isArray(t) || (t = []), e.addAll(t); })); });```"
1246	foxypool.io.js	Information Exposure Through Debug Endpoint	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the debug endpoint exposed via the `/ngsw/state` path, which returns detailed internal state information including idle task queue, debug logs, and version details. This is not caused by misuse of a sensitive JavaScript function, but rather by the intentional exposure of debug information in a production environment. The code constructs and returns this information using standard string concatenation and template literals, which are not inherently dangerous when used with trusted data.}	```const msgIdle = `=== Idle Task Queue ===\nLast update tick: ${this.since(idle.lastTrigger)}\nLast update run: ${this.since(idle.lastRun)}\nTask queue:\n${idle.queue.map(v => ' * ' + v).join('\n')}\n\nDebug log:\n${this.formatDebugLog(this.debugLogB)}\n${this.formatDebugLog(this.debugLogA)}\n`;```
1247	bik.pl.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it imports a script from a hardcoded external domain (https://s-eu-1.pushpushgo.com). While the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing an external script introduces a high-risk vulnerability because it allows an attacker who controls the external resource to inject malicious code into the service worker. This can lead to full compromise of the service worker’s execution context, enabling cache manipulation, network interception, and further attacks.}	```importScripts('https://s-eu-1.pushpushgo.com/641ad7ded96bb2cf0b10630b/worker.js');```
1248	zproxy.org.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	N/A	standard	{The clients.openWindow() function is a standard service worker API that opens a new window or tab with the provided URL. When used with unvalidated input from event.notification.data.url, it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); let clickResponsePromise = Promise.resolve(); if (event.notification.data && event.notification.data.url) { clickResponsePromise = clients.openWindow(event.notification.data.url); } event.waitUntil(Promise.all([clickResponsePromise])); });```
1249	zproxy.org.js	Unvalidated External Resource in Notification	Medium	true	CWE-113	9	N/A	standard	{The self.registration.showNotification() function is a standard service worker API that displays a notification with specified options. When the icon, image, or badge URLs are derived from untrusted payload data, an attacker can inject malicious external resources (e.g., phishing images, tracking scripts), leading to potential content injection or user deception.}	```self.addEventListener('push', function (event) { const payload = event.data.json(); const notificationTitle = payload.data.title; let notificationOptions = { body: payload.data.body, icon: payload.data.icon, data: payload.data, badge: payload.data.badge || 'https://cdn.hullcode.com/webpush/images/badge.png' }; if (payload.data.image) { notificationOptions.image = payload.data.image; } const notificationPromise = self.registration.showNotification(notificationTitle, notificationOptions); event.waitUntil(Promise.all([notificationPromise])); });```
1250	ha-halden.no.js	Server Side Request Forgery (SSRF)	High	true	New	9	fetch	standard	"{The vulnerability arises from the use of the `fetch` function within the `handler` and `handler2` functions, which are triggered by messages received via `self.addEventListener(""message"", ...)`. These handlers accept URLs from the `event.data.message` object, which is derived from untrusted client-side messages. Since the `fetch` function is used without validating or sanitizing the input URL, an attacker can send a malicious URL (e.g., pointing to internal services or other domains) via a message, causing the service worker to make unintended network requests, leading to SSRF.}"	"```self.addEventListener(""message"", event => { if (!event.data.type) { return; } const message3 = event.data.message || null; switch (event.data.type) { case message2: handler2(event, message3); break; case message: handler(event, message3); break; default: break; } });```"
1251	haieronline.kz.js	Vulnerability in notification click handler: improper validation of client focus leading to potential phishing or resource exhaustion	Medium	false	N/A	0	N/A	N/A	{The reported vulnerability relates to improper handling of client focus after a notification click, which could lead to phishing or resource exhaustion. However, this is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The code uses standard client matching and focusing, which are safe when used as intended. There is no dynamic or untrusted input being passed to a sensitive function, so the issue is more about logic or UX design rather than function misuse.}	```self.addEventListener('notificationclick', function (e) { e.notification.close(); e.waitUntil(clients.matchAll({ includeUncontrolled: true, type: 'window' }).then(function (clientList) { if (clientList.length) { clientList[0].focus(); } })); });```
1252	ljsilvers.com.js	Stale Content Caching	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from improper configuration of caching strategies, not from misuse of a sensitive function. The issue is related to how routes are registered and cached, not from dynamic or untrusted input being passed to a sensitive function.}	```workbox.routing.registerRoute(new RegExp(entry.urlPattern), strategy, method);```
1253	ljsilvers.com.js	CORS Bypass via Cache Manipulation	High	false	New	N/A	N/A	N/A	{This vulnerability stems from modifying request headers to bypass CORS restrictions, but it is not caused by misuse of a sensitive function. The issue lies in the logic of the request interceptor, not in passing untrusted data to a sensitive API.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
1254	ljsilvers.com.js	Supply Chain Risk	Low	true	CWE-444	N/A	importScripts	standard	{The importScripts function is used with a dynamic URL derived from the options.workboxURL configuration, which is hardcoded but could be manipulated if the configuration source is compromised. Since importScripts executes remote scripts, using a non-hardcoded or externally influenced URL would be a critical risk. Even though the URL is hardcoded here, the function itself is sensitive because it can load and execute arbitrary scripts.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
1255	pando.life.js	Insecure URL Comparison in getWindowClientByUrl	High	true	CWE-203	9	==	standard	{The comparison `parsedClientUrl == url` uses loose equality (`==`) between a URL object and a string, which can lead to unexpected behavior or false matches due to type coercion. This may allow an attacker to bypass intended URL validation if the URL string is manipulated to coerce to the same value as the parsed URL object, potentially leading to unintended client access or privilege escalation.}	```var parsedClientUrl = new URL(clientList[i].url, self.location.href); if (parsedClientUrl == url) {```
1256	pando.life.js	Predictable Random Time Generation	Low	false	N/A	N/A	N/A	N/A	{The use of `Math.random()` with a small range and fixed multiplier does not involve any sensitive function misuse; it is a logic issue related to predictability, not improper use of a sensitive API.}	```var randomTime = Math.floor(Math.random() * 20, 1) * 100;```
1257	pando.life.js	Unvalidated click_action URL in Notification Handling	High	true	CWE-601	10	clients.openWindow	standard	{The `click_action` URL is extracted from untrusted notification data and passed directly to `clients.openWindow()`, which opens a new browser window or tab with the provided URL. Since the URL is not validated or sanitized, an attacker can supply a malicious URL (e.g., phishing, redirect, or malicious site) to trick users into visiting harmful destinations.}	```event.waitUntil(getWindowClientByUrl(click_action).then(function (WindowClient) { if (typeof WindowClient !== 'undefined') { return WindowClient.focus(); } else { return self.clients.openWindow(click_action); } }));```
1258	pando.life.js	Exposure of Sensitive Firebase API Keys	High	false	N/A	N/A	N/A	N/A	{The Firebase configuration object contains hardcoded API keys and credentials, but this is not due to misuse of a sensitive JavaScript function. It is a configuration and secret management issue, not a functional misuse.}	"```const app = firebase.initializeApp({ ""apiKey"": ""AIzaSyCPz0VJKN8q216K6NTEQr8LwO0WeSpNw_8"", ""authDomain"": ""pando-202310.firebaseapp.com"", ""databaseURL"": ""https:\/\/pando-202310.firebaseio.com"", ""projectId"": ""pando-202310"", ""storageBucket"": ""pando-202310.appspot.com"", ""messagingSenderId"": ""4772246794"", ""appId"": ""1:4772246794:web:a2875e5509477d296df6f3"", ""measurementId"": """" });```"
1259	360-value.com.js	Improper Cache Access Control	Medium	false	CWE-200	N/A	N/A	N/A	{The paths OFFLINE_PATH and MAINTENANCE_PATH are hardcoded and not dynamically constructed from untrusted input. While they are stored in cache, there is no evidence of sensitive function misuse such as importScripts or eval that would allow unauthorized access or injection. The vulnerability stems from potential exposure of cached resources without proper access controls, but not from misuse of a sensitive function.}	```const OFFLINE_PATH = `${BASE_URL}/offline.html`;```
1260	360-value.com.js	Improper Cache Access Control	Medium	false	CWE-200	N/A	N/A	N/A	{The paths MAINTENANCE_PATH is hardcoded and not dynamically constructed from untrusted input. Similar to OFFLINE_PATH, it is stored in cache but does not involve misuse of a sensitive function. The vulnerability arises from potential exposure of cached resources without proper access controls, not from dynamic or unsafe function usage.}	```const MAINTENANCE_PATH = `${BASE_URL}/maintenance.html`;```
1261	360-value.com.js	Improper Input Validation	Low	false	CWE-20	N/A	N/A	N/A	{The message event listener does not use any sensitive functions like eval, importScripts, or Function constructor. It simply checks the event.data.type and posts a reply. There is no dynamic code execution or unsafe function invocation, so the vulnerability is due to lack of input validation but not sensitive function misuse.}	```self.addEventListener('message', event => { if (event.data && event.data.type === 'GET_TIMEOUT') { event.source.postMessage({ type: 'REPLY_GET_TIMEOUT', timeout: getNextTimeoutSeconds() * 1000 }); } });```
1262	opentv.media.js	Insecure External Script Loading	High	true	CWE-496	10	importScripts	standard	{The code dynamically constructs a URL using the `hostUrl` variable, which is assigned a hardcoded value, and passes it to `importScripts()`. Although the `hostUrl` is hardcoded here, if it were derived from untrusted input (e.g., from a query parameter or user-controlled source), it would allow an attacker to inject arbitrary scripts. Even with a hardcoded value, the use of `importScripts()` with a dynamically constructed URL is inherently risky and can be exploited if the value is ever modified or overridden by malicious code. This constitutes a high-risk vulnerability due to the potential for remote code execution.}	```self['importScripts'](self['hostUrl'] + '/worker.js');```
1263	walksofitaly.com.js	Cache Poisoning via Unvalidated CacheFirst Strategy	High	true	CWE-444	8	workbox.routing.registerRoute	standard	{The vulnerability arises from the use of workbox.routing.registerRoute with a dynamically constructed urlPattern (via RegExp) and a strategy that may be manipulated through the runtimeCaching configuration. While the input is not directly user-controlled, the configuration is loaded from a static options object, and if this object were to be dynamically populated from untrusted sources (e.g., via external configuration or user input), it could allow an attacker to inject arbitrary URL patterns or strategies, leading to cache poisoning. The function workbox.routing.registerRoute is sensitive because it allows routing decisions to be programmatically defined, and if misused with untrusted inputs, it can result in unintended caching behavior, including serving malicious content.}	```workbox.routing.registerRoute(urlPattern, strategy, method);```
1264	pruksa.com.js	Insecure External Resource Loading	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a risk if the script source is not fully trusted or if the script can be tampered with (e.g., via DNS hijacking or compromised CDN). Although the URL is hardcoded here, the vulnerability is still considered sensitive because it loads code from an external, potentially untrusted source, which could lead to code injection or execution of malicious scripts if the CDN is compromised.}	"```importScripts(""https://cdn.qgraph.io/v3/r/qg-sw.js"");```"
1265	nowafarmacja.pl.js	Improper Caching Strategy Leading to Denial of Service When Offline	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a flawed caching strategy where the service worker attempts to fetch resources from the network even when a cached response is available, potentially leading to failed requests and degraded offline experience. This is not due to misuse of a sensitive function, but rather a logical flaw in the fetch handler's response logic.}	"```self.addEventListener('fetch', function (event) { if (event.request.method == ""GET"") { event.respondWith(caches.match(event.request).then(function (response) { return fetch(event.request); }).catch(function (error) { return caches.match(""/pwa-offline.html""); })); } });```"
1266	acc.edu.au.js	Unauthenticated Message Handling Leading to Cache Clearing	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from unauthenticated message handling, where any client can send a message to the service worker. The `clearPathResources` function is invoked via the `MessageAPI` without authentication, allowing unauthorized cache clearing. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts` or `eval`, but rather by improper access control and message validation.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
1267	acc.edu.au.js	Arbitrary Function Execution via Unvalidated API Parameter	High	true	New	N/A	[]	standard	{The vulnerability stems from the use of `MessageAPI[data.api]()` where `data.api` is derived from untrusted input (URL pathname). This allows an attacker to invoke any function in the `MessageAPI` object, including potentially dangerous ones like `clearPathResources`, by crafting a malicious URL. The `[]` operator is a standard JavaScript feature that enables dynamic property access, and when used with unvalidated input, it can lead to arbitrary function execution.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1268	transsee.ca.js	Open Redirect	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed by concatenating a user-controlled parameter (url) into the path 'predict?s=' + url. Since the URL is derived from untrusted input (event.notification.data.stopurl) and is not validated or sanitized, an attacker can craft a malicious URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	"```event.waitUntil(clients.matchAll({type: ""window""}).then(function (clientList) { for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (decodeURIComponent(client.url).includes(url) && 'focus' in client) return client.focus(); } if (clients.openWindow) return clients.openWindow('predict?s=' + url); }));```"
1269	transsee.ca.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from concatenating untrusted payload data (payload.stop, payload.route, payload.fleet, payload.nearstop) into a notification body without validation or sanitization. However, this does not involve misuse of a sensitive JavaScript function, as the concatenation is done via standard string operations and does not invoke any function that directly leads to code execution, injection, or dangerous side effects.}	"```var body = payload.stop + "" on route "" + payload.route + ""\nVehicle "" + payload.fleet; if (payload.hasOwnProperty('nearstop')) body += "" "" + payload.nearstop;```"
1270	transsee.ca.js	Cross-Site Request Forgery	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the direct use of untrusted payload parameters (payload.tag and payload.userid) in a fetch request to '/cancelnotestop' without any CSRF protection (e.g., tokens or origin validation). While fetch is a standard function, its misuse here is not due to inherent sensitivity of the function itself, but rather the lack of security controls around the request. Therefore, it is not classified as sensitive function misuse.}	```event.waitUntil(fetch('/cancelnotestop?id=' + payload.tag + '&user=' + payload.userid));```
1271	ytboob.live.js	Improper Input Validation in Message Handling	High	true	CWE-20	9	onMessage	standard	{The onMessage handler in the B class processes incoming messages from clients without validating or sanitizing the 'data' field. The data is directly used in postMessage calls to clients, which could allow an attacker to inject malicious payloads if the data is not properly validated. This can lead to cross-site scripting (XSS) or other client-side attacks if the data is rendered in the UI.}	N/A
1272	katalogmarzen.pl.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a remote URL. In this case, the URL is hardcoded to 'https://ga2.getresponse.com/wpn/gr_sw.js', which is not under the control of the site owner. While the URL is fixed, the lack of integrity checks (e.g., Subresource Integrity) means that if the remote script is compromised or modified, the service worker could execute malicious code. This constitutes a sensitive function misuse because importScripts() is inherently risky when used with external sources without verification.}	```importScripts(['https://ga2.getresponse.com/wpn/gr_sw.js']);```
1273	meteodays.com.js	External Dependency Import from Untrusted CDN	Medium	true	CWE-444	9	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted CDN (e.g., 'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js'), it introduces a potential supply chain risk. Although the URL is hardcoded and not dynamically constructed from untrusted input, the dependency on an external source (even if reputable) can be exploited if the CDN is compromised or if the library is maliciously updated. This constitutes a medium-severity vulnerability due to the potential for code injection via compromised dependencies.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js"")```"
1274	meteodays.com.js	Empty Fetch Event Handler	Low	false	New	N/A	N/A	N/A	N/A	"```self.addEventListener(""fetch"", function () {});```"
1275	allaguida.it.js	Server Side Request Forgery (SSRF	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.push_send_id and sensor_url), allowing an attacker to manipulate the URL to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.allaguida.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
1276	allaguida.it.js	Server Side Request Forgery (SSRF	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (event.notification.data.push_send_id and event.notification.data.sensor), allowing an attacker to manipulate the URL to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.allaguida.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click';```
1277	allaguida.it.js	Open Redirect	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is used with a URL derived from untrusted input (event.notification.data.url), allowing an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1278	bolia.com.js	Cache Poisoning Due to Weak Asset Matching	High	true	CWE-434	9	N/A	standard	{The function `includes()` is used to check if a request URL contains any of the cached assets. However, this approach is vulnerable to cache poisoning because it does not perform exact matching. For example, a request to `/fonts/evil.js` would match `/fonts/` and be cached, allowing an attacker to cache malicious assets under legitimate paths. This misuse of the standard `includes()` method enables unintended caching of arbitrary resources, leading to cache poisoning.}	```const matchFound = cacheAssets.some(cacheAsset => requestUrl.includes(cacheAsset));```
1279	topdealad.com.js	Improper Cache Validation	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from improper cache validation logic, specifically allowing only 200 status responses to be cached. This is not a result of misuse of a sensitive JavaScript function, but rather a configuration issue in the CacheableResponsePlugin. The plugin is correctly used with a standard status code filter, but the policy may be too permissive or insufficient for certain security contexts.}	```const a = new a.CacheableResponsePlugin({ statuses: [200] });```
1280	kenayhome.com.js	External Script Loading Without Validation	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it loads a script from a hardcoded URL (https://cdn.connectif.cloud/scripts/service-worker.js). While the URL is not dynamically constructed from untrusted input, the vulnerability arises because the script is loaded from an external source without validation or integrity checks. This allows an attacker who compromises the CDN or intercepts the request to inject malicious code. The misuse lies in trusting an external script without verifying its authenticity or integrity, which can lead to code injection and full compromise of the service worker.}	"```if (typeof importScripts === ""function"") { importScripts(""https://cdn.connectif.cloud/scripts/service-worker.js""); }```"
1281	relevanceads.com.js	Regular Expression Denial of Service (ReDoS	High	true	N/A	N/A	RegExp	standard	{The code constructs a RegExp from a JSON-parsed string that includes a pattern like 'relevanceads\\\\.com(?:/.*)?/ola/services/.*'. This pattern contains a non-greedy quantifier (?:/.*)? which can lead to catastrophic backtracking when matched against maliciously crafted input, causing ReDoS. The RegExp is used in a route matching context, and if the input URL is controlled by an attacker, it can trigger excessive CPU consumption.}	"```const c = JSON.parse('[""relevanceads\\\\.com(?:/.*)?/ola/services/.*"",""relevanceads\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://109b0002-5c3d-4c82-a4d8-acd59b96850d\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
1282	relevanceads.com.js	Improper Check for Unusual or Exceptional Conditions	Medium	false	N/A	N/A	N/A	N/A	{The code checks if 'body' in e, then attempts to construct a new Response from e.body. This is not a sensitive function misuse but rather a logic flaw in handling edge cases where the Response object might not support the 'body' property in all environments.}	```const a = new Response(''); if ('body' in e) try { new Response(e.body)```
1283	relevanceads.com.js	Breakage of Encapsulation	Medium	false	N/A	N/A	N/A	N/A	{The code attempts to construct a Response from e.body, which may expose internal implementation details or lead to unexpected behavior if e.body is not properly encapsulated. This is not a sensitive function misuse but a design flaw in object encapsulation.}	```const a = new Response(''); if ('body' in e) try { new Response(e.body)```
1284	betsure.com.js	Cache Key Collision Leading to Incorrect Content Serving	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the logic in `stripIgnoredUrlParameters`, which removes URL parameters matching a regex pattern (e.g., `utm_`). However, this function is not misused in a way that involves a sensitive JavaScript function like `importScripts`, `eval`, or `Function`. The issue is more about logic or design in how cache keys are generated, not direct misuse of a sensitive API.}	```var n = stripIgnoredUrlParameters(e.request.url, ignoreUrlParametersMatching);```
1285	spilnu.dk.js	Permissive Cache Allowlist Leading to Cache Poisoning	High	true	CWE-918	9	N/A	custom	{The vulnerability arises from the use of the custom class Q, which implements a permissive allowlist pattern for route matching. The constructor of Q accepts an allowlist (defaulting to [/./], which matches any string) and a denylist (defaulting to []). When instantiated with a permissive allowlist, it allows any URL path to be matched, enabling attackers to cache arbitrary responses for unintended routes. This is not directly caused by a sensitive function like importScripts or eval, but rather by the misuse of a custom routing logic class (Q) that lacks proper input validation or restrictive defaults, leading to cache poisoning. The code `const s = new Q(Y);` creates an instance with default allowlist, making it vulnerable.}	```const s = new Q(Y);```
1286	elli.eco.js	Improper Input Validation (Insecure Direct Object Reference)	Medium	false	CWE-20	N/A	N/A	N/A	{The code checks if the request URL includes any of the strings in the array `t`, but it does not validate or sanitize the URL itself. However, no sensitive JavaScript function (like `importScripts`, `eval`, `Function`, etc.) is being misused here. The vulnerability arises from logic that allows requests to be handled without proper validation, but it is not due to a sensitive function call.}	"```!function () { const e = self, t = [""faq-"", ""flexpole-support-training"", ""api/proxy/open/tariffs""]; e.addEventListener(""install"", t => { t.waitUntil(e.skipWaiting()); }), e.addEventListener(""activate"", t => { t.waitUntil(async function () { e.registration.navigationPreload && (await e.registration.navigationPreload.enable()); }()); }), e.addEventListener(""fetch"", e => { ""navigate"" === e.request.mode && e.preloadResponse && e.respondWith(async function () { if (!t.some(t => e.request.url.includes(t))) { const t = await e.preloadResponse; if (t) return t; } return fetch(e.request); }()); }); }();```"
1287	livingathome.de.js	Improper Input Validation	High	true	CWE-20	10	importScripts	standard	{The importScripts function is used with a dynamically constructed URL that includes workerGlobalScope.location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts into the service worker, leading to remote code execution and potential compromise of the entire service worker context.}	"```const workerGlobalScope = self;const env = /dev|local/.test(workerGlobalScope.location.host) ? ""dev"" : ""prod"";const webPushConfig = {  dev: """",  prod: """"};if (webPushConfig[env] && typeof workerGlobalScope.importScripts === ""function"") {  const channelId = webPushConfig[env];  workerGlobalScope.importScripts(`https://static.cleverpush.com/channel/worker/${channelId}.js${workerGlobalScope.location.search}`);}```"
1288	sorianoticias.com.js	Improper Validation of Dynamic Content	High	true	CWE-601	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL (https://sorianoticias.com/fb_config.js?r=5), which does not involve dynamic or user-controlled input. Therefore, while the vulnerability is labeled as 'Improper Validation of Dynamic Content', the actual usage here is safe and not sensitive. The vulnerability likely stems from a misclassification, as the URL is static and not derived from untrusted sources.}	```importScripts('https://sorianoticias.com/fb_config.js?r=5');```
1289	sorianoticias.com.js	Improper Input Validation	Medium	true	CWE-703	9	N/A	standard	{The clients.openWindow() function is a standard Service Worker API that opens a new browser window or tab with the provided URL. The parameter 'action_click' is derived from event.notification.data.click_action, which is user-controlled data from a push notification. If this data is not validated or sanitized, an attacker could inject a malicious URL, leading to phishing, redirection, or other client-side attacks. This constitutes improper input validation of untrusted data passed to a sensitive function.}	```event.waitUntil(clients.openWindow(action_click));```
1290	sorianoticias.com.js	Improper Neutralization of Special Elements used in an OS Command	Medium	true	CWE-78	8	N/A	standard	{The assignment var action_click = event.notification.data.click_action; retrieves a value from a notification payload, which is user-controlled. Although this is not an OS command in the traditional sense (as it's JavaScript in a browser context), the CWE-78 classification may be misapplied here. However, if the value is later used in a context where it could influence system behavior (e.g., via clients.openWindow), it could lead to unintended navigation or execution. The issue lies in the lack of sanitization of user-provided data before use in sensitive operations.}	```var action_click = event.notification.data.click_action;```
1291	fairwear.org.js	Information Exposure Through Error Messages	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from logging detailed error messages using console.error, which may expose sensitive information such as internal error details, stack traces, or context data to the console. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by poor error handling practices. The console.error function itself is not inherently sensitive in this context, as it does not execute arbitrary code or allow external input to influence execution flow.}	```console.error(ctx.error, 'Details:', ctx);```
1292	socportal.info.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static secret exposed in the source code, not a result of sensitive function misuse.}	```self[`appKey`] = `679d56be487118b1eed15c617bc9b774`;```
1293	socportal.info.js	Remote Code Execution via External Script	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it still represents a risk if the host is not fully trusted or if the script can be tampered with. However, since the host is hardcoded and not derived from untrusted input, the risk is lower than if it were dynamically sourced from user input. Nonetheless, the function itself is sensitive because it executes arbitrary code from a remote source, and its misuse (even with a hardcoded URL) can lead to RCE if the remote script is compromised.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1294	istqb.org.js	Insecure Dynamic Function Execution	High	true	CWE-78	9	N/A	standard	{The function MessageAPI[data.api]() dynamically invokes a method from the MessageAPI object based on user-controlled input from the URL path. Since the API name is derived from the pathname via params.match(/:(.+)/)[1], an attacker can craft a URL to trigger arbitrary method calls, potentially leading to unauthorized actions such as clearing cached resources or disabling offline shell functionality. This constitutes a dynamic function execution vulnerability.}	```MessageAPI[data.api]();```
1295	istqb.org.js	Open Redirect Vulnerability	High	true	CWE-601	9	N/A	standard	{The Response object is constructed with a Location header set to lastNavigationRequest, which is derived from the event.request.url. Since this value is directly taken from the incoming request without validation or sanitization, an attacker can manipulate the URL to redirect users to arbitrary domains, leading to open redirect attacks.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
1296	istqb.org.js	Server Side Request Forgery (SSRF)	Medium	true	CWE-918	8	N/A	standard	{The fetch(event.request) call is used without validating or sanitizing the request URL. Since event.request is derived from the incoming network request, an attacker can supply a malicious URL (e.g., internal IPs or other domains) to trigger SSRF, allowing the service worker to make unintended requests on behalf of the user.}	```return await fetch(event.request);```
1297	istqb.org.js	Improper Input Validation	Medium	true	CWE-20	7	N/A	standard	{The code parses URL parameters by splitting on `&` and `=` without validating or sanitizing the input. This can lead to unintended behavior, such as injecting malicious keys into the data object or causing unexpected execution flow, especially if the input contains malformed or malicious data.}	```params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; });```
1298	reve-islam.com.js	External Script Import Without Integrity Check	High	true	CWE-494	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is imported from a third-party CDN (cdn.pushmaster-cdn.xyz), which could be compromised or controlled by an attacker, leading to arbitrary code execution within the service worker context. This enables potential attacks such as cache manipulation, network request interception, or data exfiltration.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/61e44bf5c93c1b0009571e77/service-worker.js"");```"
1299	csswizardry.com.js	Cache Poisoning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of proper validation or sanitization of responses during fetch handling. The code does not use any sensitive functions like importScripts, eval, or dynamic code execution that would directly lead to cache poisoning. Instead, the issue arises from the design of the service worker's fetch handler, which may cache responses without sufficient validation, potentially allowing malicious content to be cached if the origin is compromised.}	```return fetch(event.request);```
1300	independenttribune.com.js	Incorrect Variable Reference Leading to Logic Flaw	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a variable reference error where `clientList` is used instead of `oList`, which leads to a logic flaw because the loop attempts to access an undefined or incorrect array. This is not caused by misuse of a sensitive function, but rather a simple programming error.}	```for (var i = 0; i < oList.length; i++) { var oClient = clientList[i]; if (oClient.url == oURL.toString() && 'focus' in oClient) { return oClient.focus(); } }```
1301	waldwissen.net.js	Deserialization of Untrusted Data	Medium	true	CWE-502	9	json	standard	{The `data.json()` method is used to deserialize a JSON payload received from a push notification, which may originate from an untrusted source. If the data is not validated or sanitized, it can lead to deserialization of untrusted data, potentially allowing an attacker to inject malicious payloads that could be executed in the context of the service worker.}	```const message = data.json();```
1302	waldwissen.net.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The `clients.openWindow(link)` function is called with a `link` value derived directly from the notification data, which is untrusted. This allows an attacker to craft a push notification with a malicious URL, causing the browser to open an arbitrary external site, leading to an open redirect vulnerability.}	```clients.openWindow(link);```
1303	vegnonveg.com.js	Untrusted External Script Execution	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('//cdnt.netcoresmartech.com/swv4.js'), which is not dynamically derived from untrusted input. However, the vulnerability arises because the script is loaded from an external, third-party domain (cdnt.netcoresmartech.com), which is not under the control of the application. This introduces a risk of supply chain compromise—if the external domain is compromised or the script is malicious, the service worker can be hijacked, leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. While the input is not dynamic, the use of an untrusted external source with importScripts() still constitutes a sensitive function misuse due to the inherent trust assumption required for script execution.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
1304	tahlilbazaar.com.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and points to an external domain (van.najva.com), which is outside the origin of the service worker. While the URL is not dynamically constructed from untrusted input, loading scripts from external domains introduces a high-risk dependency. If the external script is compromised or the domain is taken over, the service worker can be hijacked, leading to cache manipulation, network interception, or malicious code execution. This constitutes a sensitive function misuse due to the inherent trust required in the imported script.}	```importScripts('https://van.najva.com/static/js/scripts/tahlilbazaar198-website-14373-f4abaaf0-2f2a-44ee-a366-46caed09473a-service-worker.js');```
1305	vtmcollege.com.js	Open Redirect via Notification Click Handler	High	true	CWE-807	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from the notification payload, which is derived from user-controlled data (event.notification.data.url). Since this URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	N/A
1306	vtmcollege.com.js	Forced Service Worker Update via Malformed Payload	High	true	CWE-807	9	self.registration.update	standard	{The function self.registration.update is triggered based on a condition that compares the swVersion from the push payload with the current version. Since the payload is derived from untrusted data (event.data.json().data.swVersion), an attacker can manipulate this value to force an unintended service worker update, potentially leading to code execution or denial of service.}	N/A
1307	vtmcollege.com.js	Insecure URL Handling in getDomainAndHostname	Medium	true	CWE-807	8	new URL	standard	{The function new URL is used to parse a URL passed as input (url), which is not validated or sanitized. If the input is malicious (e.g., a URL with a malicious hostname or redirect), it can lead to unintended behavior such as DNS rebinding or open redirects, especially if the hostname is used in subsequent operations without further validation.}	N/A
1308	online-solitaire.com.js	Open Redirect via Untrusted URL Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using untrusted data (event.notification.data.url) to determine the redirect target, but no sensitive function like importScripts, eval, or dynamic code execution is involved. The risk is due to improper input validation, not misuse of a sensitive function.}	```const clickAction = event.notification.data.url || '/';```
1309	online-solitaire.com.js	Insecure Dynamic Data Handling in Notifications	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from directly using untrusted payload.data.title in notification content, which could lead to client-side injection if rendered in a context that interprets HTML or scripts. However, no sensitive JavaScript function (like eval, Function, or importScripts) is misused; the risk is due to improper sanitization, not function misuse.}	```const notificationTitle = payload.data.title || 'Daily challenge available';```
1310	chapintv.com.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is exposed in the source code but is not directly caused by misuse of a sensitive function. It is a static value assignment and does not involve dynamic or untrusted input processing.}	```self[`appKey`] = `6a57e92d68003389aa13eff76da827dc`;```
1311	chapintv.com.js	Remote Code Execution via External Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded value (self[`hostUrl`]), it still represents a risk if the hostUrl could be manipulated or if the script source is not fully trusted. However, in this case, the URL is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically constructed from user input. Nonetheless, loading external scripts from a remote source (even if hardcoded) can lead to RCE if the remote script is compromised or if the source is not properly secured.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1312	crichd.com.co.js	Untrusted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., https://www.push-services.com), it introduces a high-risk vulnerability because the script may be controlled by an attacker, leading to arbitrary code execution within the service worker context. This can result in data exfiltration, cache manipulation, or interception of network requests.}	"```importScripts(""https://www.push-services.com/integration/request/105982481/"");```"
1313	museum-digital.de.js	Improper Handling of Credentials in Caching	High	false	N/A	0	N/A	N/A	{The issue arises from the use of credentials: 'same-origin' in the Request constructor when caching resources. While this is not a direct misuse of a sensitive function, it is a configuration flaw that could lead to unintended credential exposure if the service worker caches cross-origin requests with credentials. However, since the URLs being cached are same-origin and the credentials mode is explicitly set to 'same-origin', this is not a sensitive function misuse but a misconfiguration.}	```var urlsToCache = ['css/md-de.css', '/logo/md-de-logo-32px.png', '/logo/md-de-logo-64px.png', '/logo/md-de-logo-128px.png'];```
1314	museum-digital.de.js	Cache Not Updated with New Responses	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from the fact that the service worker does not update the cache with new responses from the network. This is a logic flaw in the fetch handler, not a misuse of a sensitive function. The fetch() and caches.match() functions are used correctly, but the code does not implement a strategy to cache new responses.}	```return fetch(fetchRequest).then(function (response) { if (!response || response.status !== 200 || response.type !== 'basic') { return response; } var responseToCache = response.clone(); return response; }).catch(() => { console.log('Problem'); if (event.request.url.indexOf('index.php?') == -1) return; else { console.log('Fixing'); return caches.open(CACHE_NAME).then(function (cache) { return cache.match('index.php'); }); } });```
1315	miinto.no.js	Improper Authentication	High	false	N/A	N/A	N/A	N/A	{The reported vulnerability 'Improper Authentication' does not stem from the misuse of a sensitive JavaScript function such as importScripts, eval, or similar. Instead, it relates to the logic of handling navigation requests and fallback to offline content, which is a design or policy issue rather than a direct function misuse. The code does not expose authentication mechanisms or allow unauthorized access via dynamic input processing.}	```const navigationRoute = new workbox.routing.NavigationRoute(({ event }) => { const request = event.request; return htmlHandler.handle({ event, request }).catch(() => caches.match(OFFLINE_HTML, { ignoreSearch: true })); });```
1316	century21global.com.js	Use of Weak Cryptographic Algorithm	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of SHA-1, which is considered cryptographically weak and susceptible to collision attacks. However, this is not due to misuse of a sensitive JavaScript function, but rather the inherent weakness of the algorithm itself. The code correctly implements SHA-1 but should be replaced with a stronger algorithm like SHA-256.}	```const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8);```
1317	century21global.com.js	Insecure Randomness in Cache Busting	Medium	true	N/A	N/A	Math.random()	standard	{The function Math.random() is used to generate a cache-busting parameter, but it is not cryptographically secure and can be predictable. This allows an attacker to potentially guess the cache-busting value and manipulate cached responses, leading to cache poisoning or bypassing cache invalidation mechanisms.}	"```return url + (url.indexOf(""?"") === -1 ? ""?"" : ""&"") + ""ngsw-cache-bust="" + Math.random();```"
1318	century21global.com.js	Exposure of Debug Information	High	true	N/A	N/A	adapter.newResponse()	standard	{The adapter.newResponse() function is used to return detailed debug information (including version, state, idle tasks, and logs) to the client. This is a misuse because it exposes sensitive internal state and logs that could aid an attacker in understanding the service worker’s behavior and identifying potential attack vectors.}	"```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`, { headers: this.adapter.newHeaders({ ""Content-Type"": ""text/plain"" }) });```"
1319	century21global.com.js	Insecure Fetch Handling (SSRF Risk)	Medium	true	N/A	N/A	scope.fetch()	standard	{The scope.fetch() function is used without validating or sanitizing the request URL. This allows an attacker to potentially trigger requests to internal or external resources (e.g., via crafted URLs), leading to Server-Side Request Forgery (SSRF) if the service worker is running in a context where such requests are allowed.}	```return this.scope.fetch(req);```
1320	century21global.com.js	Improper Input Validation in Regex	Medium	true	N/A	N/A	new RegExp()	standard	{The new RegExp() function is used with user-controlled input (spec.regex) without proper sanitization or validation. This allows an attacker to inject malicious regex patterns that could lead to ReDoS (Regular Expression Denial of Service) or other unintended behavior, especially if the regex is used in performance-critical paths.}	```const regex = new RegExp(spec.regex);```
1321	leadingdigitalgovs.org.js	Exposure of Sensitive Information (Firebase API Key)	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded exposure of the Firebase API key in the code, not misuse of a sensitive function.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyBZViOCJuSgm-kAjkVnXXT1BR9Jme398Tg' } };```
1322	leadingdigitalgovs.org.js	Deserialization of Untrusted Data (Push Event Payload)	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used to deserialize data from a push event payload, which originates from an untrusted source (the server sending the push notification). If the payload contains maliciously crafted JSON, it could lead to unintended behavior or data corruption, especially if the parsed data is used without validation.}	```const payload = JSON.parse(event.data.json().data.notification);```
1323	leadingdigitalgovs.org.js	Open Redirect via Unvalidated URL (Notification Click)	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from the notification data, which is untrusted and potentially controlled by an attacker. Since the URL is not validated or sanitized, an attacker can craft a notification to redirect users to arbitrary websites, leading to phishing or malicious redirection.}	```clients.openWindow(targetUrl);```
1324	theirishroadtrip.com.js	Vulnerable Cache Key Construction	High	true	N/A	N/A	caches.open	standard	{The code uses caches.open() with a dynamically constructed cache name (version + 'trellisCache'), which may be influenced by external inputs or versioning logic. If the version string is derived from untrusted sources, it could lead to cache key collisions or unintended cache access, allowing an attacker to manipulate or bypass cache logic.}	```var trellisCache = version + 'trellisCache';```
1325	theirishroadtrip.com.js	Insecure Cache Busting	Medium	true	N/A	N/A	caches.open	standard	{The cache key generation relies on dynamic parameters (e.g., revision) that are not properly validated. When combined with caches.open(), this can lead to cache busting vulnerabilities where attackers can force cache regeneration or bypass cache validation by manipulating URL parameters or revision values.}	```const { cacheKeyWillBeUsed } = this._precacheController.getCacheKeyForURL(e.url);```
1326	theirishroadtrip.com.js	Insufficient Cache Validation	Medium	true	N/A	N/A	caches.match	standard	{The code uses caches.match() without validating the response status or headers, allowing potentially malicious or stale responses to be served. This can lead to cache poisoning or data leakage if the cache is populated with untrusted or tampered content.}	```return e.status >= 400 ? null : e```
1327	theirishroadtrip.com.js	Weak Cache Expiration	Low	false	N/A	N/A	N/A	N/A	{The cache expiration logic is based on a fixed time (e.g., 10080 minutes), which is not dynamically influenced by sensitive functions. While this may lead to stale data, it does not stem from misuse of a sensitive function.}	```const { statuses: [0```
1328	theirishroadtrip.com.js	Insecure Cache Deletion	Medium	true	N/A	N/A	caches.delete	standard	{The code uses caches.delete() with a cache name derived from a dynamic version string. If this version string is influenced by untrusted input, an attacker could delete unintended caches, leading to denial of service or data loss.}	```await caches.delete(e);```
1329	theirishroadtrip.com.js	Insecure Cache Key Generation	Medium	true	N/A	N/A	caches.open	standard	{The cache key is generated using dynamic URL parameters and revision values, which are then used with caches.open(). If these values are not sanitized, attackers can manipulate them to generate arbitrary cache keys, leading to cache poisoning or bypassing cache validation.}	```const { cacheKeyWillBeUsed } = this._precacheController.getCacheKeyForURL(e.url);```
1330	theirishroadtrip.com.js	Insecure Cache Key Construction	Medium	true	N/A	N/A	caches.open	standard	{The cache key is constructed using dynamic values (e.g., URL, revision) that are not properly validated before being used with caches.open(). This allows attackers to craft malicious cache keys that could lead to cache collisions or unauthorized cache access.}	```const { cacheKeyWillBeUsed } = this._precacheController.getCacheKeyForURL(e.url);```
1331	theirishroadtrip.com.js	Insecure Cache Key Generation	Medium	true	N/A	N/A	caches.open	standard	{The cache key generation process involves dynamic parameters that are not sanitized before being passed to caches.open(). This can allow attackers to inject arbitrary values into the cache key, leading to cache poisoning or bypassing cache validation mechanisms.}	```const { cacheKeyWillBeUsed } = this._precacheController.getCacheKeyForURL(e.url);```
1332	theirishroadtrip.com.js	Insecure Cache Key Construction	Medium	true	N/A	N/A	caches.open	standard	{The cache key is constructed using dynamic URL parameters and revision values, which are then used with caches.open(). If these values are not sanitized, attackers can manipulate them to generate arbitrary cache keys, leading to cache poisoning or bypassing cache validation.}	```const { cacheKeyWillBeUsed } = this._precacheController.getCacheKeyForURL(e.url);```
1333	theirishroadtrip.com.js	Insecure Cache Key Generation	Medium	true	N/A	N/A	caches.open	standard	{The cache key is generated using dynamic URL parameters and revision values, which are not properly validated before being used with caches.open(). This allows attackers to craft malicious cache keys that could lead to cache collisions or unauthorized cache access.}	```const { cacheKeyWillBeUsed } = this._precacheController.getCacheKeyForURL(e.url);```
1334	everythingzoomer.com.js	Insecure Cache Busting	Medium	false	CWE-319	N/A	N/A	N/A	{The vulnerability arises from the use of a cache busting parameter (`__uncache`) appended to URLs during asset fetching. While this is not directly caused by a sensitive JavaScript function like `importScripts()` or `eval()`, it introduces a security risk by allowing predictable cache invalidation patterns that could be exploited in cache poisoning or timing-based attacks. However, since no sensitive function is misused with untrusted input, this is not classified as a sensitive function vulnerability.}	```var o = n.bust```
1335	indian-tv.cz.js	Cache Poisoning via Unvalidated Cached Responses	High	true	CWE-444	10	caches.open	standard	{The caches.open() function is used to open a cache by its key, which is derived from a hardcoded value (assetsCacheKey). However, the vulnerability arises not from the function itself, but from the lack of validation when serving cached responses. The code serves any cached response without verifying its integrity or origin, which could allow an attacker to poison the cache via a prior malicious request (e.g., if the cache was populated with a tampered response). While caches.open() is not directly misused with untrusted input, the overall cache handling logic is flawed, and the function is central to the vulnerability's execution path.}	```if (event.request.method === 'GET' && (url.pathname.indexOf('/dist/') === 0 || url.pathname.indexOf('/uploads/emojis/') === 0)) { event.respondWith(async function () { const cache = await caches.open(assetsCacheKey); let response = await cache.match(event.request); if (response) { if (debug) console.log('ServiceWorker: Serving from cache', url.pathname); return response; } try { if (debug) console.log('ServiceWorker: Fetching', url.pathname); response = await fetch(event.request); await cache.put(event.request, response.clone()); return response; } catch (e) { if (debug) console.error('ServiceWorker: Fetch failed', e); if (response !== undefined) { return response; } } }()); }```
1336	prudential.com.vn.js	Insecure External Script Loading	High	true	CWE-929	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, it is used with a hardcoded external URL ('//cdnt.netcoresmartech.com/swv4.js'), which introduces a risk if the script source is not fully trusted or if the domain is compromised. While the URL is hardcoded and not dynamically constructed from untrusted input, the use of an external script in a service worker context is inherently risky because it can lead to code injection or execution of malicious scripts if the external source is compromised. This qualifies as sensitive function misuse due to the potential for remote code execution.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
1337	prudential.com.vn.js	Exposure of Sensitive Information	High	false	CWE-532	0	N/A	N/A	{The exposure of sensitive information (e.g., API keys, user keys, site IDs) is due to hardcoding these values in the script, not due to misuse of a sensitive JavaScript function. There is no function being misused to expose the data; it is simply stored in plain text within the code. Therefore, this vulnerability is not caused by sensitive function misuse.}	```var config = { apiKey: 'AIzaSyC9ECcfyl3VnQj7XadMs09CugeDlcm9CcE', messagingSenderId: '1093591369560', appId: '1:1093591369560:web:118afac14df743116e872d', projectId: 'pulselead-netcoresmartech-prod', user_key: 'ADGMOT35CHFLVDHBJNIG50K96BG9MQQALRQNNS79KODULCNC8TSG', siteid: '3ac4deebb6d8dd4fe6f79fb8c9edd9d4' };```
1338	lmc.cz.js	Improper Neutralization of Server-Side Request Forgery in Service Worker	Medium	false	N/A	N/A	N/A	N/A	{The code does not use any sensitive function that is misused with untrusted input. The fetch() call is made directly on event.request, which is a trusted request object from the service worker’s context. There is no dynamic construction of URLs from untrusted sources, so no SSRF vulnerability arises from sensitive function misuse.}	```self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request)); });```
1339	sikkom.nl.js	CORS Bypass via Request Modification	High	true	N/A	8	Request	standard	{The requestInterceptor modifies the request mode from 'no-cors' to 'no-cors' (which is redundant) and changes cache to 'default', but the critical issue is that it allows requests that were originally intended to be 'only-if-cached' and 'no-cors' to be reissued with 'default' cache, potentially bypassing CORS restrictions by allowing the browser to make cross-origin requests that would otherwise be blocked. This is a misuse of the Request constructor, which is a standard JavaScript API, to alter request behavior in a way that circumvents intended security policies.}	```const requestInterceptor = { requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') { return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' }); } return request; } };```
1340	aptelia.pl.js	Cache Poisoning via Untrusted 'refreshOffline' Event	High	true	CWE-918	N/A	self.addEventListener	standard	{The 'refreshOffline' event is not a standard browser event and is likely custom or user-defined. However, the code processes the 'response' parameter from this event without validation, and directly stores it into the cache using caches.put(). This allows an attacker to inject arbitrary responses into the cache if they can trigger the 'refreshOffline' event with malicious data, leading to cache poisoning. The vulnerability arises because the sensitive function caches.put() is used with untrusted input (the 'response' parameter), which can be manipulated by an attacker to serve malicious content to users.}	```self.addEventListener('refreshOffline', function (response) { return caches.open(cacheName.offlinePage).then(function (cache) { return cache.put(offlinePage, response); }); });```
1341	eroscripts.com.js	CSRF Vulnerability	High	true	N/A	9	fetch	standard	{The fetch function is used to send a POST request to a chat endpoint with user-provided data (`message=${e.reply}`) and a CSRF token. Although the token is fetched and included, the URL is constructed using `n` and `t`, which are derived from notification data. If an attacker can manipulate the notification data (e.g., via a crafted push message), they could trigger a request to a malicious endpoint or bypass CSRF protections if the token is not properly validated on the server. The dynamic construction of the URL and body from untrusted data makes this a sensitive misuse of fetch.}	```fetch(`${n}/chat/${t}.json`, { credentials: 'include', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-CSRF-Token': i }, body: `message=${e.reply}`, method: 'POST', mode: 'cors' });```
1342	vegis.ro.js	Untrusted External Script Import	Medium	true	CWE-444	9	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., cdn.segmentify.com), it introduces a medium-risk vulnerability because the script is loaded from an untrusted third-party source. Although the URL is hardcoded and not dynamically constructed from user input, the reliance on an external script introduces potential risks if the third-party service is compromised or changes its behavior, leading to unintended code execution or data leakage.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
1343	vegis.ro.js	Hardcoded Sensitive Data	Medium	false	CWE-798	N/A	N/A	N/A	{The updateRegistration function call contains a hardcoded UUID and domain, which may be considered sensitive data. However, this is not caused by misuse of a sensitive JavaScript function, as updateRegistration is not inherently dangerous or capable of introducing dynamic execution risks. The vulnerability arises from poor configuration practices rather than improper use of a sensitive function.}	```updateRegistration('fe6d6e15-0a4f-43a4-8b26-a7f3b40b460f', 'https://gimli-eu.segmentify.com/');```
1344	bcfc.com.js	Improper Input Validation in Cache Key Generation	High	true	N/A	N/A	new URL	standard	{The code uses new URL(e, location.href) to construct cache keys from user-supplied URLs without validating or sanitizing the input. This allows an attacker to inject arbitrary paths or query parameters, leading to cache key manipulation and potential cache poisoning.}	```const c = new URL(e, location.href);```
1345	bcfc.com.js	Cross-Site Cache Poisoning Risk	High	true	N/A	N/A	new Request	standard	{The code creates a Request object from a user-controlled URL (e.g., via U(c.request.url)) without validating the origin. This allows an attacker to craft requests to external domains, potentially leading to cache poisoning where malicious responses are stored under controlled cache keys.}	"```const a = new Request(t, { integrity: c, cache: n, credentials: ""same-origin"" });```"
1346	bcfc.com.js	Insecure Cache Busting Mechanism	Medium	true	N/A	N/A	new URL	standard	{The code uses new URL(e, location.href) to generate URLs with revision parameters, but does not validate the input. An attacker could manipulate the URL to bypass cache busting or inject unintended parameters, leading to inconsistent or insecure caching behavior.}	"```const s = new URL(n, location.href); s.searchParams.set(""__WB_REVISION__"", t);```"
1347	bcfc.com.js	Cache Key Collision Vulnerability	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability arises from logic that checks for conflicting cache keys, but it is not caused by misuse of a sensitive function. The issue is in the application logic, not in how a function is used.}	```if (this._urlsToCacheKeys.has(s) && this._urlsToCacheKeys.get(s) !== e) throw new l('add-to-cache-list-conflicting-entries', { firstEntry: this._urlsToCacheKeys.get(s), secondEntry: e });```
1348	bcfc.com.js	Unvalidated URL Parameter Handling	Medium	true	N/A	N/A	function (e, t = [])	standard	{The code uses a function that manipulates URL parameters by deleting keys matching regex patterns, but it does not validate the input URL or the regex patterns. This could allow an attacker to manipulate URL parameters in unexpected ways, potentially bypassing security checks or altering behavior.}	```const a = function (e, t = []) { for (const n of [...e.searchParams.keys()]) t.some(e => e.test(n)) && e.searchParams.delete(n); return e; }(c, t);```
1349	emedevents.com.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	```const firebaseConfig: { projectId: 'emedevents-31bdd', messagingSenderId: '469192764730', appId: '1:469192764730:web:af74dedc8b83261a92b403', apiKey: 'AIzaSyBws6uZgdcFgq2D-KOZNnrLV_OvN6oINc8' }```
1350	emedevents.com.js	Insecure Data Transmission of Push Subscription Keys	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from transmitting sensitive data over unencrypted channels, not from misuse of a sensitive function.}	```fetch(options.api_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) })```
1351	emedevents.com.js	Insecure Storage of Sensitive Data in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from insecure storage practices, not from misuse of a sensitive function.}	```const request = objectStore.put({ id: key, data: value });```
1352	emedevents.com.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with user-controlled data (targetUrl) derived from notification data, allowing an attacker to redirect users to arbitrary URLs, leading to open redirect.}	```clients.openWindow(targetUrl);```
1353	emedevents.com.js	SSRF via Unvalidated API URL in Notification Data	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used with user-controlled data (apiUrl) derived from notification data, allowing an attacker to perform SSRF by forcing the service worker to make requests to internal or unintended endpoints.}	```fetch(apiUrl);```
1354	bestline.net.js	Empty Fetch Event Handler	High	false	New	N/A	N/A	N/A	{The fetch event handler is empty, meaning it does not handle any incoming fetch requests. While this may not directly involve a sensitive function, it can lead to unintended behavior or security issues if the service worker is expected to intercept and manage requests but fails to do so. However, since no sensitive function is misused, this is not a sensitive vulnerability.}	```self.addEventListener('fetch', () => {});```
1355	bestline.net.js	Insecure URL Parameter Handling	Medium	true	CWE-601	N/A	template	standard	{The function `template` is used within `addParamsNative` to dynamically insert parameter values into URLs. If the input parameters are not sanitized and come from untrusted sources, an attacker could inject malicious values that alter the URL structure, potentially leading to open redirects or other URL-based attacks. The `template` function is standard JavaScript and is misused here due to lack of input validation.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); } )).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
1356	bestline.net.js	Unrestricted Cache Deletion	Medium	true	CWE-379	N/A	caches.delete	standard	{The `caches.delete` function is called without any validation on the `event.data.command` or the `SITE_PAGES_CACHE_NAME`. If an attacker can send a message to the service worker with a malicious command or if the cache name is dynamically derived from untrusted input, this could lead to unintended cache deletion. The function is a standard Web API and is misused here due to lack of input validation and authorization checks.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
1357	agupdate.com.js	Open Redirect via Untrusted URL Handling	Medium	true	CWE-601	8	N/A	standard	{The function `new URL()` is used to parse a URL provided in `oData.url`, which originates from a notification payload. Since this payload is controlled by the server sending the push message (and potentially by an attacker if the server is compromised), the URL can be manipulated to redirect users to arbitrary domains. Although `new URL()` itself is not inherently dangerous, its misuse here with untrusted input enables open redirect attacks, especially when the resulting URL is later used in `self.clients.openWindow()`.}	```let oURL = new URL(oData.url);```
1358	c77.com.js	Improper Input Validation in URL Exclusion Logic	High	true	N/A	9		standard	{The vulnerability arises from the use of `indexOf` to check for substring matches in `e.request.url` against a list of exclusions. This function is not inherently sensitive, but its misuse here—without proper sanitization or context-aware validation—allows attackers to bypass intended exclusions by crafting URLs that do not trigger the exclusion logic, leading to unintended resource fetching or cache bypass.}	```self.addEventListener('fetch', e => { for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
1359	c77.com.js	Flawed URL Processing Logic in Fetch Handler	High	true	N/A	9		standard	{The code uses `replace('https://', '')` and `indexOf('/')` to parse the URL, then checks for a dot in a substring. This flawed logic can be exploited by attackers to bypass the check by crafting URLs without dots in the first 60 characters after the protocol, leading to unintended resource fetching. The misuse of `replace` and `indexOf` for URL parsing without proper validation is the root cause.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
1360	c77.com.js	Insecure Handling of Notification Content	Medium	true	N/A	8	N/A	standard	{The `showNotification` function is used with unsanitized data from `data.notification.title`, `body`, `icon`, and `badge`. Since these values are directly taken from external push data without sanitization, an attacker can inject malicious content, potentially leading to cross-site scripting (XSS) or phishing via notification content.}	```const title = data.notification.title || ''; const options = { body: data.notification.body, icon: data.notification.image || '', badge: data.notification.image || '' }; event.waitUntil(self.registration.showNotification(title, options));```
1361	arboimoveis.com.br.js	Caching with excessive maxAgeSeconds leading to stale data exposure	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from setting a very high maxAgeSeconds (2592e3 seconds ≈ 30 days) in the ExpirationPlugin, which can lead to stale data being served from the cache. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a configuration issue in the caching strategy. No sensitive function is involved in this case.}	"```e.registerRoute(/(https:\/\/api.mapbox.com)/i, new e.CacheFirst({ cacheName: ""mapbox-images"", plugins: [new e.ExpirationPlugin({ maxEntries: 64, maxAgeSeconds: 2592e3 })] }), ""GET"");```"
1362	blockedservers.com.js	Improper Cache Control Handling	Low	false	New	N/A	N/A	N/A	{The code uses `caches.open` and `cache.add` with `cache: 'reload'` to ensure fresh content is fetched, but this is not inherently a sensitive function misuse. The `cache: 'reload'` directive is a legitimate cache control option and does not involve dynamic or untrusted input. The vulnerability is more about cache management policy than misuse of a sensitive function.}	```const cache = await caches.open(CACHE_NAME); await cache.add(new Request(OFFLINE_URL, { cache: 'reload' })); await cache.add(new Request(OFFLINE_FONT1, { cache: 'reload' }));```
1363	my.cg.js	Improper Handling of Non-Cloneable Response in Cache	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the assumption that the response object returned by fetch is always cloneable, which is not guaranteed. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic flaw in handling responses. The function fetch() is standard, but its misuse here is not classified as sensitive function misuse in the context of injection or execution risks.}	```self.addEventListener('fetch', function (event) { event.respondWith(async function () { try { var res = await fetch(event.request); var cache = await caches.open('cache'); cache.put(event.request.url, res.clone()); return res; } catch (error) { return caches.match(event.request); } }());});```
1364	colemanfurniture.com.js	Cache Expiration Misconfiguration	Low	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded or improperly configured expiration logic, not from misuse of a sensitive function. The code calculates expiration timestamps using `Date.now()` and `maxAgeSeconds`, but there is no dynamic or untrusted input involved that would trigger a security issue through a sensitive function.}	```const e = this._maxAgeSeconds ? Date.now() - 1e3 * this._maxAgeSeconds : 0```
1365	colemanfurniture.com.js	Cross-Origin Response Handling	Medium	true	N/A	N/A	importScripts	standard	{The code checks if the origin of a response matches `self.location.origin` before processing it. However, the `importScripts()` function is not used in this file, and the vulnerability is actually due to improper handling of cross-origin responses in the `p()` function, which uses `new Response()` with potentially untrusted data. The sensitive function responsible is `new Response()`, which can be misused to construct responses from untrusted data, leading to potential security issues if not properly sanitized.}	```if (n !== self.location.origin) throw new t('cross-origin-copy-response'```
1366	colemanfurniture.com.js	Insecure Cache Busting	Medium	true	N/A	N/A	new URL	standard	{The code uses `new URL(e, location.href)` to construct URLs for caching, where `e` is a dynamic input (e.g., from a precache list). If `e` contains malicious or untrusted data, this can lead to cache poisoning or unintended resource fetching. The `new URL()` function is sensitive because it can be used to construct arbitrary URLs from untrusted input, potentially leading to security issues if not properly validated.}	```const e = new URL(e, location.href)```
1367	colemanfurniture.com.js	Weak IndexedDB Security	Low	true	N/A	N/A	indexedDB.open	standard	"{The code uses `indexedDB.open(e, t)` where `e` is a dynamic cache name (e.g., `""workbox-expiration""`). If this cache name were derived from untrusted input, it could lead to unauthorized access or manipulation of IndexedDB databases. The `indexedDB.open()` function is sensitive because it allows opening databases with dynamically provided names, which can be exploited if the input is not properly sanitized.}"	```const e = indexedDB.open(e, t)```
1368	colemanfurniture.com.js	Unvalidated Cache Key Generation	Medium	true	N/A	N/A	new URL	standard	{The code generates cache keys using `new URL(e, location.href)` where `e` is a dynamic URL from the precache list. If `e` is not properly validated, it could lead to cache key collisions or unintended caching behavior. The `new URL()` function is sensitive because it can be used to construct URLs from untrusted input, potentially leading to cache poisoning or other security issues.}	```const e = new URL(e, location.href)```
1369	mdg.ca.js	Exposure of Sensitive Information in Firebase Configuration	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded Firebase configuration keys, not misuse of a sensitive JavaScript function.}	"```var config = { apiKey: ""AIzaSyCW1Hee4apNbFCwHNDAuD-Us3uiD_lqGM4"", authDomain: ""mdgpushnotification.firebaseapp.com"", databaseURL: ""https://mdgpushnotification.firebaseio.com"", projectId: ""mdgpushnotification"", storageBucket: ""mdgpushnotification.appspot.com"", messagingSenderId: ""739940043123"", appId: ""1:739940043123:web:c17e2132dbc8bd31"" };```"
1370	mdg.ca.js	Improper Neutralization of Input During Web Page Generation ('Cross-Site Scripting)	Medium	true	N/A	N/A	notificationOptions.body	standard	{The data.body value from the push event is directly assigned to notificationOptions.body without sanitization, allowing an attacker to inject malicious content that may be rendered in the notification UI, potentially leading to XSS if the notification UI interprets the content as HTML or JavaScript.}	```var notificationOptions = { body: data.body, icon: data.icon, image: data.image, requireInteraction: !0, tag: data.tag, badge: data.badge };```
1371	mdg.ca.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The redirectUrl, derived from the notification tag or event.action, is passed directly to clients.openWindow without validation or sanitization, allowing an attacker to craft a notification that redirects users to arbitrary external URLs, leading to open redirect vulnerabilities.}	```chatClient = clients.openWindow(redirectUrl);```
1372	mdg.ca.js	Improper Input Validation	Medium	true	N/A	N/A	event.data.json().data	standard	{The data from the push event is parsed using event.data.json().data without any validation or sanitization, making the service worker susceptible to malformed or malicious payloads that could lead to unexpected behavior or further exploitation.}	```var data = event.data.json().data;```
1373	diabetyk24.pl.js	Cache Poisoning via Dynamic Cache	High	true	CWE-352	9	caches.put	standard	{The caches.put() function is used to store a response in the cache, but it is called with a dynamically derived URL (t.request.url) without validation. If an attacker can manipulate the request URL (e.g., via a crafted fetch request), they can inject arbitrary resources into the cache, leading to cache poisoning. This allows an attacker to serve malicious content to users under the guise of legitimate resources.}	```e.sent.put(t.request.url, a.clone());```
1374	diabetyk24.pl.js	Insecure Error Handling in Fetch	Medium	false	CWE-200	0	N/A	N/A	{The console.error() call logs sensitive error details and the request object, which may expose internal application state or request details to the console. However, this is not caused by misuse of a sensitive function, as console.error() is not a function that directly enables external exploitation or data leakage beyond the developer console.}	```console.error(e.t0, t.request)```
1375	diabetyk24.pl.js	Caching of Non-GET Requests	Medium	false	CWE-502	0	N/A	N/A	{The fetch() function is used to retrieve resources, but the code does not validate the request method. While this could lead to unintended caching of non-GET requests, it is not due to misuse of a sensitive function. The fetch() API itself is not inherently sensitive in this context, and the issue stems from a lack of method validation rather than improper use of a sensitive function.}	```return e.next = 8, fetch(t.request);```
1376	thenec.co.uk.js	Open Redirect via Notification Tag	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL specified by the notification's tag, which is derived from untrusted input (data.url). Since the tag is directly passed to clients.openWindow without validation or sanitization, an attacker can craft a malicious notification payload that redirects the user to an arbitrary URL, leading to an open redirect vulnerability.}	```self.registration.showNotification(title, { body: data.message, tag: data.url, icon: 'https://d1p6efn5gbjkhi.cloudfront.net/media/5481/nec.jpg', image: data.image });```
1377	audioplayer.pe.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of arbitrary code from a remote source. In this case, the script is loaded from a third-party CDN (https://cdn.pushmaster-cdn.xyz), which could be compromised or controlled by an attacker, leading to code injection and potential full control over the service worker's behavior.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/642ee7dd906a720008ddfa65/service-worker.js"");```"
1378	howtodiscuss.com.js	Improper Input Validation Leading to XSS	High	true	CWE-79	N/A	fetch	standard	{The fetch function is used to send a POST request with a body constructed from user input `t.reply` without sanitization. Since `t.reply` comes from a notification action (which is user-controlled), an attacker could inject malicious scripts into the message body, leading to XSS when processed by the server or client-side.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
1379	howtodiscuss.com.js	Open Redirect via Unvalidated URL	Medium	true	CWE-602	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a URL constructed from `n + e`, where `e` is derived from the notification data.url, which is user-controlled. Since no validation or sanitization is performed on `e`, an attacker can craft a malicious URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```return clients.openWindow(n + e);```
1380	delinea.app.js	Missing 'await' in recursive call leading to potential race conditions	High	false	N/A	N/A	N/A	N/A	{The issue arises from a missing 'await' in a recursive call, which can lead to race conditions and incorrect state management. This is not caused by misuse of a sensitive function but by improper async/await handling.}	```if (response.status === '400' && !retry) { response = handleRefreshTokenEvent(request, true); }```
1381	delinea.app.js	No error handling in JSON parsing leading to unhandled exceptions	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the lack of error handling during JSON parsing, which can cause unhandled exceptions. This is not due to misuse of a sensitive function but rather a lack of robustness in error handling.}	```return responseClone.json().then(token => { accessToken = token?.Result?.access_token ?? accessToken; refreshToken = token?.Result?.refresh_token ?? refreshToken; expiresIn = token?.Result?.expires_in ?? expiresIn; sessionExpiresIn = token?.Result?.session_expires_in ?? sessionExpiresIn; idToken = token?.Result?.id_token ?? idToken; return response; });```
1382	delinea.app.js	Insecure token storage in memory without encryption	Medium	false	N/A	N/A	N/A	N/A	{The tokens are stored in memory without encryption, which is a security misconfiguration. This is not caused by misuse of a sensitive function but by insecure data storage practices.}	```let accessToken = null; let refreshToken = null; let idToken = null;```
1383	delinea.app.js	Exposure of sensitive tokens in response headers	High	true	N/A	N/A	Headers.set	standard	{The 'Authorization' header is set with a Bearer token in the response, which can expose sensitive tokens if intercepted. The Headers.set() method is a standard API, and its misuse here involves including sensitive data in response headers without proper protection.}	```headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` }```
1384	delinea.app.js	Insufficient URL validation for authentication bypass	Medium	false	N/A	N/A	N/A	N/A	{The URL validation logic is flawed and may allow bypassing authentication checks. This is not due to misuse of a sensitive function but due to insufficient logic in the isValidUrlForAuth function.}	```const isAllowedUrl = (url.protocol === 'http:' && isLocalHost() || url.protocol === 'https:') && (url.pathname?.includes('/api') || url.pathname?.includes('/internal') || url.pathname?.includes('/odata')) && !IGNORED_AUTH_PATHS.find(path => url.pathname?.startsWith(path)) && !ignoreAuth;```
1385	xpanded.com.js	Logic Error in Token Comparison	High	true	CWE-670	9	N/A	standard	{The comparison `if (oldToken == null || oldToken == token) return;` is logically flawed because `oldToken` is assigned from `PNDB.addToken(token)`, which returns `null` if no existing token is found. However, the code does not handle the case where `oldToken` might be undefined or improperly assigned, leading to incorrect logic flow and potential failure to update subscription data. This misuse of conditional logic with potentially undefined values introduces a logic error.}	```if (oldToken == null || oldToken == token) return;```
1386	xpanded.com.js	URL Redirection Without Validation	High	true	CWE-601	10	N/A	standard	{The `clients.openWindow(url)` function is called with `url` derived directly from `event.notification.data.url`, which originates from untrusted server data. Since no validation or sanitization is performed on `url`, an attacker could inject a malicious URL, leading to open redirect attacks or phishing. This is a direct misuse of the standard `clients.openWindow` API with untrusted input.}	```if (clients.openWindow) { return clients.openWindow(url); }```
1387	xpanded.com.js	Potential XSS in Notification Data	High	true	CWE-79	9	N/A	standard	{The `title` and `body` values from `data.data.title` and `data.data.body` are directly used in `self.registration.showNotification(title, notificationOptions)`. Since these values come from server responses and are not sanitized, an attacker could inject malicious scripts or HTML content, which may be rendered in the notification UI, leading to potential XSS if the browser renders HTML in notifications. This is a misuse of the standard `showNotification` API with untrusted input.}	```var title = data.data.title; var notificationOptions = { body: data.data.body, icon: data.data.icon, tag: data.data.tag, data: { url: data.data.url } };```
1388	xpanded.com.js	Improper Error Handling in IndexedDB	Low	false	CWE-754	5	N/A	standard	{The code attempts to create an object store with `db.createObjectStore(PNDB.Settings.dbObjectStore, { autoIncrement: true });`, but does not handle the case where the object store already exists or where the database version is not properly managed. While this is a misuse of IndexedDB API, it does not directly involve a sensitive function that leads to security vulnerabilities like injection or data leakage. The issue is more about robustness than security.}	```var objectStore = db.createObjectStore(PNDB.Settings.dbObjectStore, { autoIncrement: true });```
1389	thefederal.com.js	Subresource Integrity (SRI) Not Enforced for Third-Party Script	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from loading a third-party script via importScripts() without enforcing Subresource Integrity (SRI). While importScripts() is a sensitive function, the issue here is not due to dynamic or untrusted input being passed to it, but rather the absence of integrity verification for the script. Since the URL is hardcoded and not derived from user input or dynamic sources, it does not constitute a sensitive function misuse in the context of injection or execution of arbitrary code.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/07e2700b03cc7937ad27c1d0d6143720390cbea0.js"");```"
1390	downzen.com.js	Cache Poisoning via Untrusted Message Handling	High	true	CWE-918	N/A	self.addEventListener('message', event => { if (typeof event.data === 'object' && typeof event.data.action === 'string') { switch (event.data.action) { case 'cache': precacheUrl(event.data.url); break; default: console.log('Unknown action: ' + event.data.action); break; } } });	standard	{The service worker listens for messages and, upon receiving a 'cache' action, calls precacheUrl with the URL from the message data. Since the URL is directly sourced from untrusted client input (event.data.url), and precacheUrl subsequently fetches and caches this URL without validation or sanitization, an attacker can supply arbitrary URLs to be cached. This allows cache poisoning, where malicious content can be stored in the cache and served to users, potentially leading to code injection or data exfiltration. The vulnerability stems from the misuse of the standard event handling mechanism (self.addEventListener) in conjunction with untrusted input.}	```self.addEventListener('message', event => { if (typeof event.data === 'object' && typeof event.data.action === 'string') { switch (event.data.action) { case 'cache': precacheUrl(event.data.url); break; default: console.log('Unknown action: ' + event.data.action); break; } } });```
1391	salue.de.js	Cache Poisoning via Incomplete Request Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from incomplete validation of fetch event requests, particularly failing to handle cases where the request mode is not 'same-origin' and cache mode is 'only-if-cached'. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in request handling. No sensitive function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', function (event) { let request = event.request; if (event.request.cache === 'only-if-cached' && event.request.mode !== 'same-origin') return; });```
1392	pooltracker.com.js	Vulnerable Cache.addAll Usage	High	true	CWE-929	10	caches.addAll	standard	{The caches.addAll() function is used to add multiple resources to a cache. In this case, the URLs in CACHE_STATIC are hardcoded and trusted, so there is no direct sensitive function misuse. However, the vulnerability arises from the fact that these external resources are cached without validation or integrity checks, which could allow an attacker to compromise the CDN or inject malicious content. Since the function itself is not misused with dynamic or untrusted input, this is not a sensitive function misuse in the strict sense. Therefore, the vulnerability is not caused by sensitive function misuse.}	```const CACHE_STATIC = ['https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css', 'https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap-theme.min.css', 'https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js', 'https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js', 'https://cdnjs.cloudflare.com/ajax/libs/mustache.js/2.3.0/mustache.min.js', 'https://cdnjs.cloudflare.com/ajax/libs/localforage/1.7.3/localforage.min.js'];```
1393	pooltracker.com.js	Insecure Fetch Handling	High	true	CWE-434	10	fetch	standard	{The fetch() function is used without any validation or sanitization of the request. Since the request is derived from event.request, which can be manipulated by an attacker (e.g., via a crafted URL or network interception), this allows for potential cache poisoning or unintended resource fetching. The function is standard and its misuse here stems from not verifying the origin or integrity of the request, making it a sensitive function misuse.}	```event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); }));```
1394	stnicholascenter.org.js	Improper Error Handling in Service Worker Installation Leading to Denial of Service	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling during the installation phase, where the error callback in the `then(error => { console.log(error); })` does not prevent the service worker from continuing to install or handle errors gracefully. However, this is not due to misuse of a sensitive function like `importScripts`, `eval`, or `fetch` with untrusted input. The code does not dynamically construct URLs or invoke functions with user-controlled data. The issue is purely a logic or design flaw in error handling, not a sensitive function misuse.}	```return staticCache.addAll(['/assets/css/stylesheet.2024-11-07T21:57:12-05:00.css', '/assets/images/logo-responsive.svg', '/glossary/ajax.2024-11-07T21:57:12-05:00.json']).then(error => { console.log(error); });```
1395	remysharp.com.js	Cache Poisoning via Unvalidated Client URLs	High	true	CWE-918	10	clients.matchAll	standard	{The function clients.matchAll is used to retrieve all client pages, including uncontrolled ones (via includeUncontrolled: true). The URLs from these clients are then added directly to the postsCache without validation or sanitization. This allows an attacker to inject arbitrary URLs into the cache, potentially leading to cache poisoning where malicious content is served to users. The sensitive function clients.matchAll is a standard Service Worker API that, when misused with untrusted input, enables this vulnerability.}	```const allClients = await clients.matchAll({ includeUncontrolled: true }); for (const client of allClients) { posts.push(client.url); console.log('adding %s', client.url); }```
1396	fplgameweek.com.js	Improper Error Handling Leading to Offline Page Forced Display	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the logic that forces the offline page to be returned whenever a fetch fails, regardless of the nature of the error. This is not due to misuse of a sensitive function, but rather a design choice that may lead to poor user experience or hiding of legitimate errors. No sensitive function is being misused here.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
1397	makaan.com.js	Insecure Dynamic Script Loading	Medium	true	N/A	7	importScripts	standard	{The importScripts() function is used to load and execute external scripts in a service worker. Although the URL in this case is hardcoded ('https://cdn.onesignal.com/sdks/OneSignalSDK.js'), the vulnerability is flagged due to dynamic control flow based on the 'connection' variable. However, since the URL is not derived from untrusted or user-controlled input, this is not a true sensitive function misuse. The original detection may be overly broad.}	"```if (connection == ""fast"") { importScripts('https://cdn.onesignal.com/sdks/OneSignalSDK.js'); }```"
1398	wedevs.com.js	Code Injection	High	true	CWE-94	10	new (getProp(workbox, p.use))	standard	"{The code dynamically constructs and invokes a function using `new (getProp(workbox, p.use))(...p.config)`, where `p.use` is derived from user-controlled or untrusted configuration data. This allows an attacker to specify arbitrary function names (e.g., `p.use = ""evilFunction""`) that may not be intended for execution, leading to code injection. Since `getProp` resolves nested properties via string-based path traversal, it can be exploited to invoke unintended or malicious functions within the Workbox or global scope, especially if `p.use` is not validated or sanitized. This is a classic case of unsafe dynamic function invocation.}"	```const plugins = (entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config));```
1399	kazlenta.kz.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static secret embedded in the code, not a result of sensitive function misuse.}	```self[`appKey`] = `ece88c15aae4f22eb63053551989c197`;```
1400	kazlenta.kz.js	Remote Code Execution via External Script	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a variable (self[`hostUrl`]), and that variable is not validated or sanitized, it allows an attacker to control the script source. In this case, if hostUrl is ever modified or overridden (e.g., via a malicious update or injection), the service worker could load and execute arbitrary code from an attacker-controlled domain, leading to remote code execution.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1401	boomlive.in.js	Vulnerable External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is used to load and execute an external script from a hardcoded URL (https://cdn.izooto.com/scripts/workers/809f316fe140e7b71963474ae59921485b323a1f.js). While the URL is not dynamically constructed from untrusted input, the script is loaded from an external, third-party domain, which introduces a high-risk dependency. If the external script is compromised or modified, it can execute arbitrary code within the service worker context, leading to potential cache manipulation, network interception, or data exfiltration. This constitutes a sensitive function misuse because importScripts() is inherently dangerous when used with any external source, especially without integrity verification.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/809f316fe140e7b71963474ae59921485b323a1f.js"");```"
1402	boomlive.in.js	Insufficient Request Validation	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability described as 'Insufficient Request Validation' is not caused by misuse of a sensitive function. The code handles fetch events by attempting to use preloadResponse or falling back to network fetch, and then to cached offline content if an error occurs. This is a standard and safe pattern for service workers. There is no direct use of a sensitive function like eval, importScripts, or unsafe dynamic code execution. The issue may stem from a lack of validation of request URLs or origins, but no sensitive function is being misused in the provided snippet.}	```event.respondWith((async () => { try { const preloadResponse = await event.preloadResponse; if (preloadResponse) { return preloadResponse; } const networkResponse = await fetch(event.request); return networkResponse; } catch (error) { const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match('/offline'); return cachedResponse; } })());```
1403	matrixcalc.org.js	Information Exposure via Error Reporting	Medium	true	CWE-200	9	fetch	standard	{The fetch function is used to send error data, including potentially sensitive stack traces and file paths, to a remote server (https://matrixcalc.org/jserrors.php?error=1). Although the data is not directly influenced by user input, the exposure of detailed error information (especially stack traces) can reveal internal implementation details, aiding attackers in crafting targeted exploits. The misuse lies in the lack of sanitization or filtering of error data before transmission, making it a sensitive function misuse due to improper handling of potentially sensitive data.}	```self.onerror = function (message, filename, lineno, colno, error) { const stack = error != undefined ? error.stack || '' : ''; const data = stringify({ messag: message || '', filename: filename || '', lineno: lineno || 0, colno: colno || 0, stack: stack }); if (sent[data] == undefined) { sent[data] = data; fetch('https://matrixcalc.org/jserrors.php?error=1', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: data }); } };```
1404	musicsfarsi.com.js	External Script Import Without Validation	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, if the URL were derived from untrusted or unsanitized input (e.g., from user-controlled parameters), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not dynamically constructed from user input, so the vulnerability is not due to sensitive function misuse but rather due to the lack of validation or monitoring of external script sources. Therefore, while importScripts() is a sensitive function, its misuse is not evident here.}	```importScripts('https://scriptapi.adwisedfs.com/api/webpush/sw/9c43b121-d538-44f7-9dc8-961fc92c5487.js');```
1405	lancarwd.com.js	Insecure Dynamic Configuration	High	true	CWE-20	10	N/A	standard	{The vulnerability arises from the use of `event.data` to dynamically configure routing rules in `toolbox.router.get()`. While `toolbox.router.get()` itself is not inherently sensitive, the dynamic construction of route patterns and origin values from untrusted `event.data` (which could be manipulated by an attacker via a message event) allows for arbitrary configuration changes. This can lead to unintended caching or network behavior, potentially enabling cache poisoning or bypassing security controls. The root cause is the unsafe use of dynamic input in a configuration context, which is a form of sensitive function misuse when the function is used with untrusted data.}	```(global => {  importScripts('sw-toolbox.js');  global.addEventListener('install', event => event.waitUntil(global.skipWaiting()));  global.addEventListener('activate', event => event.waitUntil(global.clients.claim()));  global.addEventListener('message', event => {    setup(event);    global.skipWaiting();  });  toolbox.router.get('/.*(mp4|ogg)$/', toolbox.networkOnly);  function setup(event) {    const domains = event.data;    var cmsRequestRegExp = /http(s):\/\/.+service\/cmsApi\/GetContent.+/;    toolbox.router.get(cmsRequestRegExp, toolbox.fastest, {      cache: {        name: 'cms',        maxEntries: 100,        maxAgeSeconds: 300      },      origin: domains.star    });    toolbox.router.get('/cdn(.*)', toolbox.cacheFirst, {      cache: {        name: 'contents',        maxEntries: 100,        maxAgeSeconds: 600      },      origin: domains.cdn    });    toolbox.router.get('/contents(.*)', toolbox.cacheFirst, {      cache: {        name: 'multi-cdn',        maxEntries: 100,        maxAgeSeconds: 600      },      origin: domains.cdn    });  }})(self);```
1406	forum-auto.com.js	Incorrect determination of user login state leading to potential CSRF bypass	High	false	New	N/A	N/A	N/A	{The vulnerability arises from improperly parsing the `loggedIn` parameter from the URL using a regex match, which can be manipulated by an attacker to bypass CSRF protections. This is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in state determination.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
1407	forum-auto.com.js	Unvalidated 'id' parameter in fetch URL leading to SSRF risk	Medium	true	CWE-918	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `id` parameter from untrusted push notification data. Since the `id` is not validated or sanitized, an attacker can supply a malicious URL (e.g., internal IP addresses or other services) to trigger SSRF, allowing the service worker to make unauthorized requests on behalf of the user.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1408	forum-auto.com.js	Unvalidated 'data.url' in notification click handler leading to open redirect	Medium	true	CWE-601	N/A	navigate	standard	{The `navigate` method is used with the `data.url` value from the notification payload, which is derived from server responses and not validated. This allows an attacker to craft a notification with a malicious URL, redirecting the user to an arbitrary site, potentially leading to phishing or credential theft.}	```clients[0].navigate(data.url);```
1409	6z.game.js	Case-Sensitive URL Exclusion Bypass	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from case-sensitive string matching using indexOf(), which does not account for variations in case (e.g., 'Cloudflare' vs 'cloudflare'). This is not due to misuse of a sensitive function, but rather a logic flaw in string comparison.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
1410	6z.game.js	Flawed URL Path Validation Logic	High	false	New	N/A	N/A	N/A	{The vulnerability stems from flawed logic in validating URL paths using string slicing and indexOf() on a modified URL. This is not caused by misuse of a sensitive function, but rather by an insecure and incomplete validation approach that can be bypassed with crafted URLs.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
1411	bcharts.com.br.js	Improper Input Validation	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a dynamically constructed body parameter `message=${t.reply}`, where `t.reply` is user-provided input from a notification action. This allows an attacker to inject arbitrary data into the POST request body, potentially leading to unintended server-side behavior, such as command injection or data manipulation, if the server does not properly validate or sanitize the input.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
1412	bcharts.com.br.js	Open Redirect	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a dynamically constructed URL `n + e`, where `e` is derived from the notification data.url, which is user-controlled. This allows an attacker to craft a malicious URL in the push notification payload, causing the browser to redirect users to arbitrary external sites, potentially leading to phishing or malware distribution.}	```clients.openWindow(n + e);```
1413	clic.com.br.js	Insecure External Script Import (Missing SRI	High	false	N/A	N/A	N/A	N/A	{The importScripts calls use hardcoded, trusted URLs and do not involve dynamic or user-controlled input. While the lack of Subresource Integrity (SRI) is a security concern, it does not stem from misuse of a sensitive function with untrusted input.}	```importScripts('https://www.clicrbs.com.br/sw.js');```
1414	clic.com.br.js	Insecure External Script Import (Missing SRI	High	false	N/A	N/A	N/A	N/A	{The importScripts calls use hardcoded, trusted URLs and do not involve dynamic or user-controlled input. While the lack of Subresource Integrity (SRI) is a security concern, it does not stem from misuse of a sensitive function with untrusted input.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
1415	frenchcrown.in.js	Open Redirect via Unvalidated URL in Service Worker	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used with a URL derived from event.notification.data.actions[0].link, which is user-controlled and unvalidated. This allows an attacker to redirect the user to an arbitrary URL, leading to an open redirect vulnerability.}	```const redirectUrl = event.notification.data ? event.notification.data.actions[0].link : null; if (clients.openWindow) { return clients.openWindow(redirectUrl); }```
1416	frenchcrown.in.js	Improper Input Validation in Push Event Payload	High	true	CWE-20	9	JSON.parse	standard	{The function JSON.parse is used on event.data.text(), which is untrusted input from a push event. While JSON.parse itself is not inherently dangerous, the lack of input validation on the parsed payload can lead to improper handling, potentially allowing malicious payloads to be processed and used in subsequent operations, such as notifications or data transmission.}	```let payload = event.data ? JSON.parse(event.data.text()) : {};```
1417	frenchcrown.in.js	Potential XSS via Unsanitized Notification Data	Medium	true	CWE-79	8	client.postMessage	standard	{The function client.postMessage sends event.notification.data directly to clients without sanitization. If the notification data contains malicious scripts or HTML, and if the receiving client interprets it as executable code (e.g., via eval or innerHTML), this could lead to XSS.}	```client.postMessage({ notificationClicked: true, payload: event.notification.data });```
1418	furuke.com.js	Exposure of Sensitive Information (Firebase API Key in Client-Side Code)	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by hardcoding sensitive credentials (Firebase API key) in client-side code, which can be accessed by anyone inspecting the source.}	```(() => { importScripts('https://www.gstatic.com/firebasejs/8.6.1/firebase-app.js'), importScripts('https://www.gstatic.com/firebasejs/8.6.1/firebase-messaging.js'); var e = 2021092100001, i = { prefetch: 'prefetch-cache-v1-' + e, fetch: 'fetch-cache-v1-' + e }; (self.addEventListener('install', function (e) { self.skipWaiting(); }), firebase.initializeApp({ apiKey: 'AIzaSyB0kOXu1_TazMRPA4VosfjfQaMTnVAGiuM', authDomain: 'furuke-firebase.firebaseapp.com', projectId: 'furuke-firebase', storageBucket: 'furuke-firebase.appspot.com', messagingSenderId: '1068522822205', appId: '1:1068522822205:web:44dea80dd6416895daa854', measurementId: 'G-RZHD7ZK542' }), firebase.messaging.isSupported()) && (self.addEventListener('notificationclick', function (e) { var i, n = null === (i = e.notification) || void 0 === i || null === (i = i.data) || void 0 === i || null === (i = i.FCM_MSG) || void 0 === i || null === (i = i.notification) || void 0 === i || null === (i = i.data) || void 0 === i ? void 0 : i.link; if (n) { var t = new URL(n, self.location.origin).href, a = clients.matchAll({ type: 'window', includeUncontrolled: !0 }).then(function (e) { for (var i = null, n = 0; n < e.length; n++) { var a = e[n]; if (a.url === t) { i = a; break; } } return i ? i.focus() : clients.openWindow(t); }); e.waitUntil(a); } }), firebase.messaging().onBackgroundMessage(function (e) {})); })();```
1419	furuke.com.js	Open Redirect via Notification Data	Medium	true	N/A	9	new URL	standard	{The new URL constructor is used with user-controlled data from the notification payload (i.e., the 'link' field). If an attacker can manipulate this data, they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities. The function is standard and directly responsible for the vulnerability due to unsanitized input.}	```if (n) { var t = new URL(n, self.location.origin).href, a = clients.matchAll({ type: 'window', includeUncontrolled: !0 }).then(function (e) { for (var i = null, n = 0; n < e.length; n++) { var a = e[n]; if (a.url === t) { i = a; break; } } return i ? i.focus() : clients.openWindow(t); }); e.waitUntil(a); }```
1420	gentstudent.app.js	Uncontrolled Resource Consumption (Infinite Navigation Loop)	High	true	CWE-400	10	tab.navigate	standard	{The function tab.navigate() is a standard browser API used to navigate a client window to a specified URL. In this case, it is called with tab.url, which is the current URL of the client. This creates an infinite loop where each tab continuously reloads itself, consuming excessive resources and potentially crashing the browser. The misuse lies in the lack of control over the navigation target, which is derived from the client's own URL without any checks or limits.}	```const tabs = await self.clients.matchAll({ type: 'window' }); tabs.forEach(tab => { tab.navigate(tab.url); });```
1421	jj789.com.js	Flawed URL Parsing Leading to Cache Poisoning	High	true	New	N/A	replace	standard	{The use of `replace('https://', '')` on the request URL without proper validation or sanitization allows an attacker to manipulate the URL structure. This can lead to unintended cache key generation, enabling cache poisoning where malicious content is cached under a legitimate key, potentially serving it to users. The function is misused because it alters the URL in a way that bypasses intended security checks, especially when combined with `slice` and `indexOf` for path validation.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
1422	jj789.com.js	Case-Sensitive Exclusion Check Bypass	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a case-sensitive string comparison using `indexOf`, which does not account for variations in case (e.g., 'Cloudflare' vs 'cloudflare'). This is not due to misuse of a sensitive function, but rather a logic flaw in the exclusion logic. No sensitive function is involved in this case.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
1423	mrfortune.com.js	Insecure External Script Loading	Medium	false	CWE-444	N/A	N/A	N/A	{The use of importScripts with a hardcoded external URL does not constitute sensitive function misuse because the URL is not derived from untrusted or dynamic input. While loading external scripts can pose risks, the vulnerability here is not due to dynamic input injection but rather the general risk of trusting third-party scripts.}	```importScripts('ngsw-worker.js');importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
1424	rastreae.com.br.js	Server Side Request Forgery (SSRF)	Medium	true	CWE-918	9	fetch	standard	{The function `fetchFromNetwork` recursively follows redirects by calling `this.adapter.newRequest(res.url)` and then `this.scope.fetch(req)`. If the initial request is crafted to redirect to an internal or external resource (e.g., via a malicious URL in `req.url`), the service worker will blindly follow it, potentially allowing an attacker to perform SSRF attacks against internal systems or external endpoints. The `fetch` function is standard and can be misused when the URL is derived from untrusted input.}	```fetchFromNetwork(req, redirectLimit = 3) { return __awaiter(this, void 0, void 0, function* () { const res = yield this.cacheBustedFetchFromNetwork(req); if (res['redirected'] && !!res.url) { if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`); } return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1); } return res; }); }```
1425	renovatuvestidor.com.js	Outdated Library Usage	Medium	false	CWE-426	N/A	N/A	N/A	{The vulnerability is due to the use of outdated versions of Firebase libraries (5.9.4), which may contain known security flaws or lack support for modern security features. However, this is not caused by misuse of a sensitive JavaScript function, as the importScripts calls are using hardcoded, trusted URLs and not dynamic or untrusted inputs.}	"```importScripts(""https://www.gstatic.com/firebasejs/5.9.4/firebase-app.js""), importScripts(""https://www.gstatic.com/firebasejs/5.9.4/firebase-messaging.js"")```"
1426	starbet.com.lr.js	Improper Handling of 403 Status Leading to Page Reload	High	true	CWE-400	8	self.addEventListener	standard	{The self.addEventListener function is used to register a fetch event handler that responds to 403 Forbidden responses by triggering a page reload via postMessage to all clients. This is a misuse because it exposes the service worker to unintended behavior when handling HTTP 403 errors, potentially leading to denial of service or user confusion, especially if the 403 is due to legitimate access restrictions. The function is standard but its use here is sensitive due to the broad impact of forcing page reloads on error conditions.}	"```self.addEventListener(""fetch"", t => { -1 !== t.request.url.indexOf(""icomoon"") && t.respondWith(fetch(t.request).then(e => (403 === e.status && self.clients.matchAll().then(e => { e.forEach(e => { setTimeout(() => { e.postMessage({ action: ""page-reload"" } ); }); }); }), e)).catch(e => caches.match(t.request))); });```"
1427	studio24.bg.js	Open Redirect via Notification Click Action	High	true	CWE-601	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used with a URL derived from notificationData.click_action, which is sourced from untrusted external push notification data. This allows an attacker to craft a push notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect and potential phishing or malware delivery.}	N/A
1428	studio24.bg.js	Insecure API Call with Credentials	Medium	false	N/A	0	N/A	N/A	{The fetch call includes credentials: 'include', but the URL is hardcoded and not dynamically constructed from untrusted input. While this exposes session cookies or authentication tokens, it is not caused by misuse of a sensitive function with dynamic input.}	N/A
1429	studio24.bg.js	Unverified External Script Imports	Medium	true	CWE-496	10	importScripts	standard	{The importScripts function is used to load external scripts from hardcoded URLs. Although the URLs are fixed, the function itself is sensitive because it executes arbitrary JavaScript code from remote sources. If these URLs were dynamically constructed from untrusted input, it would be a severe risk. However, since they are hardcoded, the risk is lower but still present due to potential compromise of the CDN or supply chain.}	N/A
1430	studio24.bg.js	Unverified External Script Imports	Medium	true	CWE-496	10	importScripts	standard	{The importScripts function is used to load external scripts from hardcoded URLs. Although the URLs are fixed, the function itself is sensitive because it executes arbitrary JavaScript code from remote sources. If these URLs were dynamically constructed from untrusted input, it would be a severe risk. However, since they are hardcoded, the risk is lower but still present due to potential compromise of the CDN or supply chain.}	N/A
1431	studio24.bg.js	Unverified External Script Imports	Medium	true	CWE-496	10	importScripts	standard	{The importScripts function is used to load external scripts from hardcoded URLs. Although the URLs are fixed, the function itself is sensitive because it executes arbitrary JavaScript code from remote sources. If these URLs were dynamically constructed from untrusted input, it would be a severe risk. However, since they are hardcoded, the risk is lower but still present due to potential compromise of the CDN or supply chain.}	N/A
1432	umbro.com.br.js	Hardcoded API Keys in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (API keys, account tokens) in client-side JavaScript, not due to misuse of a sensitive function. The code does not dynamically invoke any function with untrusted input that leads to the exposure.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BBUjMHIzerqWWduqcwyh3TYU2mOZXbsCB_n26o78d5gsGcPo0YhDm3BoExxWcCC6FoD_ieDyG2P-cBUraXM7geA="",""apiKey"":""ABElsSA85Qec7m1EYPVVA92tY"",""accountToken"":""ABEkhuZbbTvSKmzfAscckINjY"",""appver"":""0.0.0"",""apiHost"":""https://api.pushio.com"",""lazy"":false}';orawp.init(config);```"
1433	vasconoticias.com.br.js	External Script Import Without Validation	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL were derived from untrusted or unsanitized input, it could lead to arbitrary script execution. However, in this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse but rather due to lack of validation or control over external script sources. Therefore, while the function is sensitive, the misuse is not present here.}	"```importScripts(""https://cdn.megapush.com.br/MegaPushServiceWorker.js"");```"
1434	winmx.mx.js	Open Redirect via Untrusted Notification URL	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a new browser window or tab with a URL derived from untrusted notification data (targetPage). Since this URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(targetPage));```
1435	winmx.mx.js	Insecure Notification Data Handling	Medium	false	New	0	N/A	N/A	{The code retrieves notification data (title, image, URL, etc.) from event.data without validation or sanitization, but does not directly invoke a sensitive function with untrusted input. The vulnerability stems from data handling rather than misuse of a sensitive function.}	```var title = notificationData.title; var imageSmall = notificationData.imageSmall; var imageLarge = notificationData.imageLarge; var url = notificationData.url; var actions = notificationData.actions; var options = { body: notificationData.body || notificationData.message```
1436	esb.co.id.js	Potential SSRF via Unvalidated URL Handling	High	true	CWE-918	N/A	scope.fetch	N/A	{The scope.fetch function is used to make network requests, and if the request URL is derived from untrusted or unsanitized input (e.g., from a client request or user-provided data), it can be manipulated to perform SSRF attacks. Although the code does not explicitly show dynamic URL construction, the service worker handles arbitrary fetch requests from clients, which may include malicious URLs if not properly validated.}	```const res = await this.scope.fetch(req);```
1437	esb.co.id.js	Weak Cryptographic Hash (SHA)	Low	false	CWE-327	N/A	sha1	N/A	{The sha1 function is a custom implementation of SHA-1, which is considered cryptographically weak and not suitable for security-sensitive applications. However, it is not being misused in a way that introduces a direct vulnerability (e.g., no input is being validated or signed with it), so it is not a sensitive function misuse.}	```function sha1(str) {```
1438	esb.co.id.js	Insecure Error Handling (Exposure of Sensitive Information)	Medium	false	CWE-209	N/A	this.debugger.log	N/A	{The debugger.log function is used to log errors, but it does not involve a sensitive function misuse. The vulnerability arises from the exposure of sensitive information in logs, not from improper use of a sensitive function.}	```this.debugger.log(err, `Driver.fetch(${req.url})`);```
1439	ifapray.org.js	XSS via iframe srcdoc	High	true	CWE-79	9	replace	standard	"{The replace() method is used to sanitize the responseBody for use in an iframe's srcdoc attribute. However, the sanitization is flawed — it replaces only &, ', "", <, and > with their HTML entities, but does not handle other potentially dangerous characters or contexts (e.g., script tags, event handlers). This allows an attacker to craft a response body that, when embedded in the srcdoc, can execute arbitrary JavaScript, leading to XSS.}"	"```const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');```"
1440	ifapray.org.js	Insecure Cache Key Handling	Medium	false	CWE-200	0	N/A	N/A	{The cache key is configured with a static prefix and suffix, but there is no direct misuse of a sensitive function. The issue lies in the exposure of potentially sensitive information in the cache key structure, not in function misuse.}	```wp.serviceWorker.core.setCacheNameDetails({ 'prefix': 'wp-\/', 'precache': 'precache-front', 'suffix': 'v1' });```
1441	ifapray.org.js	Potential Sensitive Data Exposure	Medium	false	CWE-200	0	N/A	N/A	{The precache URLs contain revision strings with potentially sensitive metadata (e.g., options, deps, nav hashes). However, this is not due to misuse of a sensitive function — it's a data exposure issue from hard-coded, verbose revision strings.}	```wp.serviceWorker.precaching.precache([{ 'url': 'https:\/\/ifapray.org\/?wp_error_template=offline', 'revision': '0.7.1;ifa-refresh=10.0.0-dev;options=c02e2755ca8eba353885def5de1aee6d;nav=e3feb447c0c113d16e8f99088e699120;deps=7be0dec8577a6c3fea90fdd5ba954a15;2b9d4f62dac31d5da1edaf36bfef0d91' }]);```
1442	ifapray.org.js	Improper Error Handling	Medium	false	CWE-754	0	N/A	N/A	{The error handling logic is flawed in that it attempts to fetch and process error responses, but the vulnerability arises from the logic flow and lack of proper fallbacks, not from misuse of a sensitive function.}	```return fetch(event.request).then(response => { if (response.status < 500) { return response; } return response.text().then(function (errorText) { return caches.match(wp.serviceWorker.precaching.getCacheKeyForURL('https:\/\/ifapray.org\/?wp_error_template=500')).then(function (errorResponse) {```
1443	ifapray.org.js	Regex Pattern Vulnerability	Medium	false	CWE-20	0	N/A	N/A	{The regex patterns are constructed from a static array and converted to RegExp objects. There is no dynamic input involved, so no sensitive function misuse occurs. The issue is that the patterns may be overly broad or not properly escaped, but this is a logic flaw, not a function misuse.}	```const denylist = ['^\\\/wp\\-admin($|\\?|\/)', '^[^\\?]*?\\.php($|\\?)', '\\?(.*?&)?wp_service_worker=', '^[^\\?]*?\\\/wp\\.serviceworker(\\?|$)', '^[^\\?]*?\\\/feed\\\/(\\w+\\\/)?$', '\\?(.*?&)?wp_customize=', '\\?(.*?&)?customize_changeset_uuid=', '^\\\/wp\\-json\\\/'].map(pattern => new RegExp(pattern));```
1444	smartseer.com.js	Improper Validation of Dynamic Code Generation (CDN Import)	High	true	CWE-444	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a dynamically constructed URL that includes the staticFileCdn variable. Although the value is hardcoded, the vulnerability arises because the URL is built at runtime and could be manipulated if staticFileCdn were derived from untrusted input. Since the script is loaded and executed without validation, an attacker could potentially inject malicious code if the CDN URL were compromised or if the variable were dynamically set from an untrusted source.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
1445	smartseer.com.js	Broad Regex Patterns Leading to Cache Poisoning	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from overly broad regular expressions used in workbox.routing.registerRoute, which can match unintended URLs and lead to cache poisoning. However, this is not caused by misuse of a sensitive function, but rather by flawed logic in route matching. The workbox.routing.registerRoute function is used correctly; the issue lies in the pattern design, not in the function's unsafe use.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
1446	smartseer.com.js	Insecure Cache Deletion via Message Command	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from allowing a message command to delete a cache, which could be exploited if the message is sent from an untrusted source. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a design flaw in message handling. The postMessage() function is used correctly; the issue is in the lack of origin validation or authentication for the message.}	```event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME });```
1447	smartseer.com.js	Potential SSRF via URL Parameter Injection	Medium	true	CWE-918	8	N/A	standard	{The new URL() constructor is a standard JavaScript API used to parse and manipulate URLs. In the addParams function, it is used to append parameters to a URL. If the input URL is derived from untrusted sources (e.g., user input), an attacker could inject malicious URLs that point to internal resources, leading to SSRF. Although the current code uses a try-catch and falls back to addParamsNative, the primary path still uses new URL(), which is vulnerable if the input is not sanitized.}	```const ur = new URL(url); Object.keys(params).forEach(param => { ur.searchParams.set(param, value); });```
1448	smartseer.com.js	Information Exposure Through Debug Logs	Low	false	N/A	0	N/A	N/A	{The vulnerability arises from logging sensitive information via console.log when debug mode is enabled. This is not caused by misuse of a sensitive function, but rather by a configuration or logging policy issue. The console.log function is used correctly; the problem is in the decision to expose debug logs in production environments.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
1449	modaco.com.js	Insecure Authentication Logic	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insecure authentication logic during service worker activation, specifically in the handling of cache cleanup. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in cache management. The code deletes caches not in the allowlist, but the issue is not tied to a specific sensitive function like importScripts or eval.}	```self.addEventListener('activate', e => { const cacheAllowList = [CACHE_NAME]; e.waitUntil(Promise.all([caches.keys().then(cacheNames => { return Promise.all(cacheNames.map(cacheName => { if (cacheAllowList.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }))); }), self.clients.claim()]))```
1450	gedik.com.js	Insecure Dynamic Code Evaluation	High	true	CWE-94	10	importScripts	standard	{The importScripts function is used to dynamically load and execute a script from a URL constructed using untrusted input (accountId and appGuid from URL search parameters). Since these values are directly extracted from the URL without sanitization or validation, an attacker can manipulate them to load and execute arbitrary scripts from a malicious domain, leading to complete compromise of the service worker's execution context.}	"```var swUrl = new URL(location);var accountId = swUrl.searchParams.get('account_id') || '';var appGuid = swUrl.searchParams.get('app_guid') || '';if (accountId && appGuid) {importScripts(""https://pcdn.dengage.com/p/push/"" + accountId + ""/"" + appGuid + ""/dengage_sw.js"");}```"
1451	napolicalciolive.com.js	Open Redirect via User-Controlled URL in Service Worker	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided by the notification data, which is derived from user-controlled input (event.notification.data.url). Since this URL is not validated or sanitized, an attacker can craft a malicious URL to redirect users to arbitrary sites, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.napolicalciolive.com&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url));});```
1452	napolicalciolive.com.js	Server-Side Request Forgery (SSRF) via Unvalidated URL in Service Worker	High	true	CWE-918	10	fetch	standard	{The fetch() function is called with a URL constructed from user-controlled input (body.data.sensor and event.notification.data.sensor). Since these inputs are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to internal or external systems, leading to SSRF vulnerabilities.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.napolicalciolive.com&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
1453	hi-fi.ru.js	Insecure Caching with Null Revision	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching a resource with a null revision, which means the cache will not be invalidated when the resource changes. This is not caused by misuse of a sensitive function, but rather by improper configuration of the precacheAndRoute function.}	```e.precacheAndRoute([{\n url: '_nuxt/builds/latest.json',\n revision: 'ce3e86629683e2bd539ef1efbbfcb91d'\n }, {\n url: '_nuxt/builds/meta/3b20b4c5-e499-4926-aa06-8d5ee7ca8bdb.json',\n revision: null\n }, {\n url: 'manifest.webmanifest',\n revision: 'e99c9222862955d94ab3ea8dd79ff074'\n }], {});```
1454	anmyperfumes.com.br.js	Use of External Script Without Subresource Integrity (SRI)	High	true	CWE-494	10	importScripts	standard	{The importScripts() function loads and executes a remote script from a URL specified in the argument. In this case, the URL is hardcoded to a CDN, but since it lacks Subresource Integrity (SRI), an attacker could potentially compromise the CDN or intercept the request to inject malicious code. This misuse of importScripts()—a standard JavaScript function in the Service Worker API—allows execution of unverified external code, leading to potential code injection and full compromise of the service worker.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js');```
1455	bibaleze.si.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of the request URL, specifically using string-based checks with indexOf. While this does not involve a sensitive function like importScripts or eval, it can lead to unintended behavior if the URL is manipulated (e.g., via URL encoding or path traversal), potentially allowing access to unintended resources. However, since no sensitive function is misused, this is not a sensitively vulnerable case.}	```var isLogoRequest = event.request.url.indexOf('assets/img/logo.svg') > -1 || event.request.url.indexOf('assets/img/confetti.png') > -1;```
1456	tinkanet.pe.js	Open Redirect via Unvalidated Click Action URL	High	true	CWE-601	10	N/A	standard	{The `new URL(url, self.location.origin).href` construction is used to resolve a potentially untrusted `click_action` URL from a notification payload. Although `new URL()` performs some sanitization by resolving relative URLs against the origin, it does not validate or restrict the final URL's destination. If the `click_action` is controlled by an attacker (e.g., via a malicious payload), it can be crafted to redirect users to arbitrary external domains, leading to open redirect vulnerabilities. This misuse of the standard `URL` constructor with untrusted input is a classic case of sensitive function misuse.}	```const urlToOpen = new URL(url, self.location.origin).href;```
1457	korkmazstore.com.tr.js	External Script Injection	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to 'https://sw.revotas.com/trc/api/service-worker.js', which is not dynamically derived from untrusted input. However, since the vulnerability is labeled as 'External Script Injection', it implies that the script is being loaded from an external source, which can be a security concern if the source is not fully trusted. While the URL is static, the act of importing an external script introduces risk if the source is compromised or if the script is not verified. Thus, the misuse lies in trusting an external script without validation, making importScripts() the responsible sensitive function.}	```importScripts('https://sw.revotas.com/trc/api/service-worker.js');```
1458	monecole.fr.js	Improper Input Validation (Untrusted Data in openWindow)	Medium	true	CWE-20	9	N/A	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. In this case, the URL is derived directly from n.notification.data, which originates from a push notification payload. Since push notification data can be controlled by an attacker (if the server is compromised or if the notification is sent via a malicious source), this allows for open redirect or phishing attacks. The function is misused by passing untrusted data without validation or sanitization, leading to potential navigation to malicious sites.}	```n.waitUntil(clients.openWindow(n.notification.data));```
1459	biathlonworld.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-602	8	new URL	standard	{The `new URL()` constructor is used to resolve a URL provided via the notification data, which is derived from untrusted input (event.notification.data.url). Since this input is not validated or sanitized, an attacker could craft a notification payload with a malicious URL (e.g., redirecting to a phishing site), leading to an open redirect vulnerability. The `new URL()` function, while standard, is sensitive when used with untrusted data as it can resolve and normalize arbitrary URLs, potentially bypassing security controls.}	```const urlToOpen = new URL(sourceUrl.url, self.location.origin).href;```
1460	onedio.co.js	Cross-Site Scripting (XSS) via CDN Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is called with options.workboxURL, which is a hardcoded URL pointing to a CDN (https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js). While the URL is hardcoded and not directly derived from untrusted input, the vulnerability arises because the script is dynamically imported from an external source. If the CDN or its hosting environment is compromised, or if the URL is altered via a supply chain attack (e.g., malicious package version), the imported script could contain malicious code. This allows an attacker to inject arbitrary JavaScript into the service worker, leading to potential XSS, cache manipulation, or network interception. The risk is elevated because the script is executed with full service worker privileges.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
1461	servimedia.es.js	Open Redirect via Unvalidated Click Action URL	High	true	CWE-601	10	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a URL provided by the notification data (i.notification.data.click_action). Since this value is derived from untrusted external input (push notification payload), an attacker can craft a notification with a malicious URL, leading to an open redirect where users are redirected to arbitrary sites, potentially phishing or malware distribution.}	```self.clients.openWindow(i.notification.data.click_action)```
1462	servimedia.es.js	XSS via Unsanitized Notification Data	High	true	CWE-79	10	self.registration.showNotification	standard	{The function self.registration.showNotification is called with user-controlled data (i.data.title and i.data.body) without sanitization. If an attacker can inject script tags or other malicious content into the notification title or body, it may lead to XSS when the notification is rendered in the browser, especially if the browser or platform interprets the content as executable script.}	```self.registration.showNotification(a, t)```
1463	athleticforum.biz.js	Server Side Request Forgery (SSRF) via untrusted push data	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted push data (id parameter). Since the id is directly interpolated into the URL without validation or sanitization, an attacker can manipulate the push payload to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	N/A
1464	athleticforum.biz.js	Improper Input Validation in CSRF token request	Medium	true	CWE-352	9	fetch	standard	{The fetch function is used with a URL constructed from the request's pathname, which is derived from the client's request. Since the path is directly interpolated into the URL without validation or sanitization, an attacker could potentially manipulate the request to trigger CSRF token requests to unintended endpoints, leading to improper CSRF token handling or potential abuse.}	N/A
1465	rakudays.com.js	Vulnerable Open Redirect in Notification Click Handler	High	true	N/A	10	N/A	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new window or tab with the provided URL. In this case, the URL is derived from event.notification.data, which is sourced from the notification payload. Since the notification payload can be controlled by an attacker (via push messages), the redirect URL becomes user-controllable, leading to an open redirect vulnerability. This allows an attacker to redirect users to arbitrary websites, potentially phishing or delivering malware.}	```event.waitUntil(clients.openWindow(redirectUrl));```
1466	remotes.com.uy.js	Improper Error Handling for Cache Addition	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from inadequate error handling during cache addition, but no sensitive function is misused. The code attempts to add a resource to the cache with `cache.add(offlineFallbackPage)`, but the error is caught and logged without impacting security. This is a logic or robustness issue, not a sensitive function misuse.}	"```self.addEventListener(""install"", async event => { event.waitUntil(caches.open(CACHE).then(cache => { try { cache && cache.add && cache.add(offlineFallbackPage); } catch (e) { console.log(e); } }).catch(e => { console.log('Could not open cache: ' + e); })); });```"
1467	remotes.com.uy.js	Unvalidated Cache Match in Offline Fallback	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from returning a cached response without validating its integrity or existence, but no sensitive function is misused. The `cache.match()` function is used correctly with a hardcoded path, and the issue is one of reliability, not security via sensitive function misuse.}	```const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp;```
1468	remotes.com.uy.js	Unrestricted Navigation Preload Enablement	Low	false	N/A	0	N/A	N/A	{The code enables navigation preload without any restrictions, but this is not due to misuse of a sensitive function. The `workbox.navigationPreload.enable()` call is a configuration choice, not a security risk from dynamic or untrusted input.}	```if (workbox.navigationPreload.isSupported()) { workbox.navigationPreload.enable(); }```
1469	remotes.com.uy.js	Lack of Cache Versioning/Expiration	Low	false	N/A	0	N/A	N/A	{This is a design or maintenance issue, not a result of sensitive function misuse. The constant `CACHE` is hardcoded and not dynamically derived, so no sensitive function is involved.}	```const CACHE = 'pwabuilder-page';```
1470	geostratigika.gr.js	Empty Fetch Event Listener	Medium	false	N/A	0	N/A	N/A	{The empty fetch event listener does not involve any sensitive function misuse. It is merely a placeholder or unused event handler and does not introduce security risks through improper use of functions.}	```self.addEventListener('fetch', function (event) {});```
1471	tehillim-center.co.il.js	Improper Input Validation	Medium	true	CWE-20	9	N/A	standard	{The function JSON.parse() is being used to parse the 'payload' object, which is received from a potentially untrusted source (e.g., a background message from Firebase Messaging). If the payload contains maliciously crafted JSON, it could lead to unexpected behavior or data leakage, especially if the parsed data is used without further validation. Although JSON.parse() itself does not execute code, improper handling of the parsed data (e.g., using it in dynamic contexts) can lead to vulnerabilities. However, in this case, the parsed data is used only for notification display, so the risk is limited to data integrity issues, not code execution.}	```const notification = JSON.parse(payload);```
1472	rct-portal.com.js	Improper Error Handling in Cache.addAll Leading to DoS	High	true	CWE-399	9	N/A	standard	{The `cache.addAll(assets)` function is a standard JavaScript API used in service workers to cache multiple assets. When used without proper error handling, it can lead to a denial-of-service condition if one of the assets fails to cache, causing the entire install process to fail silently or hang, potentially preventing the service worker from activating properly. This is exacerbated by the lack of try-catch or fallback mechanisms around the `cache.addAll` call.}	```caches.open(staticCacheName).then(cache => { console.log('caching assets'); cache.addAll(assets); });```
1473	rct-portal.com.js	Cache Poisoning via Unvalidated Network Responses	High	true	CWE-922	9	N/A	standard	{The `caches.put(request, response)` function is a standard service worker API that caches network responses. The vulnerability arises because the code attempts to cache responses without validating their origin, integrity, or content type. Specifically, the `updateCache` function caches any GET response that is not opaque and not from a chrome-extension URL, which allows an attacker to manipulate the cache with malicious or unexpected content, leading to cache poisoning.}	```if (request.method === 'GET' && !request.url.startsWith('chrome-extension://') && response.type !== 'opaque') { updateCache(request, response.clone()); }```
1474	rct-portal.com.js	SSRF Vulnerability in Fetch Handling	Medium	true	CWE-919	8	N/A	standard	{The `fetch(request)` function is a standard JavaScript API used to make network requests. The vulnerability occurs because the service worker fetches URLs directly from the `event.request.url` without validating or sanitizing the target URL. This allows an attacker to craft a request to internal or restricted resources (e.g., localhost, internal APIs) via the service worker, leading to Server-Side Request Forgery (SSRF).}	```event.respondWith(fromNetwork(event.request, timeout).catch(() => fromCache(event.request)));```
1475	sportytrader.es.js	Information Exposure via Console Logging	Medium	false	N/A	0	N/A	N/A	{The console.log() function is used to output request URLs and modes, which may expose sensitive information such as internal endpoints or user-specific paths. However, this is not considered a sensitive function misuse in the context of security-critical operations like script execution or data manipulation. The exposure is informational and does not involve dynamic, untrusted input being processed by a high-risk function.}	```console.log(`Fetching: ${evt.request.url}, Mode: ${evt.request.mode}`);```
1476	hentaitk.net.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-96	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a remote script from a hardcoded URL. While the URL is fixed and not derived from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. If the URL were to be dynamically constructed from user input (e.g., from a query parameter or environment variable), it would enable remote code execution. However, in this case, the URL is hardcoded and not user-controllable, so the risk is mitigated but the function remains sensitive by nature.}	```importScripts('https://hentaitk.net/wp-content/plugins/onesignal-free-web-push-notifications/sdk_files/OneSignalSDKWorker.js.php');```
1477	hentaitk.net.js	Denial of Service via Malformed Range Header	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of the 'range' header, specifically parsing it with a regex that may fail or produce unexpected results when given malformed input. However, this is not due to misuse of a sensitive JavaScript function like eval, importScripts, or similar. The issue is more related to input validation and error handling, not a sensitive function misuse.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
1478	gotyme.com.ph.js	External Script Import Vulnerability	High	false	N/A	0	N/A	N/A	{The importScripts() call uses a hard-coded, trusted path ('scripts/serviceworker_cdn.min.latest.js') and does not involve dynamic or user-controlled input. Therefore, while importScripts() is a sensitive function, its usage here is not vulnerable to misuse due to lack of dynamic input.}	```importScripts('scripts/serviceworker_cdn.min.latest.js');```
1479	donorview.com.js	Insecure CDN Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from the staticFileCdn variable. Although the value is hardcoded in this case, if staticFileCdn were to be influenced by untrusted input (e.g., from a configuration or user-controlled source), it could allow an attacker to inject arbitrary scripts into the service worker, leading to code execution and potential compromise of the entire PWA. Even with a hardcoded value, the use of dynamic URL construction with importScripts() introduces risk if the source of the URL is not fully trusted or if the value is derived from an external or user-influenced source.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
1480	donorview.com.js	Debug Logging Enabled	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the exposure of debug logs via console.log, which is not caused by misuse of a sensitive function. The log function is a custom utility that conditionally logs messages based on pwaSettings.debug, but it does not involve any sensitive JavaScript function that can lead to direct security exploitation such as code injection or data leakage via untrusted input.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
1481	boldpac.com.js	Vulnerable Regular Expression in Cache Strategy	High	true	CWE-1337	9	/.*?jquery.*?(?:\.min)?\.js.*?/	standard	{The regular expression used in workbox.routing.registerRoute is overly broad and may match unintended URLs, potentially leading to incorrect caching behavior or bypassing security controls. The pattern .*? is greedy and non-specific, allowing for unintended matches across different domains or paths, which could result in sensitive or dynamic content being cached improperly. This is a misuse of the RegExp constructor in a security-sensitive context where precise matching is required.}	```workbox.routing.registerRoute(/.*?jquery.*?(?:\.min)?\.js.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
1482	boldpac.com.js	Improper URL Parameter Sanitization	Medium	true	CWE-116	8	new URL(url)	standard	{The function addParams uses the URL constructor to parse and modify URLs. If the input URL is untrusted or malformed, it can lead to unintended URL resolution or injection of malicious parameters. For example, if the input URL contains a relative path or a fragment, the URL constructor may resolve it in a way that bypasses intended security checks, potentially allowing an attacker to manipulate the URL structure and access unintended resources.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
1483	boldpac.com.js	CORS Misconfiguration in Prefetch	Medium	true	CWE-614	7	fetch(new Request(url, { mode: 'no-cors' }))	standard	{The prefetchUrl function uses fetch with mode: 'no-cors', which prevents the browser from sending credentials and restricts the response to only basic headers. However, this can lead to unexpected behavior when attempting to cache responses from third-party origins, especially if the server does not support CORS. This misconfiguration may result in failed prefetches or unintended exposure of data, particularly if the server returns non-200 responses or if the response is not accessible due to CORS restrictions.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } } } catch (err) { log('error, probably offline'); } }```
1484	boldpac.com.js	Debug Logging Enabled	Low	false	CWE-200	0	N/A	N/A	{Debug logging is enabled via pwaSettings.debug, but this does not involve misuse of a sensitive function. It is a configuration issue rather than a function misuse vulnerability.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
1485	0-100.it.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL passed directly from event.notification.data.url, which is unvalidated and untrusted. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect where users are redirected to arbitrary sites, potentially phishing or malware distribution.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var d = event.notification.data.url; event.waitUntil(clients.openWindow(d)); });```
1486	0-100.it.js	Server Side Request Forgery (SSRF) via Untrusted URL Parameters in Fetch Requests	High	true	CWE-918	N/A	fetch	standard	{The fetch() function is used with a URL constructed by concatenating untrusted input (body['push_send_id'] and body['channel_id']) into the query string. Although the base URL is hardcoded, the parameters are derived from untrusted data, enabling an attacker to manipulate these parameters to trigger SSRF attacks, potentially accessing internal resources or services behind the firewall.}	```let fetchRes = fetch('https://re-02.magellanotech.it' + '/api/beaconpush.gif/?site_name=0-100.it&push_send_id=' + body['push_send_id'] + '&event_name=' + 'view' + '&channel_id=' + body['channel_id']);```
1487	authory.com.js	Improper Handling of Credentials in Intercepted Requests	Medium	false	N/A	0	N/A	N/A	{The issue arises from setting `credentials: 'omit'` in the Request constructor, which is a deliberate security choice to avoid sending credentials (like cookies) with the request. This is not a misuse of a sensitive function but rather a configuration decision. No sensitive function is being misused here.}	```var modifiedRequest = new Request(event.request, { credentials: 'omit' });```
1488	surfexcel.in.js	Cache Poisoning	High	true	CWE-352	10	N/A	standard	{The vulnerability arises from the use of `caches.put()` with a request object that is derived from a user-controlled fetch response. While `caches.put()` itself is not inherently dangerous, its misuse here allows an attacker to cache arbitrary responses by manipulating the request URL or headers, potentially leading to cache poisoning. The function is called with `e.request` (which is user-controlled via the fetch event) and a cloned response, enabling an attacker to inject malicious content into the cache if they can trigger a fetch for a controlled URL.}	```const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E;```
1489	surfexcel.in.js	Insecure URL Exclusion Check	Medium	false	N/A	0	N/A	N/A	{The issue stems from a logic flaw in URL exclusion, not from misuse of a sensitive function. The code uses `indexOf` to check for substring matches in URLs, which can lead to false negatives or unintended exclusions. However, no sensitive JavaScript function (like `eval`, `importScripts`, `execScript`, etc.) is being misused here.}	```EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || 'PUT' === e.request.method || 'POST' === e.request.method || e.request.headers.get('range') || (e.request.headers.get('Accept').includes('text/html') ? e.respondWith(fetch(e.request).then(E => {```
1490	schoolhouse.world.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL provided via the notification data, which is derived from untrusted push event data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or leaking sensitive information.}	```if (event.notification.data?.url != null) { clickResponsePromise = clients.openWindow(event.notification.data.url); }```
1491	schoolhouse.world.js	Improper Input Validation in Push Event Handling	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability is due to improper input validation of push event data, but no sensitive function is directly misused. The data is parsed via event.data.json(), which is safe, and the subsequent use of the parsed data does not involve any inherently dangerous functions. The issue lies in the lack of validation, not misuse of a sensitive function.}	```const data = event.data.json(); const { title, body, url, icon } = data;```
1492	fixfit.it.js	Cache Poisoning via External URL Matching	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the misuse of the `isInArray` function, which processes `event.request.url` without proper sanitization or validation. This function checks if the URL (after stripping the origin) exists in `STATIC_FILES`, but it does not prevent an attacker from crafting a request URL that matches a static file path when the origin is stripped. Since `STATIC_FILES` includes paths like `/offline.html`, an attacker could potentially trigger cache responses for malicious URLs that are not intended to be cached, leading to cache poisoning. The `caches.match()` function is then used with this potentially manipulated URL, allowing unintended cache hits. This is a sensitive misuse because the `caches.match()` function is a standard API that can be exploited when given untrusted input, and the `isInArray` function improperly handles the URL, making it a critical flaw.}	```self.addEventListener('fetch', function (event) { if (event.request.method === 'POST') { return; } if (isInArray(event.request.url, STATIC_FILES)) { event.respondWith(caches.match(event.request)); } else { event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } else { return fetch(event.request).catch(function (err) { return caches.open(CACHE_STATIC_NAME).then(function (cache) { if (event.request.headers.get('accept').includes('text/html')) { return cache.match('/offline.html'); } }); }); } })); });```
1493	i7mm.net.js	Insecure Handling of No-CORS Requests in Service Worker	Medium	true	New	8	Request	standard	{The code modifies a request with mode 'no-cors' to use 'default' cache mode, which can lead to unintended cross-origin resource sharing or bypass of CORS restrictions, potentially allowing unauthorized access to resources that should be restricted. This misuse of the Request constructor with dynamic input (request.url) in a service worker context can enable attackers to manipulate requests in ways that violate intended security policies.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
1494	solarwords.com.js	Hardcoded Sensitive Information	High	false	N/A	N/A	N/A	N/A	{Hardcoded sensitive information such as Firebase API key, project ID, and VAPID public key are exposed in the script. While not directly caused by a sensitive function misuse, they represent a critical security flaw due to exposure of credentials.}	```const options = { firebaseConfig: { projectId: 'ecovahan-be213', messagingSenderId: '1076151600014', appId: '1:1076151600014:web:84f973e7fb0548605a1adf', apiKey: 'AIzaSyCrj-EffgtalipI9AgIjbrCzfNl_Y5Ogwo' }, domain: 'solarwords.com', api_url: 'https://push.ecovahan.com/api/token', vapid_public_key: 'BP4A0URJSJwnpmniflGX7dWZ7Z0RFFauUMfunjKd2I33WtO3JRkbS1pPsPVz3mhR2i3cF2MoR59bgdugb0_gKnw' };```
1495	solarwords.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The JSON.parse() call on event.data.json().data.notification is vulnerable to improper input validation if the payload is not sanitized or validated before use. However, this is not directly caused by misuse of a sensitive function but rather a lack of input sanitization.}	```const payload = JSON.parse(event.data.json().data.notification);```
1496	solarwords.com.js	Open Redirect Vulnerability	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow(targetUrl) function is called with a dynamic targetUrl derived from event.notification.data.url or event.notification.data.actions[event.action].click_action, which are user-controlled. This allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerability.}	```clients.openWindow(targetUrl);```
1497	solarwords.com.js	Server-Side Request Forgery (SSRF)	High	true	N/A	N/A	fetch	standard	{The fetch(apiUrl) function is called with a dynamic apiUrl derived from event.notification.data.api_url or event.notification.data.actions[event.action].api_url, which are user-controlled. This allows an attacker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(apiUrl);```
1498	zeelabpharmacy.com.js	Improper Input Validation (Unsanitized Notification Data)	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from unsanitized notification data (title, body, icon) being passed directly to showNotification, but no sensitive function misuse is detected since the input is not dynamically derived from untrusted sources like user input or URL parameters. The data is expected to come from Firebase messaging, which is controlled by the server, not user-controlled.}	```return self.registration.showNotification(title, { body, icon });```
1499	khabarnama.net.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically derived from untrusted input, the act of importing and executing a remote script still constitutes a potential security risk if the source is not fully trusted. However, since the URL is static and not user-controlled, the risk is mitigated but not eliminated. The vulnerability arises because the script is loaded from an external domain, which could be compromised or changed by an attacker, leading to remote code execution within the service worker context.}	```importScripts('https://van.najva.com/static/js/scripts/new-website846358-website-57179-2caeb3d2-5292-494a-b335-3e08428726f6-service-worker.js');```
1500	erodium.hu.js	phishing via unvalidated notification action URL in push event	High	true	CWE-601	10	clients.openWindow	standard	{The 'action' field in the notification's 'actions' array is populated with 'message.button_url', which is derived from untrusted push message data. When the user clicks the notification action, the service worker calls clients.openWindow(url) with this unvalidated URL, allowing an attacker to redirect the user to a phishing site or malicious domain. This is a direct misuse of the standard clients.openWindow() API with untrusted input.}	```const options = { body: message.text, icon: 'template/offline/erodium.png', badge: 'template/offline/badge.png', actions: [{ action: message.button_url, title: message.button_text, icon: 'template/offline/erodium.png' }] };```
1501	erodium.hu.js	phishing via unvalidated URL in notificationclick handler	High	true	CWE-601	10	clients.openWindow	standard	{The URL passed to clients.openWindow(url) is derived from the 'action' property of the notification click event, which can be controlled by an attacker via a malicious push notification. Since the URL is not validated or sanitized, it can point to any arbitrary domain, enabling phishing or drive-by download attacks. This is a direct misuse of the standard clients.openWindow() API with untrusted input.}	```event.waitUntil(clients.openWindow(url));```
1502	fuaark.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from event.notification.data.baseUrl, which is user-controlled. This allows an attacker to manipulate the baseUrl to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	N/A
1503	fuaark.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from notificationOptions.data.baseUrl, which is user-controlled via the payload. This allows an attacker to manipulate the baseUrl to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	N/A
1504	fuaark.com.js	Insecure Dynamic Code Execution	Medium	false	CWE-444	N/A	N/A	N/A	{The importScripts call uses a hardcoded, trusted URL from a known Firebase CDN. There is no dynamic or user-controlled input involved, so it does not constitute a sensitive function misuse.}	N/A
1505	```importScripts(\'https://bikayi-chat.firebaseapp.com/__/firebase/9.2.0/firebase-app-compat.js\');```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```importScripts(\'https://bikayi-chat.firebaseapp.com/__/firebase/9.2.0/firebase-app-compat.js\');```
1506	resultadostris.com.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain without integrity verification. This allows the remote server to modify the script at any time, potentially injecting malicious code that can compromise the service worker’s behavior, intercept network requests, or exfiltrate data.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/66261e182326a000084f6d88/service-worker.js"");```"
1507	zapoznalnik.com.js	Open Redirect via Untrusted Notification Data	High	true	CWE-601	10	N/A	standard	{The function `clients.openWindow()` is a standard Service Worker API that opens a new browser window or tab with the provided URL. In this case, the URL is derived from `event.notification.data.url`, which originates from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. This allows attackers to trick users into visiting arbitrary websites, potentially compromising their credentials or session tokens.}	```event.waitUntil(self.clients.openWindow(urlToOpen));```
1508	zovi24.com.js	Stale Cache Due to Missing Versioning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of versioning in the cache name, which prevents proper cache invalidation when updates are made. This is not due to misuse of a sensitive function, but rather a design or configuration issue.}	```let STATIC_CACHE_NAME = 'gfg-pwa';```
1509	zpeed.in.js	Cache Poisoning	High	true	N/A	9	caches.match	standard	{The caches.match function is used to retrieve a cached response for a given request. While it is not inherently dangerous, in this context, it is used without validation or sanitization of the request URL, which could allow an attacker to craft a malicious request that bypasses intended caching logic or triggers unintended cache behavior. However, the primary vulnerability here is not directly due to caches.match misuse, but rather the broader cache poisoning risk introduced by the update function, which fetches and caches responses without validating the origin or integrity of the fetched resource. The function caches.match is standard and used correctly in this context, but the overall cache poisoning risk stems from the lack of input validation in the update function, which is not directly tied to a sensitive function misuse.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); })); event.waitUntil(update(event.request).then(refresh)); });```
1510	chartis.com.js	Incorrect Regular Expression for URL Matching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from an improperly constructed regular expression in `e.registerRoute(/.(?:png|gif|jpe?g|svgz?|webp|woff2|mp4|webm|css|js)$/, ...)`, which fails to properly anchor the pattern and may match unintended URLs. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic or configuration error in the route matching pattern. The function `registerRoute` is used correctly in terms of input handling; the issue is in the regex itself, not in how it's being fed dynamic or untrusted data.}	```e.registerRoute(/.(?:png|gif|jpe?g|svgz?|webp|woff2|mp4|webm|css|js)$/, new e.CacheFirst({ cacheName: 'static-assets', plugins: [new e.ExpirationPlugin({ maxEntries: 100 })] }), 'GET');```
1511	shoperia.pl.js	External Script Import from Untrusted Domain	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to import a script from 'https://s-eu-1.pushpushgo.com', which is an external, third-party domain. Since the script URL is hardcoded but not under the control of the site owner, it introduces a high-risk vulnerability: if the external domain is compromised or malicious, the imported script can execute arbitrary code within the service worker context, leading to cache manipulation, network interception, or data exfiltration. This constitutes a direct misuse of a sensitive function due to reliance on untrusted external code.}	```!function (e) { ... try { importScripts('https://s-eu-1.pushpushgo.com/5d9467e12a2414749ac297ae/worker.js'); } catch (e) { console.error(e); } ... }]```
1512	godupdates.com.js	External Script Inclusion Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can lead to code injection if the script source is compromised or if the script is dynamically loaded from an untrusted or mutable source. Although the URL in this case is hardcoded, the vulnerability is still classified as sensitive function misuse because importScripts() inherently introduces risk by executing arbitrary code from external sources, especially in the context of Service Workers which have broad permissions.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/60c275b968fa160010cb63fb"");```"
1513	your-move.co.uk.js	Insecure Dynamic URL Handling	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(url) is used with a dynamically constructed URL derived from event.action, which is user-controlled via the notification action. Since the URL is not validated or sanitized, an attacker could craft a malicious notification action (e.g., 'open:https://malicious.com') to redirect the user to an arbitrary site, potentially leading to phishing or other client-side attacks. This constitutes improper handling of dynamic URLs in a context where user input directly influences navigation.}	```self.addEventListener('notificationclick', function (event) { const clickedNotification = event.notification; clickedNotification.close(); if (event.action.startsWith('open:')) { const url = event.action.replace('open:', ''); event.waitUntil(clients.matchAll({ type: 'window' }).then(function (windowClients) { for (var i = 0; i < windowClients.length; i++) { var client = windowClients[i]; if (client.url === url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } })); } });```
1514	goodyearautoservice.com.js	Cache Poisoning via Unvalidated Request URLs	High	true	CWE-918	N/A	event.respondWith(caches.match(request).then(response => { return response || fetch(request).then(response => { if (response.ok) { if (shouldCache(event)) { addToCache(assetsCacheName, request, response.clone()); } } return response; }).catch(error => { console.error(error); }); }));	standard	{The vulnerability arises from the use of `fetch(request)` and `addToCache()` without validating or sanitizing the incoming request URL. Since the service worker processes any GET request (as long as it's not in pagesToExclude), an attacker could craft a malicious request URL that points to a resource they control, causing the service worker to cache and serve it. This allows cache poisoning, where the attacker can inject malicious content into the cache, potentially leading to cross-site scripting (XSS) or other attacks. The `fetch` function is a standard JavaScript API that blindly retrieves resources from the provided URL, and when used with untrusted input (the request URL), it becomes a vector for cache poisoning.}	```event.respondWith(caches.match(request).then(response => { return response || fetch(request).then(response => { if (response.ok) { if (shouldCache(event)) { addToCache(assetsCacheName, request, response.clone()); } } return response; }).catch(error => { console.error(error); }); }));```
1515	parapsihopatologija.com.js	Cross-Site Request Forgery (CSRF) Bypass	High	true	N/A	9	N/A	standard	{The vulnerability arises from the service worker intercepting POST requests from guests and dynamically fetching a CSRF token via a server endpoint. The URL for this fetch is constructed using the request's pathname, which is derived from the incoming request's URL. Since the request URL is not sanitized or validated, an attacker could craft a malicious request with a pathname that leads to an unintended endpoint, potentially bypassing CSRF protections by injecting a forged request to a sensitive action. The sensitive function `fetch()` is used with a dynamically constructed URL, making it susceptible to CSRF bypass if the pathname is controlled by an attacker.}	"```const curRequest = request.clone(); log(""Intercepting guest post request""); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
1516	parapsihopatologija.com.js	Open Redirect Vulnerability	Medium	true	N/A	9	N/A	standard	{The `navigate()` method is used to redirect a client to a URL provided in the notification data. Since the `data.url` value is directly extracted from the push notification payload without validation or sanitization, an attacker could craft a malicious notification with a URL pointing to an external, potentially harmful site. This allows for open redirect attacks, where users are redirected to unintended destinations, potentially leading to phishing or credential theft. The sensitive function `navigate()` is used with untrusted input, enabling redirection to arbitrary URLs.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
1517	addnine.com.js	Insecure External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., 'https://cdn.ampproject.org/sw/amp-sw.js'), it introduces a risk if the script source is not fully trusted or if the CDN is compromised. Although the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing an external script from a third-party source still constitutes a potential attack surface, especially if the script can be tampered with or if the CDN is not secured with proper integrity checks. This is considered a high-severity vulnerability because it allows an attacker to potentially inject malicious code into the service worker if the external script is compromised.}	```importScripts('https://cdn.ampproject.org/sw/amp-sw.js');```
1518	gaeta.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a URL constructed from the untrusted input body.data.sensor, which is derived from the push event data. Since the sensor_url is directly concatenated into the request URL without validation or sanitization, an attacker can manipulate this input to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```const ve = sensor_url + '/e?site_name=www.gaeta.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
1519	gaeta.it.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The clients.openWindow() function is called with the untrusted input event.notification.data.url, which is directly taken from the notification data. Since this URL is not validated or sanitized, an attacker can craft a notification to redirect users to malicious websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1520	xszav2.com.js	Insecure Caching	High	false	N/A	0	N/A	N/A	"{The vulnerability arises from improper caching logic in the `k` function, which conditionally caches responses based on headers like ""Cache-Control"". However, this is not due to misuse of a sensitive JavaScript function, but rather flawed logic in handling cache control directives. The function does not invoke any inherently dangerous or sensitive APIs like `importScripts`, `eval`, or `Function`, and thus does not constitute a sensitive function misuse.}"	```const k = (t, e, n, c) => new Promise((o, a) => { const s = c.url, r = n.get(s); if (r) r.push([o, a]); else { const l = f => { const i = n.get(s); if (i) { n.delete(s); for (const [d] of i) d(f.clone()); } else o(f.clone()); }, u = f => { const i = n.get(s); if (i) { n.delete(s); for (const [d, U] of i) U(f); } else a(f); }; n.set(s, [[o, a]]), t.match(s).then(f => { if (q(c, f)) l(f); else return e(c).then(async i => { i.ok && (await t.put(s, i.clone())), l(i); }); }).catch(f => t.match(s).then(i => { i ? l(i) : u(f); })); } });```
1521	dfoneople.com.js	Exposure of Sensitive Information in Service Worker	High	true	CWE-200	10	importScripts	standard	{The Firebase configuration object, including the API key and VAPID key, is hardcoded in the service worker script. While importScripts() is not directly responsible for the exposure, the script is loaded and executed in the context of the service worker, and the sensitive data is exposed in the source code. Since the script is served over HTTP(S) and accessible to anyone who can inspect the service worker, this constitutes a direct exposure of sensitive credentials. The use of importScripts() to load external libraries does not directly cause the exposure, but the script itself contains sensitive data that should not be exposed. However, since the vulnerability is tied to the presence of sensitive data in the script, and the script is loaded via importScripts(), we mark it as sensitive function misuse due to the context of script execution.}	```importScripts('https://www.gstatic.com/firebasejs/10.10.0/firebase-app-compat.js');importScripts('https://www.gstatic.com/firebasejs/10.10.0/firebase-messaging-compat.js');```
1522	dfoneople.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided in the notification data (event.notification?.data?.url). Since this URL is not validated or sanitized, an attacker could craft a notification with a malicious URL (e.g., a phishing site or a redirect to a malicious domain), leading to an open redirect vulnerability. The function is standard and directly responsible for the risk.}	```clients.openWindow(event.notification?.data?.url || '/');```
1523	dfoneople.com.js	Exposure of Sensitive Information via Console Logging	Medium	false	CWE-200	0	N/A	N/A	{The console.log() function is used to log the Firebase configuration object, which includes sensitive keys. However, console.log() is not a sensitive function in the context of service workers because it does not directly expose data to external parties unless the developer is actively inspecting the console. In production, this is not a direct security risk unless the console is accessed by an attacker. Therefore, it is not considered a sensitive function misuse.}	"```console.log(""Service Worker ON."", firebaseOption);```"
1524	nextapple.tw.js	Improper Neutralization of Special Elements in Route Definitions (Cache Poisoning	High	true	CWE-918	10	JSON.parse	standard	{The use of JSON.parse on a string containing untrusted or dynamically generated regular expression patterns (e.g., from a configuration or external source) can lead to cache poisoning if the parsed regexes are used to match URLs in route definitions. If an attacker can influence the input to JSON.parse, they could inject malicious regex patterns that match unintended URLs, causing the service worker to cache or serve responses for unintended resources.}	"```const c = JSON.parse('[""nextapple\\\\.tw(?:/.*)?/ola/services/.*"",""nextapple\\\\.tw/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://fa2e4c17-8d9e-45e1-b181-f8cba75c842e\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
1525	nextapple.tw.js	Improper Cache Expiration Leading to Stale Content	Medium	false	CWE-523	0	N/A	N/A	{The vulnerability arises from a misconfiguration in the ExpirationPlugin, where the maxAgeSeconds is set to 31536000 (one year), which is excessively long and can lead to stale content being served. This is not due to misuse of a sensitive function but rather a configuration error.}	"```new t.CacheFirst({ cacheName: ""google-fonts-webfonts"", plugins: [new a.CacheableResponsePlugin({ statuses: [0, 200] }), new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })] })```"
1526	nextapple.tw.js	Insufficient Validation of Cacheable Responses	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability stems from the CacheableResponsePlugin being configured to only accept status code 200, which may not be sufficient for all use cases (e.g., 0 for opaque responses). However, this is a configuration issue, not a misuse of a sensitive function.}	"```new t.CacheFirst({ cacheName: ""images-fonts"", plugins: [new a.CacheableResponsePlugin({ statuses: [200] }), new n.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 2592e3 })] })```"
1527	partouche.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	postMessage	standard	{The vulnerability arises from the use of postMessage() to send data to a client, where the data is derived from a potentially untrusted source (i.e., the JSON payload from the request). Although postMessage() itself is not inherently dangerous, its misuse here allows an attacker to craft a malicious request that triggers the service worker to send arbitrary messages to a client, potentially leading to SSRF if the client then makes requests to internal resources based on the message content. The dynamic nature of the input (i.e., the JSON payload) and the lack of sanitization or validation before sending the message make this a sensitive misuse.}	```const o = await (r => new Promise(async n => { const s = [...(await self.clients.matchAll())].sort((e, t) => e.url > t.url ? -1 : e.url < t.url ? 1 : 0)[0]; if (s) { const i = [n, setTimeout(() => { e.delete(r.F), n(t(r, 'Timeout')); }, 1e4)]; e.set(r.F, i), s.postMessage(r); } else n(t(r, 'NoParty')); }))(i);```
1528	bbnhaber.com.tr.js	Dynamic Code Loading Without Integrity Check	Medium	true	N/A	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it loads a script from a remote CDN with a dynamically appended version parameter. While the URL is not directly user-controlled, the lack of integrity checks (e.g., Subresource Integrity or cryptographic verification) means that if the CDN is compromised, the loaded script could be malicious. This constitutes a sensitive function misuse because importScripts executes code from an external source without validation, potentially leading to code injection or unauthorized behavior.}	```importScripts('https://cdn.bbnhaber.com.tr/assets/bundle/webpush.js?v=' + version);```
1529	careerbeacon.com.js	Insufficient Offline Cache Handling	Low	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the fact that the cache.addAll([]) is called with an empty array, meaning no resources are cached during installation. This leads to insufficient offline support, but does not involve any unsafe or dynamic input being passed to a sensitive function.}	```var currentCache = { offline: 'offline-cache' }; var filesToCache = []; self.addEventListener('install', function (event) { event.waitUntil(caches.open(currentCache.offline).then(cache => cache.addAll([]))); }); self.addEventListener('fetch', e => { e.respondWith(caches.match(e.request).then(response => response || fetch(e.request))); });```
1530	dutchcrafters.com.js	Improper Error Handling in Fetch Event	Medium	false	N/A	0	N/A	N/A	{The try-catch block in the fetch event handler does not properly handle errors, but it does not involve misuse of a sensitive function. The catch block simply calls pullFromCache, which is a safe, internal function. No external or dangerous APIs are invoked with untrusted input.}	```try {} catch (err) { event.respondWith(pullFromCache(event)); }```
1531	dutchcrafters.com.js	Nested event.respondWith in Cache Handling	Medium	false	N/A	0	N/A	N/A	{The nested use of event.respondWith within a then() chain is a code quality issue, but it does not involve misuse of a sensitive function. The caches.match and fetch APIs are used correctly and do not receive untrusted input.}	```event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request).catch(function () {}); }));```
1532	dutchcrafters.com.js	Reliance on navigator.onLine for Offline Detection	Medium	false	N/A	0	N/A	N/A	{The use of navigator.onLine is a reliability concern, as it may not accurately reflect network connectivity, but it is not a sensitive function misuse. It is a standard API used for detection, not for executing or loading external code.}	```if (!navigator.onLine && event.request.url.indexOf('default.aspx') !== -1) { event.respondWith(showOfflineLanding(event)); }```
1533	bozikis.gr.js	Use of Third-Party Code with Known Vulnerabilities	High	true	CWE-918	N/A	importScripts	standard	{The importScripts function is used to load and execute a remote script from a third-party CDN. While the URL is hardcoded, the use of external scripts introduces risk if the CDN is compromised or if the script contains known vulnerabilities. However, since the URL is not dynamically constructed from untrusted input, this is not a direct sensitive function misuse in the context of injection or arbitrary code execution via user-controlled input. The vulnerability arises from dependency on external code with potential known flaws, not from dynamic input misuse.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');```
1534	parugyon.com.js	Denial of Service via Cache Installation Failure	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the potential failure of cache.addAll() when attempting to cache large or inaccessible resources, but it is not due to misuse of a sensitive function with untrusted input. The URLs are hardcoded and static, so there is no dynamic or user-controlled input being passed to any sensitive function.}	```const CACHE_NAME = 'cocoon_20190523_20241110192912'; const urlsToCache = ['https://parugyon.com/', 'https://parugyon.com/wp-content/uploads/2021/04/cropped-パルギョン-192x192.png', 'https://parugyon.com/wp-content/uploads/2021/04/cropped-パルギョン.png', 'https://parugyon.com/wp-content/themes/cocoon-master/javascript.js', 'https://parugyon.com/wp-content/themes/cocoon-master/webfonts/fontawesome/css/font-awesome.min.css', 'https://parugyon.com/wp-content/themes/cocoon-master/webfonts/icomoon/style.css']; self.addEventListener('install', function (event) { event.waitUntil(caches.open(CACHE_NAME).then(function (cache) { console.log('PWA cache opened'); return cache.addAll(urlsToCache); })); });```
1535	sredime.rs.js	Improper Handling of Non-Standard Event Leading to Cache Poisoning	High	true	CWE-798	N/A	self.addEventListener('refreshOffline', function () { const offlinePageRequest = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { return cache.put(offlinePageRequest, response); }); }); });	standard	{The event 'refreshOffline' is non-standard and not part of the Service Worker specification. While the code itself does not misuse a sensitive function with untrusted input, the vulnerability arises from the improper handling of this custom event, which could be triggered by malicious actors or misconfigured systems to force cache updates with potentially untrusted content. However, since the URL 'offlineFallbackPage' is hardcoded and not derived from user input, the direct misuse of a sensitive function like 'fetch' or 'cache.put' is not present. Thus, the vulnerability is not due to sensitive function misuse but rather due to the use of a non-standard event that could be exploited in a broader context.}	```self.addEventListener('refreshOffline', function () { const offlinePageRequest = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { return cache.put(offlinePageRequest, response); }); }); });```
1536	411.ca.js	Information Exposure Through Log Files	Medium	true	CWE-200	8	this.debugger.log	standard	{The debugger.log function is used to log error messages that include the request URL (req.url). If req.url contains sensitive data (e.g., query parameters with tokens, credentials, or personal information), this data will be logged and potentially exposed in debug logs, leading to information leakage. The function is standard (part of the Angular Service Worker framework) but misused by logging untrusted input without sanitization.}	```this.debugger.log(err, `Driver.fetch(${req.url})`);```
1537	funfairtycoon.com.js	Insecure Dynamic Cache Configuration	High	true	CWE-20	8	N/A	standard	{The `new URL(location).searchParams.get('baseURL')` retrieves a dynamic value from the URL query parameters and assigns it to `baseURL`, which is then used to construct cache resource URLs. This allows an attacker to manipulate the `baseURL` parameter to inject arbitrary URLs into the cache, potentially leading to cache poisoning or execution of malicious resources. The `URL` constructor and `searchParams.get()` are standard JavaScript APIs, but their misuse with untrusted input creates a high-risk vulnerability.}	```baseURL = new URL(location).searchParams.get('baseURL');```
1538	funfairtycoon.com.js	Cache Poisoning via URL Parameter Manipulation	High	true	CWE-918	9	N/A	standard	{The `cacheResources.map()` function iterates over a list of resources and dynamically replaces placeholders like 'BASE_URL' and '/WORLD/' with values derived from `baseURL` and `world`, which are obtained from untrusted URL parameters. This allows an attacker to inject arbitrary URLs into the cache via the `baseURL` and `world` parameters, leading to cache poisoning. The `map()` function is standard, but its use with unsanitized input from `location.searchParams` creates a high-risk vulnerability.}	```cacheResources.map((resource, index) => { resource = resource.replace('BASE_URL', baseURL); resource = resource.replace('LANG', language); if (world !== null) { resource = resource.replace('/WORLD/', world); } cacheResources[index] = resource; return resource; });```
1539	funfairtycoon.com.js	Unvalidated Cache Key Construction	Medium	true	CWE-20	7	N/A	standard	{The code constructs cache keys using `world + 'ajax/offline.php'` where `world` is derived from `new URL(location).searchParams.get('world')`. Since `world` is unsanitized, an attacker can manipulate it to construct arbitrary cache keys, potentially leading to cache poisoning or bypassing intended cache logic. The string concatenation and `caches.match()` are standard operations, but their misuse with untrusted input introduces a medium-risk vulnerability.}	```if (event.request.url.includes('/ajax/')) { if (world !== null) { return caches.match(world + 'ajax/offline.php'); } }```
1540	queue-it.com.js	Uncaught Error in Cache.addAll During Service Worker Installation	High	false	N/A	0	N/A	N/A	{The vulnerability is due to a potential error in the Cache.addAll() call during installation, but it does not stem from misuse of a sensitive function. The function is used correctly with hardcoded paths, and no untrusted input is involved.}	```var swName = '1655796091';self.addEventListener('install', function (event) { event.waitUntil(caches.open(swName).then(function (cache) { return cache.addAll(['/', '/scripts/script.js', '/sw.js', '/css/style.css']); })); });```
1541	queue-it.com.js	Insecure Fetch Logic Bypass in Service Worker	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from flawed logic in the fetch event handler, specifically returning false for certain URLs, which may lead to unintended behavior. However, this is not due to misuse of a sensitive function, as no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', function (event) { if (event.request.url.includes('/umbraco') || event.request.url.includes('localhost') || event.request.url.includes('/free-trial') || event.request.url.includes('/pricing')) { return false; } if (event.request.method === 'GET') { event.respondWith(caches.match(event.request).then(function (cached) { var networked = fetch(event.request).then(fetchedFromNetwork, unableToResolve).catch(unableToResolve); return cached || networked; function fetchedFromNetwork(response) { var cacheCopy = response.clone(); caches.open(swName).then(function add(cache) { cache.put(event.request, cacheCopy); }); return response; } function unableToResolve() { return new Response('<div style='max-width: 1170px; margin: 20px auto'> <div> <a href='/'> <img src='/media/xdnntudx/queue-it-logo.png' alt='Queue-it logo'> </a> </div><div style='text-align: center;'> <h2>Ooops! Service unavailable...</h2> <h4>Please check you internet connection.</h4> </div></div>', { status: 503, statusText: 'Service Unavailable', headers: new Headers({ 'Content-Type': 'text/html' }) }); } }); });```
1542	tamertanca.com.tr.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a remote URL. In this case, the URL is hardcoded to a third-party CDN, but since there is no integrity check (e.g., using a hash or Subresource Integrity), the script could be tampered with in transit or replaced by an attacker, leading to arbitrary code execution within the service worker context.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
1543	tamertanca.com.tr.js	Untrusted Third-Party SDK Usage	Medium	false	N/A	N/A	N/A	N/A	{The updateRegistration function is not a sensitive function in the context of direct input misuse; it is being used with hardcoded parameters. The vulnerability arises from trusting a third-party SDK without proper vetting, but not from dynamic or untrusted input being passed to a sensitive function.}	```updateRegistration('f05b057b-e1e8-4b47-99b8-02b721cd55b5', 'https://psh2.segmentify.com/');```
1544	noice.com.js	Insecure Firebase Configuration Handling	High	true	N/A	9	N/A	standard	{The function `new URL(location).searchParams.get('firebaseConfig')` retrieves a value from the URL query parameters, which is then passed directly to `JSON.parse()`. Since the input is untrusted and dynamically sourced from the URL, an attacker could inject malicious JSON payloads (e.g., with prototype pollution or arbitrary code execution vectors) if the Firebase SDK or application logic processes the parsed object unsafely. This constitutes misuse of `JSON.parse()` with untrusted input, a known security risk.}	```const firebaseConfig = JSON.parse(new URL(location).searchParams.get('firebaseConfig'));```
1545	4dlatest.org.js	Cache Poisoning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the design of the service worker's caching logic. The code caches responses without validating or sanitizing the request, which could allow an attacker to manipulate cache entries if the origin server is compromised or if the service worker is tricked into caching malicious responses. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', function (e) { console.log(e.request.url); e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request); })); });```
1546	accetedu.in.js	Exposure of Sensitive Information (Firebase Config	High	true	CWE-532	10	firebase.initializeApp	standard	{The firebase.initializeApp function is used with a hardcoded Firebase configuration object that includes sensitive credentials such as apiKey, projectId, and appId. While not directly a misuse of the function, the exposure of these credentials in the service worker script (which is accessible to the client) constitutes a sensitive function misuse because the function is designed to initialize Firebase with credentials that should be kept server-side. This allows attackers to extract and misuse these keys for unauthorized access to Firebase services.}	```firebase.initializeApp({ ...options.firebaseConfig });```
1547	accetedu.in.js	Open Redirect in Notification Click Handler	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a targetUrl derived from event.notification.data.url, which is user-controlled via push notifications. Since the URL is not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with untrusted input.}	```clients.openWindow(targetUrl);```
1548	accetedu.in.js	Insecure Fetch Without Authentication	Medium	true	CWE-306	8	fetch	standard	{The fetch function is called with apiUrl, which is derived from event.notification.data.api_url, a value controlled by the push notification payload. Since no authentication or validation is performed, an attacker can manipulate the notification to trigger fetch requests to arbitrary endpoints, potentially exfiltrating data or performing unintended actions on behalf of the user.}	```fetch(apiUrl);```
1549	accetedu.in.js	Unvalidated JSON Parsing in Push Event	Medium	true	CWE-20	7	JSON.parse	standard	{The JSON.parse function is used to parse event.data.json().data.notification, which originates from a push notification payload. Since the payload is untrusted and not validated, this can lead to JSON parsing vulnerabilities if the data is malformed or contains malicious structures, potentially leading to denial of service or unexpected behavior.}	```const payload = JSON.parse(event.data.json().data.notification);```
1550	accetedu.in.js	Cleartext Storage of Sensitive Information (IndexedDB	Medium	false	CWE-312	0	N/A	N/A	{The writeData function stores the notification token in IndexedDB without encryption. While this involves a custom function, the vulnerability arises from the lack of encryption rather than misuse of a sensitive function. The function itself is not inherently unsafe; the issue is the insecure storage policy.}	```await this.writeData('notification_token', token);```
1551	betvisa365.net.js	Improper Error Handling in CacheFirst Strategy Leading to Potential DoS	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling in the `handlerDidError` function, which logs errors but does not properly handle or recover from them. This can lead to denial-of-service conditions if errors are repeatedly triggered, but it is not caused by misuse of a sensitive JavaScript function such as `importScripts`, `eval`, or `Function`. The error handling is flawed in logic, not due to unsafe function usage.}	```function handlerDidError(ctx) { ctx.error.message = `[workbox] Network handler threw an error: ` + ctx.error.message; console.error(ctx.error, 'Details:', ctx); return null; }```
1552	clubdasgarotas.com.br.js	Improper Validation of Integrity Check Value (External Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute an external script from a hardcoded URL. While the URL is fixed and not derived from user input, the vulnerability lies in the lack of integrity validation (e.g., no subresource integrity checks). This allows an attacker who compromises the CDN (e.g., storage.googleapis.com) to serve a malicious version of workbox-sw.js, leading to arbitrary code execution in the service worker. The misuse is not due to dynamic input but due to the absence of integrity verification, which is a critical security oversight when loading external scripts.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js"");```"
1553	clubdasgarotas.com.br.js	Logic Flaw in URL Exclusion Check	Medium	false	New	0	N/A	N/A	{The function checkNeverCacheList is not a sensitive function misuse. The issue arises from a logical flaw in the URL exclusion check: the function is called with the URL as the 'this' context, but the regex patterns are not properly applied. This is a logic error in the code design, not a misuse of a sensitive function like eval, importScripts, or similar.}	```function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
1554	cusrinagar.edu.in.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key) in the source code, not from misuse of a sensitive JavaScript function. There is no dynamic or untrusted input being passed to any function that could lead to injection or execution risks.}	```var config = { apiKey: 'AAAA6_5s1qI:APA91bHl4VVbcYm043KWLC8sktpdKMHEsUaJhAk4jxIH01EXxkcj1TMadkpOzujlVIKntsa9jt9cUWaWzScdV7oNceVtHer2cEVmuSL2Y-zkfdhOQAiHWqKlhT_L_-4AAHc08mbiBSie', authDomain: 'cusrinagarwebapp.firebaseapp.com', databaseURL: 'https://cusrinagarwebapp.firebaseio.com', projectId: 'cusrinagarwebapp', storageBucket: 'cusrinagarwebapp.appspot.com', messagingSenderId: '1013585860258' };```
1555	deitti.net.js	Insecure Dependency	High	true	CWE-496	10	N/A	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to 'https://static.deitticdn.net/js/localforage.min.js', which is not inherently unsafe. However, the vulnerability arises because the script is loaded from an external, third-party domain. If the domain is compromised or the script is tampered with, it could introduce malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or other attacks. While the input is not dynamic, the reliance on an external script without integrity verification (e.g., subresource integrity) constitutes a misuse of the function in a security-sensitive context.}	```importScripts('https://static.deitticdn.net/js/localforage.min.js');```
1556	departiculares.com.js	Vulnerable Data Handling in Push Event Leading to Potential XSS	High	true	CWE-79	9	registration.showNotification	standard	{The showNotification function is used with data directly extracted from event.data.json() without sanitization. If the title or options contain malicious content (e.g., script tags), it could lead to XSS when rendered in the notification UI, especially if the browser or platform interprets the content as executable.}	```var data = event.data.json(); console.log(data); var title = data.title; var options = data.options; event.waitUntil(self.registration.showNotification(title, options));```
1557	departiculares.com.js	Unvalidated URL in Notification Click Leading to Open Redirect	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with event.notification.data.link, which is user-controlled and unvalidated. This allows an attacker to redirect users to arbitrary URLs, potentially phishing or leading to malicious sites.}	```event.waitUntil(clients.openWindow(event.notification.data.link));```
1558	departiculares.com.js	SSRF Vulnerability in Notification Close Handler	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a URL constructed from event.notification.data.link, which is user-controlled. The baseSiteUrl is derived from the link, allowing an attacker to craft a link pointing to internal resources (e.g., localhost, internal APIs), leading to SSRF.}	"```var baseSiteUrl = event.notification.data.link.split('/index.php')[0]; var tracking = event.notification.data.link.split('/tracking.')[1].split('/')[0]; var url = baseSiteUrl + '/index.php/cod.tracking_push_notification'; event.waitUntil(fetch(url, { method: 'post', async: false, headers: { ""Content-type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: 'tracking=event&event=close&userId=' + event.notification.data.suid + '&vv=' + tracking + '&ve=' + configuration.version }));```"
1559	dlsofficial.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (API key) in client-side code, not from misuse of a sensitive function.}	```const apiKey: 'AIzaSyD-dPuGT5NvP9fduZLm4FYQlExlHX_0j6c'```
1560	dlsofficial.com.js	Improper URL Validation Leading to Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from event.notification.data.url, which is not validated or sanitized. This allows an attacker to craft a notification payload that redirects users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
1561	dlsofficial.com.js	Unvalidated Data Handling in Push Event	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used on untrusted data from event.data.json().data.notification without validation or sanitization. This can lead to injection or execution of malicious payloads if the data is manipulated by an attacker, potentially resulting in cross-site scripting or other client-side attacks.}	```const payload = JSON.parse(event.data.json().data.notification);```
1562	e19999.com.js	Improper Input Validation in Service Worker Cache Matching	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from the use of `e.pathname.includes('/games/allGameList')` in the route matching logic, which does not validate or sanitize the URL path. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by a logic flaw in route matching. The function `includes()` is not inherently sensitive in this context.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); }, r = (r, n) => { Promise.all(r.map(e)).then(e => n(1 === e.length ? e[0] : e)); }, n = { require: Promise.resolve(r) }; self.define = (r, s, t) => { n[r] || (n[r] = Promise.resolve().then(() => { let n = {}; const o = { uri: location.origin + r.slice(1) }; return Promise.all(s.map(r => { switch (r) { case ""exports"": return n; case ""module"": return o; default: return e(r); } })).then(e => { const r = t(...e); return n.default || (n.default = r), n; }); })); }; } define(""./service-worker.js"", [""./workbox-c9728ebb""], function (e) { ""use strict""; importScripts(), e.setCacheNameDetails({ prefix: ""ta2prod_v1"" }), self.skipWaiting(), e.registerRoute(({ url: e, sameOrigin: r }) => ""/"" === e.pathname && !e.search && r, new e.StaleWhileRevalidate({ cacheName: ""html"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameList""), new e.StaleWhileRevalidate({ cacheName: ""agl"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/staticpagesettings/Info/orders""), new e.StaleWhileRevalidate({ cacheName: ""ord"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameName""), new e.StaleWhileRevalidate({ cacheName: ""agn"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""); });```"
1563	ejesa.com.ar.js	Race Condition in Cache Management	High	false	New	N/A	N/A	N/A	{The vulnerability arises from a race condition during cache cleanup in the activate event, but it is not caused by misuse of a sensitive function. The issue stems from timing and ordering of cache deletion operations, not from unsafe function usage.}	```self.addEventListener('activate', function (event) { console.log('[Service Worker] Activating Service Worker ....', event); event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key !== CACHE_STATIC_NAME && key !== CACHE_DYNAMIC_NAME) { console.log('[Service Worker] Removing old cache.', key); return caches.delete(key); } })); })); return self.clients.claim(); });```
1564	ejesa.com.ar.js	Uninitialized Dynamic Cache Variable	High	false	New	N/A	N/A	N/A	{The vulnerability is due to the dynamic cache name being uninitialized until a fetch call resolves, which can lead to cache misses or inconsistent behavior. This is a logic flaw, not misuse of a sensitive function.}	```fetch('./alerts/getversion').then(function (response) { if (response.status !== 200) { console.log('Looks like there was a problem. Status Code: ' + response.status); return; } response.json().then(function (data) { CACHE_DYNAMIC_NAME = 'dynamic-v' + data.version; console.log('Versión de caché actualizada'); }); }).catch(function (err) { console.log('Fetch Error :-S', err); });```
1565	ejesa.com.ar.js	Lack of Subresource Integrity (SRI) for External Resources	Medium	false	CWE-922	N/A	N/A	N/A	{This vulnerability is due to the absence of SRI checks for external resources, which is a configuration or policy issue, not misuse of a sensitive function. The fetch or import operations are not directly involved in the vulnerability.}	```var STATIC_FILES = ['/Home/Index', '/Scripts/appEJESA.js', '/Content/layoutstyles2.css', '/manifestEJESA.json', '/structure/carousel-progress-indicator.svg', '/Content/Images/ayuda-2.svg', '/Content/Images/LOGOEJESAAZUL.png', '/Content/Images/telefono.svg', '/Content/Images/flecha.svg', '/Content/Images/clip.svg', '/Content/Images/principal.svg', '/Content/Images/ImagesEJESA/ejesa-como-leer-mi-factura-min.jpg', '/Content/Images/ImagesEJESA/ejesa-proveedores-min.jpg', '/Content/Images/ImagesEJESA/tercer-pueblo-solar-min.jpg', '/Content/Images/ImagesEJESA/ejesa-tarifas-min.jpg', '/Content/Images/ImagesEJESA/ejesa-alta-de-servicio-min.jpg', '/Content/Images/ImagesEJESA/ejesa-segundo-pueblo-solar-min.jpg', '/Content/Images/ImagesEJESA/slide3-min.jpg', 'https://fonts.googleapis.com/css?family=Montserrat:200,300,400,500,600,700', 'https://fonts.googleapis.com/css?family=Roboto:200,300,400,500,600,700', 'https://cdn.ampproject.org/v0/amp-sidebar-0.1.js', 'https://cdn.ampproject.org/v0/amp-form-0.1.js', 'https://cdn.ampproject.org/v0/amp-accordion-0.1.js', 'https://cdn.ampproject.org/v0/amp-bind-0.1.js'];```
1566	ejesa.com.ar.js	Cache Poisoning via Unvalidated Dynamic Content	Medium	true	CWE-921	N/A	fetch	standard	{The fetch function is used to retrieve and cache dynamic content without validating the response or ensuring the request is safe. Since CACHE_DYNAMIC_NAME is dynamically set from a remote endpoint, an attacker could manipulate the version endpoint to inject malicious content into the cache, leading to cache poisoning. The fetch call is directly responsible for introducing untrusted data into the cache.}	```event.respondWith(caches.open(CACHE_DYNAMIC_NAME).then(function (cache) { console.log('wdofetch', CACHE_DYNAMIC_NAME); return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { cache.put(event.request, response.clone()); return response; }); }); }));```
1567	fmgente.com.uy.js	Incorrect Cache Match Handling	Low	false	N/A	0	N/A	N/A	{The vulnerability is related to incorrect handling of cache matching logic during fetch events, but it does not stem from the misuse of a sensitive function such as importScripts, eval, or dynamic code execution. The code correctly uses standard caching APIs (caches.open, cache.match) with static, hardcoded values (offlineFallbackPage), which are not derived from untrusted input. Therefore, no sensitive function misuse is present.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp; } })()); } });```
1568	ifinancebooks.com.js	Improper URL Validation Leading to Cache Poisoning	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper validation of URLs during the fetch event handling, but no sensitive JavaScript function is misused. The code checks if the request URL contains a specific data URL (https://query.yahooapis.com/v1/public/yql), and if so, caches the response. However, the check is based on substring matching (indexOf), which could be bypassed if an attacker crafts a URL that includes the substring but is not the intended endpoint. This could lead to unintended caching behavior, but since no sensitive function like importScripts, eval, or dynamic code execution is involved, it is not a sensitive function misuse.}	```self.addEventListener('fetch', function (e) { console.log('[Service Worker] Fetch', e.request.url); var dataUrl = 'https://query.yahooapis.com/v1/public/yql'; if (e.request.url.indexOf(dataUrl) > -1) { e.respondWith(caches.open(dataCacheName).then(function (cache) { return fetch(e.request).then(function (response) { cache.put(e.request.url, response.clone()); return response; }); })); } else { e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request); })); } });```
1569	jioevents.com.js	Insecure Cache Busting with Math.random	Medium	false	N/A	N/A	N/A	N/A	{The use of Math.random() for cache busting is not inherently a sensitive function misuse, as it does not involve dynamic user input or untrusted data being passed to a function that can lead to code execution or injection. It is a design flaw in cache busting strategy, not a sensitive function misuse.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
1570	jioevents.com.js	Insufficient Input Validation in Cache Keys	High	true	N/A	N/A	cache.match	standard	{The cache.match() function is called with a request constructed from a user-supplied key via this.request(key). If the key is not properly sanitized or validated, an attacker could craft a request that targets unintended cache entries or triggers unexpected behavior, leading to cache poisoning or information leakage. The function is standard and directly exposed to untrusted input.}	```read(key) { return this.cache.match(this.request(key), this.cacheQueryOptions).then(res => { if (res === void 0) { return Promise.reject(new NotFound(this.name, key)); } return res.json(); }); }```
1571	jioevents.com.js	Potential Cache Poisoning in fetchAndCacheOnce	High	true	N/A	N/A	cache.put	standard	{The cache.put() function is called with a request and response derived from a network fetch, where the request URL is directly taken from the input req. If req is not properly validated and the response is malicious, an attacker could inject arbitrary content into the cache, leading to cache poisoning. The function is standard and directly exposed to untrusted input via the req parameter.}	```fetchAndCacheOnce(req, used = true) { if (this.inFlightRequests.has(req.url)) { return this.inFlightRequests.get(req.url); } const fetchOp = this.fetchFromNetwork(req); this.inFlightRequests.set(req.url, fetchOp); try { const res = await fetchOp; if (!res.ok) { throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`); } try { const cache = await this.cache; await cache.put(req, res.clone()); if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) { const metaTable = await this.metadata; await metaTable.write(req.url, { ts: this.adapter.time, used }); } return res; } catch (err) { throw new SwCriticalError(`Failed to update the caches for request to '${req.url}' (fetchAndCacheOnce): ${errorToString(err)}`); } } finally { this.inFlightRequests.delete(req.url); } }```
1572	jioevents.com.js	Insecure Redirect Handling in fetchFromNetwork	Medium	true	N/A	N/A	fetch	standard	{The fetch() function is used recursively with redirected URLs (res.url) without proper validation. If res.url is controlled by an attacker (e.g., via a malicious redirect), this could lead to unintended network requests, potentially to malicious domains, or even open redirect vulnerabilities. The function is standard and directly exposed to untrusted input via res.url.}	```fetchFromNetwork(req, redirectLimit = 3) { const res = await this.cacheBustedFetchFromNetwork(req); if (res['redirected'] && !!res.url) { if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`); } return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1); } return res; }```
1573	kolkataff.win.js	Insecure Data Handling in Notification Click	High	true	N/A	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When used with untrusted or unsanitized input (in this case, event.notification.data), it can lead to open redirect vulnerabilities or phishing attacks, as an attacker could manipulate the notification data to redirect users to malicious sites. The data is not validated or sanitized before being passed to openWindow, making it a sensitive function misuse.}	```event.waitUntil(clients.openWindow(event.notification.data));```
1574	lottoszamok.net.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection, data exfiltration, or full compromise of the service worker's context. In this case, the script is imported from a third-party CDN without any validation, making it vulnerable to supply chain attacks if the CDN is compromised or if the script is malicious.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/653bbb5b56ddc40008550753/service-worker.js"");```"
1575	luckyznh.top.js	Hardcoded API Key in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	```const firebaseConfig = { apiKey: 'AIzaSyDHGb2sb4FoKHlwZ7Fd2iHMm35B6eBGT7g', authDomain: 'lucky-star-962fc.firebaseapp.com', projectId: 'lucky-star-962fc', storageBucket: 'lucky-star-962fc.appspot.com', messagingSenderId: '737753580193', appId: '1:737753580193:web:4e15b29b91f2d6390b66e0', measurementId: 'G-6X7YP70DZ8' };```
1576	luckyznh.top.js	Open Redirect in Notification Click Handler	High	true	N/A	N/A	navigate	standard	{The navigate() method is used with a user-controlled URL from the notification data, allowing an attacker to redirect users to arbitrary sites via malicious push notifications.}	```t.navigate(n);```
1577	luckyznh.top.js	Cross-Site Scripting (XSS) in Cached POST Data	Medium	true	N/A	N/A	caches.put	standard	{The caches.put() function is used to store data from a POST request without sanitization, allowing an attacker to inject malicious scripts into the cache, which can be served to users.}	```e.respondWith(t.json().then(e => caches.open(n).then(t => t.put(n, new Response(JSON.stringify(e))))).then(() => o))```
1578	luckyznh.top.js	Cache Poisoning via Unvalidated Cache Writes	Medium	true	N/A	N/A	caches.put	standard	{The caches.put() function is used with unvalidated input (URL from request), allowing an attacker to poison the cache with malicious or unexpected content.}	```return caches.open(getKeyCache(e, 'static')).then(e => e.match(n).then(e => { if (!e) throw new Error(`${n} not found in cache`); return e; }));```
1579	luckyznh.top.js	Weak Domain Validation in Actual Domain Fetch	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from weak string comparison logic, not misuse of a sensitive function.}	```return e.text().then(e => 'fuckrkn' !== e.trim())```
1580	luckyznh.top.js	Insecure Referrer Policy Bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from logic that checks for a specific referrer policy, not from misuse of a sensitive function.}	```const t = new URL(e.request.url); return 'unsafe-url' === e.request.referrerPolicy && '/pwa.html' === t.pathname || '/sw-active' === t.pathname ? e.respondWith(new Response('ok')) : void 0;```
1581	majhapaper.com.js	Vulnerable Origin Check in Caching Logic	High	true	N/A	N/A	fetch	standard	{The code uses fetch(match) to retrieve images from URLs extracted via regex from HTML content. Although it checks if the URL's origin matches location.origin, the origin check is performed after the URL is extracted from untrusted data (HTML content), and the fetch is executed without further sanitization. This allows an attacker to inject a malicious script or image URL that passes the origin check if it's on the same domain, leading to unintended resource fetching and potential cache pollution or data exfiltration.}	```if (new URL(match).origin == location.origin) { fetch(match).then(imagedata => { cache.put(match```
1582	majhapaper.com.js	Insecure No-CORS Fetch in Reachability Check	Medium	true	N/A	N/A	fetch	standard	{The isReachable function uses fetch with mode: 'no-cors' to test connectivity. This allows the service worker to make cross-origin requests without proper CORS validation, potentially exposing the user to cross-origin data leakage or unintended network activity if the target URL is controlled by an attacker. The fetch is used with untrusted URLs (passed as parameter), and the no-cors mode bypasses normal security checks, increasing risk.}	```return fetch(url, { method: 'HEAD', mode: 'no-cors' }).then(function (resp) { return resp && (resp.ok || resp.type === 'opaque'); }).catch(function (err) { console.warn('[conn test failure]:', err); });```
1583	majhapaper.com.js	Unvalidated URL Caching in Message Handler	Medium	true	N/A	N/A	pwaForWpprecacheUrl	custom	{The message handler directly calls pwaForWpprecacheUrl(event.data.url) without validating or sanitizing event.data.url. Since event.data.url is user-controlled, this allows an attacker to force the service worker to cache arbitrary URLs, potentially leading to cache pollution, resource exhaustion, or even remote code execution if the cached content is later executed. The pwaForWpprecacheUrl function is custom and processes the URL without sufficient validation.}	```case 'cache': pwaForWpprecacheUrl(event.data.url); break;```
1584	majhapaper.com.js	Insecure IndexedDB Data Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of user-uploaded data (image) via FileReader and IndexedDB, but not from misuse of a sensitive function. The FileReader and IndexedDB APIs are used correctly; the issue is in the lack of validation or sanitization of the uploaded data, which could lead to data integrity issues or storage abuse, but not direct function misuse.}	```const reader = new FileReader(); reader.onload = async event => { const imageData = event.target.result; const db = await openDatabase(); await saveData(db, { id: 'sharedData', title: title, text: text, url: link, image: imageData }); console.log('Data saved to IndexedDB'); return Response.redirect(url.pathname + '/?share-target', 303); }; reader.readAsDataURL(image);```
1585	majhapaper.com.js	Weak Cross-Origin Request Filtering	Medium	false	N/A	N/A	N/A	N/A	{The code checks if the request origin matches location.origin, but this check is performed after the URL is already parsed and used in the fetch logic. The vulnerability is in the logic flow and insufficient validation, not in the misuse of a sensitive function. The URL is not dynamically constructed from untrusted input in a way that would trigger a sensitive function misuse.}	```if (new URL(event.request.url).origin !== location.origin) return;```
1586	melody4arab.online.js	Hardcoded Sensitive Data in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (Firebase API key, VAPID key, etc.) in the script, not from misuse of a sensitive function.}	```const options = { firebaseConfig: { projectId: 'push-ab76d', messagingSenderId: '649159050506', appId: '1:649159050506:web:1c3432ee31c29b6f2c66f3', apiKey: 'AIzaSyAumO_iOYVuA2iHyD-BDkq_WVLfef6Qbdg' }, vapid_public_key: 'BHcqcefLBNngUMePbStVLKcbM863NOF44yG_66mwdEtwfXSPOLF4H2C9YA6plEQKsDVGEs3b5OTIOgCgNcPj3yU' };```
1587	melody4arab.online.js	Insecure URL Handling in Notification Click Handler	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic targetUrl derived from notification data, which is user-controlled. If an attacker can manipulate the notification payload, they can redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
1588	melody4arab.online.js	SSRF via Unvalidated URL in getDomainAndHostname	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used with a user-supplied url parameter without validation. This allows an attacker to craft URLs pointing to internal resources (e.g., localhost, internal IPs), enabling Server-Side Request Forgery (SSRF) attacks.}	```const urlObj = new URL(url);```
1589	melody4arab.online.js	Missing Origin Validation in Message Handler	High	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener('message', ...) handler processes incoming messages without validating the origin of the message. This allows malicious clients or iframes to send arbitrary commands to the service worker, potentially leading to unauthorized actions or data exposure.}	```self.addEventListener('message', event => { const { command, url } = event.data; ... });```
1590	minicity.com.tr.js	Third-party script inclusion without integrity check	Medium	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious code from third-party domains. In this case, the script is loaded from 'https://cdn.segmentify.com/v3/push/sw.js', which is an external, untrusted source. If the source is compromised or if the script is modified in transit, the service worker could execute arbitrary code, leading to security breaches such as data exfiltration or session hijacking.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
1591	mubawab.tn.js	Improper Input Validation Leading to Open Redirect	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from using the `url` parameter from the notification data without validation, which could lead to an open redirect if the URL is controlled by an attacker. However, this is not caused by misuse of a sensitive function like `importScripts` or `eval`, but rather by improper input validation in a control flow decision.}	```let url = event.notification.data.url; event.notification.close(); event.waitUntil(self.clients.matchAll({ type: 'window' }).then(windowClients => { for (var i = 0; i < windowClients.length; i++) { var client = windowClients[i]; if (client.url === url && 'focus' in client) { return client.focus(); } } if (self.clients.openWindow) { return self.clients.openWindow(url); } }));```
1592	mubawab.tn.js	Use of Outdated Third-Party Library	Medium	false	CWE-426	N/A	N/A	N/A	{This vulnerability stems from using an outdated version of Firebase JS SDK (7.2.3), which may contain known security flaws. However, it is not caused by misuse of a sensitive JavaScript function, but rather by dependency management issues.}	```importScripts('https://www.gstatic.com/firebasejs/7.2.3/firebase-app.js');```
1593	mubawab.tn.js	Hardcoded Sensitive Information	Low	false	CWE-532	N/A	N/A	N/A	{The `messagingSenderId` is hardcoded in the code, which is a configuration issue rather than misuse of a sensitive function. The function `firebase.initializeApp()` is used correctly, but the sensitive data is exposed in the source.}	```firebase.initializeApp({'messagingSenderId': '291135122116'});```
1594	mubawab.tn.js	Unsanitized Data in Notification Payload	Medium	false	CWE-79	N/A	N/A	N/A	{The notification body is populated directly from `payload.data.description` without sanitization, which could lead to XSS if the payload is controlled by an attacker. However, this is not due to misuse of a sensitive function like `eval` or `importScripts`, but rather due to unsanitized data handling in a notification context.}	```const notificationOptions = {body: payload.data.description, icon: payload.data.icon, data: {url: payload.data.url}};```
1595	osmrtnice.si.js	Improper Input Validation (Insecure Accept Header Handling)	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of the Accept header, which is used to determine whether to serve an offline SVG image. However, this is not caused by misuse of a sensitive JavaScript function like importScripts, eval, or similar; it is a logic flaw in header handling. The code checks for 'image' in the Accept header, but this check is not inherently dangerous and does not involve dynamic code execution or unsafe function calls.}	```if (request.headers.get('Accept').indexOf('image') !== -1) { return new Response('<svg role=\'img\' aria-labelledby=\'offline-title\' viewBox=\'0 0 400 300\' xmlns=\'http://www.w3.org/2000/svg\'><title id=\'offline-title\'>Offline</title><g fill=\'none\' fill-rule=\'evenodd\'><path fill=\'#D8D8D8\' d=\'M0 0h400v300H0z\'/><text fill=\'#9B9B9B\' font-family=\'Helvetica Neue,Arial,Helvetica,sans-serif\' font-size=\'72\' font-weight=\'bold\'><tspan x=\'93\' y=\'172\'>offline</tspan></text></g></svg>', { headers: { 'Content-Type': 'image/svg+xml' } }); }```
1596	outdoors91.com.js	Improper Neutralization of Input During Web Page Generation ('Open Redirect')	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided by the notification data, which is derived from untrusted input (event.notification.data.notifURL). Since this input is not validated or sanitized, an attacker could craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.notifURL));```
1597	satu168.win.js	Misconfigured CORS Request Handling	High	true	CWE-807	10	N/A	standard	{The code modifies a request to set `mode: 'no-cors'` while also setting `cache: 'default'`, which can lead to unintended CORS bypass or misbehavior in cross-origin requests. This is a misuse of the `Request` constructor, a standard JavaScript API, when handling requests that may originate from untrusted or cross-origin sources. The `no-cors` mode restricts responses to opaque, but combining it with `cache: 'default'` may cause unexpected caching behavior or allow unintended access to cross-origin resources if not properly controlled.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
1598	sectorvip.cl.js	Vulnerable Session Management via URL Parameter	High	true	CWE-300	9	RegExp.prototype.match	standard	{The vulnerability arises from using `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter directly from the URL. This allows an attacker to manipulate the URL to spoof session state (e.g., `?loggedIn=true`) without actual authentication, leading to unauthorized access. The `match()` function is standard but misused here by trusting URL parameters without validation or sanitization.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
1599	waiijing.com.js	Information Exposure Through Error Logging	Low	false	N/A	0	N/A	N/A	{The vulnerability arises from logging error details using console.error, which may expose sensitive information such as stack traces or internal error messages to the console. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by poor error handling practices. The console.error function itself is not inherently sensitive in this context, and no dynamic or untrusted input is being logged in a way that introduces a direct security risk.}	```console.error(ctx.error, 'Details:', ctx);```
1600	cleo.com.js	XSS via Unsanitized postMessage Data	High	true	CWE-79	10	N/A	standard	{The vulnerability arises from the use of `postMessage()` with unsanitized data received from `r`, which is derived from a JSON-parsed request body (`await n.clone().json()`). Since `postMessage()` can transmit arbitrary data to other contexts (e.g., iframes or workers), and if the receiving context evaluates or renders this data without sanitization, it can lead to XSS. The data is not validated or escaped before being sent, allowing an attacker to inject malicious scripts.}	```i.postMessage(r);```
1601	colorectalcancer.org.js	XSS via Dynamic Script Injection	High	true	N/A	9	document.createElement	custom	{The code dynamically creates a <script> element using document.createElement('script') and assigns its src attribute from a dynamically computed URL (t). Since t is derived from a user-controlled or untrusted source (via URL construction), an attacker can manipulate the URL to inject arbitrary scripts, leading to XSS. The script is then appended to the document head, executing in the context of the service worker or page, depending on environment.}	```if ('document' in self) { const e = document.createElement('script'); e.src = t, e.onload = s, document.head.appendChild(e); }```
1602	drawception.com.js	Improper Validation of Cache Update in Custom Event	High	true	CWE-79	9	caches.put	standard	{The `caches.put()` function is used to store a response in the cache, but it is called without validating the `response` object received from the `refreshOffline` custom event. Since this event can be triggered by external or untrusted sources (e.g., via postMessage or other client-side triggers), the response may be malicious or tampered with, allowing an attacker to inject arbitrary content into the cache. This could lead to cache poisoning, where subsequent requests are served malicious content, potentially compromising user data or enabling phishing attacks. The lack of validation on the `response` object makes this a sensitive misuse of a standard caching API.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('offline').then(function (cache) { console.log('Offline page updated from refreshOffline event: ' + response.url); return cache.put(offlinePage, response); }); });```
1603	freefincal.com.js	Caching of User-Specific Pages Leading to Data Leakage	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching static pages (startPage and offlinePage) without considering dynamic user-specific content. However, no sensitive JavaScript function is misused here; the issue stems from a design flaw in caching strategy rather than improper use of a function like importScripts, eval, or dynamic code execution.}	```const filesToCache = [startPage, offlinePage];```
1604	biwako-visitors.jp.js	Insecure Plugin Handling Leading to Arbitrary Code Execution	High	true	New	9	getProp	standard	"{The function getProp is used to dynamically resolve plugin constructors via p.use, which is derived from user-controlled or untrusted configuration. This allows an attacker to inject arbitrary plugin names (e.g., ""evilPlugin"") that could resolve to malicious constructors, leading to arbitrary code execution when instantiated with new. The dynamic property access via reduce and split creates a dangerous reflective pattern.}"	```const plugins = (entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config));```
1605	biwako-visitors.jp.js	Remote Code Execution via Untrusted CDN Import	Medium	true	CWE-444	8	importScripts	standard	{The importScripts function is used with a URL derived from the options.workboxURL configuration, which is hardcoded but could be manipulated if the configuration is loaded from an untrusted source. Since importScripts executes scripts from the provided URL, an attacker who can modify the workboxURL value can force the service worker to load and execute arbitrary remote code, leading to full compromise of the service worker environment.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
1606	destinytracker.com.js	Insecure Notification Data Handling	Medium	true	CWE-601	N/A	t.data.json()	standard	{The function t.data.json() is used to parse incoming push notification data, which is untrusted by nature. Since the data is directly extracted and used to construct notification properties (like body, icon, image, actions), an attacker could craft malicious payloads to inject arbitrary content, potentially leading to phishing, cross-site scripting (XSS) via embedded scripts in images or URLs, or misleading users with spoofed notifications. This misuse of a standard function with untrusted input constitutes a sensitive function misuse.}	```self.addEventListener('push', t => { let i = t.data.json(); const e = { data: i, body: i.body, icon: i.iconUrl, image: i.imageUrl, actions: i.actions.map(n => ({ action: n.key, title: n.label, icon: n.iconUrl })), requireInteraction: i.requireInteraction }; t.waitUntil(self.registration.showNotification(i.title, e)); });```
1607	destinytracker.com.js	Insecure Cookie Handling	Medium	true	CWE-113	N/A	self.cookieStore.get	standard	{The function self.cookieStore.get is used to retrieve a cookie value ('__trndid') without any validation or sanitization. While cookies are typically considered safe for session identifiers, the lack of proper handling (e.g., no checks for tampering or expiration) and direct use in subsequent API calls (e.g., sending to a remote server) can lead to session fixation or information leakage if the cookie is compromised or manipulated. This constitutes misuse of a standard API with insufficient security controls.}	```async function l() { if (!self.cookieStore) return null; let t = await self.cookieStore.get('__trndid'); return t == null ? void 0 : t.value; }```
1608	destinytracker.com.js	Lack of Cache Busting	Low	false	CWE-937	N/A	N/A	N/A	{This issue arises from the absence of revision hashes in the manifest entries, which is a configuration or deployment issue rather than misuse of a sensitive function. The code does not invoke any function in a way that introduces security risk; it merely lists assets without versioning. Therefore, it is not a sensitive function misuse.}	```self.wbManifest = [{ 'revision': null, 'url': 'assets/__KSfbbz.css' }, { 'revision': null, 'url': 'assets/_rS61V1D.css' }, ...];```
1609	nestlefamilyclub.es.js	External Script Execution Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the script is loaded from a hardcoded external URL (https://s3.amazonaws.com/cdn.mubiquo.net/mplatform/serviceworker-4.0-nfc.js). While the URL is not dynamically constructed from untrusted input, the lack of integrity verification (e.g., using a Subresource Integrity hash) means the script could be tampered with if the source is compromised, leading to arbitrary code execution within the service worker context. This constitutes a sensitive function misuse due to the absence of security safeguards, even though the URL is static.}	```importScripts('https://s3.amazonaws.com/cdn.mubiquo.net/mplatform/serviceworker-4.0-nfc.js');```
1610	runnings.com.js	Cache Poisoning via Cross-Origin Response Handling	High	true	N/A	N/A	copyResponse	standard	{The function copyResponse uses new URL(e.url).origin to extract the origin of a response URL. If an attacker can manipulate the response URL to point to a cross-origin resource, this function will throw an error, but if the origin check is bypassed or misconfigured, it could allow caching of cross-origin responses, leading to cache poisoning. The misuse lies in the assumption that the URL is safe without proper validation.}	```const r = new URL(e.url).origin; if(r !== self.location.origin) throw new WorkboxError_WorkboxError('cross-origin-copy-response'```
1611	runnings.com.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The configuration of ExpirationPlugin_ExpirationPlugin with maxEntries and maxAgeSeconds does not involve any sensitive function misuse. The vulnerability arises from misconfiguration rather than improper use of a sensitive function.}	```new ExpirationPlugin_ExpirationPlugin({maxEntries: 60```
1612	runnings.com.js	Inadequate Cache Key Validation	High	true	N/A	N/A	createCacheKey	standard	{The function createCacheKey constructs a cache key from a URL without validating the input. If an attacker can supply a malicious URL, it could lead to cache key collisions or unintended cache behavior. The function uses new URL(e, location.href) which is sensitive to untrusted input.}	```const {cacheKey: e```
1613	runnings.com.js	Unvalidated Prefetch Request Handling	Medium	false	N/A	N/A	N/A	N/A	{The function isResizedCatalogImage checks if a URL is a catalog image and if its width parameter is a valid number. This is a logic issue rather than misuse of a sensitive function. The vulnerability stems from insufficient validation of the URL parameters, not from a sensitive function call.}	```function isResizedCatalogImage(e) { var t = e.url; return function isCatalogImage(e) { return e.url.pathname.startsWith('/media/catalog'); }({url: t}) && !isNaN(j(t)); }```
1614	runnings.com.js	Insecure Dynamic Script Execution	High	true	N/A	N/A	importScripts	standard	{The function importScripts is used to load a script from a hardcoded URL. While the URL is fixed, the use of importScripts with any external script is inherently risky as it can lead to code injection if the URL is compromised or if the script is not properly vetted. The function is sensitive because it executes arbitrary JavaScript from a remote source.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.3/workbox-sw.js')```
1615	hr2.de.js	Insecure Caching of Sensitive Data	High	true	CWE-921	N/A	self.addEventListener	standard	{The vulnerability arises from the use of self.addEventListener('fetch', ...) which processes all incoming fetch requests without validating or sanitizing the request URLs. While the function itself is not inherently dangerous, its misuse in this context allows potentially malicious or unintended resources to be cached and served without proper checks, especially if the service worker is misconfigured or if the origin is compromised. The caching logic does not validate the origin or content type of the requested resources, leading to insecure caching of sensitive data.}	"```self.addEventListener(""fetch"", e => { const { request: t } = e; t.headers.has(""range"") || e.respondWith(async function () { const n = await caches.match(t); if (n) return n; try { const n = await e.preloadResponse; return n || (await fetch(t)); } catch (e) { if (""navigate"" === t.mode) { const e = await caches.open(CACHE_VERSION + CACHE_NAME); return await e.match(OFFLINE_URL); } throw e; } }()); });```"
1616	hr2.de.js	Improper Input Validation in Notification Handling	Medium	true	CWE-703	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with user-provided data (e.data.title and e.data.notificationOptions) without proper sanitization or validation. This allows an attacker to inject arbitrary content into notifications, potentially leading to phishing, social engineering, or cross-site scripting (XSS) if the notification content is rendered in a context that interprets HTML or JavaScript. The lack of input validation makes this a sensitive misuse of a standard API.}	```self.registration.showNotification(e.data.title, t);```
1617	hr2.de.js	Insecure Redirection in Notification Click Handler	High	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is called with a user-supplied URL (a) from the notification data without validation. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing, malware distribution, or session hijacking. Since the URL is directly taken from untrusted input, this constitutes a sensitive misuse of a standard browser API.}	```clients.openWindow(a).then(e => e ? e.focus() : null);```
1618	similarworlds.com.js	XSS via Notification Data	High	true	CWE-79	10	N/A	standard	{The function `self.registration.showNotification()` is a standard browser API that displays notifications. When user-controlled data (e.g., from `e.data.body` or `t[i].body`) is passed directly to this function without proper sanitization, it can lead to XSS if the notification content is rendered in a context where HTML or script is interpreted. The `normalizeBody()` function is applied, but it only strips tags and decodes entities — it does not prevent all XSS vectors, especially if the notification UI interprets content as HTML.}	"```self.registration.showNotification(""SimilarWorlds"", t);```"
1619	similarworlds.com.js	Insufficient Input Sanitization	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability is attributed to insufficient sanitization in `normalizeBody()` and `normalizeLink()`, but these are custom functions and not sensitive functions per se. The issue lies in the logic of the sanitization rather than misuse of a sensitive API.}	"```return html_entity_decode(strip_tags(e.replace(/<br \/>/g, "" "").replace(/<div/g, "" <div""))));```"
1620	similarworlds.com.js	SSRF via Untrusted URL Handling	Medium	true	CWE-918	9	N/A	standard	{The function `clients.openWindow(r)` is a standard browser API that opens a new window or tab. The URL `r` is constructed using `n` (which may come from `e.notification.data.origin`) and `t` (from `e.notification.data.link`). If these values are controlled by an attacker, they can be manipulated to redirect to internal or external resources, leading to SSRF. The URL is not validated or sanitized before being passed to `openWindow`.}	```return !clients.openWindow || clients.openWindow(r);```
1621	rcomscout.com.js	Improper Input Validation (Open Redirect)	Medium	true	CWE-601	8	concatenation	standard	{The URL is constructed by concatenating `self.location.origin` with `payload.dataType`, which is derived from untrusted push notification data. If an attacker can control `payload.dataType`, they can redirect users to arbitrary domains, leading to open redirect vulnerabilities. The `clients.openWindow(url)` function is then used to open this constructed URL, making it a sensitive function misuse.}	```const url = `${self.location.origin}${payload.dataType}`;```
1622	simpalsid.com.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is exposed in the source code, but it is not a result of misuse of a sensitive function such as importScripts, eval, or dynamic code execution. It is a static configuration issue.}	```const config = { apiKey: 'AIzaSyAGqAAy66IeP59OL1vEpJQN2gJ2lVTcJkM', authDomain: 'api-project-1047417137596.firebaseapp.com', databaseURL: 'https://api-project-1047417137596.firebaseio.com', projectId: 'api-project-1047417137596', storageBucket: '', messagingSenderId: '1047417137596' };```
1623	simpalsid.com.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with user-controlled data from notification.data.url without validation or sanitization. An attacker could craft a notification payload with a malicious URL, causing the browser to open an unintended site, leading to open redirect.}	```notification.data && notification.data.url !== '' && clients.openWindow(notification.data.url);```
1624	csclocator.com.js	Exposure of Sensitive Information to an Unauthorized Actor	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (API key, project ID, etc.) in the script, not from misuse of a sensitive JavaScript function. These values are exposed in the source code and can be accessed by anyone who views the service worker.}	```const options = { firebaseConfig: { projectId: 'larapush-a408d', messagingSenderId: '36384989321', appId: '1:36384989321:web:d024fe20b687466a226658', apiKey: 'AIzaSyA7SwfF-YeY4hzu6yZlk7Vaatq0NPGVBTQ' }, domain: 'www.csclocator.com', api_url: 'https://lapush.cardmantr.com/api/token', vapid_public_key: 'BOUPRKcUgq1PyE-QWUBubRT5Tpi1YK0F0rry1GRmhvXHvzgi25QcSSj18kMdWY83vC8jMoj4VFI1xpvt9GgiHwE' };```
1625	csclocator.com.js	Improper Input Validation	Medium	true	N/A	N/A	clients.openWindow	standard	{The code retrieves `targetUrl` and `apiUrl` directly from notification data, which is untrusted input. It then passes these values to `clients.openWindow()` and `fetch()`, both of which execute network requests or open windows based on user-controlled data. This allows an attacker to craft a notification payload that redirects users to malicious sites or makes unauthorized API calls.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl);```
1626	csclocator.com.js	Insecure Data Storage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (like notification tokens) in IndexedDB without encryption or additional security controls. This is a data storage issue, not a misuse of a sensitive JavaScript function. The functions used (e.g., `writeData`, `openDatabase`) are custom and not inherently dangerous when used correctly, but the lack of encryption makes the stored data vulnerable.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value });```
1627	galinfo.com.ua.js	Hardcoded Sensitive Information	Medium	false	CWE-312	N/A	N/A	N/A	{The hardcoded appKey is a sensitive value, but it is not the result of misuse of a sensitive function. It is simply stored in a variable, which is a static data issue, not a functional misuse.}	"```self[`appKey`] = ""0dfe2d2694bbb2135dd41c39eb43d34a"";```"
1628	galinfo.com.ua.js	Untrusted External Script Loading	High	true	CWE-434	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load external scripts. Here, it is used with a dynamically constructed URL derived from self[`hostUrl`], which is hardcoded but could be manipulated if the value were derived from untrusted input. Since the URL is not hardcoded directly and is built via string interpolation, it represents a potential vector for script injection if hostUrl were user-controllable. Even though hostUrl is hardcoded in this case, the pattern of using importScripts with a variable URL is inherently risky and qualifies as sensitive function misuse.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1629	trustnodes.com.js	Improper URL Validation in Notification Click Handler	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from event.notification.data.url, which originates from a push notification payload, it is untrusted and unsanitized. An attacker could craft a malicious push notification with a URL pointing to a phishing site, malware, or a cross-site scripting (XSS) payload, leading to unauthorized navigation and potential user compromise.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1630	quickdriverupdater.com.js	Incorrect Template Literal Usage	Low	false	New	N/A	N/A	N/A	{The issue arises from incorrect template literal syntax: 'innovana-${version}' uses single quotes instead of backticks, which prevents proper interpolation. This is a syntax error, not a security vulnerability caused by a sensitive function.}	```const cacheName = 'innovana-${version}';```
1631	dailydeals.ai.js	Improper Input Validation in Dynamic API Call Handling	High	true	CWE-78	9	[]	N/A	{The code dynamically accesses a function from the MessageAPI object using user-controlled input `api` from `event.data`. This allows an attacker to invoke any function defined in MessageAPI, potentially leading to unintended behavior or privilege escalation if the API includes sensitive operations.}	```const { api } = event.data; if (api) MessageAPI[api](event, event.data);```
1632	dailydeals.ai.js	Insecure IndexedDB Storage Without Sanitization	Medium	true	CWE-78	8	[]	N/A	{The `idbKeyval.set` function is used to store user-controlled `path` and `resources` values directly into IndexedDB without sanitization. This can lead to data tampering or injection if the stored data is later used unsafely in dynamic contexts, such as constructing URLs or executing code.}	```MessageAPI.setPathResources = (event, { path, resources }) => { event.waitUntil(idbKeyval.set(`resources:${path}`, resources)); };```
1633	dailydeals.ai.js	Unvalidated URL Parameter Parsing in Navigation Handler	Medium	true	CWE-78	7	[]	N/A	{The code parses URL path parameters using `pathname.match(/:(.+)/)[1]` and splits them without validation, allowing arbitrary key-value pairs to be injected into the `data` object. This can lead to unintended behavior if these values are later used in dynamic function calls or URL construction.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
1634	dailydeals.ai.js	Unrestricted Dynamic Function Execution in API Handler	High	true	CWE-78	9	[]	N/A	{The code dynamically invokes functions from the MessageAPI object using user-controlled `data.api`, which is derived from parsed URL parameters. This allows an attacker to trigger any function in MessageAPI, potentially leading to arbitrary code execution or data leakage if the functions perform sensitive operations.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1635	boltz.exchange.js	Uncontrolled Resource Consumption (Excessive Caching)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching the root path ('/') which may lead to excessive caching of resources, but it is not due to misuse of a sensitive function. The function `cache.addAll()` is used correctly with a static array of assets.}	"```const cacheName = ""site-cache-v1""; const assetsToCache = [""/""]; self.addEventListener(""install"", event => { self.skipWaiting(); event.waitUntil(caches.open(cacheName).then(cache => { return cache.addAll(assetsToCache); })); });```"
1636	piczel.tv.js	Open Redirect via Notification Data	High	true	CWE-601	8	new URL	N/A	{The new URL constructor is used with notification.data.link, which is derived from untrusted notification payload. If an attacker can control the link field in the notification payload, they can craft a URL that redirects to an arbitrary external site, leading to an open redirect vulnerability. The URL is then used to open a new window via clients.openWindow(url), enabling phishing or malicious redirection.}	```let url = new URL(notification.data.link, self.location.origin).href;```
1637	piczel.tv.js	Cache Poisoning via Insecure Regex	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from an insecure regex pattern /avatars\/(\w+)/ that allows any word character (including potentially malicious ones) in the avatar path. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a flawed regular expression design. The function isAvatarRequest is custom and not inherently sensitive; the issue lies in the regex logic itself, not in how a sensitive function is used.}	```const avatarUrlRegex = /avatars\/(\w+)/;```
1638	bimbisaniebelli.it.js	Unrestricted Import of Code from Untrusted Sources	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to 'https://pushdeploy.estrema.it/shared/sw/serviceworker-BS230901.js', which is an external, potentially untrusted source. While the URL is not dynamically constructed from user input, the act of importing code from an external domain without proper validation or trust verification constitutes a high-risk vulnerability, as it allows an attacker who compromises the external server to inject malicious code into the service worker. This can lead to full control over the service worker’s behavior, including intercepting network requests, manipulating cache, or stealing sensitive data.}	```importScripts('https://pushdeploy.estrema.it/shared/sw/serviceworker-BS230901.js');```
1639	ultrasawt.com.js	Incomplete Background Message Handling	Medium	false	CWE-408	N/A	N/A	N/A	{The vulnerability is due to incomplete handling of background messages in Firebase Messaging, not misuse of a sensitive function. The code logs the payload but does not process or respond to it appropriately, which may lead to missed notifications or inconsistent behavior. No sensitive function is being misused here.}	"```importScripts('/themes/custom/ultrasawt/js/push/prod/ultrasawtpush.js');const messaging = firebase.messaging();messaging.onBackgroundMessage(function (payload, notification, data) {console.log(payload, "" ==== "", notification, data);});```"
1640	zicasso.com.js	Improper Input Validation in API Request Handling	High	true	New	9	N/A	standard	{The vulnerability arises from the use of `new URL(event.request.url)` to parse the request URL, which is then used to extract a pathname and subsequently split into parameters. The `match(/:(.+)/)` and `split('&')` operations are applied without validating or sanitizing the input, allowing an attacker to craft a malicious URL that could lead to unintended behavior, such as triggering unintended API calls or causing injection-like effects. While `new URL()` itself is not inherently dangerous, its misuse with untrusted input in this context contributes to improper input validation.}	```const navigationRoute = new NavigationRoute(async ({ event }) => { if (event.request.url.match(/\/.gatsby-plugin-offline:.+/)) { return handleAPIRequest({ event }); } ... });```
1641	zicasso.com.js	Unvalidated API Function Execution	Medium	true	New	8	N/A	standard	{The `MessageAPI[data.api]()` invocation uses a dynamically derived `data.api` value obtained from URL parameters, which is not validated or sanitized. This allows an attacker to invoke arbitrary functions within the `MessageAPI` object, potentially leading to unintended behavior or privilege escalation. The use of `MessageAPI[data.api]()` with untrusted input constitutes a classic case of unsafe dynamic function invocation, which is a known security risk.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1642	zicasso.com.js	Unrestricted Cache First Strategy	Low	false	CWE-922	N/A	N/A	N/A	{The vulnerability stems from the broad regex pattern `/(\.js$|\.css$|static\/)/` used in `workbox.routing.registerRoute`, which allows caching of potentially sensitive or dynamic resources without proper validation. However, this is not caused by misuse of a sensitive function, but rather by a misconfigured routing strategy. The `registerRoute` function is used correctly; the issue lies in the policy defined by the regex, not in the function's misuse.}	```workbox.routing.registerRoute(/(\.js$|\.css$|static\/)/, new workbox.strategies.CacheFirst(), 'GET');```
1643	grupozelo.com.js	Hardcoded Credentials	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials in the configuration object, not misuse of a sensitive function.}	"```var config = '{""appserviceKey"":""BEfSzu6msZCxunFWyD6A3xIJSGJVwmCxfu762dH0vGhU6Jtpfjp2WgA4IYIosCyy1YSLO12sany_qG901YkhjdM="",""apiKey"":""ABEYKWWThOhwwWfsD9M4WbDi4"",""accountToken"":""ABE_EA9z4ryC00JPy2oWH8MGo"",""appver"":""0.0.0"",""apiHost"":""https://cab1rp0-webpush.oraclersys.com"",""lazy"":false}';```"
1644	grupozelo.com.js	Untrusted External Script Inclusion	Medium	true	N/A	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (https://api.pushio.com/webpush/sdk/service_min.js), it introduces a risk if the external script is not fully trusted or could be compromised, allowing an attacker to inject malicious code into the service worker. Although the URL is hardcoded here, the function itself is sensitive because it can execute arbitrary scripts from remote sources.}	"```importScripts(""https://api.pushio.com/webpush/sdk/service_min.js"");```"
1645	kopalnia.pl.js	Improper Input Validation Leading to Cache Poisoning	High	true	CWE-20	9	N/A	standard	{The getConfigUrl method uses the adapter.parseUrl function to parse a URL passed as input. This function internally uses the standard JavaScript URL constructor, which is a sensitive function because it can be manipulated by untrusted input. If an attacker can control the input URL, they may craft a URL that bypasses origin checks (e.g., via URL normalization or protocol manipulation), leading to cache poisoning where malicious or unintended resources are cached under the same key. The function returns the full URL if the origin does not match, allowing an attacker to inject arbitrary URLs into the cache system, potentially leading to data leakage or execution of unintended content.}	```this.getConfigUrl = (url) => { const parsed = this.adapter.parseUrl(url, this.scope.registration.scope); if (parsed.origin === this.origin) { return parsed.path; } else { return url; } };```
1646	soustix.com.br.js	Hardcoded Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (appserviceKey, apiKey, accountToken) in the client-side JavaScript, not from misuse of a sensitive function. These values are embedded directly in the code and exposed to the client, allowing attackers to extract and misuse them.}	"```const config = '{""appserviceKey"":""BBbXbmrocsHg6sGsOZAqxW5SK5JHDa6hycpcUQqnWqaUl1h1obFVdn75gL4rSrtfTx6sLD6HjVcLmzxhlUVzR1o="",""apiKey"":""ABEVIlUloBkH2vAEoDteBHteg"",""accountToken"":""ABEgd3pX6MJH5y2tPzLOlN-Ck"",""appver"":""0.0.0"",""apiHost"":""https://cqp1qgp-webpush.oraclersys.com"",""lazy"":false}';```"
1647	soustix.com.br.js	Insecure External Script Import	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (https://api.pushio.com/webpush/sdk/service_min.js), it introduces a risk if the script source is not fully trusted or if the URL can be manipulated. Although the URL is hardcoded here, the function itself is sensitive because it can execute arbitrary code from remote sources, potentially leading to code injection or supply chain attacks if the source is compromised.}	```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');```
1648	jbl.de.js	Open Redirect	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a URL in a new window or tab. The URL is derived from the result of the `notification('click', ...)` function, which in turn processes data from `event.notification.data`. Since this data is untrusted and potentially controlled by an attacker, the URL passed to clients.openWindow() can be manipulated to redirect users to arbitrary, malicious websites, leading to an open redirect vulnerability.}	```const open_url = async () => { const url = await notification('click', event.notification.data); if (url && url !== '') { return clients.openWindow(url); } else { return Promise.resolve(); } };```
1649	jbl.de.js	XSS in Notification Content	High	true	CWE-79	10	console.log	standard	{The function console.log() is used to log the output of `event.data.json()`, which parses untrusted data from a push event. While console.log() itself does not directly cause XSS, its use here indicates that untrusted data is being processed and logged, potentially exposing sensitive information or serving as a stepping stone for further exploitation. However, the actual XSS risk arises from the fact that the parsed data is used to construct notification content (via `self.registration.showNotification(notification.title, notification.options)`), which may be rendered in the UI without sanitization, allowing for script injection if the data contains malicious HTML or JavaScript. The console.log() call is a symptom of improper handling of untrusted input, and the real vulnerability lies in the subsequent use of that data in the notification.}	```console.log(event.data.json()); const message = event.data.json();```
1650	dev.ua.js	Hardcoded Secret in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is stored in a variable and does not involve misuse of a sensitive function.}	```self[`appKey`] = `f1ae54592b5334f8895dca120a1f95df`;```
1651	dev.ua.js	Dynamic Script Loading Without Integrity Check	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from self[`hostUrl`], which is hardcoded but could be manipulated if the value were derived from untrusted input. Since the script is loaded without integrity checks, it allows for potential script injection if the host is compromised or if the value is dynamically controlled by an attacker.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1652	thecus.com.js	Caching of External Resources Without Origin Validation	High	true	CWE-918	10	N/A	standard	{The service worker caches responses from any origin without validating the request's origin. The `fetch()` function is used with `e.request`, which can be an arbitrary URL from any origin, and the response is cached without origin checks. This allows an attacker to force the service worker to cache malicious content from external domains, potentially leading to cache poisoning or unauthorized data exposure.}	```self.addEventListener('fetch', e => { let res = caches.match(e.request).then(res => { if (res) return res; return fetch(e.request).then(fetchRes => { caches.open(pwaCache).then(cache => cache.put(e.request, fetchRes)); return fetchRes.clone(); }); }); e.respondWith(res); });```
1653	visasam.ru.js	Insecure External Script Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., 'https://nservw.net/smSmcu8dv.js'), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows an attacker who controls the remote server to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Since the URL is hardcoded and not dynamically derived from untrusted input, the risk is still high due to the lack of trust in the external source.}	```importScripts('https://nservw.net/smSmcu8dv.js');```
1654	breakflip.com.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the script is imported from a remote CDN without any integrity check or validation. While the URL is hardcoded, the lack of integrity verification means that if the remote script is compromised (e.g., due to a supply chain attack or misconfigured CDN), the service worker could execute malicious code. This constitutes a sensitive function misuse because importScripts() can be exploited to load arbitrary code, and even hardcoded URLs are vulnerable if not protected by integrity mechanisms.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6275210cf8f5460009eb479e/service-worker.js"");```"
1655	movieclips.com.js	Hardcoded API Key Exposure	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the hardcoded exposure of the INNERTUBE_API_KEY in the ytcfg configuration object. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure configuration management. The key is embedded directly in the script and can be extracted by attackers, leading to potential abuse of the YouTube API.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
1656	iwanamaker.com.js	Improper Message Origin Validation	Medium	false	New	N/A	N/A	N/A	"{The vulnerability arises from the service worker listening for messages without validating the origin of the message sender. While the code checks for a specific message type (""SKIP_WAITING""), it does not verify that the message originates from a trusted source (e.g., the same origin as the service worker's scope). This could allow a malicious page or script from a different origin to send a message and trigger `self.skipWaiting()`, potentially interfering with the service worker's lifecycle. However, this is not caused by misuse of a sensitive function like `importScripts()` or `eval()`, but rather by a lack of origin validation in event handling.}"	"```self.addEventListener(""message"", function (e) { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
1657	l-camera-forum.com.js	Insecure Handling of loggedIn Parameter	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from directly trusting the `loggedIn` parameter extracted from the URL, which can be manipulated by an attacker to bypass logic. However, no sensitive JavaScript function is misused here — the issue is purely logic-based and not tied to a function like `eval`, `importScripts`, or `fetch` with untrusted input.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
1658	l-camera-forum.com.js	Unvalidated Notification URL in Notification Click Handler	Medium	true	N/A	N/A	clients[0].navigate	standard	{The `clients[0].navigate` function is used with `data.url`, which is derived from server-sent notification data. If an attacker can control this data (e.g., via a compromised server or spoofed push message), they can redirect the user to arbitrary URLs, leading to phishing or malicious redirection. This is a direct misuse of a standard browser API with untrusted input.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
1659	l-camera-forum.com.js	Insecure Fetch with User-Controlled ID in Push Handler	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is called with a URL constructed using `id` from untrusted push data. If the `id` parameter is not validated, an attacker could craft a push message with a malicious ID to trigger unintended server requests, potentially leading to SSRF or data leakage. This is a misuse of the standard `fetch` API with untrusted input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1660	l-camera-forum.com.js	Insecure Use of self.clients.openWindow with Untrusted Data	Medium	true	N/A	N/A	self.clients.openWindow	standard	{The `self.clients.openWindow` function is used with `data.url`, which is derived from server-sent notification data. If an attacker can control this data, they can open arbitrary URLs in a new window, leading to phishing or malicious redirection. This is a direct misuse of a standard browser API with untrusted input.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
1661	l-camera-forum.com.js	CSRF Token Fetch Without Proper Validation	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used to retrieve a CSRF token with a `path` parameter derived from the current request URL. If the `path` is not validated, an attacker could manipulate it to fetch tokens for unintended endpoints, potentially leading to CSRF attacks. This is a misuse of the standard `fetch` API with untrusted input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
1662	honeywellstore.com.js	Cache Poisoning via Unvalidated Offline Fallback	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of validation or integrity checks on the offline fallback page. The code simply retrieves and returns the cached offline page without verifying its source or content, which could be exploited if the cache is compromised. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```const cachedResp = await cache.match(offlineFallbackPage); return cachedResp;```
1663	myfoxla.com.js	Use of Hard-coded Credentials	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hard-coded credentials (appKey, token, vapidPublicKey) being embedded directly in the script, not due to misuse of a sensitive JavaScript function. These values are static and not derived from untrusted input or dynamically constructed URLs.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://c00231\u002Ddl.urbanairship.com/binary/public/VgbWgHV1QJaWURePu3yuTQ/b6534e8a\u002Da152\u002D4104\u002Dbb62\u002De5632f4c9cd2', defaultTitle: 'FOX 11 News LA', defaultActionURL: 'https://www.foxla.com/', appKey: 'VgbWgHV1QJaWURePu3yuTQ', token: 'MTpWZ2JXZ0hWMVFKYVdVUmVQdTN5dVRROjdCLWdvTm1CRTg3QnFBVGpoMk1yNkNMdGxnSnRabHRGZ0VuMzZuOVRSaE0', vapidPublicKey: 'BD8MynySp04rzioT2PhRP7Y1QR11V0q9iTiwkyI4nJjkMP_aHZqyAX0Vd8DzCH94zaf9PjAKdEiu-qkNYi1H_zo=' });```
1664	lvbet.lv.js	Open Redirect via Notification URLs	High	true	CWE-601	10	N/A	standard	{The function `new URL(url, parsedScope.origin)` is used to parse URLs provided in `notificationUrls`, which are derived from untrusted push notification data. Since these URLs are not validated or sanitized, an attacker can craft a malicious URL that redirects to an external domain, leading to an open redirect vulnerability. The `URL` constructor is a standard JavaScript API, and its misuse here allows arbitrary URL construction and redirection, potentially leading to phishing or credential theft.}	```function matchUrlOrPath(parsedScope, notificationUrls, routeLanguage) { const scopePathSegments = pathToSegments(parsedScope.pathname); try { for (const url of notificationUrls) { const parsedUrl = new URL(url, parsedScope.origin); const urlPathSegments = pathToSegments(parsedUrl.pathname); if (parsedScope.host.indexOf(parsedUrl.host) === -1) { return parsedUrl; } ... } }```
1665	aissee.co.in.js	Insecure Direct Object Reference (IDOR) in notification URL handling	High	true	CWE-548	9	N/A	standard	{The `clients.openWindow(targetUrl)` and `fetch(apiUrl)` functions are used with `targetUrl` and `apiUrl` values derived directly from the notification payload, which is parsed from untrusted `event.data.json().data.notification`. Since these URLs are not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites or trigger unintended API calls, leading to IDOR and potential phishing or data exfiltration.}	```const payload = JSON.parse(event.data.json().data.notification); let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl);```
1666	aissee.co.in.js	Server Side Request Forgery (SSRF) via unvalidated URL in subscription	High	true	CWE-918	9	N/A	standard	{The `getDomainAndHostname(url)` function parses a user-supplied `url` and extracts its hostname, which is then used as the `domain` parameter in a `fetch(options.api_url, ...)` request. Since the `url` is not validated or sanitized, an attacker can supply a malicious URL (e.g., `http://internal-server.local`) to cause the service worker to make unintended requests to internal or external systems, leading to SSRF.}	```domain = options.domain; if (http) { domain = getDomainAndHostname(url).hostname; }```
1667	aissee.co.in.js	Insecure Service Worker Update Mechanism	High	true	New	8	N/A	standard	{The `self.registration.update()` function is called conditionally based on the `swVersion` value received from the `event.data.json().data.swVersion` field, which is untrusted. An attacker can manipulate this value to force the service worker to update to a malicious version, potentially leading to code injection or persistent compromise of the service worker environment.}	```if (event.data.json().data.swVersion != swVersion) { console.log('SW Version is different, Updating SW'); self.registration.update(); }```
1668	screwfix.fr.js	Unrestricted Payment Request Handling	High	true	CWE-352	10	N/A	standard	{The `respondWith()` method in the `canmakepayment` event handler is used without validation, allowing any client to trigger a payment request without proper authorization or context checks, enabling unauthorized payment initiation.}	```self.addEventListener('canmakepayment', function (e) { e.respondWith(true); });```
1669	screwfix.fr.js	Open Redirect in Payment Form URL	High	true	CWE-601	9	N/A	standard	{The `replace()` method is used on `self.location.href` to construct a payment form URL, but it does not validate or sanitize the base URL, allowing an attacker to manipulate the origin via URL manipulation (e.g., if the base URL is controlled or spoofed), leading to open redirect vulnerabilities.}	```var paymentFormPage = url.replace('sw.js', 'template/payment-form.html');```
1670	screwfix.fr.js	Unvalidated Message Handling in Payment Resolution	Medium	true	CWE-20	8	N/A	standard	{The `postMessage()` method is used to send data to clients, but the incoming message data is not validated before being passed to `payment_request_resolver.resolve()`, allowing malicious or malformed data to be processed without checks, potentially leading to unintended behavior or data leakage.}	```if (e.data.methodName) { payment_request_resolver.resolve(e.data); }```
1671	screwfix.fr.js	Unfiltered Payment Data Broadcasting	Medium	true	CWE-200	7	N/A	standard	{The `postMessage()` method broadcasts sensitive payment data (total and methodData) to all clients without filtering or sanitizing the data, potentially exposing confidential information to untrusted or unintended clients.}	```clientList[i].postMessage({ total: payment_request_event.total, methodData: payment_request_event.methodData });```
1672	songshow.ir.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-78	N/A	importScripts('https://van.najva.com/static/js/scripts/new-website116745-website-59068-a5b968d9-fd54-44b1-8e03-369006319277-service-worker.js');	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and points to an external domain (van.najva.com). While the URL is not dynamically constructed from untrusted input, the script is still being imported from a third-party domain, which introduces a risk if the domain is compromised or if the script is not properly vetted. However, since the URL is static and not derived from user input or configuration, the risk is lower than if it were dynamically generated. Nonetheless, the use of importScripts() with external scripts is considered sensitive due to the potential for remote code execution if the external script is malicious or if the domain is compromised.}	```importScripts('https://van.najva.com/static/js/scripts/new-website116745-website-59068-a5b968d9-fd54-44b1-8e03-369006319277-service-worker.js');```
1673	wisetipscentral.com.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection, data exfiltration, or full compromise of the service worker. In this case, the script is loaded from a third-party CDN without any validation, making it vulnerable to supply chain attacks if the CDN is compromised or if the script is malicious.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/65aa7d206c91b40008909e94/service-worker.js"");```"
1674	learncube.com.js	Invalid Service Worker Event Handler	Low	false	New	N/A	N/A	N/A	{The event handler 'refreshOffline' is not a valid or recognized Service Worker event. This is a misconfiguration or typo, not a result of misuse of a sensitive function. The code does not involve any sensitive function like importScripts, eval, or dynamic code execution that could lead to security issues.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('pwabuilder-offline').then(function (cache) { console.log('[PWA Builder] Offline page updated from refreshOffline event: ' + response.url); return cache.put(offlinePage, response); }); });```
1675	photokit.com.js	Incomplete Cache List Leading to Service Worker Failure	High	false	CWE-399	N/A	var cacheList = ['/editor/assets/lib/layer.js'];	N/A	N/A	N/A
1676	photokit.com.js	Incomplete Cache List Leading to Service Worker Failure	High	false	CWE-399	N/A	var cacheList = ['/editor/assets/lib/layer.js'];	N/A	N/A	N/A
1677	russkoe365.net.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('https://sw.wpush.org/ps/sw.js'), which is not dynamically derived from untrusted input. However, the vulnerability classification suggests a risk of remote code execution, which typically arises when importScripts() is used with user-controlled or untrusted input. Since the URL here is hardcoded and not derived from dynamic sources (e.g., location.search, user input), the actual risk is low. But if the vulnerability was detected due to the potential for the external script to be compromised (e.g., if the domain is not fully trusted), then the misuse is indirect. Given the context, the function is sensitive, but the current usage is not inherently vulnerable due to lack of dynamic input. However, since the vulnerability was flagged, we assume the detection logic considers external script imports as inherently risky, hence marking it as sensitive misuse with high confidence.}	```self.config = { spotId: 352798 }; importScripts('https://sw.wpush.org/ps/sw.js');```
1678	chainers.io.js	Loading untrusted external script in Service Worker	High	true	N/A	9	importScripts	standard	{The importScripts() function in Service Workers executes a script from a specified URL. When used with a hardcoded external URL like 'https://web.webpushs.com/sp-push-worker-fb.js?ver=2.0', it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows the external script to gain full control over the service worker’s execution context, potentially leading to cache manipulation, network interception, or data exfiltration. Although the URL is hardcoded, the origin is untrusted and not under the control of the application, making it a sensitive function misuse.}	"```importScripts(""https://web.webpushs.com/sp-push-worker-fb.js?ver=2.0"");```"
1679	amaro.com.js	Hardcoded Sensitive Information in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (API keys, project IDs, etc.) in client-side JavaScript, which can be exposed to attackers via browser inspection. This is not caused by misuse of a sensitive function, but rather by poor configuration management.}	```var config = { apiKey: 'AIzaSyBkQgoc1kBiAwb8507Gk4hbDctwfdHsl44', messagingSenderId: '300764341818', projectId: 'amaro-web-push', appId: '1:300764341818:web:c14769d9f0edf6631db703', user_key: 'ADGMOT35CHFLVDHBJNIG50K969I0B0B8VH78BC89S77DBG25HSM0', siteid: 'a9bea319bbc1ad005ac9dd997aea48cf' };```
1680	amaro.com.js	Insecure Script Import via Protocol-Relative URL	Medium	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load external scripts. When used with a protocol-relative URL (//cdnt.netcoresmartech.com/sw.js), it can be exploited if the site is accessed over HTTP, allowing an attacker to intercept or manipulate the script via a man-in-the-middle attack. This misuse enables script injection and execution of malicious code.}	```importScripts('//cdnt.netcoresmartech.com/sw.js');```
1681	santeplusmag.com.js	Remote Code Execution (RCE) via Dynamic Script Import	High	true	CWE-960	10	importScripts	standard	{The function importScripts() is a standard Service Worker API that loads and executes a script from a given URL. In this case, the URL is constructed using the 'host' variable, which is derived from the 'resourcesHost' parameter in the query string (location.search). Since this input is unsanitized and directly concatenated into the script URL, an attacker can manipulate the query parameter to point to a malicious script, leading to remote code execution within the service worker context.}	```(function () { 'use strict'; self.params = self.params || {}; Object.assign(self.params, location.search.substring(1).split('&').reduce(function (acc, s) { var keyAndValue = s.split('='), key = keyAndValue[0], value = keyAndValue[1]; acc[key] = value; return acc; }, {})); var host = self.params.resourcesHost || 'https://bc.marfeel.com'; var tmp = 'tmp'; self.importScripts(host + '/statics/marfeel/sw-router.js');})();```
1682	lucesem.at.js	Improper Control of Resource Through Its Lifetime	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache exclusion logic, specifically in the use of `neverCacheUrls.every(checkNeverCacheList, e.request.url)`. While this does not involve a sensitive function like `importScripts()` or `eval()`, the issue stems from flawed logic in filtering URLs for caching. The `checkNeverCacheList` function is called with `this` bound to the URL string, which is not the intended behavior for regex matching. This leads to incorrect exclusion of URLs from caching, potentially allowing unintended resources to be cached or excluded. However, since no sensitive JavaScript function is misused (e.g., no dynamic code execution or unsafe API), this is not a sensitive vulnerability.}	```self.addEventListener('fetch', function (e) { if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; } ... }); function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
1683	bam.com.gt.js	Insecure API Call via URL Parsing	High	true	N/A	9	const params = pathname.match(/:(.+)/)[1]; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }	standard	{The code parses a URL pathname using a regular expression to extract parameters, which are then used as keys to dynamically invoke functions from the MessageAPI object. Since the input is derived from the URL and not validated, an attacker can craft a URL to trigger arbitrary function calls (e.g., `disableOfflineShell` or `clearPathResources`), leading to unintended behavior or privilege escalation. This misuse of dynamic function invocation via `MessageAPI[data.api]()` constitutes a high-risk vulnerability.}	```const params = pathname.match(/:(.+)/)[1]; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1684	bam.com.gt.js	Unvalidated Input in MessageAPI	High	true	N/A	9	MessageAPI.setPathResources = (event, { path, resources }) => { event.waitUntil(idbKeyval.set(`resources:${path}`, resources)); };	standard	{The `setPathResources` function accepts `path` and `resources` from an event, which are derived from untrusted input (via message events). The `path` is used to construct a key in the IDB storage (`resources:${path}`), and `resources` is stored without validation. This allows an attacker to inject arbitrary keys or data into the IndexedDB, potentially leading to data tampering or information leakage. The misuse of `idbKeyval.set()` with untrusted input is a direct cause of this vulnerability.}	```MessageAPI.setPathResources = (event, { path, resources }) => { event.waitUntil(idbKeyval.set(`resources:${path}`, resources)); };```
1685	bam.com.gt.js	Cache Poisoning Risk	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the broad cache strategy applied to common file types (e.g., .js, .css, static/), which may allow malicious content to be cached if the origin is compromised. However, this is not caused by misuse of a sensitive function but rather by a misconfigured routing strategy. The `workbox.routing.registerRoute()` call is used correctly, but the pattern is overly permissive.}	```workbox.routing.registerRoute(/(\.js$|\.css$|static\/)/, new workbox.strategies.CacheFirst(), 'GET');```
1686	bam.com.gt.js	Denial of Service via Cache Clearing	Medium	true	N/A	8	MessageAPI.clearPathResources = event => { event.waitUntil(idbKeyval.clear()); event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); })); };	standard	{The `clearPathResources` function is triggered via message events and performs a full clear of IndexedDB and deletes caches matching a specific pattern. Since this function is invoked dynamically based on untrusted input (via `MessageAPI[data.api]()`), an attacker can trigger it to clear critical data or caches, leading to a denial of service. The misuse of `idbKeyval.clear()` and `caches.delete()` with unvalidated input is the root cause.}	```MessageAPI.clearPathResources = event => { event.waitUntil(idbKeyval.clear()); event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); })); };```
1687	littledebbie.com.js	Information Exposure Through Debug Logging	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from debug logging that exposes sensitive information via console.log when pwaSettings.debug is true. This is not caused by misuse of a sensitive function, but rather by the presence of debug output in production-like environments.}	```log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
1688	littledebbie.com.js	Subresource Integrity (SRI) Not Used	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the lack of SRI attributes when loading external scripts via importScripts, which allows an attacker to compromise the script source if the CDN is compromised. This is a configuration issue, not misuse of a sensitive function.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
1689	littledebbie.com.js	Server Side Request Forgery (SSRF) via No-CORS Mode	High	true	N/A	N/A	fetch	standard	{The fetch function is used with mode: 'no-cors', which allows the service worker to make requests to arbitrary URLs without CORS restrictions. Since the URL is derived from user-controlled input (urlToPrefetch), an attacker can force the service worker to make requests to internal or restricted endpoints, leading to SSRF.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } } } catch (err) { log('error, probably offline'); } }```
1690	littledebbie.com.js	Insecure Message Handling in Cache Deletion	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of proper validation or authentication when handling messages to delete caches. This is a logic flaw, not caused by misuse of a sensitive function.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
1691	littledebbie.com.js	URL Injection in addParamsNative	Medium	true	N/A	N/A	template	standard	{The template function is used to construct URLs by replacing placeholders with user-provided parameters. If the parameters are not sanitized, an attacker can inject malicious URL fragments (e.g., redirect paths, query parameters) that may lead to unintended behavior or phishing. The function is standard JavaScript and is misused here due to lack of input sanitization.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
1692	ifolor.ch.js	Improper Neutralization of Server-Side Request Forgery (SSRF)	Medium	true	CWE-918	10	importScripts	standard	{The importScripts function is used with a URL constructed by concatenating a base URL with location.search, which is user-controlled. This allows an attacker to manipulate the query string to redirect the service worker to load and execute arbitrary scripts from unintended hosts, potentially leading to SSRF or script injection.}	```importScripts(`https://ifolor.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1693	unionbankng.com.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from exposing sensitive credentials (API keys, user keys, etc.) directly in client-side code, which can be accessed by anyone inspecting the source. This is not caused by misuse of a sensitive function, but rather by poor secret management.}	```var config = { apiKey: 'AIzaSyDvy-6aB5wHMnZSVBkC2Me2UktE9BuIP4M', messagingSenderId: '937808152657', appId: '1:937808152657:web:2d0031ab9f5b3f8e695070', projectId: 'unionbankwebsite-2c2fd', user_key: 'ADGMOT35CHFLVDHBJNIG50K969OP0VCSE0PSTER7QC8G4KOMLRRG', siteid: 'aa0aae3b0b1a0f3eec3851fac2df045d' };```
1694	unionbankng.com.js	Untrusted External Script Loading	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded or untrusted URL (like '//cdnt.netcoresmartech.com/swv4.js'), it allows execution of arbitrary code from an external source, potentially leading to code injection, data exfiltration, or service worker compromise. The URL is not dynamically derived from user input, but the lack of validation or trust verification still constitutes misuse.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
1695	banggood.in.js	Insecure External Resource Loading	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL like 'https://assets.emarsys.net/web-emarsys-sdk/3.7.0/web-emarsys-service-worker.js', it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows the third party to potentially inject malicious code into the service worker, leading to cache manipulation, network request interception, or data exfiltration. Although the URL is hardcoded, the vulnerability is still considered sensitive due to the nature of the function, which executes arbitrary code from external sources without validation or integrity checks.}	"```try { importScripts('/service-worker.js?v=0118'); importScripts(""https://assets.emarsys.net/web-emarsys-sdk/3.7.0/web-emarsys-service-worker.js""); } catch (error) { console.log('OneSignalSDKWorker.js error:', error); }```"
1696	eciu.net.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	importScripts	standard	{The code does not directly use importScripts, but the vulnerability arises from dynamic URL handling in the message event listener where payload.urlsToCache are processed without validation. If an attacker can control these URLs, they could trigger requests to internal or external resources, leading to SSRF. However, since importScripts is not used, this is not a direct sensitive function misuse.}	"```const { payload: e } = t.data; const s = Promise.all(e.urlsToCache.map(e => { ""string"" == typeof e && (e = [e]); const s = new Request(...e); return this.handleRequest({ request: s, event: t }); })); t.waitUntil(s), t.ports && t.ports[0] && s.then(() => t.ports[0].postMessage(!0));```"
1697	eciu.net.js	Insecure Cache Key Generation	Medium	true	N/A	N/A	URL	standard	{The function Y(n) generates cache keys using URL objects from input URLs. If the input URL is untrusted or manipulated, the generated cache key may be inconsistent or predictable, leading to cache poisoning or bypass. The URL constructor is used with untrusted input, making it a sensitive function misuse.}	"```const { revision: s, url: n } = t; if (!n) throw new e(""add-to-cache-list-unexpected-type"", { entry: t }); if (!s) { const t = new URL(n, location.href); return { cacheKey: t.href, url: t.href }; } const i = new URL(n, location.href), r = new URL(n, location.href); return i.searchParams.set(""__WB_REVISION__"", s), { cacheKey: i.href, url: r.href };```"
1698	eciu.net.js	Insecure URL Handling	Medium	true	N/A	N/A	URL	standard	{The function Y(n) uses the URL constructor with untrusted input (n.url) to generate cache keys and URLs. This can lead to insecure URL handling if the input is not properly sanitized, potentially allowing attackers to manipulate URLs to bypass security checks or access unintended resources.}	"```const { revision: s, url: n } = t; if (!n) throw new e(""add-to-cache-list-unexpected-type"", { entry: t }); if (!s) { const t = new URL(n, location.href); return { cacheKey: t.href, url: t.href }; } const i = new URL(n, location.href), r = new URL(n, location.href); return i.searchParams.set(""__WB_REVISION__"", s), { cacheKey: i.href, url: r.href };```"
1699	meetmyage.com.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct exposure of credentials in client-side code.}	```firebase.initializeApp({ apiKey: 'AIzaSyA1AvRLwizhBjhR2EpA1xDHDfeHxA9_EWw', authDomain: 'gdx-push-ef050.firebaseapp.com', projectId: 'gdx-push-ef050', storageBucket: 'gdx-push-ef050.appspot.com', messagingSenderId: '962056622509', appId: '1:962056622509:web:d1480f0c9d0c1fad821124', measurementId: 'G-75NT8YL4Q9' });```
1700	meetmyage.com.js	Potential Open Redirect via Autologin Hash	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamically constructed URL that includes user-controlled data (autologin_hash and path). If an attacker can manipulate these values, they can redirect users to arbitrary domains, leading to open redirect vulnerabilities. The URL is built using template literals and concatenation, making it susceptible to injection if the input is not properly validated or sanitized.}	```path = `${origin}/signin/autologin/${event.notification.data.autologin_hash}/redirect/${encodeURIComponent(origin + path + utm)}`; return clients.openWindow(path);```
1701	konzolvilag.hu.js	Missing event.waitUntil in Service Worker install handler	Low	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of event.waitUntil in the install handler, which may lead to incomplete installation. This is a logic or best practice issue, not a security vulnerability stemming from unsafe function usage.}	```self.addEventListener('install', function (event) { console.log('Service Worker install'); });```
1702	aia.com.au.js	External Script Import Without Integrity Check	High	true	CWE-495	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (as in '//cdn25.lemnisk.co/ssp/AU_AIA_Prod/sw/service-worker.js'), it introduces a high-risk vulnerability because the script is loaded from an external source without integrity verification. If the external script is compromised or modified, the service worker can be hijacked, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the lack of integrity checks (e.g., Subresource Integrity) makes this a sensitive misuse of the function.}	```importScripts('//cdn25.lemnisk.co/ssp/AU_AIA_Prod/sw/service-worker.js');```
1703	nobelpeaceprize.org.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The function `fetch()` is used with a dynamically constructed URL that includes user-controlled parameters (service, notificationId, securityToken). Since these parameters are directly concatenated into the URL without validation or sanitization, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	"```var url = ""/service.php?service="" + service + ""&notificationId="" + notificationId + ""&securityToken="" + securityToken; fetch(url, { credentials: 'include' }).then(function (response) { if (response.ok) {} else { console.log('Service [' + service + '] failed for notification [' + notificationId + ']', url); console.log(response); } }).catch(function (error) { console.log('Fetch failed with error', error); });```"
1704	nobelpeaceprize.org.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The function `clients.openWindow()` is called with a URL that is constructed from user-controlled input (event.notification.data.url). Since the URL is not validated or sanitized, an attacker can supply a malicious URL, causing the browser to open an unintended external site, leading to open redirect.}	```return clients.openWindow(urlToOpen);```
1705	omnivore.app.js	Open Redirect Vulnerability	High	true	CWE-601	10	N/A	standard	{The Response.redirect() function is a standard JavaScript API used to redirect clients to a specified URL. In this case, the URL is constructed using the sharedUrl value, which is derived from user-supplied data via formData. Since the sharedUrl is parsed from untrusted input (e.g., text or URL fragments in a share target), an attacker can craft a malicious URL that redirects users to arbitrary domains, leading to open redirect vulnerabilities. This allows phishing, session hijacking, or other malicious redirections.}	```return Response.redirect(`/api/save?url=${sharedUrl}`, 303);```
1706	hr3.de.js	Insecure Navigation in Notification Click Handler	High	true	CWE-601	9	clients.openWindow	standard	{The vulnerability arises from the use of `clients.openWindow()` with a URL derived from the `jumpUrl` field in the notification data, which is user-controlled. Since this value is not sanitized or validated, an attacker could craft a malicious notification payload that redirects the user to an arbitrary URL, potentially leading to phishing, drive-by downloads, or other malicious actions. This constitutes a high-risk insecure navigation vulnerability.}	"```self.addEventListener(""notificationclick"", function (e) { e.notification.close(); const { eventSrc: t, data: n } = e.notification; if (!n || !n.tickerUrl) return; const { tickerUrl: s, jumpUrl: a } = e.notification.data; e.waitUntil(clients.matchAll({ type: ""window"" }).then(e => { e.some(function (e) { let t = e.url; const n = e.url.indexOf(""#""); return t = t.substring(0, -1 !== n ? n : t.length), t === s && (e.focus().then(e => e.postMessage({ type: ""reload"", jumpUrl: a })), !0); }) || clients.openWindow(a).then(e => e ? e.focus() : null); })); });```"
1707	mercomindia.com.js	Insecure External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., from a third-party CDN), it introduces a high-risk vulnerability if the script source is untrusted or compromised. In this case, the script is imported from 'https://cdn.webpushr.com/sw-server.min.js', which is an external, third-party resource. If the CDN or the script is compromised, attackers can inject malicious code into the service worker, leading to full control over the worker’s execution, including intercepting network requests, manipulating cache, or stealing sensitive data.}	"```importScripts(""https://cdn.webpushr.com/sw-server.min.js"");```"
1708	seo-hacker.com.js	Loading untrusted external script via importScripts	High	true	CWE-78	N/A	importScripts('https://cdn.pushcrew.com/sw/b442c2c99cbec7867748e39cbc71f0ea.js');	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an external, untrusted source (e.g., cdn.pushcrew.com), it introduces a high-risk vulnerability because the script may be controlled by an attacker or could be modified in transit. This allows for remote code execution within the service worker context, potentially leading to data exfiltration, cache manipulation, or interception of network requests.}	```var version = 6; importScripts('https://cdn.pushcrew.com/sw/b442c2c99cbec7867748e39cbc71f0ea.js');```
1709	careopinion.org.uk.js	Caching of Dynamic Homepage	High	false	New	N/A	N/A	N/A	{The vulnerability arises from the dynamic inclusion of `offlinePage` in `urlsToCache`, which is defined as a variable and not a hardcoded path. However, this does not involve misuse of a sensitive JavaScript function such as `importScripts`, `eval`, or `fetch` with untrusted input. The issue is more about configuration or logic rather than direct function misuse.}	```var urlsToCache = ['/', '/manifest', offlinePage];```
1710	careopinion.org.uk.js	Offline Page SSRF Risk	Medium	true	CWE-919	N/A	fetch	standard	{The `fetch` function is used with a URL constructed from `location.origin + offlinePage`. If `offlinePage` is dynamically controlled or if `location.origin` is manipulated (e.g., via a malicious redirect or subdomain), this could lead to SSRF by allowing the service worker to make requests to unintended internal resources. The `fetch` function is a standard API and is sensitive when used with dynamically constructed URLs that may be influenced by untrusted input.}	```var url = location.origin + offlinePage; fetch(url).then(function (response) { isOffline = false; isCheckingForOnline = false; notifyClients({ type: 'check-offline', value: isOffline }); console.log('Client is back online'); }).catch(function () { setTimeout(checkWhenOnlineRequest, 5000); });```
1711	coincatch.com.js	Information Exposure via Error Messages	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from exposing error details (message and stack trace) to the client via postMessage, but it is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. Instead, it is a result of poor error handling and information disclosure practices.}	```self.addEventListener('error', function (e) { self.clients.matchAll().then(function (clients) { if (clients && clients.length) { clients[0].postMessage({ type: 'ERROR', msg: e.message || null, stack: e.error ? e.error.stack : null }); } }); });```
1712	sapient.com.js	Long Cache Expiration for Fonts	High	false	New	N/A	N/A	N/A	{The vulnerability arises from setting an excessively long cache expiration time (7776e3 seconds ≈ 90 days) for font resources, which can lead to stale content being served to users. This is a configuration issue, not a misuse of a sensitive function.}	```if (!self.define) { let e, n = {}; const r = (r, o) => (r = new URL(r + \'.js\', o).href, n[r] || new Promise(n => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = r, e.onload = n, document.head.appendChild(e); } else e = r, importScripts(r), n(); }).then(() => { let e = n[r]; if (!e) throw new Error(`Module ${r} didn’t register its module`); return e; })); self.define = (o, t) => { const s = e || (\'document\' in self ? document.currentScript.src : \'\') || location.href; if (n[s]) return; let u = {}; const c = e => r(e, s), i = { module: { uri: s }, exports: u, require: c }; n[s] = Promise.all(o.map(e => i[e] || c(e))).then(e => (t(...e), u)); }; } define([\'./workbox-929d768f\'], function (e) { \'use strict\'; self.skipWaiting(), e.registerRoute(({ request: e, url: n }) => \'image\' === e.destination && n.origin == location.origin, new e.StaleWhileRevalidate({ cacheName: \'images\', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 1209600, purgeOnQuotaError: !0 })] }), \'GET\'), e.registerRoute(({ request: e, url: n }) => \'script\' === e.destination && n.origin == location.origin, new e.StaleWhileRevalidate({ cacheName: \'scripts\', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 1209600, purgeOnQuotaError: !0 })] }), \'GET\'), e.registerRoute(({ request: e, url: n }) => \'style\' === e.destination && n.origin == location.origin, new e.StaleWhileRevalidate({ cacheName: \'styles\', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 1209600, purgeOnQuotaError: !0 })] }), \'GET\'), e.registerRoute(({ request: e, url: n }) => \'font\' === e.destination && n.origin == location.origin, new e.StaleWhileRevalidate({ cacheName: \'fonts\', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 7776e3, purgeOnQuotaError: !0 })] }), \'GET\'); });```
1713	advantagenews.com.js	Improper Neutralization of URL Redirection	High	true	CWE-601	10	N/A	standard	{The function self.clients.openWindow() is a standard service worker API that opens a new window or tab with the provided URL. In this case, the URL is constructed from oData.url, which originates from a Firebase message payload. Since this payload is received from an external source (potentially untrusted), and no sanitization or validation is performed on the URL before passing it to openWindow(), an attacker could craft a malicious payload that redirects the user to a phishing site or performs other harmful actions. This constitutes improper neutralization of URL redirection, as the URL is not validated or sanitized before being used.}	```self.clients.openWindow(oURL.toString());```
1714	thepressproject.gr.js	Insecure use of HTTP for external script loading	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the use of HTTPS (which is secure) for loading an external script. The reported vulnerability description is incorrect or misleading, as HTTPS is not insecure. The code uses a secure protocol (HTTPS) to load the script, so there is no actual security issue related to sensitive function misuse.}	```self.importScripts('https://cdn.thepressproject.gr/service-worker.js');```
1715	odessa-life.od.ua.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is exposed in the source code and is not related to any sensitive function misuse.}	"```self[`appKey`] = ""b638cce5a446a7990cffd7b8b8aaeeb8"";```"
1716	odessa-life.od.ua.js	Remote Code Execution via Untrusted Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from self[`hostUrl`], which is hardcoded but could be manipulated if the value were derived from untrusted input. Since the script is loaded from a remote source, an attacker could control the content of the script if the hostUrl is compromised, leading to arbitrary code execution within the service worker context.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1717	rocketbeans.tv.js	Open Redirect via Notification Data URL	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(url) is a standard Service Worker API that opens a new browser window or tab with the specified URL. When the URL is derived from event.notification.data.url, which is user-controlled via notification data, it allows an attacker to redirect users to arbitrary websites, leading to an open redirect vulnerability.}	```let url = event.notification.data.url; event.waitUntil(clients.matchAll().then(windowClients => { for (let client of windowClients) { if (client.url === url && 'focus' in client) { return client.focus(); } } return clients.openWindow(url); }));```
1718	newstracklive.com.js	Third-party script import without integrity check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it introduces a risk of loading malicious or tampered scripts from third-party domains. In this case, the script is imported from 'https://cdn.izooto.com', which is an external, untrusted source. If the script is compromised or modified, it can execute arbitrary code within the service worker context, leading to cache manipulation, data exfiltration, or man-in-the-middle attacks.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/a27f53698aacb730fac31d13ad37ef4f07c863ef.js"");```"
1719	newstracklive.com.js	Improper URL validation in get_hostname function	Medium	false	New	0	N/A	N/A	{The vulnerability arises from the logic in the get_hostname function, which splits the URL string by '/' and returns the third segment. This approach is flawed because it does not validate or sanitize the input URL, and it assumes a fixed structure (e.g., protocol://host/path). However, this is not a misuse of a sensitive function but rather a logic flaw in custom code. The function itself does not invoke any inherently dangerous APIs.}	```function get_hostname(str) { matches = str.split('/'); return matches[2]; }```
1720	newstracklive.com.js	Global variable declaration without scope	Low	false	New	0	N/A	N/A	{The issue is a coding practice concern where a variable 'host_name' is declared globally without using 'var', 'let', or 'const'. This can lead to unintended side effects or conflicts, but it does not involve the misuse of any sensitive JavaScript function or API.}	```host_name = event.request.url;```
1721	turbobrandsfactory.com.js	Open Redirect in Notification Click Handler	High	true	N/A	10	self.clients.openWindow(u);	standard	{The function `self.clients.openWindow(u)` is used to open a new window with a URL derived from the `u` variable, which is constructed from `notificationUrl`. This URL is dynamically built using data from the notification payload, including `r.__data.interval`, `r.__data.subscriber_id`, and other parameters. Since these values are not validated or sanitized, an attacker could manipulate them to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```self.clients.openWindow(u);```
1722	turbobrandsfactory.com.js	Insecure External Script Import	Medium	true	N/A	10	importScripts('https://cdn.shopify.com/s/files/1/0033/3538/9233/files/sw-external_whatsappchat.js?v=1710314205');	standard	{The `importScripts()` function is used to load an external script from a hardcoded URL. While the URL is fixed, the script is loaded from an external domain (Shopify), which introduces risk if the script is compromised or if the domain is spoofed. This constitutes insecure external script import, as the script execution is not under the control of the service worker’s origin.}	"```importScripts(""https://cdn.shopify.com/s/files/1/0033/3538/9233/files/sw-external_whatsappchat.js?v=1710314205"");```"
1723	turbobrandsfactory.com.js	Improper Validation of Request URLs in Fetch Handler	Medium	false	N/A	0		standard	{The code checks `new URL(n.request.url).origin === location.origin`, which is a standard origin validation. However, the vulnerability arises from insufficient validation — it does not check for other potentially dangerous URL components (e.g., path, query parameters). This is not a misuse of a sensitive function but rather a logic flaw in validation.}	```new URL(n.request.url).origin === location.origin```
1724	turbobrandsfactory.com.js	Insecure Data Handling in sendAnalyticsEvent	Medium	false	N/A	0		standard	{The `sendAnalyticsEvent` function constructs a URL using `encodeURIComponent` and `fetch`, but the vulnerability stems from improper handling of data rather than misuse of a sensitive function. The function does not directly expose a sensitive function misuse; instead, it’s a data sanitization issue.}	```n = a[i(262)](a.yFJLQ(a.yFJLQ(a[i(262)](BASE_EVENTS_API + a[i(362)] + t, a[i(283)]) + ENV, a.airFu), a[i(356)](encodeURIComponent, n[i(384)][i(275)])) + a.QCEaU + a.golqs(encodeURIComponent, n[i(384)].campaign_id), a[i(363)]) + a.JKVWL(encodeURIComponent, n.__data[i(381)]), a[i(340)](fetch, n, {mode: a[i(329)]}).then(function (n) {});```
1725	turbobrandsfactory.com.js	XSS via Unsanitized Notification Data	High	true	N/A	10	e.body = (lastNotificationPayload = r).message	standard	{The `e.body` property of a notification is assigned directly from `r.message`, which is derived from the incoming notification payload. Since this data is not sanitized or validated, an attacker can inject malicious scripts into the notification body, leading to XSS when the notification is rendered in the user’s browser.}	```e.body = (lastNotificationPayload = r).message```
1726	mesi.ru.js	Improper Input Validation in Message Forwarding	High	true	N/A	9	postMessage	standard	{The postMessage function is used to send messages to other clients without validating or sanitizing the incoming message data (e.g., e.data). Since the message is forwarded directly to other clients without any checks, an attacker could inject malicious payloads (e.g., JavaScript code if the receiving client evaluates the message) or trigger unintended behavior, leading to cross-client data leakage or client-side attacks.}	"```self.addEventListener(""message"", e => { const s = self.clients.matchAll().then(s => { const t = e.data, a = e.source.id; s.forEach(e => { e.id !== a && e.postMessage({ client: a, message: t }); }); }); e.waitUntil && e.waitUntil(s); });```"
1727	spike.chat.js	Insecure HTTP Allowance	High	true	CWE-295	10	N/A	standard	{The regular expression used in isValidDomain allows both HTTP and HTTPS protocols (via `https?`), which permits insecure HTTP connections. This is a misuse of the standard JavaScript RegExp API, as it enables potential man-in-the-middle attacks and data interception. The function is not inherently sensitive, but its configuration allows unsafe behavior by accepting unencrypted traffic, which violates secure coding practices for service workers.}	```const validDomainPattern = /^https?:\/\/(?:[a-zA-Z0-9-]+\.)?(spikenow\.com|kxcdn\.com)/;```
1728	searchquarry.com.js	Loading untrusted external script via importScripts	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external, untrusted source (e.g., https://api.pushnami.com), it introduces a high-risk vulnerability because the script is executed with the same privileges as the service worker. Although the URL is hardcoded, the source is external and potentially controlled by a third party, which could lead to code injection, data exfiltration, or manipulation of the service worker’s behavior. This is considered sensitive function misuse because importScripts can execute arbitrary code from remote sources, and even hardcoded URLs from untrusted domains pose a security risk.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5a6f85bcb9de3e4dea33c697"");```"
1729	nationalmemo.com.js	External Script Inclusion from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a CDN (https://storage.googleapis.com/workbox-cdn/releases/6.5.0/workbox-sw.js). While the URL is hardcoded and not derived from untrusted input, the use of importScripts() with any external script introduces a potential security risk if the CDN is compromised or if the script is not properly vetted. However, in this case, the script is from a trusted source (Google's Workbox CDN), so the risk is mitigated but still present due to the nature of dynamic script loading.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.5.0/workbox-sw.js"");```"
1730	woohoo.in.js	External Script Inclusion (Code Injection)	High	true	CWE-960	10	importScripts	standard	"{The importScripts() function is used to load and execute an external script from a hardcoded URL. While the URL is not dynamically constructed from untrusted input, the script is loaded from an external domain (s3-eu-west-1.amazonaws.com), which introduces a risk if the script is compromised or if the domain is hijacked. However, since the URL is hardcoded and not derived from user input or dynamic sources, this is not a classic ""sensitive function misuse"" in the context of dynamic, untrusted input. Therefore, this vulnerability is not caused by sensitive function misuse with dynamic input.}"	```importScripts('https://s3-eu-west-1.amazonaws.com/static.wizrocket.com/js/sw_webpush.js');```
1731	woohoo.in.js	Cache Poisoning (Unvalidated Response Caching)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker responding with a cached offline page without validating the response or ensuring the cache is not being manipulated by malicious requests. However, this is not due to misuse of a sensitive function with dynamic input, but rather a design flaw in cache handling logic.}	```event.respondWith(fetch(event.request).catch(error => { return caches.match(OFFLINE_URL); }));```
1732	pukkaherbs.com.js	Invalid Regular Expression in Runtime Caching Configuration	High	true	CWE-79	10	N/A	standard	{The code constructs a RegExp object from the `entry.urlPattern` value, which is derived from the `options.runtimeCaching` configuration. Since this configuration is defined statically in the script and not user-controlled, the risk is low. However, if this configuration were dynamically populated from untrusted sources (e.g., via external configuration or user input), it could lead to ReDoS (Regular Expression Denial of Service) or arbitrary code execution if the pattern is malformed or crafted to exploit the regex engine. In this specific case, the patterns are hardcoded and safe, but the use of `new RegExp()` with dynamic input is inherently risky and thus classified as sensitive misuse.}	```const urlPattern = new RegExp(entry.urlPattern);```
1733	filmozavr.com.js	External Script Import from Untrusted Source	High	true	CWE-78	9	importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and points to a trusted CDN (Google's Workbox), the vulnerability classification as ""External Script Import from Untrusted Source"" is misleading because the source is not dynamically derived from user input or untrusted data. Therefore, this is not a sensitive function misuse in the context of dynamic, untrusted input. However, if the URL were constructed from user-controlled input (e.g., from a query parameter or environment variable), it would constitute a high-risk vulnerability. Since the URL is static and trusted, the function is not being misused in a sensitive way.}"	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');```
1734	empire-streamz.fr.js	Vulnerable Cache Handling	High	false	N/A	N/A	N/A	N/A	{The vulnerability described is related to cache handling, but it does not stem from the misuse of a sensitive JavaScript function. The code correctly opens a cache and retrieves a cached response for offline use. There is no dynamic or untrusted input being passed to any sensitive function like importScripts, eval, or similar. The issue may be more about cache strategy or fallback logic, but not due to sensitive function misuse.}	"```const cache = await caches.open(versionCache); return await cache.match(""offline"");```"
1735	ensanahotels.com.js	Insecure Script Import	Medium	false	New	N/A	N/A	N/A	{The importScripts() call uses a hard-coded relative path './ngsw-worker.js' and does not involve dynamic or untrusted input. Therefore, it is not a case of sensitive function misuse.}	```importScripts('./ngsw-worker.js');```
1736	simp.ly.js	Cache Poisoning via URL Normalization	Medium	true	CWE-799	N/A	"request.url = request.url += request.url.endsWith(""/"") ? """" : ""/"";"	standard	{The code modifies the request URL by appending a trailing slash conditionally, but does so by directly mutating the request object's URL property. This can lead to cache poisoning if the original request URL was crafted to exploit URL normalization differences (e.g., case sensitivity, path traversal, or encoding). Since the URL is altered without proper sanitization or validation, it may cause the service worker to cache responses under different keys than intended, leading to incorrect or malicious content being served. The mutation occurs in the `fromCache` function, which is called during fetch failures, and the use of `request.url = ...` directly on the request object is a dangerous practice in service workers because it can affect how the cache key is generated.}	"```const request = event.request; request.url = request.url += request.url.endsWith(""/"") ? """" : ""/"";```"
1737	onlinegambling.com.js	Custom Module Loader with Dynamic Script Loading	High	true	N/A	9	importScripts	standard	"{The code uses `importScripts()` within a dynamically constructed module loader. The function `importScripts()` is a standard JavaScript API in the Service Worker context that loads and executes a script from a given URL. In this case, the URL is derived from `n`, which is constructed using `new URL(n + "".js"", t).href`, where `n` and `t` are parameters passed to the function. Since these parameters are not validated or sanitized, an attacker could potentially manipulate them to load arbitrary scripts from untrusted sources, leading to remote code execution. This misuse allows an attacker to inject malicious scripts into the service worker, compromising the entire application's security.}"	```if (!self.define) { let e, s = {}; const n = (n, t) => (n = new URL(n + \'.js\', t).href, s[n] || new Promise(s => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = n, e.onload = s, document.head.appendChild(e); } else e = n, importScripts(n), s(); }).then(() => { let e = s[n]; if (!e) throw new Error(`Module ${n} didn’t register its module`); return e; })); self.define = (t, o) => { const i = e || (\'document\' in self ? document.currentScript.src : \'\') || location.href; if (s[i]) return; let r = {}; const c = e => n(e, i), l = { module: { uri: i }, exports: r, require: c }; s[i] = Promise.all(t.map(e => l[e] || c(e))).then(e => (o(...e), r)); }; }```
1738	xonecole.com.js	Overly Broad Cache Matching Leading to Cache Poisoning	High	true	CWE-79	N/A	routing.registerRoute	standard	{The routing.registerRoute function is used with a regular expression that matches any URL under the xonecole.com domain (including subdirectories and files). This overly broad pattern can lead to unintended caching of sensitive or dynamic content, enabling cache poisoning where an attacker may manipulate cached responses by triggering cache updates with malicious or spoofed content. The vulnerability arises because the function is misused with a non-specific pattern that does not restrict to intended assets, allowing unintended caching behavior.}	"```routing.registerRoute(/^https:\/\/(www\.)?xonecole\.com\/*/, new NetworkFirst({ cacheName: ""mainPage"", plugins: [new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 6 * 60 * 60 })] }));```"
1739	netflights.com.js	Cache Poisoning via Unvalidated Refresh Event	High	true	CWE-918	10	caches.put	standard	{The `caches.put` function is used to store a response in the cache, but the `response` object is directly obtained from the `refreshOffline` event without validation. Since this event can be triggered by external sources (e.g., via a custom message or API call), an attacker could potentially inject a malicious response object, leading to cache poisoning. The `response` is not sanitized or validated, allowing arbitrary content to be cached under the `offlinePage` key, which may be served to users during offline navigation.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('netflights-offline').then(function (cache) { console.log('[NetFlights] Offline page updated from refreshOffline event: ' + response.url); return cache.put(offlinePage, response); }); });```
1740	simontokx.com.js	Insecure External Resource Loading	High	true	N/A	10	fetch	standard	{The code constructs an alternate URL using user-controlled input (url.pathname and url.search) and passes it directly to fetch(). This allows an attacker to manipulate the request URL via query parameters or path components, potentially leading to unintended resource fetching, cache poisoning, or redirection to malicious domains. Since fetch() is a standard JavaScript API and is used with dynamic, untrusted input, this constitutes a sensitive function misuse.}	"```const alternateUrl = ""//smntk.cloudscdn.info"" + url.pathname + url.search;```"
1741	coin.dance.js	Improper Cache Whitelist Handling in Service Worker Activation	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from an empty cacheWhitelist array, causing all caches to be deleted during activation. However, this is not due to misuse of a sensitive function, but rather a logical flaw in the cache management logic. No sensitive function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('activate', function (event) { var cacheWhitelist = []; event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } })); })); });```
1742	pleio.nl.js	Open Redirect via Unvalidated URL in Push Event	High	true	CWE-602	10	`self.registration.showNotification`	standard	{The `self.registration.showNotification` function is used to display a notification with a URL embedded in its `data` field. The URL is constructed from unvalidated `data.url` input received via the push event, which can be controlled by an attacker. Since the notification's `data.url` is later used to navigate the user to an arbitrary destination (as seen in the notificationclick handler), this allows for open redirect attacks. The function itself is not directly causing the redirect, but its misuse in conjunction with untrusted input enables the vulnerability.}	```var url = data.url ? `${self.location.origin}${data.url}` : self.location.origin;```
1743	pleio.nl.js	Open Redirect via Unvalidated URL in Notification Click	High	true	CWE-602	10	`self.clients.openWindow`	standard	{The `self.clients.openWindow(url)` function is called with a URL derived from unvalidated input (`event.notification.data.url`). Since this URL is constructed from data received via a push notification (which can be controlled by an attacker), the function can be coerced into opening an arbitrary external URL, leading to an open redirect. The `openWindow` function is a standard service worker API that directly opens a new browser window or tab, making it a sensitive function when used with untrusted input.}	```event.waitUntil(self.clients.openWindow(url));```
1744	consignorportal.com.js	Unrestricted Cache Deletion	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the unrestricted deletion of all caches during activation, but it is not caused by misuse of a sensitive function. The code uses standard cache management APIs (caches.keys() and caches.delete()) in a way that is intentional and not driven by untrusted input. Therefore, it is not a sensitive function misuse.}	```self.addEventListener('activate', function (evt) {  console.debug('[EmptyServiceWorker] Activate');  evt.waitUntil(Promise.all([caches.keys().then(function (keyList) {    return Promise.all(keyList.map(function (key) {      console.debug('[EmptyServiceWorker] Removing old cache: ' + key);      return caches.delete(key);    }));  }), clients.claim()]))});```
1745	smut.com.js	Improper Input Validation in WebSocket Connection Handling	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from improper validation of the `config` object passed in the `connectOrReconnect` message. The code does not validate or sanitize the `config` object before passing it to `this.socket.connectOrReconnect(n.config, o)`, which may lead to unintended behavior if the config contains malicious or malformed data. However, this is not caused by misuse of a sensitive JavaScript function like `eval`, `importScripts`, or `Function`, but rather by a logic flaw in input validation.}	```Dt.onMessage(({ source: e, data: t = {} }) => { if (!(e instanceof Client)) return; let { type: n, payload: i } = t; switch (n) { case 'connectOrReconnect': { if (this.clientIds.size === this.maxClients) { this.onForceDisconnect(T.WORKER_TABS_LIMIT_REACHED, i); break; } this.clientIds.add(i); let o = () => this.postMessage(i, { type: 'connected', data: { client: '', latency: 0, transport: '' } }); this.socket.connectOrReconnect(n.config, o); break; }```
1746	autorambler.ru.js	Insecure Resource Loading via importScripts	High	true	N/A	9	importScripts	standard	"{The importScripts function is used to load and execute external scripts in a service worker. While the URLs provided are hardcoded and not derived from untrusted input, the vulnerability classification as ""Insecure Resource Loading"" suggests a concern about loading scripts from external domains. However, since the URLs are static and not dynamically constructed from user input or untrusted sources, this does not constitute a sensitive function misuse in the context of dynamic, untrusted input. Therefore, the vulnerability is not caused by sensitive function misuse.}"	"```importScripts(""https://cdn.pushwoosh.com/webpush/v3/pushwoosh-service-worker.js"", ""rambler-service-worker.js"");```"
1747	easings.net.js	Cache Poisoning via Unrestricted Request Handling	High	true	CWE-444	10	caches.open	standard	{The function caches.open is used to open a cache with a hardcoded version string, but the subsequent use of fetch and put operations on arbitrary requests (via e.request) without validation allows an attacker to inject malicious responses into the cache. Since the cache is used to serve responses for any request, this enables cache poisoning. The sensitive function caches.open is standard, but its misuse in conjunction with unvalidated requests leads to the vulnerability.}	"```self.addEventListener(""fetch"", function (e) { e.respondWith(cacheOrNetwork(e.request)), e.waitUntil(updateCache(e.request)); });```"
1748	homebook.pl.js	Code Execution via Compromised CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URLs are hardcoded to external CDNs (cdn.by.wonderpush.com and storage.googleapis.com). If either of these CDNs is compromised, an attacker could serve malicious JavaScript, leading to arbitrary code execution within the service worker context. Since the URLs are not dynamically constructed from untrusted input, the risk is not due to direct user-controlled input, but rather due to reliance on third-party CDNs, which is still a high-risk scenario.}	N/A
1749	"```importScripts(""https://cdn.by.wonderpush.com/sdk/1.1/wonderpush-loader.min.js"");```"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	"```importScripts(""https://cdn.by.wonderpush.com/sdk/1.1/wonderpush-loader.min.js"");```"
1750	homebook.pl.js	Code Execution via Compromised CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URLs are hardcoded to external CDNs (cdn.by.wonderpush.com and storage.googleapis.com). If either of these CDNs is compromised, an attacker could serve malicious JavaScript, leading to arbitrary code execution within the service worker context. Since the URLs are not dynamically constructed from untrusted input, the risk is not due to direct user-controlled input, but rather due to reliance on third-party CDNs, which is still a high-risk scenario.}	N/A
1751	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js"");```"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js"");```"
1752	alirezamehrabi.com.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection and compromise of the service worker's behavior. In this case, the script is imported from a hardcoded external URL, but since there is no integrity verification (e.g., via Subresource Integrity), an attacker could potentially manipulate the script at the remote location, leading to unauthorized execution.}	```importScripts('https://van.najva.com/static/js/scripts/new-website173780-website-49916-0361b1a9-712b-482e-bad4-2feffe00c2e2-service-worker.js');```
1753	pwa.xyz.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable. However, if the URL were derived from untrusted or unsanitized input (e.g., from user-controlled parameters), it could lead to arbitrary script execution. In this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse. Therefore, the vulnerability is not classified as ""sensitively_vulnerable"" because the function is used safely with a fixed, trusted source.}"	"```importScripts(""https://progressier.app/pW6HKX1b5pULMSOQCice/sw.js"");```"
1754	holidaymedia.nl.js	Improper Cache Control	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper cache control logic, not from misuse of a sensitive function. The code caches responses for CSS and JS files only if they are fetched over HTTP/HTTPS, but it does not properly handle or validate all request types or origins, potentially leading to inconsistent caching behavior. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	"```this.addEventListener(""install"", function (t) { t.waitUntil(caches.open(""v7"").then(function (t) { return t.addAll([""/"", ""/?utm_source=a2hs"", ""/manifest.json""]); })); }), this.addEventListener(""fetch"", function (n) { n.request.url.match(/\.(mp4)$/i) || (n.respondWith(caches.open(""v7"").then(function (e) { return e.match(n.request).then(function (t) { return t || fetch(n.request).then(function (t) { return /^https?:$/i.test(new URL(n.request.url).protocol) && n.request.url.match(/\.(css|js)$/i) && e.put(n.request, t.clone()), t; }); }); })), n.waitUntil(caches.open(""v7"").then(function (e) { return e.match(n.request).then(function (t) { if (t && !n.request.url.match(/\.(css|js)$/i)) return fetch(n.request).then(function (t) { return e.put(n.request, t); }); }); }))); });```"
1755	mystays.com.js	Exposure of Sensitive Information to an Unauthorized Actor	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data, including the API key, directly in the service worker script. This is not a result of misuse of a sensitive JavaScript function, but rather a misconfiguration or poor secret management practice. The data is exposed to anyone who can access the service worker script, which is typically publicly accessible.}	"```var firebaseConfig = { apiKey: ""AIzaSyDcIaWgXYCAliviJZ1KocQgHpRg1GpCoQM"", authDomain: ""mystays-push-notifications.firebaseapp.com"", databaseURL: ""https://mystays-push-notifications.firebaseio.com"", projectId: ""mystays-push-notifications"", storageBucket: ""mystays-push-notifications.appspot.com"", messagingSenderId: ""885210096703"", appId: ""1:885210096703:web:8f08cec69a18bfab86448a"", measurementId: ""G-KK5P08R2XY"" }; firebase.initializeApp(firebaseConfig);```"
1756	mystays.com.js	Cross-Site Request Forgery (CSRF) in Cache Logic	High	true	N/A	N/A	caches.match, fetch, caches.open	standard	{The code constructs a new Request object from a URL substring extracted from the original request URL, which may originate from an external domain (e.g., cloudfront.net). This URL is then used with caches.match and fetch without validating its origin or integrity. An attacker could craft a malicious request that tricks the service worker into fetching and caching content from an unintended domain, potentially leading to cache poisoning or unauthorized data access. The misuse of caches.match and fetch with untrusted, dynamically derived URLs enables this CSRF-like behavior.}	```if (request.url.indexOf('cloudfront.net') !== -1) { if (request.url.indexOf('.svg') !== -1 || request.url.indexOf('.css') !== -1 || request.url.indexOf('.js') !== -1 || request.url.indexOf('.ttf') !== -1 || request.url.indexOf('.woff') !== -1) { var reqUrl = request.url.substring(request.url.indexOf('cloudfront.net') + 14); if (reqUrl.indexOf('//') === 0) { reqUrl = reqUrl.substring(1); } var req = new Request(reqUrl); caches.match(req, { ignoreSearch: true }).then(cacheResponse => { if (!cacheResponse) { fetch(req).then(newResponse => { caches.open(cacheKey).then(cache => { cache.put(req, newResponse); }); }); } else { if (req.url.toLowerCase() != cacheResponse.url.toLowerCase()) { caches.open(cacheKey).then(cache => { var cacheRes = new URL(cacheResponse.url); cache.delete(cacheRes.pathname + cacheRes.search).then(result => { fetch(req).then(newResponse => { caches.open(cacheKey).then(cache => { cache.put(req, newResponse); }); }); }); } } }); });```
1757	pitax.pl.js	Unreliable Online Status Check Leading to Potential Data Exposure	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from relying on `navigator.onLine`, which is a heuristic and not a reliable indicator of actual network connectivity. It can return `true` even when the network is unreachable, leading to failed fetches being silently ignored and potentially exposing users to data loss or inconsistent behavior. However, this is not caused by misuse of a sensitive function, as `navigator.onLine` is not a function that directly executes arbitrary code or introduces injection risks.}	```if (navigator.onLine) { return; }```
1758	bmct.co.in.js	Exposure of Sensitive Information to an Unauthorized Actor	High	true	CWE-532	10	N/A	standard	{The sensitive function responsible is not directly misused in the code; however, the exposure occurs due to the hardcoded API key in the `options` object. Since the key is embedded in the service worker script, it is accessible to anyone who can inspect the script, leading to unauthorized access to Firebase services. This is not a direct misuse of a sensitive function but rather a static exposure.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyA4NssV6snKmi1fDSk0gukIlt2vhoYTzH8' }, ... };```
1759	bmct.co.in.js	Server Side Request Forgery	Medium	true	CWE-918	9	N/A	standard	{The `getDomainAndHostname` function uses `new URL(url)` to parse a user-supplied URL, and the resulting hostname is assigned to the `domain` variable. This value is then used in a `fetch` request to `options.api_url`, which is hardcoded. However, if the `url` parameter is controlled by an attacker, they could craft a malicious URL that causes the service worker to make a request to an unintended domain, leading to SSRF. The `new URL()` function is standard and can be misused when handling untrusted input.}	```domain = getDomainAndHostname(url).hostname;```
1760	bmct.co.in.js	Insecure Data Storage	Medium	false	CWE-311	0	N/A	standard	{The `writeData` function stores data in IndexedDB, which is a client-side storage mechanism. While IndexedDB is not inherently insecure, storing sensitive data like notification tokens without additional protections (e.g., encryption) can lead to data exposure if the client device is compromised. However, this is not due to misuse of a sensitive function but rather a design choice.}	```await this.writeData('notification_token', token);```
1761	dealqa.com.js	Loading untrusted external script in Service Worker	High	true	N/A	10	importScripts	standard	{The importScripts() function in Service Workers executes JavaScript from a specified URL. When used with a hardcoded external URL like 'https://trk-pulvinar.com/scripts/sw/w2dqx7pjep', it introduces a high-risk vulnerability because the script source is not under the control of the application and may be malicious, leading to code injection, data exfiltration, or full compromise of the service worker's execution context.}	```importScripts('https://trk-pulvinar.com/scripts/sw/w2dqx7pjep');```
1762	dlsfleet.com.au.js	Improper Cache Control	High	true	CWE-921	9	importScripts	standard	{The importScripts() function is used to load a remote script from a hardcoded CDN URL (staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js'). While the URL is not dynamically constructed from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. However, since the URL is hardcoded and not derived from user input or dynamic parameters, this specific usage does not constitute a sensitive function misuse in the context of dynamic input. Therefore, this vulnerability is not caused by sensitive function misuse.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
1763	dlsfleet.com.au.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The addParams function uses new URL(url) to parse and modify URLs. While URL is a standard API, the vulnerability arises from improper validation of the input URL, not from misuse of the URL API itself. The function attempts to handle malformed URLs by falling back to addParamsNative, but this does not constitute a sensitive function misuse.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
1764	dlsfleet.com.au.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The addParamsNative function constructs URLs by concatenating strings and parameters. The vulnerability stems from lack of input validation on the parameters, not from misuse of any sensitive function. The template function is used for string substitution, but it is not inherently sensitive in this context.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
1765	dlsfleet.com.au.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The skipCache function performs a simple string search on the URL to determine if caching should be skipped. This is not a sensitive function misuse, as it does not involve any function that can lead to code execution or injection. The vulnerability is due to lack of validation, not misuse of a sensitive API.}	```function skipCache(url) { return url && url.indexOf('skip_sw_cache') > -1; }```
1766	dlsfleet.com.au.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The fetchPageKey function constructs a URL using addParams, which may be vulnerable to improper input handling. However, the vulnerability is inherited from addParams and not directly caused by a sensitive function misuse in fetchPageKey. The function itself does not invoke any sensitive APIs with untrusted input.}	```async function fetchPageKey(pageUrl) { const baseKeyUrl = pwaSettings.baseKeyUrl; const pageUri = getPathName(pageUrl); const pageKeyUrl = addParams(baseKeyUrl, { uri: encodeURIComponent(pageUri), skip_sw_cache: true }); return await fetch(pageKeyUrl); }```
1767	dlsfleet.com.au.js	Information Exposure	Low	false	CWE-200	N/A	N/A	N/A	{The log function logs messages to the console if debug mode is enabled. This is not a sensitive function misuse, as console.log is not inherently dangerous. The vulnerability is due to debug information exposure, not misuse of a sensitive API.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
1768	dlsfleet.com.au.js	Improper Implementation	Medium	false	CWE-664	N/A	N/A	N/A	{The fetch event listener is defined but does nothing (empty function). This is an implementation issue, not a sensitive function misuse. No sensitive functions are involved.}	```self.addEventListener('fetch', () => {});```
1769	overflixtv.co.js	Improper Input Validation in Push Event Handling	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from push event data. If this 'id' is not properly validated or sanitized, it can lead to unintended requests to malicious or unintended endpoints, potentially resulting in information disclosure or unauthorized actions.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1770	overflixtv.co.js	Insecure CSRF Token Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of the 'loggedIn' state via URL parameters, not from misuse of a sensitive function. The code reads the 'loggedIn' value from the URL, but does not involve a sensitive function like eval, importScripts, or unsafe dynamic code execution.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
1771	overflixtv.co.js	Credential Leakage in Fetch Request	High	true	CWE-1004	N/A	fetch	standard	{The fetch function is used with credentials: 'include', and the URL is dynamically constructed using the 'path' parameter from the intercepted request. If the 'path' is not sanitized, it could lead to credential leakage via unintended requests to malicious endpoints, especially if the path is controlled by an attacker.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`, { credentials: curRequest.credentials })```
1772	overflixtv.co.js	Insecure Notification URL Handling	Medium	true	CWE-79	N/A	clients[0].navigate	standard	{The clients[0].navigate function is used with a URL derived from the notification data, which may be controlled by an attacker. If the 'data.url' is not validated, it can lead to open redirects or phishing attacks, as the service worker will navigate the client to an arbitrary URL.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
1773	popshelf.com.js	Caching of Sensitive POST Responses	High	true	CWE-522	10	N/A	standard	{The `cache.put()` function is used to store responses in the service worker's cache. When applied to POST requests, which typically contain sensitive data (e.g., credentials, personal information), this can lead to unintended exposure if the cached response is later accessed by unauthorized parties or if the cache is not properly secured. The misuse occurs because the code does not differentiate between request types and blindly caches all responses, including those that should not be cached for security reasons.}	```await cache.put(evt.request, networkResponse.clone());```
1774	haba-play.com.js	Loading untrusted external script in Service Worker	High	true	N/A	9	importScripts	standard	{The importScripts() function in Service Workers allows loading and executing external scripts. When used with a hardcoded external URL like 'https://assets.emarsys.net/web-emarsys-sdk/4.3.1/web-emarsys-service-worker.js', it introduces a risk if the external script is not fully trusted or could be compromised. Although the URL is hardcoded and not dynamically derived from untrusted input, the act of loading external code into a Service Worker context is inherently risky because it can lead to code injection, cache manipulation, or network interception if the external script is malicious or compromised. This is considered a sensitive function misuse due to the elevated privileges of Service Workers and the potential for supply chain attacks.}	```importScripts('https://assets.emarsys.net/web-emarsys-sdk/4.3.1/web-emarsys-service-worker.js');```
1775	thinkfirefly.com.js	Debug Logging Enabled in Production	Low	false	N/A	N/A	N/A	N/A	{Debug logging is enabled via pwaSettings.debug = true, which may expose sensitive information in production environments. This is a configuration issue, not misuse of a sensitive function.}	```const pwaSettings = {}; pwaSettings.debug = true;```
1776	thinkfirefly.com.js	Empty Fetch Event Handler	Medium	false	N/A	N/A	N/A	N/A	{The fetch event listener is defined but does nothing, which may lead to unhandled requests or missed caching opportunities. This is a logic or design flaw, not misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
1777	thinkfirefly.com.js	Cache Poisoning via Broad Regex	Medium	false	N/A	N/A	N/A	N/A	{The regex /.*?d[dp]-cdn\.multiscreensite\.com.*?/ is overly broad and may match unintended URLs, leading to cache poisoning. This is a logic issue with pattern matching, not misuse of a sensitive function.}	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
1778	thinkfirefly.com.js	No-CORS Prefetch Request	Medium	false	N/A	N/A	N/A	N/A	{The fetch request uses mode: 'no-cors', which prevents access to response data and may lead to silent failures. This is a misconfiguration, not misuse of a sensitive function.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
1779	thinkfirefly.com.js	Cache Bypass via URL Parameter	Low	false	N/A	N/A	N/A	N/A	{The skipCache function checks for 'skip_sw_cache' in the URL, allowing clients to bypass caching. This is a feature, not misuse of a sensitive function.}	```function skipCache(url) { return url && url.indexOf('skip_sw_cache') > -1; }```
1780	stargazerslounge.com.js	Improper Neutralization of Input	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from unsanitized user input in the `id` parameter used in a URL string for a fetch request. However, this is not due to misuse of a sensitive JavaScript function like `eval`, `importScripts`, or `setTimeout` with dynamic input. Instead, it is a classic case of improper input validation leading to potential server-side injection or unintended behavior, but no sensitive function is being misused in the context of JavaScript execution control or dynamic code evaluation.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' }).then(response => { if (!response.ok) { throw new Error('Invalid response'); } return response.json(); }).then(data => { if (data.error) { throw new Error('Server error'); } const { body, url, grouped, groupedTitle, groupedUrl, icon, image } = data; let { title } = data; let tag; if (data.tag) { tag = data.tag.substr(0, 30); } let options = { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } }; if (!tag || !grouped) { return self.registration.showNotification(title, options); } else { return self.registration.getNotifications({ tag }).then(notifications => { options = { ...options, tag, renotify: true, data: { ...options.data, unseenCount: 1 } }; if (notifications.length) { try { const lastWithTag = notifications[notifications.length - 1]; if (lastWithTag.data && typeof lastWithTag.data.unseenCount !== 'undefined') { const unseenCount = lastWithTag.data.unseenCount + 1; options.data.unseenCount = unseenCount; options.body = pluralize(grouped.replace('{count}', unseenCount), unseenCount); if (groupedUrl) { options.data.url = groupedUrl ? groupedUrl : options.data.url; } if (groupedTitle) { title = pluralize(groupedTitle.replace('{count}', unseenCount), unseenCount); } lastWithTag.close(); } } catch (err) { console.log(err); } return self.registration.showNotification(title, options); }); }); }).catch(err => { return returnDefaultNotification(); }); e.waitUntil(promiseChain);```
1781	mdmexclusives.com.js	Insecure Dynamic Code Loading via Hostname-Based Key	High	true	CWE-94	N/A	importScripts(uri + key);	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, the script dynamically constructs a URL by concatenating a base URI with a key that is determined based on the hostname. Although the key is not directly user-controlled, it is derived from a potentially untrusted source (hostname), and if an attacker can influence the hostname (e.g., via DNS spoofing, subdomain takeover, or misconfigured CNAMEs), they could cause the service worker to load and execute arbitrary remote code. This constitutes a dynamic code loading vulnerability, which can lead to full compromise of the service worker's execution context.}	```var uri = 'https://api.pushnami.com/scripts/v2/pushnami-sw/',  key = '5b637897d634027355ae72d2';switch (self.location.hostname) {  case 'www.divinepets.com':    key = '5b4d6859d500dd00100637fb';    break;  case 'www.divineeats.com':    key = '5b63784cdf4d4b27d9318ebc';    break;  case 'a.everydaywinner.com':  case 'a.everydaywinner.net':  case 'www.everydaywinner.com':  case 'www.everydaywinner.net':    key = '5b6378b561b71d0ad0423c7d';    break;  case 'www.ilovesamples.com':    key = '5b6378c70646cf4dbbec6c0f';    break;  case 'worldofsweeps.com':  case 'www.worldofsweeps.com':    key = '65396473f3494c0de1ca6a36';    break;}importScripts(uri + key);```
1782	kamuajans.net.js	Third-party script loading without integrity check	Medium	true	CWE-928	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and not derived from untrusted input, the lack of an integrity check (e.g., using a Subresource Integrity hash) means the script can be tampered with in transit or replaced by an attacker if the CDN is compromised. This allows for malicious code injection, which is a direct consequence of misusing the importScripts() function without proper security safeguards.}	```importScripts('https://cdn.kamuajans.net/assets/bundle/webpush.js?v=' + version);```
1783	ethersys.fr.js	Insecure Cache Management	Medium	false	New	N/A	N/A	N/A	{The vulnerability is related to insecure cache management practices, but it does not stem from the misuse of a sensitive JavaScript function. The code uses standard and safe caching patterns with caches.open and cache.addAll, where the URLs to cache are hard-coded and not derived from untrusted input. There is no dynamic or user-controlled input influencing the cache operations, so no sensitive function misuse is present.}	```var CACHE_NAME = 'ethersys-offline'; var urlsToCache = ['/offline.html', './img/logo.svg', './img/favicons/favicon-16x16.png']; self.addEventListener('install', function (event) { event.waitUntil(caches.open(CACHE_NAME).then(function (cache) { return cache.addAll(urlsToCache); })); }); self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } return fetch(event.request); })); });```
1784	elvetino.ch.js	Improper Handling of Service Worker Activation Leading to Immediate Client Takeover	High	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of `self.skipWaiting()` during the install event, which forces the new service worker to activate immediately, potentially bypassing the activation phase and leading to client takeover. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a design/behavioral issue with the service worker lifecycle.}	"```self.addEventListener(""install"", function (s) { self.skipWaiting(), s.waitUntil(caches.open(CACHE_NAME).then(function (s) { return s.addAll([OFFLINE_PAGE]); }).catch(function (s) {})); });```"
1785	elvetino.ch.js	Caching of External Resources from Untrusted Domains Leading to Cache Poisoning	Medium	false	CWE-434	N/A	N/A	N/A	{The vulnerability stems from including a resource from `cdn-dev.app.sbb.ch` in the `ASSETS_TO_CACHE` array, which is a dev domain and may not be fully trusted. However, this is not due to misuse of a sensitive function, but rather a misconfiguration in the hardcoded list of assets.}	"```""https://cdn-dev.app.sbb.ch/base/12.64.336/media/svg/bahninfrastruktur.svg""```"
1786	elvetino.ch.js	Insecure URL Matching in Cache Logic Leading to Cache Poisoning	Medium	true	CWE-22	N/A	ASSETS_TO_CACHE.includes	N/A	{The `includes()` method is used to check if a URL is in the `ASSETS_TO_CACHE` list, but it performs a substring match rather than a full URL or path comparison. This allows an attacker to craft a URL that matches a cached asset by including its string in the path (e.g., `https://evil.com/12.64.336/js/0.min.js`), leading to cache poisoning. The function `includes()` is a standard JavaScript method, but its misuse here creates a vulnerability.}	```ASSETS_TO_CACHE.includes(a)```
1787	elvetino.ch.js	Insecure URL Whitelisting in Ignore Logic Leading to Bypass	Medium	true	CWE-369	N/A	s.includes	standard	"{The `includes()` method is used in the `ignoreUrl` function to check if a URL contains specific substrings (e.g., ""ticketshop/b2c/adw.do""). This is insecure because it performs substring matching, allowing an attacker to bypass the ignore logic by including the substring in a different context (e.g., `https://example.com/ticketshop/b2c/adw.do?malicious=1`). This misuse of `includes()` leads to improper filtering and potential bypass.}"	```if (s.includes(n[p])) return !0;```
1788	yitake.in.js	Exposure of Sensitive Information in Service Worker	High	true	CWE-532	9	importScripts	standard	{The importScripts function is used with a dynamically constructed URL that includes the firebaseVersion variable. Although the value is hardcoded and not user-controlled, the use of dynamic string concatenation in importScripts can lead to unintended script loading if the variable were to be manipulated, potentially exposing sensitive information or allowing malicious script execution. However, in this case, the value is static and safe, so the risk is low. But since the vulnerability is labeled as High, it implies a broader concern about dynamic script loading, which is inherently risky.}	N/A
1789	yitake.in.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	8	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from event.notification.data.url. This value is directly taken from the push notification payload without validation or sanitization, allowing an attacker to craft a notification with a malicious URL, leading to an open redirect and potential phishing or malware delivery.}	N/A
1790	yitake.in.js	XSS via Unvalidated Push Payload	Medium	true	CWE-79	9	self.registration.showNotification	standard	{The showNotification function is called with payload.title and other data from the push notification payload without sanitization. If the payload contains user-controlled content, it can lead to XSS attacks when rendered in the notification UI, especially if the browser or platform interprets the content as executable script.}	N/A
1791	yitake.in.js	Exposure of Push Subscription Data	High	true	CWE-312	9	fetch	standard	{The fetch function is used to send sensitive push subscription data (endpoint, auth, p256dh, token) to a remote API endpoint. Although the data is sent over HTTPS, the exposure of this data to an external server without proper access controls or encryption can lead to unauthorized access or misuse of the subscription, potentially allowing attackers to send push notifications to the user.}	N/A
1792	americanapparel.com.js	Cache Poisoning via Misconfigured Cache Keys	High	true	CWE-444	9	N/A	standard	{The vulnerability arises from the use of the `O` function, which processes URLs and revisions to generate cache keys. When a URL is provided without a revision (e.g., `/static/css/2.c5d05573.chunk.css`), the function generates a cache key based on the URL alone, without any integrity checks. This allows an attacker to manipulate the cache by providing a malicious URL that maps to the same cache key as a legitimate resource, leading to cache poisoning. The `O` function is a custom utility, but it is used in conjunction with standard `caches.open()` and `caches.match()` functions, which are standard browser APIs. The misuse occurs because the cache key generation is not tied to a unique, immutable identifier (like a content hash or revision), making it vulnerable to collision attacks.}	```const { cacheKey: e, url: t } = O(s), a = this._cacheKeysToIntegrities.get(e), i = this._urlsToCacheModes.get(t);```
1793	beykent.edu.tr.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes scripts from a specified URL. In this case, the URLs are hardcoded to external domains ('https://push.setrowid.com/libs/dbFunks.min.js' and 'https://push.setrowid.com/sw.js'), which are not under the control of the application. While the URLs are static, they still represent untrusted external sources. If these scripts are compromised or controlled by an attacker, they can execute arbitrary code within the context of the service worker, leading to Remote Code Execution. This constitutes misuse of a sensitive function because the script sources are not validated or trusted, and the function is inherently dangerous when used with untrusted URLs.}	```importScripts('https://push.setrowid.com/libs/dbFunks.min.js');importScripts('https://push.setrowid.com/sw.js');```
1794	babyplan.ru.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the id parameter received from a push event. Since id is derived from untrusted external data (push notification payload), an attacker can manipulate it to cause the service worker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1795	babyplan.ru.js	Broken Access Control	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from logic that checks the loggedIn parameter in the URL, but this is not a sensitive function misuse—it’s a flawed access control decision based on URL parsing. No sensitive function is misused here.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
1796	babyplan.ru.js	Cross-Site Request Forgery (CSRF) Mitigation Weakness	Medium	false	N/A	0	N/A	N/A	{The issue is not due to misuse of a sensitive function, but rather a design flaw in CSRF token handling. The code fetches a CSRF token and injects it into requests, but the vulnerability stems from the lack of proper validation or scope enforcement, not from improper use of a sensitive function.}	```headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
1797	babyplan.ru.js	Open Redirect	High	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the data.url field of a notification, which is sourced from untrusted push data. This allows an attacker to redirect users to arbitrary websites, leading to open redirect.}	```clients[0].navigate(data.url);```
1798	babyplan.ru.js	Insecure Caching of Sensitive Data	Low	false	N/A	0	N/A	N/A	{The vulnerability is due to caching an offline page without proper validation or scope control, but it does not stem from misuse of a sensitive function like cache.match(). The function is used correctly; the issue is in the design of what is cached.}	```return cache.match(OFFLINE_URL);```
1799	babyplan.ru.js	Exposure of Debug Information	Low	false	N/A	0	N/A	N/A	{The vulnerability arises from logging debug messages conditionally based on a DEBUG flag, but it does not involve misuse of a sensitive function. The console.log() function is used appropriately; the issue is in the logic of exposing debug info.}	```if (DEBUG) { if (typeof message === 'string') { message = `SW: ${message}`; } console.log(message); }```
1800	opi.org.pl.js	Improper Cache Invalidation	Medium	false	CWE-379	N/A	N/A	N/A	{The vulnerability arises from improper cache cleanup logic, but it does not stem from misuse of a sensitive function. The code correctly deletes caches other than 'iworks-pwa-offline-cache-pl-2', but the issue is more about logic or design rather than unsafe function usage.}	```caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.filter(function (cacheName) { return 'iworks-pwa-offline-cache-pl-2' !== cacheName; }).map(function (cacheName) { return caches.delete(cacheName); })); })```
1801	opi.org.pl.js	Insecure Cache Bypass	High	true	New	N/A	caches.add	standard	{The function caches.add is used with a Request object that includes a cache: 'reload' option, which may bypass intended caching behavior and force network fetches even when offline, potentially exposing the application to network-based attacks or inconsistent state. However, the primary risk here is not direct injection but improper cache handling.}	```cache.add(new Request('iworks-pwa-offline', { cache: 'reload' }));```
1802	opi.org.pl.js	Static Offline Page XSS Risk	High	true	CWE-79	N/A	cache.match	standard	{The function cache.match is used to retrieve a cached response for 'iworks-pwa-offline', which may contain user-generated or untrusted content. If the offline page is dynamically generated or includes user input without proper sanitization, this could lead to XSS when served to users. The function itself is not inherently unsafe, but its misuse in serving potentially untrusted content introduces risk.}	```cache.match('iworks-pwa-offline')```
1803	bettybarclay.com.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts from a remote host, leading to remote code execution within the service worker context.}	```importScripts(`https://bettybarclay.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1804	manyzone.com.js	Exposed API Key	High	false	N/A	N/A	N/A	N/A	{The API key is hardcoded in the script and exposed in the source code, but no sensitive JavaScript function is misused to cause this vulnerability.}	```const firebaseConfig = { apiKey: 'AIzaSyAbuZPqbyQUvPK00jNjnerwEHP2vAUaJEU', authDomain: 'umastro-39798.firebaseapp.com', databaseURL: 'https://umastro-39798.firebaseio.com', projectId: 'umastro-39798', storageBucket: 'umastro-39798.appspot.com', messagingSenderId: '884361479586', appId: '1:884361479586:web:9a7488b3b5a17091ae5efb' }; firebase.initializeApp(firebaseConfig);```
1805	manyzone.com.js	Insufficient Input Validation	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used on untrusted data from event.data.json(). If the data is malformed or crafted by an attacker, it can lead to unexpected behavior or injection, especially since the parsed data is later used to construct notification options and other dynamic behavior.}	```options.actions = JSON.parse(obeventdata.data.actions);```
1806	manyzone.com.js	Open Redirect	Medium	true	N/A	N/A	encodeURIComponent	standard	{The navigate_url is constructed using user-controlled data from randdata.noclur and then passed to encodeURIComponent. While encodeURIComponent is safe for encoding, the underlying data source (randdata.noclur) is untrusted and can be manipulated to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```navigate_url = encodeURIComponent(navigate_url);```
1807	manyzone.com.js	Insecure Inter-Process Communication	Medium	true	N/A	N/A	postMessage	standard	{The postMessage function is used to send messages to a BroadcastChannel without validating or sanitizing the message content. If the message data is derived from untrusted sources, it can be exploited to trigger unintended actions or leak information across contexts.}	```channel4Broadcast.postMessage({ type: 'PlayRingSound' });```
1808	afristay.com.js	Open Redirect	High	true	N/A	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a URL provided by the notification data, which is derived from untrusted input (event.notification.data.url). Since this URL is not validated or sanitized, an attacker can craft a malicious payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```self.clients.openWindow(event.notification.data.url);```
1809	afristay.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing JSON without validating the structure or content of the payload. However, no sensitive function is directly misused here—this is a logic flaw in data handling, not a misuse of a sensitive API.}	```var data = JSON.parse(payload), head = data.head, body = data.body, badge = data.badge, icon = data.icon;```
1810	afristay.com.js	Insecure Direct Object Reference	Medium	false	N/A	N/A	N/A	N/A	{The assignment of url = data.url ? data.url : self.location.origin is a logic issue where user-controlled data is used to set a URL, but no sensitive function is directly misused. The risk stems from trusting user input without validation, not from a sensitive function call.}	```url = data.url ? data.url : self.location.origin;```
1811	hr-inforadio.de.js	Insecure Handling of Notification URLs	High	true	CWE-601	9	clients.openWindow	standard	{The `clients.openWindow(a)` function is used to open a new browser window or tab with the URL specified in `a`, which is derived from `e.notification.data.jumpUrl`. Since this value is directly taken from the notification payload without validation or sanitization, an attacker could craft a malicious notification with a `jumpUrl` pointing to an arbitrary, potentially harmful, external site. This allows for open redirects or phishing attacks, as the service worker will open the specified URL without any checks.}	N/A
1812	hr-inforadio.de.js	Lack of Input Validation in Fetch Handling	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability stems from the lack of input validation on the `fetch(t)` call, where `t` is the request object from the event. However, this is not due to misuse of a sensitive function per se, but rather a design flaw in handling requests without validating or sanitizing the request URL or headers. The `fetch` function itself is used correctly; the issue lies in the absence of security checks on the request object, which could lead to unintended resource fetching or cache poisoning if the request is manipulated.}	N/A
1813	tvcultura.com.br.js	XSS via Firebase SDK	High	false	CVE-2020-16155	N/A	N/A	N/A	{The vulnerability CVE-2020-16155 is related to a flaw in the Firebase SDK itself, not due to misuse of a sensitive JavaScript function in this script. The script merely imports the SDK, and the vulnerability arises from the SDK's handling of untrusted data, not from how importScripts is used here.}	```importScripts('https://www.gstatic.com/firebasejs/6.2.4/firebase-app.js');```
1814	tvcultura.com.br.js	Open Redirect via Untrusted URL	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic URL derived from event.notification.data.link, which originates from a push notification payload. Since this payload is controlled by an external source (e.g., a server or attacker), it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(notificationPage));```
1815	today.ua.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which exposes it to potential extraction by attackers.}	"```self[`appKey`] = ""9eb01d26dfe76f8400bfa731dd46b019"";```"
1816	today.ua.js	Untrusted Script Loading via External CDN	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is derived from a hardcoded value (self.hostUrl), it introduces a risk if the CDN is compromised or if the script is not properly vetted. Although the URL is not dynamically derived from untrusted input, the reliance on an external CDN for script loading still constitutes a security risk, especially if the script is not integrity-protected.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1817	trabajos.com.js	Outdated Library Usage	High	false	CWE-426	N/A	N/A	N/A	{The vulnerability is due to using an outdated version of Firebase (4.1.1), which may contain known security flaws. This is not caused by misuse of a sensitive JavaScript function, but rather by using an old library version.}	```importScripts('https://www.gstatic.com/firebasejs/4.1.1/firebase-app.js');```
1818	trabajos.com.js	Open Redirect via click_action	Medium	true	New	N/A	click_action	standard	{The click_action field in notificationOptions is derived from untrusted payload data and passed directly to showNotification(). If an attacker can control this field, they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities. The showNotification() function is a standard browser API that does not sanitize or validate the click_action URL, making it sensitive when used with untrusted input.}	```const notificationOptions = { body: payload.notification.body, icon: payload.notification.icon, click_action: payload.notification.click_action };```
1819	engadin.ch.js	Improper Input Validation (Substring-based Domain Check)	Medium	false	CWE-20	N/A	N/A	N/A	"{The vulnerability arises from using substring matching (indexOf) on the full URL to determine if a request should be cached. This approach is not sensitive function misuse but rather a logic flaw in validation, as it can be bypassed by attackers injecting the substring into benign URLs (e.g., ""https://example.com/empfehlio.com/path""). No sensitive JavaScript function is misused here.}"	```urlsPartsToIgnore.forEach(text => { if (event.request.url.indexOf(text) !== -1) { allowToCache--; } });```
1820	de10.com.mx.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and not derived from untrusted input, the vulnerability classification as ""Remote Code Execution via Untrusted Script Import"" implies a risk if the URL were to be dynamically constructed from user-controlled or untrusted sources. However, in this specific instance, the URL is fixed and does not involve dynamic input, so the risk is minimal. The detection may be a false positive or based on a broader policy.}"	"```self.importScripts(""https://client-version.cf.emarsys.net/web-emarsys-sdk-v4/latest/web-emarsys-service-worker.js"");```"
1821	wineandfoodtour.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL (ve) that incorporates untrusted input from body.data.sensor and body.data.push_send_id. Since these values are derived from external push message data, an attacker can manipulate them to cause the service worker to make HTTP requests to arbitrary internal or external endpoints, leading to SSRF.}	```var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.wineandfoodtour.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
1822	wineandfoodtour.it.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The clients.openWindow() function is called with event.notification.data.url, which is directly sourced from untrusted push notification data. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1823	onlinetvrecorder.com.js	Improper Input Validation for Notification Content	Medium	true	CWE-20	N/A	self.registration.showNotification(title	standard	{The function self.registration.showNotification() is a standard browser API used to display notifications. When the 'body' parameter is directly derived from untrusted input (event.data.text()), it can lead to improper input validation. Although the notification content is not executable code, it may still be used to display malicious or misleading content, potentially leading to social engineering attacks or phishing. The vulnerability arises because the input is not sanitized or validated before being passed to the notification API.}	```self.registration.showNotification(title, { body, icon: '//static.onlinetvrecorder.com/images/web-push/otr.jfif' });```
1824	stuffandnonsense.co.uk.js	Improper URL Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from the use of a broad regular expression `new RegExp('/*')` in `workbox.routing.registerRoute`, which matches all URLs. While this is not directly caused by misuse of a sensitive function, it represents a configuration issue rather than a function misuse. The `registerRoute` method is part of the Workbox library and is used correctly; the issue lies in the overly permissive route pattern, not in improper handling of untrusted input or unsafe function execution.}	```workbox.routing.registerRoute(new RegExp('/*'), new workbox.strategies.StaleWhileRevalidate({ cacheName: CACHE }));```
1825	nosotrasonline.com.co.js	Improper Input Validation in Message Handling	High	true	CWE-20	N/A	self.addEventListener	standard	{The self.addEventListener function is used to handle incoming messages, but the event.data.gatsbyApi is directly used as a key to invoke functions from the MessageAPI object without validation. This allows an attacker to trigger arbitrary functions if they can control the message payload, leading to potential code execution or unintended behavior.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
1826	nosotrasonline.com.co.js	Exposed API Key in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials in client-side code, not misuse of a sensitive function.}	"```var firebaseConfig = { apiKey: ""AIzaSyC7EtozMNgbJqFGu4p-fOZXHQldABDj0MY"", authDomain: ""familia-nol-pdn.firebaseapp.com"", projectId: ""familia-nol-pdn"", storageBucket: ""familia-nol-pdn.appspot.com"", messagingSenderId: ""220031623814"", appId: ""1:220031623814:web:a42c5a3353e1e8db4c6707"", measurementId: ""G-83RC8HYPKH"" };```"
1827	nosotrasonline.com.co.js	Insecure Dynamic API Call Handling	High	true	CWE-548	N/A	MessageAPI[data.api]	custom	{The MessageAPI object is accessed dynamically using data.api, which is derived from untrusted input (URL path parameters). Since no validation or whitelisting is applied, an attacker can invoke any function in the MessageAPI object, leading to arbitrary function execution.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
1828	nosotrasonline.com.co.js	Improper URL Parameter Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper parsing and validation of URL path parameters, but no sensitive JavaScript function is misused. The issue is in logic design, not function misuse.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
1829	rashedoon.ir.js	External Script Import Without Integrity Check	High	true	CWE-436	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection, data exfiltration, or full compromise of the service worker. In this case, the script is imported from a hardcoded URL, but the lack of integrity verification (e.g., via Subresource Integrity) still constitutes a high-risk vulnerability because the script could be tampered with in transit or replaced by an attacker if the server is compromised.}	```importScripts('https://van.najva.com/static/js/scripts/rashedoon-website-18310-61ee1665-03c6-4ed5-bf9e-d1ff36563a8d-service-worker.js');```
1830	pricee.com.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow() function is used to open a new browser window or tab with a URL derived from untrusted notification data (event.notification.data.url or event.currentTarget.actions.click_action). Since these values are not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	N/A
1831	pricee.com.js	Open Redirect via Unvalidated Push Data	High	true	CWE-601	9	clients.openWindow	standard	{Although clients.openWindow is not directly called in this code snippet, the vulnerability arises because the notification URL (data.notification.url) is used in the notification data object without validation. If this URL is later used by clients.openWindow or similar functions in other parts of the service worker or client-side code, it can lead to open redirect. The lack of input sanitization on the URL from the external API makes it a sensitive function misuse.}	N/A
1832	```var url = 'https://notifications.gadgets360.com/alerts/gadgets360Alerts.json'; event.waitUntil(fetch(url).then(function (response) { if (response.status !== 200) { console.log('Looks like there was a problem. Status Code: ' + response.status); throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { console.log('The API returned an error.', data.error); throw new Error(); } var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var requireInteractionFlag = false; if (navigator.userAgent.indexOf('Mobile') === -1) { requireInteractionFlag = true; } self.registration.showNotification(title, { body: message, icon: icon, vibrate: [300, 100, 400], tag: data.notification.url, image: data.notification.image, data: { url: data.notification.url }, requireInteraction: requireInteractionFlag }); }));```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```var url = 'https://notifications.gadgets360.com/alerts/gadgets360Alerts.json'; event.waitUntil(fetch(url).then(function (response) { if (response.status !== 200) { console.log('Looks like there was a problem. Status Code: ' + response.status); throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { console.log('The API returned an error.', data.error); throw new Error(); } var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var requireInteractionFlag = false; if (navigator.userAgent.indexOf('Mobile') === -1) { requireInteractionFlag = true; } self.registration.showNotification(title, { body: message, icon: icon, vibrate: [300, 100, 400], tag: data.notification.url, image: data.notification.image, data: { url: data.notification.url }, requireInteraction: requireInteractionFlag }); }));```
1833	pacificwestcollege.com.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the specified URL. In this case, the URL is derived directly from event.notification.data.url, which is user-controlled data from a push notification. Since no validation or sanitization is performed on this input, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This allows phishing, credential theft, or redirection to malicious sites.}	```clients.openWindow(event.notification.data.url);```
1834	agconnect.nl.js	Insecure External Script Import	High	true	CWE-829	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL were derived from untrusted input (e.g., user-controlled parameters), it could lead to arbitrary code execution. However, in this case, the URL is hardcoded and not dynamic, so the vulnerability is not due to sensitive function misuse with dynamic input. Therefore, the vulnerability is not classified as ""sensitively_vulnerable"" because the function is not misused with dynamic or untrusted input.}"	"```try { self.importScripts(""https://campaign5-webpush.ternairsoftware.com/publicwebpush/TernairWebPushSDK""); } catch (e) { console.error(e); }```"
1835	pocketsiem.co.uk.js	SSRF via Cache Strategies	High	true	CWE-918	10	URL	standard	{The code constructs a URL using `new URL(e, location.href)` where `e` is a user-controlled or dynamically derived string (e.g., from a route match or precache entry). This allows an attacker to supply a malicious URL (e.g., internal network resources) that is then used to fetch or cache data, leading to Server-Side Request Forgery (SSRF). The vulnerability arises because the URL is not validated or sanitized before being used in cache operations.}	```const a = new URL(e, location.href); return this._urlsToCacheKeys.get(a.href);```
1836	kegoc.kz.js	Cache Deletion During Installation Leading to Ineffective Caching	High	false	N/A	N/A	N/A	N/A	{The caches.delete(CACHE_NAME) call during installation removes the cache immediately after opening it, preventing any resources from being cached. This is a logic error, not a misuse of a sensitive function.}	```var CACHE_NAME = 'amu-site-cache-v1'; var urlsToCache = []; self.addEventListener('install', function (event) { event.waitUntil(caches.open(CACHE_NAME).then(function (cache) { console.log('Opened cache'); caches.delete(CACHE_NAME); return cache.addAll(urlsToCache); })); });```
1837	kegoc.kz.js	Cache Deletion on Every Fetch Request Leading to Availability Issues	High	false	N/A	N/A	N/A	N/A	{The caches.delete(CACHE_NAME) call within the fetch event handler deletes the cache every time a request is made, which prevents caching from being effective and leads to repeated network requests. This is a logic error, not a misuse of a sensitive function.}	```self.addEventListener('fetch', function (event) { event.waitUntil(caches.open(CACHE_NAME).then(function (cache) { caches.delete(CACHE_NAME); })); event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } return fetch(event.request); })); });```
1838	saraymedya.com.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and not derived from untrusted input, the absence of an integrity check (e.g., using a Subresource Integrity hash) means the script can be tampered with if the CDN is compromised. This allows an attacker to inject malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or request interception. Although the input is not dynamic, the lack of integrity verification makes this a sensitive misuse of a standard function.}	```importScripts('https://cdn.saraymedya.com/assets/bundle/webpush.js?v=' + version);```
1839	dbtyojana.com.js	Hardcoded Sensitive Information (Firebase Config)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (API key, project ID, etc.) in the code, not from misuse of a sensitive function.}	```const options = { firebaseConfig: { projectId: 'marathi-4fba7', messagingSenderId: '262638634676', appId: '1:262638634676:web:156b45ace46c7c7339f9e1', apiKey: 'AIzaSyC1l4tRUuG38qPJgmhuKIKnL-wk8ZY5Gpk' }, domain: 'dbtyojana.com', api_url: 'https://push.marathinewz.com/api/token', vapid_public_key: 'BEA7OyCePQlLzgF31aseIBl_eutpweaYHhmLmVXFpBDjA9oI1jNqvo4Eie1WmU36jsWH0cig5VLKAJgMzi_DcDA' };```
1840	dbtyojana.com.js	Open Redirect in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is unsanitized and potentially controlled by an attacker. This allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
1841	dbtyojana.com.js	XSS via Unsanitized Notification Payload	Medium	true	N/A	N/A	self.registration.showNotification	standard	{The showNotification function is called with payload data that is not sanitized or validated. Since the payload is derived from untrusted push message data, an attacker can inject malicious content (e.g., script tags) into the notification, leading to XSS if rendered in a context that executes script.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
1842	dbtyojana.com.js	Insecure Storage of Sensitive Data (IndexedDB)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption or access controls, not from misuse of a sensitive function.}	```const request = objectStore.put({ id: key, data: value });```
1843	dbtyojana.com.js	Insufficient Input Validation in Push Event	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from lack of input validation on the push event payload, not from misuse of a sensitive function. The JSON.parse call is safe, but the data is used without validation, which could lead to logic errors or injection if misused.}	```const payload = JSON.parse(event.data.json().data.notification);```
1844	googlefeud.com.js	Insecure Message Handling	High	true	CWE-200	9	self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });	standard	{The use of `self.addEventListener('message', ...)` with dynamic API call resolution via `MessageAPI[api]` allows an attacker to inject arbitrary function names from the message data, leading to unauthorized execution of potentially dangerous operations. This is a classic case of insecure message handling where untrusted input directly controls function invocation.}	N/A
1845	googlefeud.com.js	Improper Input Validation	Medium	true	CWE-20	8	const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }	standard	{The code parses URL path parameters without sanitizing or validating them, allowing arbitrary key-value pairs to be injected into the `data` object. This can lead to unintended behavior, especially if `data.api` is used to invoke functions dynamically, potentially enabling command injection or other logic flaws.}	N/A
1846	googlefeud.com.js	Cache Poisoning Risk	Medium	false	N/A	5	workbox.routing.registerRoute(/(\.js$|\.css$|static\/)/, new workbox.strategies.CacheFirst(), 'GET');	standard	{The use of `CacheFirst` strategy for common static assets is a standard caching approach and does not inherently introduce cache poisoning. The vulnerability arises from broader caching policy design, not misuse of a sensitive function.}	N/A
1847	googlefeud.com.js	Excessive Cache Deletion Permissions	Medium	false	N/A	6	event.waitUntil(idbKeyval.clear()); event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));	standard	{The `caches.delete()` and `idbKeyval.clear()` functions are used as intended for cache management. The risk stems from the broad scope of deletion (e.g., clearing all IDB data or caches with 'runtime' in name), not from misuse of a sensitive function.}	N/A
1848	googlefeud.com.js	Uncontrolled Resource Consumption	Low	false	N/A	4	self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });	standard	{The event listener itself is not inherently resource-intensive. The risk of uncontrolled consumption is due to potential misuse of the `MessageAPI` functions, not the `addEventListener` function.}	N/A
1849	ez-slot.org.js	Insecure Caching of Offline Content	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the insecure caching behavior of storing an offline page without validating or sanitizing its content. The code uses `cache.add()` with a hardcoded `OFFLINE_URL`, which is not dynamically derived from untrusted input, so no sensitive function misuse is present.}	```await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
1850	liumingye.cn.js	Vulnerable Dynamic Function Execution	High	true	N/A	N/A	__esm	standard	{The __esm function dynamically executes code passed as a parameter (fn) without validation, allowing arbitrary code execution if fn is controlled by an attacker. This is a classic case of dynamic code evaluation, which is inherently dangerous.}	```var __esm = (fn, res) => function __init() { return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res; };```
1851	liumingye.cn.js	Insecure WebSocket URL Handling	Medium	true	N/A	N/A	new WebSocket2	standard	{The WebSocket constructor is used with a URL derived from user input (this._url), which is not validated or sanitized. An attacker could supply a malicious URL to establish a WebSocket connection to an unintended server, potentially leaking data or performing actions on behalf of the user.}	```this._ws = this._protocols ? new WebSocket2(url, this._protocols) : new WebSocket2(url);```
1852	liumingye.cn.js	XSS in Notification Rendering	High	true	N/A	N/A	globalThis.registration.showNotification	standard	{The showNotification API is used with user-controlled data (data.body.note.text) directly inserted into the notification body without sanitization. This allows an attacker to inject malicious scripts or HTML that may be rendered in the notification interface, leading to XSS.}	```await globalThis.registration.showNotification(...n);```
1853	liumingye.cn.js	Insecure URL Construction	Medium	true	N/A	N/A	new URL	standard	{The new URL constructor is used with a user-provided URL (url) without validation. This allows an attacker to manipulate the URL to point to a malicious domain or perform open redirects, potentially leading to phishing or data exfiltration.}	```const u = new URL(url, origin);```
1854	liumingye.cn.js	Unvalidated User Input in API Requests	Medium	true	N/A	N/A	payload.append	standard	{The FormData.append method is used to add user-controlled parameters (params) to a request body without validation. This allows an attacker to inject arbitrary data into API requests, potentially leading to unintended behavior or data leakage.}	```payload.append(key, value);```
1855	liumingye.cn.js	Insecure Cache Busting	Low	false	N/A	N/A	N/A	N/A	{The cache.put operation uses a dynamically generated cache name, but there is no direct sensitive function misuse. The issue is more about cache management and potential cache pollution, not a direct security vulnerability from a sensitive function.}	```caches.open(this.cacheName).then(cache => cache.put(localeUrl, clone));```
1856	unilever.co.uk.js	Improper Input Validation (Substring Matching in URL Checks	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from using substring matching (indexOf) on the full URL string to check for excluded paths or hosts. This is not inherently caused by misuse of a sensitive function, but rather by flawed logic in input validation. The code does not invoke any sensitive functions like eval, importScripts, or dynamic code execution APIs.}	```const { hostname: t } = new URL(e.request.url); IGNORED_HOSTS.indexOf(t) >= 0 || EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || 'PUT' === e.request.method || 'POST' === e.request.method || e.request.headers.get('range') || (e.request.headers.get('Accept').includes('text/html') ? e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request```
1857	unilever.co.uk.js	Caching Without Response Validation	Medium	false	CWE-200	N/A	N/A	N/A	{This issue stems from caching responses without validating their integrity or origin. The code uses standard caching APIs (caches.open, caches.put), but there is no evidence of misuse of sensitive functions. The vulnerability is due to design flaws, not improper use of a sensitive function.}	```e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request```
1858	unilever.co.uk.js	Potential Cache Poisoning via Third-Party Content	High	false	New	N/A	N/A	N/A	{The vulnerability arises from caching responses from third-party hosts without validating their content or origin. While the code uses fetch and caches.put, these are standard APIs used correctly. The issue is due to trust assumptions in the caching logic, not misuse of a sensitive function.}	```fetch(e.request).then(n => RUNTIME_IGNORED_HOSTS.indexOf(t) > -1 ? n : E.put(e.request```
1859	radixweb.com.js	Insecure Cache Bypass via Host Manipulation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in the isIgnoreCache function, which checks if the request URL contains the current location.host. This is not a misuse of a sensitive function but rather a flawed logic decision that could allow bypassing cache rules if the host is manipulated.}	```return t.indexOf(location.host) === -1;```
1860	radixweb.com.js	Regex Pattern Over-Matching in Origin Cache Rules	Medium	false	New	N/A	N/A	N/A	{The issue stems from the use of a regex pattern with word boundaries (\b) that may not correctly match the intended domain due to context, but this is not caused by misuse of a sensitive function—it is a misconfiguration in pattern design.}	```new RegExp(/\bfonts.googleapis.com\b/g)```
1861	radixweb.com.js	Insecure Message Handling in Cache Update	High	true	CWE-200	N/A	caches.open	standard	{The caches.open function is called with user-controlled input (t.cacheName) from a message event, allowing an attacker to specify arbitrary cache names and potentially overwrite or access unintended caches, leading to cache manipulation or data leakage.}	```e.waitUntil(caches.open(t.cacheName).then(async a => a.addAll(t.assets)));```
1862	codefling.com.js	Improper Validation of Logged-In Status Leading to Authentication Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the logged-in status via a URL parameter, not from misuse of a sensitive JavaScript function. The code parses `loggedIn` from the URL using a regex, but does not validate or sanitize it properly, allowing attackers to manipulate the URL to bypass authentication checks. This is a logic flaw, not a sensitive function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
1863	codefling.com.js	Server-Side Request Forgery (SSRF) via Unsanitized Push Notification ID	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received from a push notification. Since `id` is not validated or sanitized, an attacker can craft a malicious push notification with an `id` that points to an internal or external resource, causing the service worker to make unauthorized requests on behalf of the user, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1864	codefling.com.js	Open Redirect in Notification Click Handler via Unvalidated URL	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a URL derived from the `data.url` field in the notification payload. Since this URL is not validated or sanitized, an attacker can inject a malicious URL, causing the browser to redirect the user to an arbitrary site, leading to open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
1865	codefling.com.js	CSRF Token Fetching with Credentials Exposing to Token Leakage	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used to retrieve a CSRF token with `credentials: 'include'`, and the request URL includes the `path` parameter from the intercepted request. If the `path` is not sanitized, an attacker could manipulate it to trigger unintended requests, potentially leaking CSRF tokens or causing unintended actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
1866	codefling.com.js	Information Exposure Through Debug Logging	Low	false	N/A	N/A	N/A	N/A	{The vulnerability stems from debug logging that outputs sensitive information when `DEBUG` is enabled. This is not caused by misuse of a sensitive function, but rather by insecure logging practices. The `console.log` function is used appropriately, but the content being logged is sensitive.}	```if (DEBUG) { if (typeof message === 'string') { message = `SW: ${message}`; } console.log(message); }```
1867	lifepal.co.id.js	Loading external script without integrity checks	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL (//cdnt.netcoresmartech.com/swv4.js) without integrity checks, it introduces a risk of loading a malicious or tampered script if the CDN is compromised. Although the URL is hardcoded and not dynamic, the lack of integrity verification (e.g., using a Subresource Integrity hash) makes it vulnerable to supply chain attacks.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
1868	lifepal.co.id.js	Hardcoded sensitive information in client-side code	Medium	false	CWE-200	N/A	N/A	N/A	{Hardcoded sensitive information such as API keys, project IDs, and user keys in client-side JavaScript is a security issue, but it is not caused by misuse of a sensitive function. The vulnerability arises from poor secret management, not from improper use of a function like importScripts or eval.}	```var config = {appId: '1:685494632447:web:3b61f9c350033f2fb4b1ca', projectId: 'lifepal-firebase', apiKey: 'AIzaSyA402W3gJrlV9sIsTMnIC-HPVuEkze97e4', messagingSenderId: '685494632447', user_key: 'ADGMOT35CHFLVDHBJNIG50K96BO9QDMCC4BKDHCR20IKALIAIBU0', siteid: '8025ddff64f12cd7dd7c17c6b5d5272f'};```
1869	lawsofux.com.js	Caching Sensitive Data Without Validation	High	false	N/A	0	N/A	N/A	{The vulnerability described is not caused by misuse of a sensitive JavaScript function, but rather by a design flaw in caching strategy—specifically, the lack of validation or filtering of requests before caching. The code caches responses without checking if the requested resource is safe or intended to be cached, which could lead to caching sensitive or unintended data. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```event.respondWith(caches.open(CACHE_NAME).then(function (cache) { return cache.match(request).then(function (response) { return response || fetch(request).then(function (response) { cache.put(request, response.clone()); return response; }); }); }));```
1870	swica.ch.js	Remote Code Execution via Dynamic Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts from a remote host, leading to remote code execution within the service worker context.}	```importScripts(`https://swica.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
1871	juvelive.it.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (body.data.sensor and event.notification.data.sensor). Since these inputs are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.juvelive.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
1872	juvelive.it.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (event.notification.data.sensor). Since this input is not validated or sanitized, an attacker can manipulate it to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.juvelive.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click';```
1873	layerfive.com.js	Server Side Request Forgery (SSRF) via 'no-cors' mode in prefetchUrl	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with 'no-cors' mode, which allows requests to be made to any origin without CORS restrictions. The URL is constructed from user-controlled input via addParams(), which can be manipulated to point to internal or external resources, enabling SSRF attacks.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
1874	layerfive.com.js	Cache Deletion via Unauthenticated Message Command	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from unauthenticated message handling, not from misuse of a sensitive JavaScript function. The code listens for messages and deletes a cache based on a command, but no sensitive function is misused in this context.}	```event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME });```
1875	layerfive.com.js	Potential Cache Poisoning via Unvalidated URL Handling	Medium	true	CWE-113	8	N/A	standard	{The new URL() constructor is used with user-controlled input from the addParams() function. If the input URL is malformed or crafted by an attacker, it can lead to unintended URL resolution or cache poisoning, especially when combined with cache.put() operations.}	```const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); });```
1876	inabruzzo.it.js	Open Redirect via Unvalidated URL Construction	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided by untrusted data (event.notification.data.url) without validation, allowing an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1877	inabruzzo.it.js	Open Redirect via Unvalidated URL Construction	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided by untrusted data (event.notification.data.url) without validation, allowing an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1878	inabruzzo.it.js	Insecure Fetch to Untrusted URL	Medium	true	CWE-352	9	fetch	standard	{The fetch() function is called with a URL constructed from untrusted input (sensor_url and body.data.push_send_id), which can be manipulated by an attacker to send requests to arbitrary endpoints, leading to insecure fetch behavior.}	```fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
1879	inabruzzo.it.js	Insecure Fetch to Untrusted URL	Medium	true	CWE-352	9	fetch	standard	{The fetch() function is called with a URL constructed from untrusted input (event.notification.data.sensor and event.notification.data.push_send_id), which can be manipulated by an attacker to send requests to arbitrary endpoints, leading to insecure fetch behavior.}	```fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {});```
1880	farescraper.com.js	External Script Injection via importScripts	High	true	CWE-78	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://api.pushnami.com/scripts/v2/pushnami-sw/650b4bceceb5bf0013a6b63f'. While the URL is not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a security risk: if the remote script is compromised or modified, it can execute arbitrary code within the service worker context, leading to potential data exfiltration, cache manipulation, or network interception. This constitutes a sensitive function misuse because the function is inherently dangerous when used with external sources, even if the source is static.}	```importScripts('https://api.pushnami.com/scripts/v2/pushnami-sw/650b4bceceb5bf0013a6b63f');```
1881	sendasmile.de.js	Vulnerable Cache.addAll Usage	High	true	N/A	9	caches.addAll	standard	{The caches.addAll() function is used to add multiple resources to a cache. When the 'links' parameter is derived from external input (via message event), it allows an attacker to inject arbitrary URLs into the cache, potentially leading to cache poisoning or execution of malicious scripts if those resources are later served to the client.}	```const cache = await caches.open('editor'); await cache.addAll(links);```
1882	sendasmile.de.js	Unvalidated JSON Input in Push Event	Medium	false	N/A	N/A	N/A	N/A	{The JSON input from the push event is parsed and destructured, but no sensitive function is directly misused. The vulnerability arises from insufficient validation of the parsed data, not from improper use of a sensitive function.}	```const { type, firstName, day, month, year, contactId, calendarEventType } = e.data.json();```
1883	sendasmile.de.js	Open Redirect in Notification Click	Medium	true	N/A	9	self.clients.openWindow	standard	{The self.clients.openWindow() function is used to open a URL passed from the notification data. If the 'url' parameter is derived from untrusted input (e.g., from the push event data), it can be manipulated to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```return self.clients.openWindow(url);```
1884	catalogs.com.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can load scripts from untrusted sources, potentially allowing an attacker to inject malicious code if the script source is compromised or if the URL is dynamically controlled by an attacker. In this case, although the URL is hardcoded, the lack of integrity verification still poses a risk if the remote script is ever modified or if the domain is compromised.}	```try { importScripts('https://s3.amazonaws.com/trackpush/push-worker-sdk.js'); } catch (e) {}```
1885	wesbank.co.za.js	Improper Caching of Sensitive Data	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from caching all .js, .html, and .json files using a broad regular expression without considering the sensitivity of the content. However, this is not due to misuse of a sensitive JavaScript function like importScripts() or eval(), but rather a misconfiguration in caching strategy. The workbox.strategies.StaleWhileRevalidate() is used correctly, but the route pattern is overly permissive, leading to potential caching of sensitive data. No sensitive function misuse is involved.}	```workbox.routing.registerRoute(/.*.(?:js|html|json)$/, new workbox.strategies.StaleWhileRevalidate(dataStoreCondig), 'GET');```
1886	cartermuseum.org.js	Improper Validation of Response Before Caching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from caching the response from fetch without validating its integrity or origin. However, no sensitive function is misused in a way that directly enables injection or arbitrary code execution. The fetch() call is used correctly with a known, hardcoded URL (OFFLINE_URL), and the response is cached without dynamic or untrusted input influencing the request. Thus, while the caching behavior is risky, it does not stem from misuse of a sensitive function.}	```'use strict';const CACHE_VERSION = 1;let CURRENT_CACHES = {offline: 'offline-v' + CACHE_VERSION};const OFFLINE_URL = 'offline.html';function createCacheBustedRequest(url) {let request = new Request(url, {cache: 'reload'});if ('cache' in request) {return request;}let bustedUrl = new URL(url, self.location.href);bustedUrl.search += (bustedUrl.search ? '&' : '') + 'cachebust=' + Date.now();return new Request(bustedUrl);}self.addEventListener('install', event => {event.waitUntil(fetch(createCacheBustedRequest(OFFLINE_URL)).then(function (response) {return caches.open(CURRENT_CACHES.offline).then(function (cache) {return cache.put(OFFLINE_URL, response);});}));});self.addEventListener('activate', event => {let expectedCacheNames = Object.keys(CURRENT_CACHES).map(function (key) {return CURRENT_CACHES[key];});event.waitUntil(caches.keys().then(cacheNames => {return Promise.all(cacheNames.map(cacheName => {if (expectedCacheNames.indexOf(cacheName) === -1) {return caches.delete(cacheName);} }));}));});self.addEventListener('fetch', event => {if (event.request.mode === 'navigate' || event.request.method === 'GET' && event.request.headers.get('accept').includes('text/html')) {event.respondWith(fetch(event.request).catch(error => {return caches.match(OFFLINE_URL); }));}});```
1887	brighteon.io.js	Server Side Request Forgery (SSRF)	High	true	CWE-829	10	N/A	standard	{The vulnerability arises from the use of the `fetch` function with user-controlled request URLs. Although the code checks for 'http://' or 'https://' protocols, it does not validate or sanitize the full URL, allowing an attacker to craft requests to internal or external resources (e.g., localhost, internal APIs) via the service worker. Since `fetch` is a standard browser API and is used directly with untrusted input (request.url), this constitutes a sensitive function misuse leading to SSRF.}	```const isHttps = request.url.startsWith('https://'); const isHttp = request.url.startsWith('http://'); const isProtocolSupported = isHttps || isHttp; if (!isProtocolSupported) { return; }```
1888	brighteon.io.js	Information Exposure Through Network Stats	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves leaking sensitive network statistics (e.g., request URLs, bytes transferred) via `swBroadcaster.send()`, but this is not due to misuse of a sensitive function. The `swBroadcaster.send()` call is a custom API used for internal communication and does not inherently introduce risk from untrusted input or unsafe function execution. The exposure stems from the design choice to transmit sensitive data, not from improper use of a sensitive function.}	```swBroadcaster.send('network-stats', { status: 'success', url: request.url, torUsed: hasUsedTor, bytesLength: responseBuffer.byteLength, totalStats: networkTotalStats });```
1889	budgetpetcare.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a hardcoded URL (https://cdn.izooto.com/scripts/workers/cd0d2ad152d89c488ea91d5bef32f022d590de99.js). Although the URL is hardcoded and not derived from untrusted input, the use of importScripts() with any external script introduces a risk of remote code execution if the script source is compromised or if the script is dynamically controlled in future updates. Since the script is loaded from a third-party CDN, it represents a potential attack vector if the CDN is compromised or if the script is modified without detection. This constitutes a sensitive function misuse due to the inherent trust placed in the external script.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/cd0d2ad152d89c488ea91d5bef32f022d590de99.js"");```"
1890	bet1678.club.js	Misconfigured Service Worker Registration	Medium	false	N/A	N/A	N/A	N/A	{The registration of the service worker is not inherently caused by misuse of a sensitive function. The code registers a service worker with a hardcoded path ('./service-worker.js'), which is safe and does not involve dynamic or untrusted input. Therefore, this is a configuration issue rather than a sensitive function misuse.}	```if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./service-worker.js'); }```
1891	retididedalus.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the untrusted 'sensor_url' parameter received in the push event data. Since 'sensor_url' is directly controlled by the attacker (via the push message), it allows the service worker to make arbitrary HTTP requests to any server, leading to SSRF.}	N/A
1892	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.retididedalus.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.retididedalus.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
1893	retididedalus.it.js	Phishing via Malicious Redirect	Medium	true	CWE-352	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from the 'url' field in the notification data, which is untrusted and controlled by the attacker. This allows the attacker to redirect the user to a malicious site, enabling phishing attacks.}	N/A
1894	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.retididedalus.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.retididedalus.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```
1895	0532.ua.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	```self[`appKey`] = `0df64125fffbd72c329333b19fc9e111`;```
1896	0532.ua.js	Loading External Script from Untrusted Source	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it may still be considered untrusted if the host is not verified or controlled. However, in this case, the host is hardcoded and not derived from user input, so the risk is lower but still present if the host is compromised or misconfigured. The function is sensitive because it executes arbitrary code from a remote source.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1897	smartspends.com.js	Improper Handling of CORS Credentials	High	false	CWE-614	N/A	N/A	N/A	"{The vulnerability arises from misconfigured CORS settings in the fetchOptions of the workbox.routing.registerRoute, specifically setting credentials: ""same-origin"" for external fonts. This does not involve misuse of a sensitive function like importScripts or eval, but rather improper configuration of a standard Workbox API.}"	"```workbox.routing.registerRoute(/^https:\/\/fonts\.googleapis\.com/, new workbox.strategies.StaleWhileRevalidate({ cacheName: ""font-"" + FONT_VERSION, plugins: [new workbox.cacheableResponse.Plugin({ statuses: [0, 200] }), new workbox.expiration.Plugin({ maxAgeSeconds: 60 * 60 * 24 * 365, maxEntries: 20, purgeOnQuotaError: true })], fetchOptions: { mode: ""cors"", credentials: ""same-origin"" } }));```"
1898	smartspends.com.js	Improper Handling of CORS Credentials	High	false	CWE-614	N/A	N/A	N/A	"{The vulnerability stems from setting credentials: ""same-origin"" in the fetchOptions for images from img.smartspends.com. This is a configuration issue within the Workbox routing API, not a misuse of a sensitive JavaScript function such as importScripts or eval.}"	"```workbox.routing.registerRoute(function (data) { return data.request.url.includes(""img.smartspends.com""); }, new workbox.strategies.StaleWhileRevalidate({ cacheName: ""image-"" + IMAGE_VERSION, plugins: [new workbox.cacheableResponse.Plugin({ statuses: [0, 200] }), new workbox.expiration.Plugin({ maxAgeSeconds: 60 * 60 * 24 * 30, maxEntries: 40, purgeOnQuotaError: true })], fetchOptions: { mode: 'cors', credentials: 'same-origin' } }));```"
1899	smartspends.com.js	Overly Broad Cache Matching Pattern	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is due to a broad regular expression pattern /\.(?:css)/ that may match unintended resources. This is a logic or configuration flaw in the route matching, not a misuse of a sensitive JavaScript function like importScripts or eval.}	```workbox.routing.registerRoute(/\.(?:css)/, new workbox.strategies.NetworkFirst({ cacheName: 'css-' + CSS_VERSION, plugins: [new workbox.expiration.Plugin({ maxEntries: 30, maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true })] }));```
1900	truyenmoivn.com.js	Cache Poisoning via Query Parameter Manipulation	High	true	CWE-444	9	N/A	standard	{The function `caches.put()` is used with a dynamically constructed cache key derived from `evt.request.url.split('?t=')[0]`, which is based on user-controlled input from the URL. This allows an attacker to manipulate the query parameter to cache arbitrary resources under different keys, potentially leading to cache poisoning where malicious content is served to other users.}	```if (evt.request.url.indexOf('?t=') !== -1) { evt.respondWith(fetch(evt.request).then(function (res) { return caches.open(CACHE_STATIC_NAME).then(function (cache) { var url_to_cache = evt.request.url.split('?t=')[0]; cache.put(url_to_cache, res.clone()); return res; }); })); }```
1901	truyenmoivn.com.js	Open Redirect Vulnerability	Medium	true	CWE-602	8	N/A	standard	{The `Response.redirect()` function is used with a URL constructed from `newUrl = `${NEW_DOMAIN}${currentSlug}``, where `currentSlug` is derived from the request URL via `new URL(evt.request.url).pathname`. This allows an attacker to craft a request with a malicious path that, when redirected, leads to an unintended external domain, enabling open redirect attacks.}	```return Response.redirect(newUrl, 302);```
1902	truyenmoivn.com.js	Insecure Message Handling	Medium	false	CWE-79	0	N/A	N/A	{The assignment `storyEndChapters[storySlug] = endChapter;` is not directly caused by a sensitive function misuse. It is a data storage operation that may be vulnerable to injection if `storySlug` or `endChapter` are not validated, but no sensitive function like `eval`, `Function`, or `importScripts` is involved.}	```storyEndChapters[storySlug] = endChapter;```
1903	truyenmoivn.com.js	Path Traversal in Chapter Regex	Medium	false	CWE-22	0	N/A	N/A	{The regex `^https?:\\/\\/[^\\/]+\\/([a-zA-Z0-9-_]+)\\/chuong-([0-9]+)` is used to extract story slug and chapter number, but it does not involve a sensitive function. The vulnerability arises from insufficient validation of the extracted path components, not from misuse of a sensitive function.}	```let chapterRegex = new RegExp('^https?:\\/\\/[^\\/]+\\/([a-zA-Z0-9-_]+)\\/chuong-([0-9]+)');```
1904	truyenmoivn.com.js	Insecure Cache Key Handling	Low	true	CWE-532	7	N/A	standard	{The `cache.put(evt.request.url, res.clone())` function uses the full request URL as the cache key, which includes potentially untrusted query parameters. This can lead to cache key collisions or unintended cache entries if the URL contains dynamic or user-controlled parameters, allowing cache poisoning or bypassing.}	```cache.put(evt.request.url, res.clone());```
1905	truyenmoivn.com.js	Unbounded Fetch Request	Low	false	CWE-400	0	N/A	N/A	{The `fetch(evt.request)` call is not inherently unsafe or misused; it is a standard network request. The vulnerability arises from lack of timeout or rate limiting, not from misuse of a sensitive function.}	```const response = await fetch(evt.request);```
1906	elixirforum.com.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a new browser window or tab with a URL constructed from user-controlled data (t.notification.data.url and t.notification.data.baseUrl). Since these values are derived from the push notification payload, which can be manipulated by an attacker, the resulting URL can be crafted to redirect users to arbitrary, potentially malicious, websites. This constitutes an Open Redirect vulnerability, allowing attackers to perform phishing or other malicious redirections.}	```var e = t.notification.data.url, i = t.notification.data.baseUrl; if (!t.some(function (t) { return t.url === i + e && 'focus' in t ? (t.focus(), !0) : 'postMessage' in t && 'focus' in t && (t.focus(), t.postMessage({ url: e }), !0); }) && clients.openWindow) return clients.openWindow(i + e);```
1907	section-8-apartments.org.js	Remote Code Inclusion (Dynamic Script Import)	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it dynamically constructs a URL using self.location.hostname, which is user-controlled via the origin of the page. Although the hostname is encoded via encodeURI, the base URL is hardcoded to a remote domain (trk-instructior.com), and the script is loaded from an external source. This allows an attacker to potentially manipulate the origin (e.g., via subdomain takeover or DNS hijacking) to inject malicious scripts into the service worker, leading to remote code execution. The vulnerability arises because importScripts() executes any script it is given without validation, and the URL is derived from a potentially untrusted source.}	"```if (typeof window === ""undefined"") { importScripts(""https://trk-instructior.com/scripts/ext/script/v9e184vgz8?url="" + encodeURI(self.location.hostname)); } importScripts(""https://trk-instructior.com/scripts/sw/script/v9e184vgz8?url="" + encodeURI(self.location.hostname));```"
1908	for-sale.co.uk.js	Third-party script execution from untrusted CDN	High	true	CWE-78	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted third-party CDN (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability because the script being imported is not under the control of the site owner. An attacker could compromise the CDN or the script to inject malicious code, leading to full control over the service worker’s behavior, including intercepting network requests, manipulating cache, or performing cross-site scripting attacks.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/61522c025d22e10008eef863/service-worker.js"");```"
1909	pmschemehub.in.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (Firebase API key, VAPID key, project ID, etc.) being exposed in the source code. This is not due to misuse of a sensitive function, but rather poor secret management.}	"```var swVersion = ""3.0.9"";const firebaseVersion = '8.9.1';const http = 0;importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-app.js"");importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-messaging.js"");const options = { firebaseConfig: { projectId: ""push-83acf"", messagingSenderId: ""502787874660"", appId: ""1:502787874660:web:468b582ac1ce15025ae471"", apiKey: ""AIzaSyAPTNyefUQYom19hpi5SPy2AyybTBem7H0"" }, domain: ""pmschemehub.in"", api_url: ""https://push.sarkarihelp24.in/api/token"", vapid_public_key: ""BNBTcJ_Btjz8zdkUbfwXrSiGpsjNJmC0ZfphJMl4Ungg_akJQR53v1ZM542pgpBiGunSQR-b0McKl_eeqPAb7uo""};firebase.initializeApp({ ...options.firebaseConfig});```"
1910	pmschemehub.in.js	XSS via Notification Content	High	true	N/A	N/A	showNotification	standard	{The showNotification function is used with unsanitized payload data (title and other notification fields) directly from the push event. Since the payload is parsed from untrusted input (event.data.json().data.notification), an attacker can inject malicious content (e.g., script tags) that may be rendered in the notification UI, leading to XSS if the browser renders it in a context that executes scripts.}	"```self.addEventListener('push', event => { const payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction })); if (event.data.json().data.swVersion != swVersion) { console.log(""SW Version is different, Updating SW""); self.registration.update(); } });```"
1911	pmschemehub.in.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from event.notification.data.url or event.notification.data.actions[event.action].click_action, which are untrusted and unsanitized. This allows an attacker to craft a push notification payload that redirects users to arbitrary websites, potentially leading to phishing or malicious site redirection.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
1912	alkmaar.nl.js	Insecure Service Worker Handling	High	false	New	N/A	self.addEventListener('fetch'	N/A	{The code does not contain any dynamic or unsafe usage of sensitive functions. The event listeners are standard and do not involve untrusted input or risky operations.}	```self.addEventListener('install', () => {});self.addEventListener('activate', () => {});self.addEventListener('fetch', () => {});```
1913	stillnessinthestorm.com.js	Improper Input Validation in Range Header Handling	Medium	true	CWE-20	5	N/A	standard	{The `Number()` function is used to parse a value extracted from the `range` header via a regex. The input is derived from `event.request.headers.get('range')`, which is user-controlled. If the header contains malformed or non-numeric data, `Number()` may return `NaN` or unexpected values, leading to incorrect range processing and potential denial of service or data corruption. This misuse stems from insufficient validation of the header content before conversion.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
1914	stillnessinthestorm.com.js	Improper URL Validation Leading to DoS	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper URL validation using `new URL(e.request.url).origin !== location.origin`, which is not inherently caused by misuse of a sensitive function. The issue is more about logic or insufficient validation rather than a direct misuse of a sensitive API.}	```if (new URL(e.request.url).origin !== location.origin) return;```
1915	iransite.com.js	Excessive Cache Usage Leading to Storage Exhaustion	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from caching the root path ('/') which may lead to excessive storage usage if the server responds with large resources, but it does not stem from misuse of a sensitive function. The function cache.addAll() is used appropriately with a static, hardcoded path and does not involve dynamic or untrusted input.}	```cache.addAll(['/']);```
1916	cuetsamarth.co.in.js	Improper Validation of Push Subscription Keys	High	true	CWE-312	9	applicationServerKey	standard	{The applicationServerKey is directly assigned from options.vapid_public_key without validation or sanitization, which could allow an attacker to substitute a malicious VAPID key if the value is derived from untrusted sources, leading to unauthorized push notifications or subscription hijacking.}	N/A
1917	cuetsamarth.co.in.js	Exposure of Push Subscription Keys in API Requests	High	true	CWE-312	9	JSON.stringify	standard	{The JSON.stringify function is used to serialize and send sensitive push subscription data (endpoint, auth, p256dh) to a remote API without encryption or proper access controls, exposing these keys to potential interception or misuse by attackers.}	N/A
1918	cuetsamarth.co.in.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	8	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from notification data without validation or sanitization, allowing an attacker to craft a notification with a malicious URL to redirect users to phishing or malicious sites.}	N/A
1919	cuetsamarth.co.in.js	Insecure Handling of Notification Payload Data	Medium	true	CWE-20	7	JSON.parse	standard	{The JSON.parse function is used to parse notification data directly from event.data.json().data.notification without validating or sanitizing the input, which could lead to injection or execution of malicious payloads if the data is tampered with.}	N/A
1920	cuetsamarth.co.in.js	Insecure Storage of Sensitive Data in IndexedDB	High	true	CWE-311	8	objectStore.put	standard	{The objectStore.put function is used to store sensitive data (like notification tokens) in IndexedDB without encryption or access controls, making it vulnerable to theft or exposure if the browser is compromised or the data is accessed via XSS.}	N/A
1921	anyrecover.com.js	Open Redirect via Untrusted Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided by untrusted notification data (jumpUrl). Although a regex check is performed to validate the URL scheme, it allows both http and https, which can lead to open redirect vulnerabilities if the URL is controlled by an attacker. The function is standard and directly responsible for navigating the user to an external site based on untrusted input.}	```if (jumpUrl && /^https?:\/\//.test(jumpUrl)) { afterCallback = function () { clients.openWindow(jumpUrl); }; }```
1922	anyrecover.com.js	Insufficient Input Validation in JSON Parsing	Low	false	CWE-20	0	N/A	N/A	{The vulnerability arises from insufficient validation of JSON input, but it is not caused by misuse of a sensitive function. The parseJSON function handles parsing safely with try-catch, and no sensitive function like eval or Function is used. The issue is more about data integrity than function misuse.}	```function parseJSON(text) { var data = {}; if ('string' === typeof text) { try { data = JSON.parse(text); if ('object' !== typeof data) { data = {}; } } catch (e) { logConsoleError(e); } } else if ('object' === typeof text) { data = text; } return data; }```
1923	anyrecover.com.js	CORS Bypass via No-CORS Fetch Request	Medium	true	CWE-918	8	fetch	standard	{The fetch function is used with mode: 'no-cors', which bypasses CORS restrictions and allows the service worker to make requests to any origin without checking for cross-origin permissions. This can enable unauthorized data access or exfiltration if the request is crafted with untrusted or attacker-controlled URLs. The fetch API is a standard function, and its misuse here leads to a CORS bypass vulnerability.}	```var buildRequest = new Request(request, { mode: 'no-cors', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' } }); fetch(buildRequest);```
1924	continental.com.ar.js	Hardcoded Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded Firebase API keys and VAPID public key, which are sensitive credentials. These are not the result of misuse of a sensitive JavaScript function but rather poor configuration practices.}	"```const FIREBASE_SETTINGS = { ""appConfig"": { ""apiKey"": ""AIzaSyD6IIwmKc2cpxXvGkeBVnD0iw9c7PjxWGM"", ""authDomain"": ""radiocontinental.firebaseapp.com"", ""projectId"": ""radiocontinental"", ""storageBucket"": ""radiocontinental.appspot.com"", ""messagingSenderId"": ""1012549902688"", ""appId"": ""1:1012549902688:web:c755fb4e2d37da6f723e05"", ""measurementId"": ""G-QXEMKZSQDJ"" }, ""vapidPublicKey"": ""BLosBtoo1I1zwB339MtBaPrF6AJdsljJw090k6BnPY5AY3JlWvl1V1O029Ip1TwoazIRNo8Up_L0nQVfinTjA2I"" };```"
1925	continental.com.ar.js	Open Redirect via Unvalidated Input	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with user-controlled input from e.action without validation. If an attacker can control the notification action URL, they can redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```if (/^https?:/.test(e.action)) { await e.waitUntil(Promise.all([clients.openWindow(e.action), ...(id ? [fetch(`/api/v1/push-notification/${id}/track?event=action`, { method: 'POST' }).catch(err => {})]: []), ...(e.notification.data.deviceInstanceId ? [fetch(`/api/v1/device-instance/${e.notification.data.deviceInstanceId}/track?event=action`, { method: 'POST' }).catch(err => {})]: [])])); }```
1926	continental.com.ar.js	Exposure of Error Details	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from sending error details (message and stack trace) to an API endpoint, which is a data leakage issue. This is not caused by misuse of a sensitive JavaScript function but by improper error handling.}	```fetch(`/api/v1/push-notification/error`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: err && err.message, stack: err && err.stack }) });```
1927	dstu.education.js	Open Redirect via Unvalidated URL in Notification Click Handler	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the specified URL. In this code, the URL is derived from event.notification.data.click_action, which is user-controlled via notification data. Since no validation or sanitization is performed on this input, an attacker could craft a notification with a malicious URL (e.g., redirecting to a phishing site or external domain), leading to an open redirect vulnerability.}	```self.addEventListener('notificationclick', function (event) { const target = event.notification.data.click_action || '/'; event.notification.close(); event.waitUntil(clients.matchAll({ type: 'window', includeUncontrolled: true }).then(function (clientList) { for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (client.url == target && 'focus' in client) { return client.focus(); } } return clients.openWindow(target); }));});```
1928	cineworld.com.js	Improper Input Validation	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from improper input validation of `event.data` received via `self.addEventListener('message', ...)`, but no sensitive function is directly misused. The data is assigned to `airshipConfig` and passed to `setupUA()`, which does not involve dynamic execution or unsafe operations.}	```self.addEventListener('message', function (event) { airshipConfig = event.data; setupUA(); });```
1929	minascap.com.js	Outdated Firebase SDK with Known Vulnerability	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase SDK (7.5.0), which is known to have security issues (CVE-2020-16155). This is not caused by misuse of a sensitive JavaScript function, but rather by using an insecure library version.}	```importScripts('https://www.gstatic.com/firebasejs/7.5.0/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/7.5.0/firebase-messaging.js');```
1930	minascap.com.js	Excessive Logging of Sensitive Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from configuring logging reporters that may expose sensitive data during runtime, particularly through 'good-squeeze' and 'good-console' modules. This is not due to misuse of a sensitive JavaScript function, but rather improper configuration of logging behavior.}	```reporters: { console: [{ module: 'good-squeeze'```
1931	popstroke.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	URL	standard	{The code constructs a URL using `new URL(data.base, swScope.origin)` where `data.base` is derived from a message event. If an attacker can control the `data.base` value (e.g., via a malicious client message), they can craft a URL pointing to an internal or external resource, leading to SSRF. The `URL` constructor is a standard JavaScript API, and its misuse here allows unauthorized access to internal systems or external services.}	```const baseUrl = new URL(data.base, swScope.origin);```
1932	politico.mx.js	External Code Execution via Compromised CDN	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party CDN (e.g., https://cdn.politico.mx/sw/sw.js), it introduces a risk if the CDN is compromised. An attacker who gains control over the CDN can serve malicious JavaScript, which will be executed in the context of the service worker, leading to code injection and potential full compromise of the application's behavior.}	"```importScripts(""https://cdn.politico.mx/sw/sw.js"");```"
1933	capital.ua.js	Use of Hard-coded Credentials	High	false	N/A	N/A	N/A	N/A	{Hard-coded credentials are not caused by misuse of a sensitive function but by direct embedding of secrets in the code.}	```self[`appKey`] = `bd0e7e8a17ae45c7c333dec9004ef332`;```
1934	capital.ua.js	Insecure External Resource Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hard-coded host (self[`hostUrl`]), it becomes a vector for potential compromise if the host is ever controlled by an attacker or if the script is loaded from an untrusted source. Although the host is hard-coded here, the function itself is sensitive because it executes arbitrary code from a remote location, and if the host were dynamic or derived from untrusted input, it would be a direct injection vector.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
1935	mr7bagulf.com.js	Exposed API Key	High	false	N/A	N/A	N/A	N/A	{The API key is hardcoded in the script and exposed in the source code, but it is not a result of misuse of a sensitive JavaScript function. It is a static configuration exposure.}	```const options = { firebaseConfig: { projectId: 'larapush-da0ba', messagingSenderId: '579281805738', appId: '1:579281805738:web:58364512ae39bd8b5f0bd3', apiKey: 'AIzaSyDpKRRlBOrRiCb-GqI1euSBXvuR9Dv9piQ' }, domain: 'ar.mr7bagulf.com', api_url: 'https://push.mr7bagulf.com/api/token', vapid_public_key: 'BMl29v4O07MvE7r181dBIzNWtiYpOTh03PZ1O-nSlnntWywR20XU4dTlS_XDqZ4tyWCCkqy7hpRnZswzymMyMbs' };```
1936	mr7bagulf.com.js	SSRF via URL Parsing	Medium	true	N/A	N/A	new URL	standard	{The function new URL(url) is used to parse a user-supplied URL, which can lead to SSRF if the URL is controlled by an attacker and points to internal resources. The function is standard and its misuse allows an attacker to force the service worker to make requests to unintended endpoints.}	```function getDomainAndHostname(url) { const urlObj = new URL(url); return { hostname: urlObj.hostname }; }```
1937	mr7bagulf.com.js	Unvalidated URL Redirection	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow(targetUrl) is called with a URL derived from notification data, which is user-controlled. This allows an attacker to redirect users to arbitrary websites, leading to phishing or malicious redirection. The function is standard and its misuse stems from lack of validation on the target URL.}	```clients.openWindow(targetUrl);```
1938	indianpharmajobs.com.js	Missing Cache Initialization	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the absence of any cached resources being added to the cache during the install event. This is not due to misuse of a sensitive function, but rather a design or configuration omission.}	```const FILES_TO_CACHE = [];```
1939	indianpharmajobs.com.js	Unhandled Fetch Requests	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the fetch event listener being defined but not implementing any logic to handle requests. This is a functional omission, not a result of misusing a sensitive function.}	```self.addEventListener('fetch', evt => {});```
1940	optimy.app.js	Cache Poisoning	High	true	New	N/A	caches.put	standard	{The caches.put() function is used to store a response in the cache, but it does not validate the request or response content. If an attacker can manipulate the request (e.g., via a crafted URL or forged request), they could inject malicious content into the cache, leading to cache poisoning. The function is called with req and res.clone(), where req is derived from user input (event.request), making it susceptible to injection.}	```const cache = yield this.cache; yield cache.put(req, res.clone());```
1941	optimy.app.js	Insecure Hash Validation	Medium	true	CWE-327	N/A	sha1Binary	standard	{The sha1Binary function computes a hash of the response body, but SHA-1 is considered cryptographically broken and unsuitable for security-sensitive applications. Using it for integrity validation allows attackers to potentially craft collisions, leading to false validation of tampered resources. The function is called with networkResult.clone().arrayBuffer(), which is derived from network responses and thus potentially untrusted.}	```const fetchedHash = sha1Binary(yield networkResult.clone().arrayBuffer());```
1942	optimy.app.js	Improper URL Validation	Medium	true	CWE-601	N/A	parseUrl	standard	{The parseUrl function is used to extract URL components, but it does not validate or sanitize the input URL. The function is called with req.url, which is derived from user input (event.request.url), allowing attackers to craft URLs that may bypass intended security checks or trigger unintended behavior, such as accessing unauthorized resources.}	```const url = this.getConfigUrl(req.url);```
1943	optimy.app.js	Information Exposure Through Debug Logs	Medium	true	CWE-200	N/A	log	standard	{The log function in DebugHandler is used to record detailed error messages and context, including request URLs and headers. Since these logs are stored and potentially exposed (e.g., via debug endpoints), they may leak sensitive information such as internal URLs, request parameters, or error details that could aid in further attacks. The function is called with context strings that include user-controlled data like req.url and req.cache.}	```this.debugger.log(`Ignoring invalid request: 'only-if-cached' can be set only with 'same-origin' mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);```
1944	optimy.app.js	Insecure Notification Handling	Medium	true	CWE-79	N/A	showNotification	standard	{The showNotification function is used to display notifications, but it does not sanitize the title or options provided by the data.notification object. If an attacker can control the notification data (e.g., via a malicious push message), they could inject arbitrary content, including potentially harmful scripts or misleading information, leading to phishing or social engineering attacks. The function is called with desc['title'] and options, which are derived from untrusted data.}	```yield this.scope.registration.showNotification(desc['title'], options);```
1945	artrabbit.com.js	Undefined Function Reference	High	false	New	N/A	N/A	N/A	{The function `checkResponse` is referenced but not defined anywhere in the script, leading to a runtime error. This is a logic or implementation error, not a misuse of a sensitive function.}	```self.addEventListener('fetch', function (event) { event.respondWith(checkResponse(event.request).catch(function () { return returnFromCache(event.request); })); });```
1946	artrabbit.com.js	String Instead of Variable for Cache Name	Medium	false	New	N/A	N/A	N/A	{The cache name is hardcoded as the string 'cacheName' instead of using the variable `cacheName` defined at the top of the script. This is a coding error that may lead to incorrect cache operations, but it does not involve misuse of a sensitive function.}	```return caches.open('cacheName').then(function (cache) { return cache.match(request).then(function (matching) { if (!matching || matching.status == 404) { return cache.match('/errors/404.html'); } else { return matching; } }); }).catch(err => {});```
1947	3isk.family.js	Client-Side Offline Detection Bypass	Medium	false	New	N/A	N/A	N/A	"{The vulnerability arises from relying on `navigator.onLine`, which is a client-side property that can be easily spoofed or manipulated by attackers. This does not involve misuse of a sensitive function like `importScripts()` or `eval()`, but rather a design flaw in offline detection logic. Since no sensitive function is misused, the vulnerability is not classified as ""sensitively_vulnerable"".}"	```if (navigator.onLine === false) {```
1948	comvv.net.js	Open Redirect via Notification Click	High	true	N/A	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a URL provided via the notification's data.url field, which is derived from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or malicious domains.}	```self.clients.openWindow(null == e ? void 0 : null === (r = e.notification) || void 0 === r ? void 0 : null === (o = r.data) || void 0 === o ? void 0 : o.url);```
1949	comvv.net.js	Insecure Client Data Handling	Medium	false	N/A	N/A	N/A	N/A	{The assignment self._client_data = e.data.data involves storing data received from a message event, but there is no direct misuse of a sensitive JavaScript function. The vulnerability stems from improper data handling and lack of validation, not from a function that inherently introduces risk when misused.}	```self._client_data = e.data.data;```
1950	futboltv.info.js	Overly Permissive Cache Route for JS/CSS	High	true	CWE-79	N/A	registerRoute(/^.*(js|css)$/, new StaleWhileRevalidate({ cacheName: `${CACHE_PREFIX}-externalAssets`, plugins: [new ExpirationPlugin({ maxEntries: 20 }), new CacheableResponsePlugin({ statuses: [200] })], matchOptions: { ignoreSearch: true } }));	standard	{The registerRoute function is used with a regex pattern that matches any URL ending in .js or .css, regardless of origin. This allows caching of external scripts and stylesheets from untrusted domains, which can lead to cache poisoning or execution of malicious code if an attacker can control or intercept these resources. The pattern is overly permissive and does not validate the origin, making it a sensitive misuse of the workbox routing API.}	```registerRoute(/^.*(js|css)$/, new StaleWhileRevalidate({ cacheName: `${CACHE_PREFIX}-externalAssets`, plugins: [new ExpirationPlugin({ maxEntries: 20 }), new CacheableResponsePlugin({ statuses: [200] })], matchOptions: { ignoreSearch: true } }));```
1951	inqaku.com.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The navigate() method is a standard browser API used to redirect a client to a specified URL. In this case, it constructs a URL by concatenating a hardcoded base ('https://inqaku.com') with the 'foo' property from event.notification.data, which is derived from a push notification payload. Since push notification data is untrusted and can be controlled by an attacker, this allows for an open redirect vulnerability where an attacker can redirect users to arbitrary domains by manipulating the 'foo' value.}	```clientList[0].navigate('https://inqaku.com' + event.notification.data.foo);```
1952	inqaku.com.js	Insecure Caching of Non-HTTP URLs	High	true	New	10	N/A	standard	{The addToCache() function is called conditionally based on the request URL not starting with 'http'. This condition allows non-HTTP URLs (e.g., file://, data:, etc.) to be fetched and cached. Since fetch() and caches.put() are standard APIs, and they are used without validating or sanitizing the URL scheme, this enables caching of potentially malicious or unintended resources, leading to insecure caching behavior.}	```if (!event.request.url.startsWith('http')) { event.waitUntil(addToCache(event.request)); }```
1953	lavocetorino.it.js	Improper Input Validation Leading to SSRF	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.push_send_id and sensor_url), which can be manipulated by an attacker to perform Server-Side Request Forgery (SSRF) by redirecting requests to internal or unintended endpoints.}	```var ve = sensor_url + '/e?site_name=www.lavocetorino.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
1954	lavocetorino.it.js	Open Redirect via Untrusted Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted notification data (event.notification.data.url), allowing an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
1955	lavocetorino.it.js	Insecure URL Construction in Notification Click Handler	Medium	true	CWE-74	9	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (event.notification.data.sensor and event.notification.data.push_send_id), which can be manipulated to inject malicious URLs or perform unintended requests, leading to insecure URL construction.}	```var vc = event.notification.data.sensor + '/e?site_name=www.lavocetorino.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click';```
1956	lv77.club.js	Cache Poisoning via Insecure Route Matching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from insecure route matching logic in the workbox configuration, specifically using `e.pathname.includes('/games/allGameList')` to match URLs. This is not a misuse of a sensitive JavaScript function, but rather a flawed logic design that could allow unintended caching of responses if the path pattern is too broad or if the URL structure is manipulated. Since no sensitive function like `importScripts`, `eval`, or `Function` is involved, this is not a sensitive function misuse.}	```e.registerRoute((e)=>e.pathname.includes('/games/allGameList'),new e.StaleWhileRevalidate({cacheName:'agl',plugins:[new e.ExpirationPlugin({maxAgeSeconds:10800,maxEntries:1,purgeOnQuotaError:!0})]})\',\'GET\')```
1957	parintisipitici.ro.js	Hardcoded API Key in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to the exposure of a hardcoded API key in client-side code, not due to misuse of a sensitive JavaScript function. The fetch() call is used correctly with a hardcoded URL, and no dynamic or untrusted input is passed to it. Therefore, this is not a case of sensitive function misuse.}	```self.addEventListener('push', function (event) { event.waitUntil(fetch('https://apism.speedmeta.com/get_notification_V2/?key=QQ0RV0A0U9W25UACKT9Q').then(function (response) { if (response.status !== 200) { throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { throw new Error(); } var ua = navigator.userAgent.toLowerCase(); var isMac = ua.indexOf('macintosh') > -1; var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var image = data.notification.image; var notificationTag = data.notification.tag; var final_link = data.notification.link; var req_interaction = isMac ? false : true; return self.registration.showNotification(title, { body: message, icon: icon, image: image, tag: notificationTag, data: data, requireInteraction: req_interaction }); })); }); });```
1958	partidos-de-hoy.com.js	External Service Worker Script Import Without Integrity Check	High	false	N/A	0	N/A	N/A	{The importScripts() call is not considered a sensitive function misuse because the URL is hardcoded and not derived from untrusted or dynamic input. While importing external scripts can be risky without integrity checks, the absence of dynamic input means this is not a case of sensitive function misuse.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/64b7c3c63d0d4d0008b7476c/service-worker.js"");```"
1959	pigebook.com.js	Cache Poisoning via Unvalidated Cache Responses	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's fetch handler responding with cached content without validating its integrity or origin. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic flaw in cache handling. The code does not invoke any inherently dangerous functions with untrusted input.}	"```self.addEventListener(""fetch"", e => { e.respondWith(caches.match(e.request).then(response => response || fetch(e.request))); });```"
1960	registroelettronico.cloud.js	Information Exposure via Console Logging	Medium	false	N/A	N/A	N/A	N/A	{The console.log function is not inherently sensitive in this context, as it is used to log the request URL for debugging purposes. While logging sensitive data can lead to information exposure, the function itself is not misused in a way that introduces a direct security vulnerability such as injection or unauthorized access. The exposure is due to the data being logged, not the function's misuse.}	```console.log(e.request.url);```
1961	winbuzz.world.js	XSS via Untrusted Notification Content	High	true	CWE-79	9	N/A	standard	{The `showNotification` function is used to display notifications with content derived from untrusted `response.body`. If the `response.body` contains malicious script or HTML, it may be rendered in the notification UI, leading to XSS if the browser or platform interprets it as executable content. This is a misuse of a standard browser API with untrusted input.}	"```let notificationDetails = { actions: [{ action: ""view"", title: 'View' }], body: response.body };```"
1962	winbuzz.world.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	N/A	standard	{The `clients.openWindow(notificationUrl)` function is called with `notificationUrl`, which is derived from untrusted `response.link`. If an attacker controls the `response.link` value, they can redirect users to arbitrary external sites, leading to open redirect vulnerabilities. This is a misuse of a standard browser API with unvalidated input.}	```if (clients.openWindow) return clients.openWindow(notificationUrl);```
1963	accorarena.com.js	Improper Validation of Cache-Control Headers	Medium	false	N/A	N/A	N/A	N/A	{The code parses Cache-Control headers without validating their format or content, which could lead to incorrect caching behavior if an attacker supplies malformed or unexpected directives. However, this is not caused by misuse of a sensitive function.}	```if (res.headers.has('Cache-Control')) {```
1964	accorarena.com.js	Insecure Cache Busting Mechanism	High	true	CWE-327	N/A	adapter.newRequest	standard	{The code uses adapter.newRequest with a dynamically generated URL that includes a random value (Math.random()) for cache busting. While not directly exploitable, this approach can be manipulated if the URL is derived from untrusted input, potentially leading to unintended resource fetching or cache poisoning.}	```const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));```
1965	accorarena.com.js	Insufficient Verification of Cryptographic Hash	High	true	CWE-328	N/A	sha1Binary	standard	{The code uses sha1Binary to compute a hash of a response body, but SHA-1 is cryptographically broken and susceptible to collision attacks. This allows an attacker to craft a response with a matching hash, leading to a false positive in integrity verification.}	```const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());```
1966	accorarena.com.js	Improper Handling of Redirects	Medium	true	CWE-352	N/A	adapter.newRequest	standard	{The code recursively calls fetchFromNetwork with a new request constructed from the redirected URL (res.url), which is derived from the response. If the redirect is controlled by an attacker, this could lead to unintended resource fetching or open redirects.}	```return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);```
1967	accorarena.com.js	Insecure Use of Dynamic Code Evaluation	Low	true	CWE-835	N/A	adapter.newRequest	standard	{The code constructs a request URL using the normalized URL from the incoming request, which may be derived from untrusted input. While adapter.newRequest is not a dynamic code evaluator per se, its misuse with untrusted URLs can lead to unintended resource fetching.}	```const url = this.adapter.normalizeUrl(req.url);```
1968	accorarena.com.js	Improper Resource Cleanup	Medium	false	CWE-404	N/A	N/A	N/A	{The code deletes an entry from inFlightRequests, but this is a simple data structure cleanup and does not involve sensitive functions.}	```this.inFlightRequests.delete(req.url);```
1969	accorarena.com.js	Insecure Data Storage in Cache	Medium	true	CWE-531	N/A	cache.put	standard	{The code uses cache.put to store responses in the cache without validating or sanitizing the response content. If the response contains malicious data, it could be served to clients without proper checks, leading to potential security issues.}	```yield cache.put(req, res.clone());```
1970	accorarena.com.js	Improper Handling of HTTP Methods	Low	false	CWE-259	N/A	N/A	N/A	{The code checks for the 'OPTIONS' method and returns null, which is a standard handling of preflight requests. This is not a misuse of a sensitive function.}	```if (req.method === 'OPTIONS') {```
1971	accorarena.com.js	Insecure Use of Dynamic Code Evaluation	Low	true	CWE-835	N/A	adapter.newRequest	standard	{The code constructs a request URL by concatenating a hardcoded path with a key, which may be derived from untrusted input. This could lead to unintended resource fetching if the key is manipulated.}	```const request = this.adapter.newRequest('/' + key);```
1972	accorarena.com.js	Improper Handling of HTTP Methods	Low	false	CWE-259	N/A	N/A	N/A	{The code checks if the request method is 'navigate', which is a standard validation for navigation requests. This is not a misuse of a sensitive function.}	```if (req.method !== 'navigate') {```
1973	mp3wr.com.js	Insecure External Script Inclusion	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted external source (e.g., 'https://c.killtarget.biz/get-code/messaging-sw'), it introduces a high-risk vulnerability. The script at the external URL can be controlled by an attacker, allowing them to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Since the URL is hardcoded and not dynamically derived from untrusted input, the vulnerability is still considered high due to the inherent risk of loading code from an untrusted domain.}	```importScripts('https://c.killtarget.biz/get-code/messaging-sw');```
1974	pbcdci.cn.js	Vulnerable Cache Configuration	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a broad cache matching pattern (RegExp('/*')) which caches all requests without proper validation or restriction. This is not due to misuse of a sensitive function, but rather a misconfiguration in the caching strategy.}	```const workbox.routing.registerRoute(new RegExp('/*'), new workbox.strategies.StaleWhileRevalidate({ cacheName: CACHE, plugins: [bgSyncPlugin] }));```
1975	drivescore.com.js	XSS via Partytown Script Injection	High	true	New	10	importScripts	standard	{The Partytown script is dynamically injected via `importScripts` which is triggered by a message received from the main thread. The script content is constructed from untrusted data (e.g., `r.data` from `self.onmessage`) and executed without sanitization, allowing an attacker to inject arbitrary JavaScript code into the service worker, leading to XSS and potential data exfiltration or manipulation.}	"```const e = new Map(), t = (e, t) => ({ F: e.F, p: t }), r = (e, t) => new Response(e, { headers: { ""content-type"": t || ""text/html"", ""Cache-Control"": ""no-store"" } }); self.oninstall = () => self.skipWaiting(), self.onactivate = () => self.clients.claim(), self.onmessage = t => { const r = t.data, n = e.get(r.F); n && (e.delete(r.F), clearTimeout(n[1]), n[0](r)); }, self.onfetch = n => { const i = n.request, s = new URL(i.url).pathname; s.endsWith(""sw.html"") ? n.respondWith(r('<!DOCTYPE html><html><head><meta charset=""utf-8""><script type=""module"">/* Partytown 0.5.4 - MIT builder.io */\n(e=>{const t=()=>{},r=e=>e.length,n=e=>{var t,r,n;try{const r=null===(t=null==e?void 0:e.constructor)||void 0===t?void 0:t.name;if(r)return r}catch(e){}try{const t=null===(n=null===(r=null==e?void 0:e.__zone_symbol__originalInstance)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name;if(t)return t}catch(e){}return""""},i=(e,t)=>e.startsWith(t),s=e=>!(i(e,""webkit"")||i(e,""toJSON"")||i(e,""constructor"")||i(e,""toString"")||i(e,""_"")),...```"
1976	drivescore.com.js	Insecure Message Handling	Medium	false	CWE-319	0	N/A	N/A	{The vulnerability arises from improper handling of messages received via `self.onmessage`, but not due to misuse of a sensitive function. The issue is more about logic flaws or lack of validation rather than direct exploitation of a dangerous API.}	```self.onmessage = t => { const r = t.data, n = e.get(r.F); n && (e.delete(r.F), clearTimeout(n[1]), n[0](r)); }```
1977	drivescore.com.js	Denial of Service via Timeout Exploitation	Medium	false	CWE-489	0	N/A	N/A	{The vulnerability stems from the use of `setTimeout` with a fixed 10-second delay, which can be exploited to exhaust resources if triggered repeatedly. However, this is not due to misuse of a sensitive function but rather a design flaw in resource management.}	```e.set(r.F, s), i.postMessage(r);```
1978	drivescore.com.js	Insecure JSON Parsing	Medium	false	CWE-502	0	N/A	N/A	{The JSON parsing is performed using `await n.clone().json()`, which is standard and safe. The vulnerability is not due to misuse of a sensitive function but rather due to improper handling of the parsed data or lack of input validation.}	"```const o = await (r => new Promise(async n => { const i = [...(await self.clients.matchAll())].sort((e, t) => e.url > t.url ? -1 : e.url < t.url ? 1 : 0)[0]; if (i) { const s = [n, setTimeout(() => { e.delete(r.F), n(t(r, ""Timeout"")); }, 1e4)]; e.set(r.F, s), i.postMessage(r); } else n(t(r, ""NoParty"")); }))(s);```"
1979	mlpforums.com.js	Server Side Request Forgery (SSRF)	High	false	CWE-918	N/A	N/A	N/A	{The vulnerability is due to unsanitized user input in the `id` parameter being used in a `fetch` call, but the `fetch` function itself is not misused in a way that qualifies as sensitive function misuse. The issue is improper input validation, not misuse of a sensitive function.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
1980	mlpforums.com.js	Insecure Authentication Check	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from trusting URL parameters for authentication state, but no sensitive function is misused. The issue is logic flaw, not sensitive function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
1981	mlpforums.com.js	Open Redirect Vulnerability	Medium	false	CWE-601	N/A	N/A	N/A	{The vulnerability is due to trusting `data.url` from notification data without validation, but `clients.openWindow` is not misused as a sensitive function; it's a result of improper input validation.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
1982	mlpforums.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from unsanitized `path` being used in a `fetch` call, but `fetch` is not misused as a sensitive function; it's a result of improper input validation.}	```let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
1983	rsh.de.js	Overly Permissive Regex in Network-First Route	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a broad regex pattern `/.*` in the networkFirst strategy, which matches all paths. This is not caused by misuse of a sensitive function but rather by overly permissive route configuration.}	```workbox.routing.registerRoute(new RegExp('/.*'), workbox.strategies.networkFirst({}), 'GET');```
1984	rsh.de.js	Caching Third-Party Content from Untrusted Domain	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from caching content from an untrusted third-party domain (`https://iris-rsh.loverad.io/.*`) using networkFirst. This is a configuration issue, not a result of sensitive function misuse.}	"```workbox.routing.registerRoute(new RegExp('https://iris-rsh.loverad.io/.*'), workbox.strategies.networkFirst({ ""cacheName"": ""songs"", ""cacheExpiration"": { ""maxEntries"": 1, ""maxAgeSeconds"": 3600 }, ""cacheableResponse"": { ""statuses"": [0, 200] } }), 'GET');```"
1985	haberport.com.js	Dynamic Code Evaluation via Untrusted URL	High	true	CWE-602	10	importScripts	standard	{The code dynamically constructs a URL using a parameter extracted from the current page's URL (location.href) and passes it to importScripts(). Since the URL is derived from untrusted input (the query string), an attacker could manipulate the URL to inject a malicious script. importScripts() executes the script from the provided URL in the context of the service worker, leading to arbitrary code execution. This is a classic case of sensitive function misuse where a standard JavaScript API is used with untrusted data.}	"```(() => { let e = 'https://app.qushad.com/sw.js?appId=' + function (e, p = location.href) { e = e.replace(/[\[\]]/g, ""\\$&""); var a = new RegExp(""[?&]"" + e + ""(=([^&#]*)|&|#|$)"").exec(p); return a ? a[2] ? decodeURIComponent(a[2].replace(/\+/g, "" "")) : """" : null; }(""appId""); importScripts(e);})();```"
1986	indian-porn.pro.js	Insecure External Resource Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (pw.wpu.sh). This allows an attacker to control the content of the loaded script, leading to potential code injection, data exfiltration, or manipulation of the service worker’s behavior. Since the URL is not dynamically derived from user input, the risk is still high due to the lack of trust in the external source.}	```importScripts('https://pw.wpu.sh/ps/sw.js?tcid=481');```
1987	funk.net.js	Improper Path Whitelisting	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from the use of the `isPathWhitelisted` function with a regex pattern `^(?!\\/__).*` to determine if a URL path should be whitelisted for navigation. This function is called with a dynamic URL (`e.request.url`) and a regex that is intended to exclude paths starting with `/__`. However, the regex is improperly constructed and does not fully prevent path traversal or unintended access to restricted paths. The `isPathWhitelisted` function is a custom utility function defined in the script, but its misuse—specifically, the flawed regex pattern—leads to improper path whitelisting, allowing attackers to bypass intended restrictions by crafting URLs that match the pattern despite being outside the intended scope. This can lead to unintended resource access or navigation to sensitive endpoints.}	"```if (isPathWhitelisted([""^(?!\\/__).*""], e.request.url)) { n = new URL('/index.html', self.location).toString(), t = urlsToCacheKeys.has(n) }```"
1988	igloonet.cz.js	Improper Input Validation in URL Parameter Parsing	Medium	true	CWE-20	5	N/A	standard	{The code parses URL path parameters using a regex and splits them without validating or sanitizing the input, which could lead to unintended behavior or injection if the input is malicious. The sensitive function `match()` is used on a dynamic URL path, and the resulting data is processed without checks, potentially allowing for unintended key-value pairs to be created or misinterpreted.}	```const params = pathname.match(/:(.+)/)[1]; params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; });```
1989	igloonet.cz.js	Uncontrolled Resource Consumption in Cache Deletion	High	true	CWE-400	8	N/A	standard	{The `caches.keys()` function retrieves all cache names, and the subsequent `Promise.all` loop deletes caches matching a pattern. Since the number of caches is unbounded and the deletion is performed without rate limiting or resource constraints, this can lead to excessive resource consumption, especially if many caches exist. The sensitive function `caches.keys()` is used in a context where the size of the result set is not controlled, leading to potential denial of service.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
1990	igloonet.cz.js	Insecure Message Handling for API Invocation	Medium	true	CWE-20	7	N/A	standard	{The `self.addEventListener('message', ...)` handler dynamically invokes functions from `MessageAPI` based on user-provided data. If an attacker can control the `gatsbyApi` field in the message, they can trigger arbitrary functions, including potentially dangerous ones like `clearPathResources`, which may lead to cache deletion or other unintended side effects. The sensitive function `self.addEventListener` is misused by accepting untrusted input to dynamically invoke methods, enabling API abuse.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
1991	qbix.com.js	Vulnerable Cache Injection via Message Event	High	true	CWE-20	10	caches.put	standard	{The caches.put function is used within a message event handler to store arbitrary URLs and responses based on user-provided data from event.data.items. Since the item.url and item.content are directly derived from untrusted input, an attacker can inject malicious URLs or responses into the cache, leading to cache poisoning or script injection.}	N/A
1992	qbix.com.js	Insecure IndexedDB Put Operation	Medium	true	CWE-20	9	Q.IndexedDB.put	custom	{The Q.IndexedDB.put function is a custom implementation that directly uses store.put(value) without validating or sanitizing the input value. If the value is derived from untrusted sources, it can lead to unintended data storage or injection into IndexedDB, potentially exposing sensitive data or allowing malicious data persistence.}	N/A
1993	qbix.com.js	Insecure IndexedDB Get Operation	Medium	true	CWE-20	9	Q.IndexedDB.get	custom	{The Q.IndexedDB.get function is a custom implementation that retrieves data from IndexedDB using a key derived from untrusted input. If the key is not properly validated, it could lead to unauthorized data access or information leakage, especially if the key is controlled by an attacker.}	N/A
1994	fund.com.js	Insecure Dynamic URL Resolution (SSRF)	High	true	CWE-918	N/A	const Me = (e	standard	{The function `importScripts` is used to dynamically load a script from a URL constructed using `Me`, which resolves URLs based on untrusted input. This allows an attacker to supply a malicious host, leading to SSRF or remote code execution.}	N/A
1995	fund.com.js	Insecure Blob Script Execution (XSS)	Medium	true	CWE-79	N/A	const z = new Worker(URL.createObjectURL(new Blob([\'/* Partytown 0.10.0 - MIT builder.io */\\n(e=>{const t=Symbol()	standard	{The `URL.createObjectURL` function is used to create a URL for a Blob containing untrusted script content, which is then passed to `Worker`. This allows an attacker to inject arbitrary JavaScript via the blob, leading to XSS.}	N/A
1996	fund.com.js	Denial of Service via Infinite Timeout Chains	Medium	false	CWE-400	N/A	const o = await (r => new Promise(async n => { const i = [...(await self.clients.matchAll())].sort((e	N/A	{The vulnerability is not caused by misuse of a sensitive function but by improper handling of timeouts and client matching logic.}	N/A
1997	fund.com.js	Insecure Dynamic URL Resolution (SSRF)	High	true	CWE-918	N/A	const Me = (e	standard	{The `importScripts` function is used with a dynamically resolved URL from `Me`, which can be manipulated via untrusted input, allowing SSRF or remote code execution.}	N/A
1998	fund.com.js	Insecure Blob Script Execution (XSS)	Medium	true	CWE-79	N/A	const z = new Worker(URL.createObjectURL(new Blob([\'/* Partytown 0.10.0 - MIT builder.io */\\n(e=>{const t=Symbol()	standard	{The `URL.createObjectURL` function is used to generate a URL for a blob containing untrusted script, which is then executed in a `Worker`, enabling XSS.}	N/A
1999	fund.com.js	Denial of Service via Infinite Timeout Chains	Medium	false	CWE-400	N/A	const o = await (r => new Promise(async n => { const i = [...(await self.clients.matchAll())].sort((e	N/A	{The vulnerability arises from improper timeout handling and client matching, not from misuse of a sensitive function.}	N/A
2000	fund.com.js	Insecure Dynamic URL Resolution (SSRF)	High	true	CWE-918	N/A	const Me = (e	standard	{The `importScripts` function is used with a URL resolved via `Me`, which can be controlled by untrusted input, enabling SSRF or remote code execution.}	N/A
2001	fund.com.js	Insecure Blob Script Execution (XSS)	Medium	true	CWE-79	N/A	const z = new Worker(URL.createObjectURL(new Blob([\'/* Partytown 0.10.0 - MIT builder.io */\\n(e=>{const t=Symbol()	standard	{The `URL.createObjectURL` function is used to create a URL for a blob containing untrusted script, which is then executed in a `Worker`, leading to XSS.}	N/A
2002	fund.com.js	Denial of Service via Infinite Timeout Chains	Medium	false	CWE-400	N/A	const o = await (r => new Promise(async n => { const i = [...(await self.clients.matchAll())].sort((e	N/A	{The vulnerability is due to improper timeout and client matching logic, not misuse of a sensitive function.}	N/A
2003	kinocheck.com.js	Server Side Request Forgery (SSRF) via Unvalidated Fetch Requests	High	true	CWE-829	10	N/A	standard	"{The fetch() function is used with a URL constructed from self.config.cdn, which is derived from the 'config' query parameter via JSON.parse(new URL(location).searchParams.get(""config"")). Since this input is unvalidated and untrusted, an attacker can manipulate the 'config' parameter to inject arbitrary URLs, causing the service worker to make requests to internal or external systems, leading to SSRF.}"	"```self.addEventListener(""fetch"", e => { ""navigate"" === e.request.mode && e.respondWith((async () => { try { const a = await e.preloadResponse; if (a) return a; return await fetch(e.request); } catch (e) { const a = await caches.open(self.cacheName); return await a.match(self.offlineUrl); } })()); });```"
2004	swapd.co.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-601	N/A	self.addEventListener	standard	{The event handler for 'notificationclick' uses the notification data's 'url' field directly to navigate or open a window without validating or sanitizing it. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect. The function self.addEventListener is not inherently sensitive, but its misuse in handling untrusted data from notifications creates the vulnerability.}	"```self.addEventListener(""notificationclick"", function (e) { e.notification.close(); var t = e.notification.data.url, n = e.notification.data.baseUrl; if (""reply"" === e.action) { let o; fetch(""/session/csrf"", { credentials: ""include"", headers: { Accept: ""application/json"" } }).then(e => { if (!e.ok) throw new Error(""Network response was not OK""); return e.json(); }).then(s => { o = s.csrf; let i = t.match(chatRegex); if (i.length > 0) { let t = i[1]; fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": o }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" }); } }); } else e.waitUntil(clients.matchAll({ type: ""window"" }).then(function (e) { if (!e.some(function (e) { return e.url === n + t && ""focus"" in e ? (e.focus(), !0) : ""postMessage"" in e && ""focus"" in e && (e.focus(), e.postMessage({ url: t }), !0); }) && clients.openWindow) return clients.openWindow(n + t); })); });```"
2005	swapd.co.js	XSS via Unsanitized Notification Reply Input	Medium	true	CWE-79	N/A	fetch	standard	{The code fetches a CSRF token and then uses the 'e.reply' value directly in a POST request body without sanitization. If the reply input contains malicious script, it could be executed on the server if the server does not sanitize it, leading to XSS. The fetch function is standard, but its misuse with unsanitized user input from the notification reply action creates the vulnerability.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": o }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
2006	designcode.io.js	Insecure Dynamic Method Invocation	High	true	CWE-787	9	N/A	standard	{The vulnerability arises from dynamic method invocation via `MessageAPI[data.api]()` where `data.api` is derived from URL path parameters parsed from `event.request.url`. Since the `pathname` is extracted from the request URL and used to construct `data.api` without sanitization or validation, an attacker can craft a URL with arbitrary path segments (e.g., `/:maliciousFunction`) to invoke unintended methods in the `MessageAPI` object. This allows for potential code execution or unintended behavior if the attacker can trigger a method that performs sensitive operations, such as clearing cache or enabling/disabling offline shell features. The `new URL(event.request.url)` function is standard and used to parse the URL, but the subsequent dynamic property access on `MessageAPI` is the root cause of the vulnerability.}	```function handleAPIRequest({ event }) { const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); } if (!data.redirect) { return new Response(); } return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } }); }```
2007	nullkong.com.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., 'https://news-xdowulo.com/sitesw_v2.js'), it introduces a high-risk vulnerability if the domain is untrusted or controlled by an attacker. Although the URL is hardcoded here, the function itself is sensitive because it executes arbitrary code from a remote source, which can lead to full compromise of the service worker’s context, including interception of network requests, cache manipulation, and further exploitation.}	```self.options = { domainId: 1823 }; importScripts('https://news-xdowulo.com/sitesw_v2.js');```
2008	nightride.fm.js	Improper Neutralization of Input in Notification Content	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with user-controlled input from payload.data.title and payload.data.body without sanitization. This allows an attacker to inject malicious content into notifications, potentially leading to phishing, social engineering, or client-side attacks if the notification is rendered in a context where user interaction is possible.}	```const notificationTitle = payload.data.title; const notificationOptions = { body: payload.data.body, vibrate: [100, 200, 100, 100, 200], tag: payload.data.tag || 'general', icon: payload.data.icon || '/static/img/favicon.png' };```
2009	nightride.fm.js	Improper Neutralization of Input in Message Event	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with user-controlled input from event.data.title and event.data.body without sanitization. This allows an attacker to inject malicious content into notifications via message events, potentially leading to phishing, social engineering, or client-side attacks if the notification is rendered in a context where user interaction is possible.}	```const notificationTitle = event.data.title; const notificationOptions = { body: event.data.body, vibrate: [100, 200, 100, 100, 200], tag: `chat_${event.data.channel}`, icon: 'static/img/favicon.png', data: { channel_id: event.data.channel } };```
2010	nightride.fm.js	Unvalidated Port Usage in Message Handling	Medium	false	N/A	N/A	N/A	N/A	{The assignment of event.ports[0] to port is not inherently a sensitive function misuse, as it does not involve direct execution or injection of untrusted code. The vulnerability lies in the lack of validation of the port object, but no sensitive function is misused in this context.}	```port = event.ports[0]; return self.registration.showNotification(notificationTitle, notificationOptions);```
2011	rmweb.co.uk.js	Insecure determination of user authentication status using URL parameter	High	true	CWE-284	9	N/A	standard	{The vulnerability arises from using `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter. While `match()` itself is not inherently dangerous, its misuse here allows an attacker to manipulate the URL to spoof authentication state, leading to potential privilege escalation or unauthorized access. The function is standard, and the risk stems from trusting URL parameters without validation.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
2012	rmweb.co.uk.js	Potential SSRF via unvalidated path in CSRF token request	High	true	CWE-918	9	N/A	standard	{The `fetch()` function is used with a dynamically constructed URL that includes `path`, which is derived from `url.pathname`. Since `path` is not validated or sanitized, an attacker can inject arbitrary paths, potentially leading to SSRF by forcing the service worker to make requests to internal or external systems. `fetch()` is a standard function, and its misuse here enables SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json())```
2013	rmweb.co.uk.js	Insecure caching of sensitive resources without proper access control	Medium	false	CWE-921	0	N/A	N/A	{The vulnerability is due to hard-coded caching of a single asset (`https://www.rmweb.co.uk/offline/`) without access control checks. This is not caused by misuse of a sensitive function, but rather by design flaws in caching strategy.}	"```const CACHED_ASSETS = [""https://www.rmweb.co.uk/offline/""];```"
2014	rmweb.co.uk.js	Improper URL encoding of path parameter in CSRF token request	Low	false	CWE-116	0	N/A	N/A	{The issue stems from not encoding `path` before inclusion in the URL, but no sensitive function is misused. The problem is a lack of encoding, not a function misuse.}	```let path = url.pathname;```
2015	lidermedia.hr.js	External Script Loading in Service Worker	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, in this context, the URL is hardcoded to a third-party domain (pushpushgo.com), which may be controlled by an external entity. While not directly caused by unsanitized user input, the use of a remote script from an untrusted source introduces a high-risk dependency. If the remote script is compromised or modified, it can lead to arbitrary code execution within the service worker, enabling attacks such as cache manipulation, network interception, or data exfiltration. This constitutes a sensitive function misuse due to reliance on an external, potentially untrusted script source.}	```importScripts('https://s-eu-1.pushpushgo.com/6719f4e8862c7e761aebfdd7/worker.js');```
2016	basschat.co.uk.js	Logic flaw using URL parameter for authentication state	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using a URL parameter (loggedIn) to determine authentication state, which is inherently unreliable and can be manipulated by an attacker. This is a logic flaw, not caused by misuse of a sensitive JavaScript function.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2017	basschat.co.uk.js	CSRF token handling based on unreliable loggedIn check	High	false	N/A	N/A	N/A	N/A	{The issue stems from relying on the `loggedIn` parameter to conditionally fetch CSRF tokens, which is a logic flaw due to the parameter being user-controllable and not securely validated. This is not caused by misuse of a sensitive function.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token'```
2018	basschat.co.uk.js	Open redirect in notification click handler	Medium	true	N/A	N/A	clients[0].navigate	standard	{The `clients[0].navigate()` function is used with a URL derived from `data.url`, which is obtained from a push notification payload. Since this data is not validated or sanitized, an attacker can craft a notification with a malicious URL, leading to an open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2019	reflect.app.js	Improper URL Validation in Message Handling	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used with user-controlled input from t.base, which is derived from a message event. If the input is not validated, it can lead to improper URL resolution, potentially allowing an attacker to redirect requests to unintended domains or bypass security checks.}	```const r = new URL(t.base, e.origin);```
2020	reflect.app.js	Cache Poisoning via Prefetching	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used with a URL constructed from a split and modified path, which is derived from user input. This allows an attacker to manipulate the URL to cache malicious or unintended resources, leading to cache poisoning.}	```const c = o.href.split('/'), h = c[c.length - 1]; c[c.length - 1] = ''; const t = new URL(c.join('/'));```
2021	reflect.app.js	Insecure Cache Deletion	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper logic in cache deletion, not from misuse of a sensitive function. The code deletes cache entries based on a filtered list, but the issue is in the logic rather than a specific function misuse.}	```const f = E(n, o); await Promise.all(f.map(l => t.delete(l)));```
2022	reflect.app.js	Regex Injection in Link Bundles	Medium	true	N/A	N/A	RegExp.prototype.test	standard	{The test method of a RegExp object is used with user-controlled input from linkBundles, which can be manipulated to inject malicious patterns. This allows an attacker to bypass intended URL matching logic and trigger unintended prefetching behavior.}	```if (f.test(r)) { y(e, n, s, h, b(e, l)); break; }```
2023	reflect.app.js	Open Redirect via URL Construction	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used with a URL constructed from a split and modified path, which is derived from user input. This allows an attacker to craft a URL that redirects to an external domain, leading to open redirect vulnerabilities.}	```const c = o.href.split('/'), h = c[c.length - 1]; c[c.length - 1] = ''; const t = new URL(c.join('/'));```
2024	indogamers.com.js	Improper Input Validation (Untrusted URL Handling	Medium	true	CWE-20	9	N/A	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted input (e.g., payload.data.action), it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```const action = e.notification.data.action; clients.openWindow(action);```
2025	indogamers.com.js	Improper Input Validation (Untrusted URL Handling	Medium	true	CWE-20	9	N/A	standard	{The onclick property in the notification options is set to payload.data.action, which is user-controlled. If this value is not sanitized, it can be manipulated to redirect users to malicious URLs when the notification is clicked, leading to open redirect or phishing attacks.}	```onclick: payload.data.action```
2026	indogamers.com.js	Exposure of Sensitive Information (Firebase Config	Low	false	CWE-532	N/A	N/A	N/A	{The exposure of Firebase configuration is not due to misuse of a sensitive function, but rather due to hard-coding sensitive credentials in the script. No function is being misused here; it's a static data exposure issue.}	```const firebaseConfig = { apiKey: 'AIzaSyARt5sbdBts7QpB1eg-BsFdbYgQR4V4X6k'```
2027	greatwarforum.org.js	Server-Side Request Forgery (SSRF)	Medium	true	CWE-602	7	N/A	standard	{The fetch() function is used with a URL constructed from the `id` parameter received via push notification. Although the URL is prefixed with BASE_URL, if the `id` parameter is controlled by an attacker (e.g., via a crafted push message), it could be used to forge requests to internal or unintended endpoints, leading to SSRF. The `id` is derived from `e.data.json()` which is untrusted input.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' });```
2028	greatwarforum.org.js	Insecure Logic Check for Authentication	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from a logic flaw in how `loggedIn` is extracted from the URL, not from misuse of a sensitive function. The code uses a regex to parse `loggedIn=true|false` from the URL, which is inherently insecure due to lack of proper authentication state management, but no sensitive function is misused.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2029	greatwarforum.org.js	Open Redirect in Notification Handling	Medium	true	CWE-601	8	N/A	standard	{The navigate() method is used with `data.url` from a notification, which is derived from server response data. If an attacker can manipulate the notification payload to include a malicious URL, the browser will navigate to it, leading to an open redirect. The `data.url` is not validated or sanitized before being passed to navigate().}	```clients[0].navigate(data.url);```
2030	wineberserkers.com.js	Improper Input Validation	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes user-controlled data from `n` and `t`, which are derived from notification data. Since these values are not validated or sanitized, an attacker could manipulate them to trigger requests to arbitrary endpoints, potentially leading to SSRF or unauthorized data access. The use of `fetch` with untrusted input in the URL construction is a classic case of improper input validation.}	```fetch(`${n}/chat/${t}.json`, { credentials: 'include', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-CSRF-Token': i }, body: `message=${e.reply}`, method: 'POST', mode: 'cors' });```
2031	videoseyred.in.js	Improper Caching of Opaque Responses	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper configuration of the CacheableResponsePlugin when used with CacheFirst strategy for image assets. The plugin is configured to cache responses with a maxAgeSeconds value, but it does not explicitly handle opaque responses (e.g., those with status 0), which may lead to unintended caching behavior. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a misconfiguration in caching policy.}	```registerRoute(new RegExp('https:\/\/videoseyred\.in\/wp\-content\/.*\.(?:jpg|jpeg|gif|png|webp).*?$'), new CacheFirst({ cacheName: 'vsImages', plugins: [new CacheableResponsePlugin({ maxAgeSeconds: 60 * 60 * 24 * 30 })] }));```
2032	clearcare.co.uk.js	XSS via Unsanitized Data in postMessage	High	true	CWE-79	9	postMessage	standard	{The postMessage function is used to send data to client windows, but the data object is passed directly without sanitization. Since the data comes from event.data.json() (which is untrusted push notification data), an attacker can inject arbitrary JavaScript or HTML payloads. When the client receives this message, it may execute the payload if the client-side code does not properly sanitize or handle the incoming data, leading to cross-site scripting (XSS).}	```self.addEventListener('push', event => { const data = event.data.json(); const pushPromise = isClientFocused().then(async value => { if (value) { await clients.matchAll({ type: 'window', includeUncontrolled: true }).then(windowClients => { windowClients.forEach(windowClient => { windowClient.postMessage({ notification: data }); }); }); } else { await self.registration.showNotification(data.title, { body: data.body.replace(/<[^>]*>/g, '').replace(/&amp;/g, '&') }); } }); event.waitUntil(Promise.all([pushPromise])); });```
2033	burnhard.com.js	Improper Cache Versioning	Medium	false	New	N/A	N/A	N/A	{ url: '_nuxt/builds/meta/d25683bb-dbc9-4cf5-a265-c48fda3d55ec.json', revision: null }	"```define([""./workbox-e1498109""], function (e) { ""use strict""; self.skipWaiting(), e.clientsClaim(), e.precacheAndRoute([ { url: ""_nuxt/builds/latest.json"", revision: ""d72dc91dfc30043de1492650cbe56119"" }, { url: ""_nuxt/builds/meta/d25683bb-dbc9-4cf5-a265-c48fda3d55ec.json"", revision: null }, { url: ""manifest.webmanifest"", revision: ""528783df2422b2d223e6958da24330c9"" } ], {}), e.cleanupOutdatedCaches(), e.registerRoute(new e.NavigationRoute(e.createHandlerBoundToURL(""/""))); });```"
2034	sexygirlspics.live.js	Insecure IndexedDB Storage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of IndexedDB operations, but not due to misuse of a sensitive function. The code correctly uses standard IndexedDB APIs (open, transaction, put, get, delete) without direct exposure to untrusted input. The risk stems from potential data leakage or tampering if the stored data is sensitive, but no sensitive function is misused.}	```this.setItem = async (e, t) => { return await this.initializationPromise, new Promise((n, i) => { let o = this.getStore('readwrite').put({ id: e, value: t }); o.onsuccess = () => n(), o.onerror = c => i(c.target.error); }); };```
2035	sexygirlspics.live.js	Insecure Client Message Handling	High	true	N/A	N/A	onMessage	standard	{The onMessage function in the B class processes incoming messages from clients without validating or sanitizing the 'data' payload. The 'type' field from the message is used directly in a switch statement to route logic, and the 'config' object is passed to connectOrReconnect without validation. This allows an attacker to send arbitrary 'type' values or malicious 'config' data, potentially leading to unauthorized actions like forcing disconnects or triggering unintended behavior.}	```this.onMessage = ({ source: e, data: t = {} }) => { if (!(e instanceof Client)) return; let { type: n, payload: i } = t; switch (n) { case 'connectOrReconnect': { if (this.clientIds.size === this.maxClients) { this.onForceDisconnect(T.WORKER_TABS_LIMIT_REACHED, i); break; } this.clientIds.add(i); let o = () => this.postMessage(i, { type: 'connected', data: { client: '', latency: 0, transport: '' } }); this.socket.connectOrReconnect(n.config, o); break; } }```
2036	sexygirlspics.live.js	Insecure Subscription Key Handling	High	true	N/A	N/A	onMessage	standard	{The onMessage function in the B class directly uses the 'subscriptionKey' from the client's message payload to call the socket.subscribe method without any validation or sanitization. An attacker can send arbitrary subscription keys, potentially leading to unauthorized access to subscriptions or triggering unintended behavior in the socket layer.}	```this.onMessage = ({ source: e, data: t = {} }) => { if (!(e instanceof Client)) return; let { type: n, payload: i } = t; switch (n) { case 'subscribe': this.socket.subscribe(i, n.subscriptionKey); break; } }```
2037	sexygirlspics.live.js	Insecure Configuration Handling	Medium	true	N/A	N/A	onSyncHealthCheckConfigMessageEvent	standard	{The onSyncHealthCheckConfigMessageEvent function processes incoming configuration data from a message without validating the 'pwaRedirectsMirrorsEnabled' value. It directly stores this value in IndexedDB using setItem, which could allow an attacker to manipulate the configuration if they can send messages to the service worker.}	```this.onSyncHealthCheckConfigMessageEvent = async e => { if (!('pwaRedirectsMirrorsEnabled' in e && e.pwaRedirectsMirrorsEnabled === void 0)) try { await this.storage.setItem('pwaRedirectsMirrorsEnabled', e.pwaRedirectsMirrorsEnabled); } catch (t) { console.error(t); } };```
2038	lalucedimaria.it.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.push_send_id and sensor_url), allowing an attacker to manipulate the URL to make requests to internal or external systems, leading to SSRF.}	```var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.lalucedimaria.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
2039	lalucedimaria.it.js	Open Redirect	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted input (event.notification.data.url), enabling an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
2040	derechadiario.com.ar.js	Server Side Request Forgery (SSRF)	Medium	true	CWE-918	8	`M`	standard	{The `M` function is used to register a route that matches any URL starting with a forward slash (`/`). This route is handled by a `F` (NetworkFirst) strategy, which attempts to fetch resources from the network. Since the route pattern is overly broad and does not restrict the origin or domain, it allows the service worker to make network requests to arbitrary internal or external endpoints based on user-controlled input (e.g., via a crafted URL). This enables SSRF, where an attacker can trick the service worker into fetching data from internal systems or services that should not be accessible from the web.}	"```M(function (e) { return e.url.pathname.startsWith(""/""); }, new F())```"
2041	rllmukforum.com.js	Improper Input Validation Leading to SSRF	High	true	CWE-549	9	N/A	standard	{The fetch function is used with a URL constructed from the `id` parameter from the push event data, which is untrusted. Since the `id` value is directly interpolated into the URL without validation or sanitization, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
2042	rllmukforum.com.js	Insecure Handling of Authentication State	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of the `loggedIn` state derived from the URL, but no sensitive function is misused. The issue is more about logic and state management rather than a direct misuse of a sensitive API.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2043	rllmukforum.com.js	CSRF Token Handling Without Validation	Medium	false	N/A	N/A	N/A	N/A	{The issue is not due to misuse of a sensitive function, but rather due to lack of validation of the CSRF token obtained from the server. The fetch function is used correctly here, and the vulnerability stems from design flaws, not improper function usage.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`);```
2044	rllmukforum.com.js	Open Redirect in Notification Handling	Medium	true	CWE-601	8	N/A	standard	{The navigate function is used with the `data.url` value from a notification, which is derived from server responses and potentially untrusted. Since the URL is not validated or sanitized, an attacker can craft a notification with a malicious URL, leading to open redirect and potential phishing or session hijacking.}	```clients[0].navigate(data.url);```
2045	rllmukforum.com.js	Insecure Cache Management	Low	false	N/A	N/A	N/A	N/A	{The cache.addAll function is used with a hardcoded list of assets, so there is no dynamic or untrusted input involved. The vulnerability is due to lack of cache cleanup or policy enforcement, not misuse of a sensitive function.}	```return cache.addAll(CACHED_ASSETS);```
2046	eden.com.js	Improper Input Validation in URL Parameter Parsing Leading to Unexpected Behavior	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper parsing of URL path parameters using a regex that does not validate or sanitize the input. However, no sensitive JavaScript function (like eval, importScripts, or dynamic code execution) is misused here. The issue is purely a logic flaw in input handling.}	```const params = pathname.match(/:(.+)/)[1];```
2047	eden.com.js	Denial of Service via Cache Clearing	High	true	CWE-408	N/A	idbKeyval.clear()	custom	{The idbKeyval.clear() function is a custom utility that clears all data in the IndexedDB storage. When triggered by an untrusted message event (via self.addEventListener('message')), it can be abused by an attacker to delete all stored data, leading to a denial of service. The function is not standard but is used in a context where input is not validated, making it a sensitive misuse.}	```event.waitUntil(idbKeyval.clear());```
2048	eden.com.js	Denial of Service via Offline Shell Disabling	Medium	true	CWE-408	N/A	offlineShellEnabled = false	custom	{The offlineShellEnabled flag is set to false via a message event handler, which is triggered by untrusted input. Although this is not a function call per se, the assignment is part of a custom API (MessageAPI.disableOfflineShell) that can be invoked remotely. This allows an attacker to disable offline functionality, leading to a denial of service. The vulnerability stems from the misuse of a custom state-setting mechanism without proper access control.}	```offlineShellEnabled = false;```
2049	insideiim.com.js	Improper Request Blocking in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in the fetch event handler, where event.stopImmediatePropagation() is called without properly preventing or redirecting the request. This does not stem from misuse of a sensitive function like importScripts() or eval(), but rather from incorrect handling of the fetch event. The code does not use any sensitive functions with untrusted input.}	```self.addEventListener('fetch', event => { if (event && event.request && event.request.url && event.request.url.includes('/amp/')) { event.stopImmediatePropagation(); } });```
2050	himalmag.com.js	Insecure External Script Loading	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in service workers to load and execute external scripts. When used with hardcoded URLs, it is not inherently dangerous, but if the URL is derived from untrusted or dynamic input, it can lead to arbitrary code execution. In this case, the URLs are hardcoded and not derived from user input or dynamic sources, so the vulnerability is not due to sensitive function misuse. However, the original detection flagged it as insecure, likely due to the external nature of the scripts. Since the URLs are fixed and not dynamically constructed from untrusted sources, the risk is low, but the function itself is sensitive.}	```importScripts('https://www.himalmag.com/service-worker.js?version=0');importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
2051	otib.co.uk.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this `id` is derived from untrusted external input (push notification payload), an attacker could craft a malicious notification to trigger a request to an arbitrary internal or external endpoint, leading to SSRF. The URL is built using template literals with user-controlled data, and no validation or sanitization is applied.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2052	otib.co.uk.js	Insecure Login Status Check	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper logic in parsing the `loggedIn` parameter from the URL, not from misuse of a sensitive function. The code uses a regex to extract the value, but the issue is in the logic flow and lack of proper authentication state management, not in a dangerous function call.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2053	otib.co.uk.js	CSRF Token Endpoint with Unvalidated Path	High	true	CWE-352	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `path` parameter, which is derived from the request's URL pathname. Since this `path` is taken directly from the client's request without validation, an attacker could manipulate the request to inject arbitrary paths, potentially leading to CSRF token leakage or unauthorized actions. The URL is built using template literals with untrusted input, and no sanitization is applied.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2054	otib.co.uk.js	Unvalidated URL Redirection	Medium	true	CWE-601	8	N/A	standard	{The navigate() method is used with a URL derived from the notification data's `url` field, which is obtained from a remote push notification. Since this data is untrusted and not validated, an attacker could craft a notification to redirect the user to a malicious site, leading to phishing or other attacks. The URL is passed directly without any checks for allowed domains or sanitization.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2055	hititrich.com.js	Insecure URL Handling	High	true	CWE-601	N/A	actions	standard	{The code constructs notification actions using untrusted data from `o.cta_btn_1.link` and `o.cta_btn_2.link`, which are derived from the push message payload. These URLs are directly assigned to the `action` field in the notification, which can be used to redirect users to arbitrary sites. Since the source of `o` is untrusted (from `t.data.json()`), this allows an attacker to inject malicious URLs, leading to phishing, redirection, or other client-side attacks.}	```var a = []; 'cta_btn_1' in o && o.cta_btn_1.link && o.cta_btn_1.text && a.push({ action: o.cta_btn_1.link, type: 'button', title: o.cta_btn_1.text }), 'cta_btn_2' in o && o.cta_btn_2.link && o.cta_btn_2.text && a.push({ action: o.cta_btn_2.link, type: 'button', title: o.cta_btn_2.text }), a.length && (n.actions = a)```
2056	hititrich.com.js	Insecure Data Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of data before passing it to the `h` function, but no sensitive JavaScript function is directly misused. The `h` function is a custom utility, and the issue is more about data sanitization than function misuse.}	```var c = n.data.send_key, l = n.data.app_id, f = n.data.zid; u(c) && u(l) && u(f) && t.waitUntil(h(l, f, c, 'receive'))```
2057	hititrich.com.js	Insecure Data Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of data before passing it to the `h` function, but no sensitive JavaScript function is directly misused. The `h` function is a custom utility, and the issue is more about data sanitization than function misuse.}	```var i = t.notification.data.send_key, a = t.notification.data.app_id, c = t.notification.data.zid; u(i) && u(a) && u(c) && t.waitUntil(h(a, c, i, 'click', e, r))```
2058	hititrich.com.js	Insecure Data Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of data before passing it to the `h` function, but no sensitive JavaScript function is directly misused. The `h` function is a custom utility, and the issue is more about data sanitization than function misuse.}	```var r = t.notification.data.send_key, e = t.notification.data.app_id, n = t.notification.data.zid; u(r) && u(e) && u(n) && t.waitUntil(h(e, n, r, 'dismiss'))```
2059	hititrich.com.js	XSS Vulnerability	High	true	CWE-79	N/A	Notification API	standard	{The code assigns `r.body` directly to `n.body` without sanitization. Since `r.body` comes from `t.data.json()`, which is untrusted, this allows an attacker to inject arbitrary HTML or JavaScript into the notification body. When rendered by the browser, this can lead to XSS attacks, especially if the notification is displayed in a context where script execution is allowed.}	```n.body = r.body```
2060	hititrich.com.js	XSS Vulnerability	High	true	CWE-79	N/A	Notification API	standard	{The code assigns `r.title` directly to `n.title` without sanitization. Since `r.title` comes from `t.data.json()`, which is untrusted, this allows an attacker to inject arbitrary HTML or JavaScript into the notification title. When rendered by the browser, this can lead to XSS attacks, especially if the notification is displayed in a context where script execution is allowed.}	```n.title = r.title```
2061	charles.co.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-1333	9	RegExp.prototype.match	standard	{The regular expression /:(.+)/ is used to extract parameters from a URL pathname. If an attacker can control the pathname, they can supply a malicious string that causes catastrophic backtracking, leading to ReDoS. The match() function is a standard JavaScript method, and its misuse with untrusted input is the root cause.}	```const params = pathname.match(/:(.+)/)[1];```
2062	charles.co.js	Improper Input Validation	Medium	true	CWE-20	8	N/A	standard	{The code uses MessageAPI[data.api]() without validating or sanitizing the 'data.api' value, which is derived from user-controlled input via URL parameters. This allows an attacker to invoke arbitrary functions in the MessageAPI object, potentially leading to unintended behavior or privilege escalation.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
2063	charles.co.js	Improper Input Validation	Medium	true	CWE-20	7	N/A	standard	{The code iterates over cache keys obtained from caches.keys() and deletes caches based on whether the key includes 'runtime'. Since cache keys can be manipulated by an attacker (e.g., via cache poisoning or malicious service worker updates), this leads to improper input validation and potential cache deletion or manipulation.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
2064	leitz.com.js	Cache Poisoning via Unvalidated Network Request	Medium	true	N/A	9	caches.add	standard	{The caches.add() function is used to store a response in the cache, but it is called with the original network request (event.request) without validating or sanitizing it. Since the request may originate from an untrusted source or be manipulated by an attacker (e.g., via a crafted URL or request header), this allows for cache poisoning — where malicious responses can be stored in the cache and served to subsequent users. This is a misuse of a standard cache API that assumes trust in the request object.}	```self.addEventListener('fetch', event => { if (event.request.method != 'GET') return; event.respondWith(async function () { const cache = await caches.open('v3'); const cachedResponse = await cache.match(event.request); if (cachedResponse) { event.waitUntil(cache.add(event.request)); return cachedResponse; } return fetch(event.request); }()); });```
2065	ripper.store.js	Failure to Handle Exception or Status Code	Medium	false	CWE-758	N/A	N/A	N/A	{The vulnerability arises from not handling potential errors or non-2xx status codes from the fetch() call. While fetch() is a sensitive function, the issue here is not due to misuse of the function with untrusted input, but rather due to lack of error handling. The code does not check for network errors or invalid responses, which could lead to silent failures or unexpected behavior.}	```return fetch(event.request);```
2066	kaizenep.com.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	safeFetch	standard	{The `safeFetch` function uses `this.scope.fetch(req)` to make network requests. Since `req` is derived from client-controlled `event.request`, and no validation is performed on the request URL or origin, an attacker can craft a request to internal or external resources (e.g., `http://localhost:8080` or `http://internal-api.com`), leading to SSRF. The function does not restrict the target domain or validate the request, making it a direct misuse of the standard `fetch` API with untrusted input.}	```const safeFetch = async (req) => { try { return await this.scope.fetch(req); } catch (err) { return this.adapter.newResponse(null, { status: 504, statusText: 'Gateway Timeout' }); } };```
2067	kaizenep.com.js	Insecure Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The cache busting mechanism uses `Math.random()` to append a random query parameter. While this is not a sensitive function misuse per se, it is considered insecure because `Math.random()` is predictable and not cryptographically secure, potentially allowing attackers to guess the cache-busting parameter and bypass cache invalidation. This is a design flaw, not a sensitive function misuse.}	```const cacheBust = (url) => url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random();```
2068	kaizenep.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The `handleFetch` function attempts to ensure initialization before processing the request, but if initialization fails, it falls back to `safeFetch(event.request)` without validating the request. While `safeFetch` is designed to handle errors, the lack of input validation on the request object (e.g., URL, method, headers) before passing it to `fetch` could allow malicious requests to be processed. However, this is not a direct misuse of a sensitive function, but rather a control flow issue.}	```const handleFetch = async (event) => { try { await this.ensureInitialized(event); } catch (e) { return this.safeFetch(event.request); } };```
2069	k7.game.js	Improper Cache Management	Medium	false	CWE-400	N/A	N/A	N/A	{The vulnerability arises from caching the root path ('/') without proper validation or consideration of dynamic content, but it does not stem from misuse of a sensitive function like importScripts or eval. The caches.open and cache.addAll functions are used appropriately in this context.}	```e.waitUntil(caches.open('fox-store').then(cache => cache.addAll(['/'])));```
2070	k7.game.js	Flawed URL Filtering Logic	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from a flawed logic in filtering URLs using indexOf, which is not inherently a sensitive function misuse. The issue is in the logic design, not in the use of a dangerous API.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
2071	k7.game.js	Unvalidated JSON Input	Low	false	CWE-20	N/A	N/A	N/A	{The use of JSON.parse is not inherently dangerous unless the parsed data is used in a context that can lead to code execution or injection. Here, the parsed data is used only for notification display, which does not involve sensitive function misuse.}	```let data = JSON.parse(event.data.text());```
2072	aslain.com.js	Incorrect Use of Service Worker Location for Login Status Check	High	true	CWE-200	9	N/A	standard	{The vulnerability arises from using `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to extract login status from the URL. This is unsafe because the URL is user-controllable and can be manipulated to spoof login state (e.g., by appending `?loggedIn=true` to a malicious URL), leading to unauthorized access or privilege escalation. The `match()` function is standard, but its misuse with untrusted input creates a security risk.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
2073	aslain.com.js	Insecure Handling of CSRF Token Path	Medium	true	CWE-347	8	N/A	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since `path` is derived from `url.pathname` (which is user-controlled), an attacker can manipulate it to forge CSRF tokens for unintended endpoints, potentially leading to unauthorized actions. The `fetch` API is standard, but its misuse with unsanitized input introduces a CSRF vulnerability.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2074	aslain.com.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	9	N/A	standard	{The `navigate` method is used with `data.url`, which is derived from server-provided notification data. If this data is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to redirect users to arbitrary sites, leading to phishing or credential theft. The `navigate` method is part of the standard Client API, but its misuse with untrusted input creates an open redirect vulnerability.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2075	supersales.nl.js	Outdated Workbox version with known cache poisoning vulnerability	High	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of Workbox (4.3.1), which contains a known cache poisoning vulnerability (CVE-2021-41235). This is not caused by misuse of a sensitive JavaScript function, but rather by using an insecure version of a library. The importScripts call is safe because the URL is hardcoded and not derived from untrusted input.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js');```
2076	supersales.nl.js	Insecure dependency on outdated jQuery version with known vulnerabilities	High	false	N/A	0	N/A	N/A	{The vulnerability arises from including an outdated version of jQuery (1.11.0) via a hardcoded URL, which is known to have multiple security issues (CVE-2015-9251). This is not due to misuse of a sensitive JavaScript function, but rather due to using a vulnerable third-party library. The URL is hardcoded and not dynamically constructed from untrusted input.}	```'https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js'```
2077	homegrown.co.in.js	Loading external script without integrity check	Medium	false	N/A	N/A	N/A	N/A	{The use of importScripts with a hardcoded URL does not involve dynamic or untrusted input, so it is not a sensitive function misuse. The vulnerability arises from lack of integrity checks, not from unsafe function usage.}	```importScripts('https://homegrown.co.in/service-worker.js?version=0');```
2078	homegrown.co.in.js	Loading third-party script without Subresource Integrity	Medium	false	N/A	N/A	N/A	N/A	{The use of importScripts with a hardcoded URL does not involve dynamic or untrusted input, so it is not a sensitive function misuse. The vulnerability arises from lack of integrity checks, not from unsafe function usage.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
2079	eauk.org.js	Cache Poisoning via URL Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient filtering of URLs, particularly those containing 'google-analytics' or 'plugin', but does not stem from misuse of a sensitive JavaScript function. The logic is flawed in its filtering approach, but no function like importScripts, eval, or dynamic code execution is involved.}	```if (request.url.indexOf('google-analytics') !== -1) { return; } if (request.url.indexOf('plugin') !== -1) { return; }```
2080	eauk.org.js	Incorrect Cache Matching without Vary Headers	Medium	false	N/A	N/A	N/A	N/A	{The issue stems from improper cache handling logic where responses are cached without considering Vary headers, which can lead to incorrect responses being served. This is a logic or design flaw, not misuse of a sensitive JavaScript function such as eval or importScripts.}	```event.respondWith(caches.match(request).then(response => { return response || fetch(request).then(response => { ... }); }));```
2081	unilever.com.br.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a request URL derived directly from the incoming fetch event (e.request.url), which is under user control. Since the service worker does not validate or sanitize the hostname or URL path before passing it to fetch(), an attacker can craft a request to internal or external resources, leading to SSRF. The lack of strict URL validation allows arbitrary endpoint access.}	```const { hostname: t } = new URL(e.request.url); IGNORED_HOSTS.indexOf(t) >= 0 || EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || 'PUT' === e.request.method || 'POST' === e.request.method || e.request.headers.get('range') || (e.request.headers.get('Accept').includes('text/html') ? e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E; }).catch(() => caches.match(e.request).then(e => e))) : e.respondWith(caches.match(e.request).then(E => E || caches.open(CACHE_KEYS.RUNTIME).then(E => fetch(e.request).then(n => RUNTIME_IGNORED_HOSTS.indexOf(t) > -1 ? n : E.put(e.request, n.clone()).then(() => n)).catch(() => {})))));```
2082	unilever.com.br.js	Denial of Service (Cache Bloat)	High	true	CWE-400	8	N/A	standard	{The caches.put() function is called with a request and response pair derived from user-controlled fetch requests. Since there is no rate limiting or size validation, an attacker can trigger repeated caching of large or numerous responses, leading to unbounded cache growth and potential exhaustion of storage resources, resulting in DoS.}	```e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E; }).catch(() => caches.match(e.request).then(e => e)))```
2083	unilever.com.br.js	Insecure Accept Header Check	Medium	false	CWE-200	0	N/A	standard	{The vulnerability arises from a logic flaw in the Accept header check, not from misuse of a sensitive function. The .includes('text/html') method is used correctly, but the logic allows bypasses by manipulating the Accept header. This is a misconfiguration, not a sensitive function misuse.}	```e.request.headers.get('Accept').includes('text/html')```
2084	unilever.com.br.js	Substring URL Matching Logic Flaw	Medium	false	New	0	N/A	standard	"{The vulnerability stems from using indexOf() for substring matching on URLs, which can lead to false negatives or positives (e.g., matching ""/api"" in ""/api.example.com""). This is a logic flaw in URL filtering, not misuse of a sensitive function.}"	```EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1)```
2085	cookh5.com.js	Cache Poisoning	High	true	N/A	10	N/A	standard	{The fetch() function is used to retrieve resources from the network, and the response is then cloned and stored in the cache via caches.put(). While fetch() itself is not inherently dangerous, the issue arises because the script does not validate or sanitize the URL being fetched. If an attacker can manipulate the request URL (e.g., via a crafted request in a fetch event), the service worker may cache a malicious response, leading to cache poisoning. The vulnerability is exacerbated by the fact that the cached response is used for subsequent requests without revalidation, potentially serving malicious content to users.}	```return fetch(t).then(e => { const n = e.clone(); return caches.open(c('resources')).then(e => { e.put(t, n); }), t.method, t.url, e; });```
2086	cookh5.com.js	Incorrect URL Matching in Fallback Logic	Medium	true	N/A	9	N/A	standard	{The caches.match() function is used to retrieve a cached response, but the fallback logic incorrectly references req.url instead of t.url, which is undefined in the current scope. This leads to a potential logic error where the fallback may not match the intended URL, causing incorrect or no cache retrieval. Since caches.match() is a standard API, its misuse here—due to incorrect variable reference—can result in unintended behavior, such as serving stale or incorrect responses, or failing to serve cached content when expected.}	```return caches.match(t).then(e => e || function (t) { if (t.method, t.url, t.url.match(/^https?:\/\/(www|dev|static)?.cookh5.com\/*/)) return caches.match(req.url); }(t));```
2087	takipmax.com.js	Empty Fetch Event Handler in Service Worker	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the presence of an empty fetch event handler, which may indicate incomplete or placeholder logic. This does not involve dynamic or untrusted input being passed to a sensitive function.}	"```console.log(""sw loaded"");self.addEventListener('fetch', function (event) {});```"
2088	aanbodpagina.nl.js	Caching third-party resources without validation leading to potential XSS or data leakage	Medium	true	CWE-937	10	N/A	standard	{The function cache.addAll() is a standard service worker API that caches a list of URLs. In this case, it includes a third-party font URL from Google Fonts, which is not validated or sanitized. If the third-party resource is compromised or dynamically altered (e.g., via DNS hijacking or CDN injection), it could deliver malicious content, leading to XSS or data leakage. The vulnerability arises because the service worker blindly caches external resources without verifying their integrity or origin.}	```cache.addAll(assets);```
2089	aanbodpagina.nl.js	Caching dynamic content without checking for sensitive resources leading to sensitive data storage	Medium	true	New	10	N/A	standard	{The function cache.put() is a standard service worker API used to store responses in a cache. Here, it caches responses from any fetched URL without validating whether the URL or content is sensitive (e.g., containing authentication tokens, PII, or other confidential data). This can lead to sensitive data being stored in the browser’s cache, potentially accessible to other scripts or persisted across sessions, increasing the risk of data leakage.}	```cache.put(event.request.url, res.clone());```
2090	surrealdb.com.js	Arbitrary Code Execution	High	true	N/A	N/A	new Function	N/A	{The code dynamically constructs a JavaScript string using user-controlled or untrusted input (via `n.replace` and `h.i.globalFns`) and then evaluates it using `new Function(t).call(e.U)`. This is a classic case of unsafe dynamic code evaluation, which allows an attacker to inject and execute arbitrary JavaScript code if they can control the input to `n` or `h.i.globalFns`. The `new Function` constructor is a standard JavaScript function, but its misuse here leads to high-risk arbitrary code execution.}	```const t=`with(this){${n.replace(/([a-zA-Z0-9_$\\\.\\\\\\\'\\\\'\\\\`])?(\\.\\.\\.)?this(?![a-zA-Z0-9_$:])/g,((e,t,r)=>{const n=(t||\'\')+(r||\'\');return null!=t?n+\'this\':n+\'(thi$(this)?window:this)\'}))}\\\\n;function thi$(t){return t===this}};${(h.i.globalFns||[]).filter((e=>/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(e))).map((e=>\`(typeof ${e}==\\\'function\\\'&&(this.${e}=${e}))\`).join(\';\')};`+(r?\'\\\\n//# sourceURL=\'+r:\'\'),new Function(t).call(e.U)```
2091	1win.run.js	Insecure Caching of Untrusted Content	High	false	CWE-918	0	N/A	N/A	{The vulnerability arises from improper configuration of caching strategies, particularly in the Te class, which caches responses without sufficient validation of their origin or integrity. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather due to flawed logic in cache policy (e.g., caching responses with status 200 without checking for malicious content). The code does not dynamically invoke functions with untrusted input in a way that constitutes sensitive function misuse.}	"```class Te extends E { constructor(e = {}) { super(e), this.plugins.some(t => ""cacheWillUpdate"" in t) || this.plugins.unshift($), this._networkTimeoutSeconds = e.networkTimeoutSeconds || 0; } async _handle(e, t) { const n = [], a = []; let r; if (this._networkTimeoutSeconds) { const { id: o, promise: h } = this._getTimeoutPromise({ request: e, logs: n, handler: t }); r = o, a.push(h); } const i = this._getNetworkPromise({ timeoutId: r, request: e, logs: n, handler: t }); a.push(i); const c = await t.waitUntil((async () => (await t.waitUntil(Promise.race(a))) || (await i))()); if (!c) throw new l(""no-response"", { url: e.url }); return c; } _getTimeoutPromise({ request: e, logs: t, handler: n }) { let a; return { promise: new Promise(i => { a = setTimeout(async () => { i(await n.cacheMatch(e)); }, this._networkTimeoutSeconds * 1e3); }), id: a }; } async _getNetworkPromise({ timeoutId: e, request: t, logs: n, handler: a }) { let r, i; try { i = await a.fetchAndCachePut(t); } catch (c) { c instanceof Error && (r = c); } return e && clearTimeout(e), (r || !i) && (i = await a.cacheMatch(t)), i; } }```"
2092	telecontact.ru.js	Vulnerable Service Worker Cache Handling	High	false	N/A	N/A	N/A	N/A	{The vulnerability described is related to cache handling logic, but it does not stem from the misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The code uses standard caching operations (caches.match, fetch) in a way that is generally safe and follows best practices. There is no dynamic, untrusted input being passed to a sensitive function that could lead to code injection or arbitrary execution.}	```self.addEventListener('fetch', evt => { evt.respondWith(caches.match(evt.request).then(cacheRes => { return cacheRes || fetch(evt.request); })); });```
2093	mycarcheck.com.js	Improper Error Handling in Fetch Event	Medium	false	CWE-200	0		N/A	{The error is returned directly without proper handling or logging, which may expose sensitive information to the client. However, this is not caused by misuse of a sensitive function like importScripts, eval, or similar; it is a logic flaw in error management.}	```return error;```
2094	bookmygarage.com.js	Improper Error Handling in Service Worker	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to improper error handling in the fetch event handler, not misuse of a sensitive function. The code attempts to fetch a resource and falls back to cache on failure, but the error handling is not robust and may lead to unexpected behavior or degraded user experience. No sensitive function is being misused here.}	```self.addEventListener('fetch', function (event) { if (event.request.url.indexOf('/api/') !== -1 || event.request.url.indexOf('/bmg-api/') !== -1 || event.request.url.indexOf('localhost:4000') !== -1) { return false; } event.respondWith(async function () { try { return await fetch(event.request); } catch (err) { const cachedResponse = await caches.match(event.request); if (cachedResponse) return cachedResponse; return caches.match('/offline.htm'); } }()); });```
2095	get-save.com.js	Caching of POST Requests	High	true	N/A	10	N/A	standard	{The vulnerability arises from the service worker caching responses for all requests, including POST requests, which are typically not cacheable by design. The code uses `caches.put(event.request, networkResponse.clone())` without checking the request method. Since `caches.put()` is a standard API, and it is being misused by not filtering out non-cacheable methods like POST, this leads to unintended caching behavior that can cause data inconsistency, replay attacks, or exposure of sensitive data. The function is standard and its misuse is directly responsible for the vulnerability.}	```const CACHE_NAME = 'gs_cache_v19';const EXCLUDED_DOMAINS = ['sw.js', 'test', 'admin.php'];self.addEventListener('install', event => self.skipWaiting());self.addEventListener('fetch', event => {const requestUrl = new URL(event.request.url);const isOwnDomain = requestUrl.origin === self.location.origin;if (!isOwnDomain || EXCLUDED_DOMAINS.some(excluded => requestUrl.pathname.includes(excluded))) {event.respondWith(fetch(event.request));return;}const isHTMLPage = requestUrl.pathname.endsWith('/') || requestUrl.pathname.endsWith('.html');if (isHTMLPage) {event.respondWith(caches.match(event.request).then(cachedResponse => {return cachedResponse || fetch(event.request).then(networkResponse => {return networkResponse.clone().text().then(bodyText => {const hasMetaRobots = bodyText.includes('index, follow');if (hasMetaRobots) {return caches.open(CACHE_NAME).then(cache => {cache.put(event.request, networkResponse.clone());return networkResponse;});}return networkResponse;});}).catch(() => caches.match(event.request));}));} else {event.respondWith(caches.match(event.request).then(cachedResponse => {return cachedResponse || fetch(event.request).then(networkResponse => {return caches.open(CACHE_NAME).then(cache => {cache.put(event.request, networkResponse.clone());return networkResponse;});});}));}self.addEventListener('activate', event => {event.waitUntil(caches.keys().then(cacheNames => {return Promise.all(cacheNames.filter(cacheName => cacheName !== CACHE_NAME).map(cacheName => caches.delete(cacheName)));}));self.clients.claim();});```
2096	bon-kredit.de.js	Code Injection via Dynamic Function Construction	High	false	CWE-78	0	N/A	N/A	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the dynamic construction of function names via reflection (Object.getOwnPropertyNames and Object.getPrototypeOf). This code is part of a utility to collect all function names from the prototype chain, which is not inherently dangerous unless used in conjunction with dynamic code evaluation (e.g., eval, Function constructor). Since no such evaluation is performed in the snippet, it does not constitute a direct code injection vulnerability.}	```const t = new Set(); let r = []; do { Object.getOwnPropertyNames(r).forEach(e => { \'function\' == typeof r[e] && t.add(e); }); } while ((r = Object.getPrototypeOf(r)) !== Object.prototype); return Array.from(t);```
2097	bitmidi.com.js	Insecure Resource Loading	High	true	N/A	10	N/A	standard	{The function `cache.add()` is used with a dynamically constructed `Request` object where the URL is passed directly without validation. Although the URL is hardcoded as `OFFLINE_URL` in this context, the vulnerability detection previously flagged it as risky, likely due to the general pattern of using `cache.add()` with dynamic URLs. However, in this specific code, the URL is static and not derived from untrusted input, so the risk is mitigated. The detection may be a false positive or based on a broader pattern.}	```const cacheAdd = (cache, url) => cache.add(new Request(url, { cache: 'reload' }));```
2098	bitmidi.com.js	Improper Input Validation	High	false	N/A	N/A	N/A	N/A	{The `fetch(event.request)` call is not inherently vulnerable to improper input validation in this context, as it is used to handle network requests normally. The vulnerability detection may be misleading, as `fetch()` is a standard API used correctly here. There is no evidence of untrusted input being passed directly into `fetch()` without sanitization or validation.}	```return fetch(event.request);```
2099	juguetilandia.com.js	Insecure Fetch in Push Event Leading to SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL derived from e.data.trackOpenEndpoint, which originates from untrusted push notification data. Since this input is not validated or sanitized, an attacker can craft a push notification with a malicious URL (e.g., internal network endpoints) to trigger SSRF, allowing unauthorized access to internal resources.}	```t.waitUntil(self.registration.showNotification(n, e).then(function () { return fetch(e.data.trackOpenEndpoint); }));```
2100	juguetilandia.com.js	Unvalidated Redirect URL in Notification Click	Medium	true	CWE-601	9	self.clients.openWindow	standard	{The self.clients.openWindow function is called with i.redirectUrl, which is derived from untrusted notification data. Without validation, an attacker can manipulate the notification payload to redirect users to arbitrary URLs, potentially leading to phishing or malicious site redirection.}	```self.clients.openWindow(i.redirectUrl)```
2101	whitehat.vn.js	Insecure Cache Busting (Cache Poisoning	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the use of fetch() to retrieve a cache configuration from a remote endpoint (CACHE_ROUTE). If an attacker can manipulate the response from this endpoint (e.g., via server-side compromise or DNS spoofing), they can inject arbitrary URLs into the cache via cache.addAll(files), leading to cache poisoning. The function fetch() is sensitive because it executes network requests with potentially untrusted URLs, and here it is used without validating or sanitizing the response data, allowing malicious files to be cached.}	```return fetch(CACHE_ROUTE).then(function (response) { return response.json(); }).then(function (response) { var key = response.key || null; var files = response.files || []; files.push(OFFLINE_ROUTE); return cache.addAll(files).then(function () { return key; }); });```
2102	whitehat.vn.js	Insecure Notification URL Handling	High	true	CWE-601	10	N/A	standard	{The function clients.openWindow() is used to open a URL provided in the notification data (notification.data.url). If this URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to phishing sites, execute cross-site scripting, or perform other malicious actions. Since the URL is directly taken from untrusted data, this constitutes a sensitive function misuse.}	```event.waitUntil(clients.openWindow(notification.data.url));```
2103	whitehat.vn.js	Insecure Message Handling (Unvalidated Message Types	Medium	false	CWE-703	0	N/A	N/A	{This vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by insufficient validation of message types. The code checks for the existence of a handler, but does not prevent arbitrary message types from being processed if a handler is registered. This is a logic flaw, not a direct misuse of a sensitive function like eval, importScripts, or fetch.}	```var handler = messageHandlers[type]; if (typeof handler === 'undefined') { console.error('No handler available for message type:', type); return; }```
2104	tourisme-alsace.com.js	Caching Sensitive Data	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from caching files with extensions like .php, which may contain sensitive or dynamic content. However, this is not due to misuse of a sensitive JavaScript function, but rather a policy decision in the caching logic.}	```if (request.url.match(/\/wp-content\//gi) || request.url.match(/\.(css|mp4|jpg|jpeg|png|json|js|php)$/gi)) {```
2105	tourisme-alsace.com.js	Incorrect Handling of 404 and Offline Pages	Medium	false	CWE-601	N/A	N/A	N/A	{The issue stems from logic that returns cached offline or 404 pages without proper validation, but it does not involve misuse of a sensitive JavaScript function.}	```if (!matching || matching.status == 404) {```
2106	tourisme-alsace.com.js	Insecure Cache Storage	Low	false	CWE-921	N/A	N/A	N/A	{The use of cache.addAll() to store static offline and 404 pages is not inherently unsafe, and no sensitive function is misused here.}	```return cache.addAll(['/offline/', '/404/']);```
2107	tourisme-alsace.com.js	Insecure Handling of PHP Files	Medium	false	CWE-918	N/A	N/A	N/A	{This vulnerability is due to caching PHP files, which may be dynamic and sensitive, but it is not caused by misuse of a sensitive JavaScript function.}	```request.url.match(/\.(css|mp4|jpg|jpeg|png|json|js|php)$/gi)```
2108	digi-follower.com.js	Insecure Dynamic Script Import	Medium	false	CWE-94	N/A	N/A	N/A	{The importScripts() call uses a hardcoded URL and does not involve dynamic or user-controlled input. Therefore, while the script is imported from an external source, it is not considered a sensitive function misuse because the URL is not derived from untrusted or unsanitized input.}	```var site_url = 'https://www.digi-follower.com'; importScripts('https://www.digi-follower.com/wp-content/plugins/letspush/js/letspush_service_worker.min.js');```
2109	germanscooterforum.de.js	Incorrect login status check using Service Worker's URL instead of client's state, Leading To Potential Csrf Or Incorrect Request Handling	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from relying on the Service Worker's URL (e.g., `e.currentTarget.location.href`) to determine login status, which is not a secure or reliable indicator of the client's actual authentication state. This does not involve misuse of a sensitive JavaScript function but rather a logical flaw in state management.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
2110	germanscooterforum.de.js	Open redirect via notification click due to unvalidated URL in notification data	High	true	N/A	N/A	clients.navigate	standard	{The `clients.navigate()` method is used with `data.url` from notification data without validation, allowing an attacker to craft a notification with a malicious URL, leading to open redirect and potential phishing or unauthorized navigation.}	```clients[0].navigate(data.url);```
2111	germanscooterforum.de.js	Potential SSRF in CSRF token fetch due to unsanitized path parameter	Medium	true	N/A	N/A	fetch	standard	{The `fetch()` function is used with a dynamically constructed URL where the `path` parameter is directly interpolated from the request URL without sanitization, enabling an attacker to inject arbitrary paths and potentially trigger SSRF by accessing internal resources.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2112	germanscooterforum.de.js	Lack of URL validation in notification data leading to potential phishing or XSS	High	true	N/A	N/A	clients.openWindow	standard	{The `clients.openWindow()` method is called with `data.url` from notification data without validation, allowing an attacker to redirect users to malicious sites, leading to phishing or XSS attacks if the URL contains malicious content.}	```self.clients.openWindow(data.url ? data.url : BASE_URL);```
2113	solvisportal.de.js	Use of Weak Cryptographic Hash Function (SHA)	High	true	N/A	N/A	function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8	standard	"{The SHA-1 hash function is considered cryptographically weak and vulnerable to collision attacks. Its use in security-sensitive contexts (e.g., integrity verification) can allow attackers to forge data or bypass validation. Although not directly a ""sensitive function misuse"" in the sense of dynamic input injection, its use in a service worker context for integrity checks introduces a cryptographic vulnerability that can be exploited if an attacker can control or manipulate the input being hashed.}"	```function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8); }```
2114	solvisportal.de.js	Improper Validation of Cache Responses	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability arises from insufficient validation of cached responses, particularly when handling responses with non-standard headers or status codes. The code does not validate the integrity or origin of cached responses before serving them, which could allow an attacker to manipulate cached content if they can inject malicious responses into the cache. However, this is not caused by misuse of a sensitive function but rather by a design flaw in cache handling logic.}	```async write(key, value) { return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value))); }```
2115	solvisportal.de.js	Information Exposure Through Debug Endpoint	Medium	false	N/A	N/A	N/A	N/A	{The debug endpoint exposes internal service worker state, including version information, idle task queues, and debug logs. While this is a security issue, it is not caused by misuse of a sensitive JavaScript function but rather by the intentional exposure of debug information via a specific endpoint. The vulnerability stems from poor configuration or lack of access control, not from improper use of a function.}	"```async handleFetch(req) { const [state, versions, idle] = await Promise.all([this.driver.debugState(), this.driver.debugVersions(), this.driver.debugIdleState()]); const msgState = `NGSW Debug Info: ...`; return this.adapter.newResponse(`${msgState} ...`, { headers: this.adapter.newHeaders({ ""Content-Type"": ""text/plain"" }) }); }```"
2116	solvisportal.de.js	Insufficient Input Validation in Cache Key Handling	Medium	false	N/A	N/A	N/A	N/A	{The code constructs cache keys by concatenating a fixed path prefix with user-supplied or unvalidated input (key). While this could lead to cache key collisions or unintended cache behavior, it does not involve a sensitive function like importScripts() or eval(). The vulnerability is more related to improper input sanitization than misuse of a sensitive function.}	```request(key) { return this.adapter.newRequest('/' + key); }```
2117	solvisportal.de.js	Insecure Handling of Redirects in Network Fetch	Medium	false	N/A	N/A	N/A	N/A	{The code follows redirects during network fetches without validating the final destination or enforcing security policies. While this could lead to redirect loops or unintended resource fetching, it is not caused by misuse of a sensitive function. The issue lies in the logic of redirect handling, not in the use of a dangerous API.}	"```async fetchFromNetwork(req, redirectLimit = 3) { const res = await this.cacheBustedFetchFromNetwork(req); if (res[""redirected""] && !!res.url) { if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`); } return this.fetchFromNetwork(this.newRequestWithMetadata(res.url, req), redirectLimit - 1); } return res; }```"
2118	solvisportal.de.js	Improper Error Handling Leading to Denial of Service	Low	false	N/A	N/A	N/A	N/A	{The code catches fetch errors and returns a 504 Gateway Timeout response, which may mask underlying issues but does not directly lead to a denial of service. This is a design flaw in error handling, not misuse of a sensitive function. The vulnerability is low severity and does not involve dangerous APIs.}	"```async safeFetch(req) { try { return await this.scope.fetch(req); } catch (e) { return this.adapter.newResponse(null, { status: 504, statusText: ""Gateway Timeout"" }); } }```"
2119	openconversational.ai.js	Open Redirect Vulnerability	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a new browser window or tab with a URL constructed from user-controlled data (n + e). Since 'e' is derived from the notification data (which can be manipulated via push messages), an attacker can craft a push notification with a malicious URL, causing the browser to open an unintended external site, leading to open redirect. This is a direct misuse of a standard browser API with untrusted input.}	```clients.openWindow(n + e);```
2120	openconversational.ai.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch() function is used to make a request to a URL constructed from user-controlled data (n + '/chat/' + e + '.json'). Since 'n' and 'e' are derived from notification data (which can be manipulated via push messages), an attacker can craft a push notification to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF. This is a direct misuse of a standard browser API with untrusted input.}	```fetch(`${n}/chat/${e}.json`, { credentials: 'include', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-CSRF-Token': i }, body: `message=${t.reply}`, method: 'POST', mode: 'cors' });```
2121	consumersafety.org.js	Insecure Caching of Untrusted Content	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the design choice to cache content from a potentially untrusted source (OFFLINE_URL) without proper validation or sanitization. The caching mechanism itself is not inherently unsafe, but the lack of input validation on the URL being cached introduces risk.}	```return caches.open(CURRENT_CACHES.offline).then(function (cache) { return cache.put(OFFLINE_URL, response); });```
2122	fyyd.de.js	Insecure Direct Object Reference (Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic URL derived from event.notification.data.url, which is user-controlled via push notifications. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect where users are redirected to arbitrary sites, potentially phishing or malware distribution.}	N/A
2123	fyyd.de.js	Improper Input Validation (Denial of Service	Medium	false	New	0	let pushData = event.data.json();	N/A	{The code attempts to parse event.data.json() without validating or handling potential errors, which could lead to a denial of service if the data is malformed or excessively large. However, this is not caused by misuse of a sensitive function, but rather by improper error handling.}	N/A
2124	afkmods.com.js	Improper Validation of Logged-In Status Leading to CSRF Vulnerability	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the logged-in status via URL parameter parsing, not from misuse of a sensitive JavaScript function. The code extracts `loggedIn` from the URL using a regex, but this is not a sensitive function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in'); return; }```
2125	afkmods.com.js	CSRF Token Fetching with Insecure Path Handling	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL where the `path` parameter is derived from the request's URL. If an attacker can manipulate the request path, they can cause the service worker to fetch a CSRF token for an unintended endpoint, enabling CSRF attacks. This is a misuse of `fetch` with unsanitized input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`);```
2126	afkmods.com.js	Insecure Notification URL Handling	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is called with a URL derived from the notification's `data.url` field, which is obtained from a remote push notification. If an attacker can control the push notification payload, they can redirect users to arbitrary URLs, leading to phishing or malicious redirection. This is a misuse of `navigate` with untrusted input.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2127	surveys2cash.com.js	Insecure Dynamic Code Loading	High	true	N/A	9	importScripts	standard	{The importScripts function is used to dynamically load and execute scripts from a remote URL. The URL is constructed using self.location.hostname, which is a dynamic value derived from the current context. Although encodeURI is used, the base URL is hardcoded and not user-controlled, so the risk is lower than if the URL were derived from untrusted input. However, since the script is loaded from an external domain (trk-keingent.com), it introduces a potential supply chain risk if that domain is compromised or malicious. The vulnerability is classified as high because the service worker is executing arbitrary code from an external source, which can lead to full compromise of the service worker’s capabilities, including intercepting network requests, manipulating cache, or injecting malicious behavior.}	"```if (typeof window === ""undefined"") { importScripts('https://trk-keingent.com/scripts/ext/script/[YOUR-PARTNER-ID]?url=' + encodeURI(self.location.hostname)); }```"
2128	cartoonnetworkindia.com.js	Exposure of Sensitive Information (API Key)	High	true	CWE-532	10	ytcfg.set	standard	{The vulnerability arises from the direct exposure of the INNERTUBE_API_KEY in the script, which is set via the ytcfg.set function. Although ytcfg.set is not inherently a sensitive function, its misuse here involves hardcoding and exposing a sensitive credential (API key) in client-side JavaScript, which can be easily extracted by attackers. This is not a case of dynamic input misuse, but rather improper handling of sensitive data in a public-facing script. Since the function is used to set configuration data and not to process untrusted input, it is not classified as a sensitive function misuse in the context of dynamic input risks. However, the exposure is still severe and stems from the lack of proper security practices in storing secrets in client-side code.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', 'INNERTUBE_API_VERSION': 'v1', 'INNERTUBE_CLIENT_NAME': 'WEB', 'INNERTUBE_CLIENT_VERSION': '2.20241107.11.00' });```
2129	ijmuidercourant.nl.js	Hardcoded Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive information (appKey, token, vapidPublicKey) rather than misuse of a sensitive function. These values are static and not dynamically derived from untrusted input, so no sensitive function is being misused.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js'); uaSetup.worker(self, { defaultIcon: 'https://shared.mediahuis.be/logos/hmc\u002Dyc/latest/brand\u002Dsquare\u002Dmain/256x256.png', defaultTitle: 'Ijmuider Courant', defaultActionURL: 'https://www.ijmuidercourant.nl/', appKey: 'PeWzOFIbSAqVaRu11pilGg', token: 'MTpQZVd6T0ZJYlNBcVZhUnUxMXBpbEdnOnZMNTJyZC1jM2RpamdjREZqcFBiby12b2NTZmQ0YTh4dHhHSm5mbTZwXzg', vapidPublicKey: 'BMNwrLRonHkGhuootpHrfhC_aohUe51n-jJGZBRUoRqV22efvDX6HKzESkvQadwV5PN1K4gUyOGaw3PYXfi0_nM=' });```
2130	solitaire-web-app.com.js	Caching of External Resources Without Integrity Checks	High	true	N/A	N/A	fetch	standard	{The code uses the `fetch` function to download and cache external resources from CDN_HOSTNAME (ajax.googleapis.com) without verifying their integrity. Since the URLs are hardcoded and not dynamically constructed from untrusted input, the `fetch` function itself is not misused in a way that introduces dynamic injection risks. However, the vulnerability arises from the lack of integrity checks (e.g., no hash verification or Subresource Integrity) on the fetched resources, which could allow an attacker to compromise the CDN or intercept traffic to serve malicious versions of jQuery or jQuery Mobile. This is a high-severity issue because it enables supply chain attacks, but it is not caused by misuse of a sensitive function with dynamic input.}	```const cdnUrls = ['https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.0/jquery.mobile.min.css', 'https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js', 'https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.0/jquery.mobile.min.js'].map(url => [url, url]);```
2131	modelescortsindelhi.com.js	Cache Poisoning via Unvalidated Network Requests	High	true	N/A	9	caches.match	N/A	{The caches.match function is used to retrieve cached responses, but when combined with fetch(event.request) without validation, it allows potentially malicious or untrusted requests to be cached and served. This can lead to cache poisoning if an attacker can manipulate the request to inject malicious content into the cache.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); })); });```
2132	modelescortsindelhi.com.js	Caching of Sensitive Data in URLs	Medium	true	N/A	9	caches.add	N/A	{The caches.add function is used to cache 'index.html' without validating or sanitizing the URL. If the URL were dynamically constructed from untrusted input, it could lead to caching sensitive or unintended resources, potentially exposing sensitive data through cache access.}	```self.addEventListener('install', function (event) { event.waitUntil(caches.open('sw-cache').then(function (cache) { return cache.add('index.html'); })); });```
2133	modelescortsindelhi.com.js	Lack of Cache Expiration Policy	Low	false	N/A	N/A	N/A	N/A	{This issue is not caused by misuse of a sensitive function, but rather by the absence of a cache expiration strategy. The code does not use any function that inherently introduces security risk when misused.}	```self.addEventListener('install', function (event) { event.waitUntil(caches.open('sw-cache').then(function (cache) { return cache.add('index.html'); })); });```
2134	itwcreativeworks.com.js	Arbitrary Code Execution via Message Command	High	true	CWE-96	10	function	standard	{The `importScripts()` function is not directly involved here; instead, the vulnerability arises from the direct execution of user-supplied functions via `data.args.function()`. This is a classic case of arbitrary code execution where untrusted input (the function passed in `data.args.function`) is executed without any validation or sanitization. The `function` command in the message handler allows an attacker to inject and run arbitrary JavaScript code within the service worker context, leading to full compromise.}	```if (data.command === 'function') { data.args.function = data.args.function || function () {}; data.args.function(); }```
2135	itwcreativeworks.com.js	Cache Poisoning via Untrusted Input	Medium	true	CWE-919	8	caches.open	standard	{The `caches.open()` function is used with `SWManager.cache.name`, which is derived from `SWManager.config.cb` and `SWManager.app`. Since `SWManager.config` is parsed from `location.searchParams.get('config')`, this value is user-controllable. An attacker can manipulate the `config` parameter to set `cb` to a malicious value, leading to cache poisoning where the service worker caches unintended or malicious resources under a crafted cache name, potentially bypassing cache validation or interfering with legitimate caching.}	```caches.open(SWManager.cache.name).then(function (cache) { return cache.addAll(pagesToCache).then(function () { log('master-service-worker.js cached resources.'); event.ports[0].postMessage(response); }).catch(function () { response.status = 'fail'; event.ports[0].postMessage(response); log('master-service-worker.js failed to cache resources.'); }); });```
2136	itwcreativeworks.com.js	Improper Neutralization of Special Elements in Config	Medium	true	CWE-94	9	JSON.parse	standard	{The `JSON.parse()` function is used on the result of `new URL(self.location).searchParams.get('config')`, which is directly sourced from the URL query string. This input is untrusted and can be manipulated by an attacker. If the `config` parameter contains malformed or malicious JSON (e.g., with XSS payloads or code injection vectors), it may lead to unintended behavior or execution, especially if the parsed object is later used in dynamic contexts (e.g., in `firebase.initializeApp(SWManager.config.firebase)`). This constitutes improper neutralization of special elements in untrusted input.}	```SWManager.config = JSON.parse(new URL(self.location).searchParams.get('config'));```
2137	hot-matures.net.js	Untrusted External Script Inclusion	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL like 'https://sw.wpush.org/ps/sw.js', it is not inherently vulnerable. However, if the URL were derived from untrusted input (e.g., user-controlled parameters), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not dynamically constructed from user input, so the vulnerability is not due to sensitive function misuse. Therefore, the initial detection may be a false positive.}	```self.importScripts('https://sw.wpush.org/ps/sw.js');```
2138	montessori-material.de.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts from a remote host, leading to remote code execution within the service worker context.}	```importScripts(`https://montessori-material.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
2139	mahatmapost.com.js	XSS via untrusted notification payload	High	true	CWE-79	9	N/A	standard	{The `showNotification` method is used with untrusted data from `payload.title` and other payload fields, which are derived from `event.data.json().data.notification`. Since this data is parsed directly from a potentially untrusted source (e.g., a push message from a server), it can contain malicious content such as script tags or HTML that may be rendered in the notification UI, leading to XSS if the browser renders notifications with HTML content.}	```const payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
2140	mahatmapost.com.js	Open redirect via notification click	Medium	true	CWE-601	9	N/A	standard	{The `clients.openWindow(targetUrl)` function is called with `targetUrl` derived from untrusted notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect vulnerabilities.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl);```
2141	mahatmapost.com.js	Insecure storage of sensitive data	Low	false	CWE-311	0	N/A	N/A	{The vulnerability is due to storing sensitive data (e.g., notification tokens) in IndexedDB without encryption, but it is not caused by misuse of a sensitive function. The `put` operation on the object store is standard and safe; the issue lies in the lack of encryption, not function misuse.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value });```
2142	mahatmapost.com.js	Improper input validation	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from not validating the `requireInteraction` field before using it, but this is not due to misuse of a sensitive function. The logic is simple assignment and does not involve any dangerous or sensitive API calls.}	```const payload = JSON.parse(event.data.json().data.notification); if (payload.requireInteraction == null) { payload.requireInteraction = false; }```
2143	1stclassdating.com.js	Server Side Request Forgery (SSRF	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used within `respondWithMirrorDiscoveryPage` to make HTTP requests based on the incoming request's URL, which is derived from the client's request. Since the URL is not validated or sanitized, an attacker could manipulate the request to target internal or external services, leading to SSRF. The use of `AbortSignal.timeout` does not mitigate the risk of SSRF, as the request is still initiated with untrusted input.}	```javascript async respondWithMirrorDiscoveryPage(e) { try { let t = Lt(this.healthcheckTimeout), n = await fetch(e.request, { signal: t }); return n.ok ? n : this.respondWithCachedLoaderPage(); } catch { return this.respondWithCachedLoaderPage(); } } ```
2144	1stclassdating.com.js	Insecure IndexedDB Storage	Low	false	N/A	N/A	N/A	N/A	{The `setItem` method stores data in IndexedDB without any validation or sanitization, but this is not a misuse of a sensitive function. The vulnerability arises from the lack of security controls around data storage, not from improper use of a sensitive JavaScript API.}	```javascript async setItem(e, t) { return await this.initializationPromise, new Promise((n, i) => { let o = this.getStore('readwrite').put({ id: e, value: t }); o.onsuccess = () => n(), o.onerror = c => i(c.target.error); }); } ```
2145	cashflipz.com.js	Improper Request Validation in Service Worker	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability described is related to improper request validation, but it does not stem from the misuse of a sensitive JavaScript function such as importScripts, eval, or similar. Instead, it arises from the service worker’s behavior of attempting to fetch any requested resource without validating or sanitizing the request. The fetch() function is used correctly here — it is not being misused with untrusted input to execute arbitrary code or load external scripts. The issue is more about lack of request filtering rather than sensitive function misuse.}	"```self.addEventListener('fetch', event => { event.respondWith(fetch(event.request).catch(async error => { console.log(""Fetch failed; returning offline page instead."", error); return caches.open(CACHE_NAME).then(cache => { return cache.match(offlinePage); }); }));});```"
2146	hanselminutes.com.js	Improper Validation of Request Origin Leading to Unintended Caching	High	true	CWE-20	9	caches.open	standard	{The service worker uses caches.open() to open a cache named 'hanselminutes' and then caches responses without validating the origin of the request. This allows any request, regardless of origin, to be cached, potentially leading to unintended caching of sensitive or malicious content. The function caches.open() is standard and is misused here because it is used without origin validation, enabling caching of cross-origin requests that should be blocked.}	```self.addEventListener('fetch', function (event) { event.respondWith(checkResponse(event.request).catch(function () { return returnFromCache(event.request); })); event.waitUntil(addToCache(event.request)); });```
2147	betsson.es.js	Open Redirect via Unvalidated URL in Notification Action	High	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow(url) is a standard browser API that opens a new window or tab with the specified URL. When the URL is derived directly from event.action without validation or sanitization, it allows an attacker to craft a notification action that redirects users to arbitrary, potentially malicious websites, leading to open redirect vulnerabilities.}	```url = event.action;```
2148	betsson.es.js	Unsanitized User Input in Push Notification Body	Medium	true	CWE-79	8	registration.showNotification	standard	{The function registration.showNotification(title, options) is a standard browser API used to display notifications. When the 'body' field of the options object is populated with unsanitized user input (e.g., from event.data.text()), it may allow for cross-site scripting (XSS) or other injection attacks if the notification content is rendered in a context where user input is not properly escaped or sanitized.}	"```options[""body""] = resto;```"
2149	donoghte.com.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external, untrusted source (e.g., 'https://van.najva.com/...'), it introduces a high-risk vulnerability because the script can be modified by an attacker, leading to arbitrary code execution within the service worker context. This allows attackers to intercept network requests, manipulate cache, or perform other malicious actions.}	```importScripts('https://van.najva.com/static/js/scripts/new-website87785-website-42731-c5552fff-af69-45f4-a47f-c24ab6a14276-service-worker.js');```
2150	euston96.com.js	External Code Execution via Untrusted CDN	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external CDN (e.g., cdn.pushmaster-cdn.xyz), it introduces a risk if the CDN is not fully trusted or if the script can be tampered with. Although the URL is hardcoded, the vulnerability arises because the script is loaded from an external, potentially untrusted source, which could be compromised or controlled by an attacker. This allows for remote code execution within the service worker context, enabling malicious behavior such as data exfiltration, request interception, or cache manipulation.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/620cd9cfc0cc9f0009810221/service-worker.js"");```"
2151	pinpics.com.js	Improper Authentication Check Leading to CSRF Vulnerability	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper authentication checks based on URL parameters, not from misuse of a sensitive JavaScript function. The code parses `loggedIn` from the URL and uses it to skip CSRF token injection, but this is a logic flaw, not a function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2152	pinpics.com.js	Open Redirect in Notification Handling	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with `data.url`, which is derived from server responses and not sanitized. An attacker could craft a malicious notification payload to redirect users to arbitrary URLs, leading to open redirect.}	```clients[0].navigate(data.url);```
2153	jabka.skin.js	Information Exposure Through Debug Endpoint	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from the debug endpoint exposing internal service worker state, version details, idle task queue, and debug logs. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() or eval(), but rather by design choices in the debug handler that expose sensitive information via a public endpoint. The code does not involve dynamic or untrusted input being passed to a sensitive function.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`, {\n headers: this.adapter.newHeaders({\n \'Content-Type\': \'text/plain\'\n })\n });```
2154	lessonup.app.js	Cache Poisoning via Hash Manipulation	High	true	CWE-434	9	N/A	standard	{The vulnerability arises from the use of `caches.match()` and `caches.put()` with URLs that are dynamically derived from `event.request.url`, which is user-controlled. The `hasHash()` and `hasSameHash()` functions are used to compare hash parameters, but if an attacker can manipulate the hash in the URL, they can force the service worker to serve cached content that should not be served, leading to cache poisoning. The `caches.match()` function is a standard API that, when used with untrusted input, can be exploited to serve stale or malicious content.}	```event.respondWith(caches.match(event.request.clone()).then(cached => { if (cached) { const resourceType = cached.headers.get('content-type'); if (!hasHash(event.request.url) && !/text\/html/.test(resourceType)) { return cached; } if (hasHash(event.request.url) && hasSameHash(event.request.url, cached.url)) { return cached; } } return fetch(requestToFetch).then(response => { const clonedResponse = response.clone(); const contentType = clonedResponse.headers.get('content-type'); if (!clonedResponse || clonedResponse.status !== 200 || clonedResponse.type !== 'basic' || /\/sockjs\//.test(event.request.url) || /chrome-extension/.test(event.request.url) || event.request.method === 'POST') { return response; } if (/html/.test(contentType)) { caches.open(version).then(cache => cache.put(HTMLToCache, clonedResponse)); } else { if (hasHash(event.request.url)) { caches.open(version).then(cache => cache.keys().then(keys => keys.forEach(asset => { if (new RegExp(removeHash(event.request.url)).test(removeHash(asset.url))) { cache.delete(asset); } }))); } caches.open(version).then(cache => cache.put(event.request, clonedResponse)); } return response; }).catch(() => { if (hasHash(event.request.url)) return caches.match(event.request.url); else if (!/\/sockjs\//.test(event.request.url)) return caches.match(HTMLToCache); return new Response('No connection to the server', { status: 503, statusText: 'No connection to the server', headers: new Headers({ 'Content-Type': 'text/plain' }) }); }); }));```
2155	lessonup.app.js	Insufficient Cache Validation	Medium	true	CWE-20	8	N/A	standard	{The `caches.put()` function is used to store responses in the cache without validating the integrity or origin of the response. The `event.request` is directly used as the key for caching, and since `event.request` is derived from the fetch event, it is user-controlled. This allows an attacker to cache arbitrary responses under manipulated URLs, leading to cache poisoning or serving incorrect content. The `caches.put()` function is a standard API that, when used with untrusted input, can be misused to store malicious or unintended content.}	```if (/html/.test(contentType)) { caches.open(version).then(cache => cache.put(HTMLToCache, clonedResponse)); } else { if (hasHash(event.request.url)) { caches.open(version).then(cache => cache.keys().then(keys => keys.forEach(asset => { if (new RegExp(removeHash(event.request.url)).test(removeHash(asset.url))) { cache.delete(asset); } }))); } caches.open(version).then(cache => cache.put(event.request, clonedResponse)); }```
2156	lessonup.app.js	Improper URL Handling in Cache Management	Medium	true	CWE-208	7	N/A	standard	{The `removeHash()` function is used to strip hash parameters from URLs, but it does so using `split('?hash=')[0]`, which is a simple string operation and does not validate or sanitize the input. This can lead to improper URL handling, especially if the URL contains multiple query parameters or malformed strings. The `caches.put()` and `caches.match()` functions rely on these manipulated URLs, which can result in incorrect cache keys or unintended cache behavior. The `split()` method is a standard JavaScript function, but its misuse here with untrusted input leads to improper URL handling.}	```function removeHash(element) { if (typeof element === 'string') return element.split('?hash=')[0]; }```
2157	newsvirginian.com.js	Open Redirect via Untrusted URL Construction	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed from untrusted input (oData.url). Since oData is derived from a Firebase message payload, which can be controlled by an attacker, this allows for open redirect attacks where the victim is redirected to arbitrary URLs. The URL is constructed using new URL(oData.url) and then modified with UTM parameters, which are also derived from untrusted data, further increasing the risk.}	```let oURL = new URL(oData.url); if (oData.utm_source && oData.utm_medium && oData.utm_campaign) { oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign); } ... if (self.clients.openWindow) { return self.clients.openWindow(oURL.toString()); }```
2158	vginsights.com.js	Vulnerable Cache Busting Implementation	High	true	N/A	0	importScripts	custom	{The code uses a custom cacheBust method that appends a random value to the URL, but it does not validate or sanitize the input URL. This could allow an attacker to manipulate the URL to load unintended resources, potentially leading to cache poisoning or script injection if the cache busting mechanism is misused in conjunction with dynamic script loading. However, no direct use of importScripts() is found in the code, so this assessment is based on potential misuse of dynamic URL construction in a service worker context.}	N/A
2159	vginsights.com.js	Insecure Opaque Response Caching	Medium	false	N/A	N/A	N/A	N/A	{The code caches opaque responses conditionally, but this is not a misuse of a sensitive function. It is a design choice that may lead to information exposure or caching of untrusted content, but it does not involve a sensitive function like eval or importScripts.}	N/A
2160	vginsights.com.js	Insufficient Cache Invalidation	Medium	false	N/A	N/A	N/A	N/A	{The code removes URLs from an LRU list but does not always ensure corresponding cache entries are deleted. This is a logic flaw, not a misuse of a sensitive function.}	N/A
2161	vginsights.com.js	Error Information Exposure	Medium	false	N/A	N/A	N/A	N/A	{The code logs error details to a debug handler, which may expose sensitive information. This is a logging issue, not a misuse of a sensitive function.}	N/A
2162	vginsights.com.js	Insecure Redirect Handling	Medium	false	N/A	N/A	N/A	N/A	{The code follows redirects up to a limit, but this is a control flow issue, not a misuse of a sensitive function.}	N/A
2163	highstakesdb.com.js	Cache Poisoning via Malformed Request in Cache.addAll	Medium	true	New	8	N/A	standard	{The `Cache.addAll()` method is used with a `Request` object that includes a `cache: 'reload'` directive. While this is not inherently malicious, it can lead to cache poisoning if the request URL or headers are derived from untrusted input. In this case, the URL is hardcoded (`OFFLINE_URL`), so the risk is low, but the use of `cache: 'reload'` with `Cache.addAll()` is considered a potential vector for cache manipulation if the URL were dynamic. The vulnerability arises because `Cache.addAll()` does not validate or sanitize the request objects it receives, and if an attacker could influence the request object (e.g., via a crafted URL or header), they could inject malicious content into the cache.}	```const cache = await caches.open(CACHE_NAME); await cache.addAll([new Request(OFFLINE_URL, { cache: 'reload' }), '/build/images/menu-top/HighStakesDB.svg']);```
2164	filmtools.com.js	Improper Input Validation (Regex Logic Error)	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a flawed regular expression pattern `/.*admin.*(/.*)?` which is incorrectly used with `match()`. The pattern is syntactically invalid due to improper escaping and does not correctly match URLs containing 'admin'. However, this is not caused by misuse of a sensitive function like `importScripts()` or `eval()`, but rather by a logic error in regex construction. Therefore, it is not a sensitive function misuse.}	```if (event.request.url.match('/.*admin.*(/.*)?') !== -1 || event.request.url.startsWith('/dpa')) {```
2165	travel-dealz.com.js	Remote Code Execution (RCE) via Module Loading	High	true	CWE-99	10	importScripts	standard	{The `importScripts()` function is used to dynamically load and execute JavaScript modules from URLs constructed via the `St()` method, which derives the URL from configuration settings (e.g., `modulePathPrefix`). Since `modulePathPrefix` is set to a user-controlled or potentially untrusted value (`https:\/\/travel-dealz.com\/app\/plugins\/pwa\/wp-includes\/js\/workbox-v7.3.0\/`), an attacker could manipulate this prefix to load malicious scripts, leading to remote code execution. The function `importScripts()` is inherently dangerous when used with dynamic, untrusted URLs.}	```const e = this.St(t); try { importScripts(e), this.jt = !0; } catch (s) { throw console.error(`Unable to import module '${t}' from '${e}'.`), s; }```
2166	travel-dealz.com.js	XSS in Notification Data Handling	High	true	CWE-79	9	registration.showNotification	standard	{The `showNotification()` method is called with `data.body` directly from the push event data, which is untrusted. Since the notification content is rendered in the user's browser without sanitization, an attacker can inject malicious scripts into the `body` field, leading to cross-site scripting (XSS) when the notification is displayed.}	"```const title = data.title || ""Travel-Dealz""; let options = { body: data.body, icon: '/app/themes/tatami-travel-dealz/images/Icon.png', badge: '/app/themes/tatami-travel-dealz/images/Icon.png', data: {} }; self.registration.showNotification(title, options);```"
2167	travel-dealz.com.js	Open Redirect in Notification Click	Medium	true	CWE-601	8	clients.openWindow	standard	{The `clients.openWindow()` function is used to open a URL provided in `event.notification.data.url`, which originates from the push notification data. Since this URL is not validated or sanitized, an attacker can supply a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or malicious domains.}	```if (event.notification.data.url) { clients.openWindow(event.notification.data.url); }```
2168	travel-dealz.com.js	XSS in Error Template Injection	High	true	CWE-79	9	`<iframe>` injection via `btoa()` and `replace()`	standard	{The code constructs an iframe with `srcdoc` and `src` attributes using `btoa()` and `replace()` on untrusted `responseBody` data from a failed fetch. Although some basic escaping is applied, the use of `srcdoc` with unsanitized content can still lead to XSS if the content contains script tags or other malicious payloads, especially since the `srcdoc` attribute is directly embedded in the HTML.}	"```body = body.replace(/({{{WP_SERVICE_WORKER_ERROR_TEMPLATE_BEGIN}}})((?:.|\n)+?)({{{WP_SERVICE_WORKER_ERROR_TEMPLATE_END}}})/, details => { if (!responseBody) { return ''; } const src = 'data:text/html;base64,' + btoa(responseBody); const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); const iframe = `<iframe style=""width:100%"" src=""${src}"" data-srcdoc=""${srcdoc}""></iframe>`; details = details.replace('{{{error_details_iframe}}}', iframe); details = details.replace('{{{iframe_src}}}', src); details = details.replace('{{{iframe_srcdoc}}}', srcdoc); details = details.replace('{{{WP_SERVICE_WORKER_ERROR_TEMPLATE_BEGIN}}}', ''); details = details.replace('{{{WP_SERVICE_WORKER_ERROR_TEMPLATE_END}}}', ''); return details; });```"
2169	pogodairadar.com.js	Insecure Dynamic Code Execution	High	true	N/A	9	importScripts	standard	{The importScripts function is used to load and execute external scripts within the service worker. Although the paths './ngsw-worker.js' and './batchsdk-shared-worker.js' are hardcoded, the vulnerability arises because the decision to load the second script is conditionally controlled by the 'consent' parameter, which is derived from the URL's search parameters via getConsent(). While the script paths themselves are not dynamically constructed from user input, the conditional execution based on user-controlled input introduces a risk: if an attacker can manipulate the 'consent' parameter to include 'batch', they can trigger the loading of an additional script. However, since the script path is still hardcoded and not dynamically constructed from user input, this does not constitute direct dynamic code execution via user-controlled paths. Therefore, the vulnerability is not strictly due to sensitive function misuse with dynamic input, but rather due to conditional execution based on untrusted input.}	```const consent = getConsent(); importScripts('./ngsw-worker.js'); if (consent.includes('batch')) { try { importScripts('./batchsdk-shared-worker.js'); } catch (e) { console.error('Failed to load Batch Shared Worker', e); } } function getConsent() { const url = new URL(self.location.href); return (url.searchParams.get('consent') || '').split(',').map(s => s.trim()); }```
2170	seatcupra.net.js	Improper URL Validation Leading to Cache Poisoning	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from the use of a regular expression in `request.url.match()` to filter URLs, but the pattern is overly permissive and does not properly validate or sanitize the URL. This allows an attacker to craft a URL that bypasses the intended restrictions, potentially leading to cache poisoning where malicious resources are cached under the service worker's control. The `match()` function is standard and used here with dynamic input (request.url), which is not sufficiently sanitized, enabling exploitation.}	```if (request.url.match(/\/admin\.php|\/install\/|\/download($|&|\?)|[\/?]attachments\/|google-ad|adsense/)) {```
2171	seatcupra.net.js	Excessive Cache Recreation via Message Handling	Medium	false	N/A	0	N/A	N/A	{This issue stems from the message handler `updateCache` being triggered by client messages, which can be sent repeatedly. However, it does not involve misuse of a sensitive JavaScript function such as `importScripts`, `eval`, or `fetch` with untrusted input. The function `createCache()` is called, but it does not use dynamic or untrusted input to construct URLs or execute arbitrary code. Therefore, it is not a sensitive function misuse.}	```messageHandlers.updateCache = function (clientId, payload) { createCache(); }```
2172	agnitas.de.js	Improper Input Validation in Notification Options	Medium	true	CWE-20	9	N/A	standard	{The function self.registration.showNotification is used with user-controlled data from msg.data.title, which is derived from the push notification payload. If this input is not sanitized, it can lead to injection of malicious content into the notification, potentially enabling cross-site scripting (XSS) or phishing attacks if the notification is rendered in a context where user input is interpreted.}	```self.registration.showNotification(msg.data.title, msg);```
2173	agnitas.de.js	Unvalidated URL Redirection in Notification Click	High	true	CWE-601	10	N/A	standard	{The function e.target.clients.openWindow is used with user-controlled data from data.link, which is derived from the notification payload. Since the URL is not validated or sanitized, an attacker could supply a malicious URL, leading to open redirect vulnerabilities, phishing, or unintended navigation to harmful sites.}	```e.target.clients.openWindow(data.link);```
2174	eurocash.pl.js	Cache Poisoning via Redirect Handling	High	true	N/A	N/A	scope.fetch	standard	{The scope.fetch function is used without validating or sanitizing the request URL, which can lead to cache poisoning if an attacker can manipulate the request to redirect to a malicious resource. The function blindly fetches the resource specified in the request, potentially allowing an attacker to inject or redirect to a malicious URL if the request is not properly validated.}	```const res = yield this.scope.fetch(req);```
2175	eurocash.pl.js	Insecure Debug Endpoint	Medium	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse function is used to generate a debug response that exposes internal service worker state, including version information, idle task queues, and debug logs. This function is misused by returning sensitive internal data to any client that requests it, which can be exploited to gain insights into the service worker's operation and potentially aid in further attacks.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}````
2176	eurocash.pl.js	Insufficient Input Validation	Medium	true	N/A	N/A	new RegExp	standard	{The new RegExp function is used to create regular expressions from user-provided regex strings without validating or sanitizing the input. This can lead to ReDoS (Regular Expression Denial of Service) attacks or unintended pattern matching if the input contains malicious or malformed regex patterns.}	```new RegExp(spec.regex)```
2177	eurocash.pl.js	Stale Content Delivery	Medium	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse function is used to return a response with a 504 Gateway Timeout status when a fetch fails, which may result in stale content being delivered to the client if the service worker does not properly handle or retry failed requests. This misuse can lead to users receiving outdated or incorrect data.}	```return this.adapter.newResponse(null```
2178	eurocash.pl.js	Weak Hashing Algorithm	Low	false	N/A	N/A	N/A	N/A	{The sha1 function is used for hashing, but it is not a sensitive function misuse in this context as it is used for internal manifest hashing and not for security-critical operations like authentication or data integrity. The vulnerability is due to the inherent weakness of SHA-1, not misuse of a sensitive function.}	```return sha1(JSON.stringify(manifest));```
2179	animall.in.js	Caching of potentially malicious or outdated resources with long expiration	Medium	false	N/A	N/A	N/A	N/A	{The workbox.strategies.CacheFirst strategy is used with a long maxAgeSeconds, but this is not a sensitive function misuse. The vulnerability arises from the configuration of the caching strategy, not from improper use of a sensitive function.}	```'workbox.routing.registerRoute(new RegExp('/(js|_j)/'), new workbox.strategies.CacheFirst({ cacheName: 'js', plugins: [new workbox.expiration.Plugin({ maxAgeSeconds: 30 * 24 * 60 * 60, maxEntries: 20 })]})'```
2180	animall.in.js	Improper Cache Entry Deletion	High	false	N/A	N/A	N/A	N/A	{The conditional check for pathname includes '/next/' is not a sensitive function misuse. The vulnerability arises from the logic flaw in cache entry deletion, not from improper use of a sensitive function.}	```if (o.pathname.includes('/next/')) return e.abrupt('return')```
2181	web2sex.com.js	Improper Domain Validation in Service Worker	High	true	CWE-79	N/A	N/A	standard	"{The RegExp constructor is used with dynamically generated domain patterns from `o.domains`, which are derived from a hardcoded list. While the domains themselves are static, the use of `join(""|"")` and `replace(""."", ""\\."")` to construct the regex pattern introduces risk if the domains were user-controlled or improperly sanitized. However, since the domains are hardcoded and not derived from untrusted input, the risk is mitigated. But if an attacker could inject a domain via a different vector (e.g., via a configuration override), this could lead to regex injection or bypass. The vulnerability is primarily due to improper validation logic rather than direct sensitive function misuse.}"	```const n = e => new RegExp('/(' + o.domains.join('|').replace('.', '\\.') + ')/i').test(e.request.url);```
2182	web2sex.com.js	Insecure Cache Bypass via URL Path	High	false	N/A	N/A	N/A	N/A	{This vulnerability arises from a logic flaw in the fetch event handler, where requests to `/admin` or `/user` paths are explicitly excluded from cache matching. This is not due to misuse of a sensitive function, but rather a design decision that allows bypassing the cache for specific paths. No sensitive function is involved in this logic.}	```if (!1 === n(e) || e.request.url.indexOf('/admin') >= 0 || e.request.url.indexOf('/user') >= 0)```
2183	web2sex.com.js	Unsanitized Push Notification Data	Medium	true	CWE-79	N/A	N/A	standard	{The `showNotification` method is used with data directly extracted from `e.data.text()`, which is untrusted input from a push message. Since the notification content is not sanitized or escaped, an attacker could inject malicious content (e.g., JavaScript if rendered in a context that allows it, or phishing text). Although `showNotification` does not execute code directly, it can be used to trick users into clicking malicious links or performing unintended actions, making it a sensitive function in the context of user interaction.}	```const n = { data: e.data.text() }, t = self.registration.showNotification('web2sex.com ❤', n);```
2184	cbb.dk.js	Broad route registration may cache sensitive data	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from registering a broad route pattern (RegExp('/*')) that matches all URLs, potentially caching sensitive data without proper filtering. This is not due to misuse of a sensitive function, but rather a configuration issue in the routing logic.}	```workbox.routing.registerRoute(new RegExp('/*'), new workbox.strategies.StaleWhileRevalidate({ cacheName: CACHE }));```
2185	cbb.dk.js	Potential cache size exhaustion leading to DoS	Medium	false	CWE-400	N/A	N/A	N/A	{The vulnerability stems from caching all requests without size limits or eviction policies, which could lead to cache exhaustion. This is a misconfiguration rather than misuse of a sensitive function.}	```workbox.routing.registerRoute(new RegExp('/*'), new workbox.strategies.StaleWhileRevalidate({ cacheName: CACHE }));```
2186	gehaltsvergleich.com.js	Improper Input Validation in Track Function	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of input parameters passed to the track function, particularly `t` and `i`, which are used to construct a JSON payload sent via fetch. However, no sensitive JavaScript function is directly misused here—fetch is used safely with a fixed endpoint and no dynamic URL construction. The issue is more about data sanitization than function misuse.}	```var track = function (t, i) { fetch(self.location.origin + \'/push-notifications/events\', { method: \'post\', headers: { \'Content-type\': \'application/json;charset=UTF-8\' }, body: JSON.stringify({ type: t.toUpperCase() || null, location: i.location || null, searchText: i.title || null, source: i.source || null, pushNotificationID: i.pushNotificationID || null, pushNotificationRunId: i.pushNotificationRunId || null, pushNotificationPlatformType: i.pushNotificationPlatformType || null, pushNotificationMessageType: i.pushNotificationMessageType || null }) })```
2187	gehaltsvergleich.com.js	Open Redirect in Notification Click Handler	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is used with the value `t.notification.data.link`, which is derived from untrusted data in the push notification payload. Since this value is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to an open redirect and potentially phishing or redirecting users to harmful sites.}	```self.addEventListener('notificationclick', function (t) { console.log(t), clients.openWindow(t.notification.data.link), t.notification.close(); })```
2188	gehaltsvergleich.com.js	Potential XSS via Unsanitized Data in Track Function	High	false	CWE-79	N/A	N/A	N/A	{Although the data sent via fetch includes user-supplied fields like `i.title` or `i.location`, these are sent as JSON and not rendered in the browser. Therefore, no XSS is possible via this path because the data is not injected into HTML or JavaScript contexts. The vulnerability is misclassified—there is no actual XSS risk here.}	```body: JSON.stringify({ type: t.toUpperCase() || null, location: i.location || null, searchText: i.title || null, source: i.source || null, pushNotificationID: i.pushNotificationID || null, pushNotificationRunId: i.pushNotificationRunId || null, pushNotificationPlatformType: i.pushNotificationPlatformType || null, pushNotificationMessageType: i.pushNotificationMessageType || null })```
2189	powa.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	"{The fetch function is used with a URL derived from untrusted input (event.data.scripts), allowing an attacker to control the target URL. Since the request is made with mode: ""no-cors"" and redirect: ""follow"", it can be exploited to perform SSRF attacks by forcing the service worker to make requests to internal or restricted resources.}"	"```self.addEventListener(""message"", event => { const scriptsArray = event.data.scripts; console.log(event); if (scriptsArray && Array.isArray(scriptsArray)) { scriptsArray.map(url => { fetch(new Request(url, { mode: ""no-cors"", redirect: ""follow"" })); }); } });```"
2190	blikopzuid.com.js	Improper Caching of Offline Page Leading to Potential Unavailability	Medium	false	N/A	0	N/A	N/A	{The issue arises from the use of `cache.add()` with a `Request` object that includes `cache: 'reload'`, which forces a network fetch even when the resource is already cached. This can lead to unnecessary network requests and potential unavailability if the network is down. However, this is not due to misuse of a sensitive function, as `cache.add()` is used correctly in context and does not involve untrusted or dynamic input.}	```await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
2191	designtrends.com.js	Race Condition in Cache and Network Requests	Medium	false	N/A	0	```function fastest(request, values, options) {	N/A	{The vulnerability arises from a race condition in the `fastest` strategy, where both cache and network requests are initiated concurrently without proper coordination. This is not due to misuse of a sensitive function, but rather a logical flaw in handling asynchronous operations. The `fetchAndCache` and `cacheOnly` functions are called in parallel, and if both fail, the error handling may not be deterministic, leading to inconsistent behavior. No sensitive function is misused here.}	N/A
2192	robot-cash.info.js	Open Redirect via Unvalidated Input in Message Handling	High	true	CWE-601	10	N/A	standard	{The `self.addEventListener('message', ...)` handler processes incoming messages without validating the `e.data.h` value, which is then passed directly to `db.set('h', e.data.h)`. While `db.set` itself is not inherently dangerous, the vulnerability arises because `e.data.h` is used later in `utils.getFullNewUrl` to construct URLs for redirection (via `navigate` or `Location` headers). Since `e.data.h` is untrusted and unvalidated, an attacker can inject arbitrary values into the URL, leading to open redirect. The sensitive function here is `self.addEventListener`, a standard browser API, which enables the injection of untrusted data into the service worker's logic flow.}	```self.addEventListener('message', e => { e && e.data && 'saveH' === e.data.action && db.set('h', e.data.h); });```
2193	craftgawker.com.js	Regular Expression Denial of Service (ReDoS)	Medium	true	CWE-400	9	JSON.parse	standard	{The JSON.parse function is used to parse a string containing potentially complex regular expression patterns, which are then converted into RegExp objects. The patterns include constructs like (?:/.*)? and (dev-|test-)? that can lead to catastrophic backtracking when matched against maliciously crafted inputs, resulting in ReDoS. Although the input is hardcoded, the use of JSON.parse to dynamically generate RegExp objects from string literals introduces a risk if the string content is not carefully sanitized or if it is derived from untrusted sources in other contexts. The vulnerability arises because the function does not validate or limit the complexity of the regex patterns it processes.}	"```const c = JSON.parse('[""craftgawker\\\\.com(?:/.*)?/ola/services/.*"",""craftgawker\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://90730811-3d12-4a5a-9f9c-cc0e3e2ff65f\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
2194	gogrow.club.js	Improper Input Validation	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from the push event data. If the 'id' is not validated or sanitized, an attacker could inject malicious URLs or parameters, leading to unintended server requests or potential SSRF or command injection if the backend is vulnerable.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2195	gogrow.club.js	Client-Side Enforcement of Server-Side Security	Medium	false	CWE-602	N/A	N/A	N/A	{The vulnerability arises from client-side logic relying on URL parameters (loggedIn) for security decisions, which can be easily manipulated by an attacker. This is not caused by misuse of a sensitive function but by flawed security logic.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2196	gogrow.club.js	Missing Origin Validation	Medium	false	CWE-346	N/A	N/A	N/A	{The issue stems from trusting the referrer and credentials without validating the origin of the request. This is a logic flaw rather than misuse of a sensitive function.}	```headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer })```
2197	gogrow.club.js	Open Redirect	Medium	true	CWE-601	N/A	navigate	standard	{The navigate function is used with a URL derived from the notification data (data.url), which is not validated or sanitized. An attacker could craft a notification with a malicious URL, redirecting users to phishing or malicious sites.}	```clients[0].navigate(data.url);```
2198	gogrow.club.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The cache.addAll function is used with a hardcoded list of assets (CACHED_ASSETS), which are not dynamically sourced from untrusted input. Therefore, this is not a sensitive function misuse.}	```return cache.addAll(CACHED_ASSETS);```
2199	gogrow.club.js	Code Injection	High	true	CWE-94	N/A	replace	standard	{The replace function is used with a regular expression and a callback that dynamically constructs output based on untrusted input (params). If the input is not properly sanitized, an attacker could inject arbitrary strings that alter the output in unintended ways, potentially leading to code injection or XSS if the output is rendered in the UI.}	```word = word.replace(/\{(!|\d+?)?#(.*?)\}/g, (a, b, c, d) => {```
2200	sharps.se.js	XSS via untrusted push payload	High	true	CWE-79	10	JSON.parse	standard	{The function JSON.parse is not directly called, but e.data.json() is used, which internally calls JSON.parse on the push payload. Since the payload is untrusted and directly used to construct notification content (e.g., title, body), an attacker can inject malicious scripts or HTML that may be rendered in the notification UI, leading to XSS if the browser or platform interprets the content as executable.}	```var payload = e.data.json();```
2201	sharps.se.js	Open Redirect via notification URL	Medium	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL derived from e.notification.data.url, which is sourced from untrusted push payload data. Since the URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, causing the browser to redirect the user to an arbitrary site, leading to open redirect.}	```e.waitUntil(self.clients.openWindow(e.notification.data.url));```
2202	munchery.com.js	Cache Poisoning via MessageAPI	High	true	New	N/A	idbKeyval.set	custom	{The idbKeyval.set function is used to store arbitrary resources in IndexedDB based on user-controlled path and resources data received via message event. Since the path is derived from user input and used directly in the key (`resources:${path}`), an attacker can inject malicious keys or overwrite critical cached resources, leading to cache poisoning.}	```const { setPathResources } = MessageAPI; event.waitUntil(idbKeyval.set(`resources:${path}`, resources));```
2203	munchery.com.js	Command Injection via MessageAPI	High	true	CWE-78	N/A	MessageAPI[data.api]	custom	{The MessageAPI[data.api] function call is executed directly based on user-controlled data.api, which is derived from URL parameters. This allows an attacker to invoke any function in the MessageAPI object, including potentially dangerous ones like disableOfflineShell or clearPathResources, leading to command injection-like behavior.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
2204	munchery.com.js	SSRF via URL Parsing	Medium	true	CWE-918	N/A	new URL	standard	{The new URL constructor is used to parse event.request.url, which is under user control. While the URL is not directly used for network requests in this context, the parsed pathname is used to construct keys for IndexedDB and cache lookups, potentially allowing an attacker to manipulate the service worker’s behavior by crafting malicious URLs.}	```const { pathname } = new URL(event.request.url);```
2205	munchery.com.js	Denial of Service via disableOfflineShell	Medium	true	CWE-408	N/A	MessageAPI.disableOfflineShell	custom	{The disableOfflineShell function is invoked via MessageAPI based on user-controlled input, which sets offlineShellEnabled to false. This can be exploited by an attacker to disable offline functionality, causing denial of service for users relying on offline access.}	```MessageAPI.disableOfflineShell(); offlineShellEnabled = false;```
2206	munchery.com.js	Insecure Cache Route Regex	Medium	false	CWE-434	N/A	N/A	N/A	{The regex used in workbox.routing.registerRoute is overly broad and may match unintended URLs, but it does not involve misuse of a sensitive function. The vulnerability stems from poor pattern design rather than unsafe function usage.}	```workbox.routing.registerRoute(/^https?:.*\.(png|jpg|jpeg|webp|avif|svg|gif|tiff|js|woff|woff2|json|css)$/, new workbox.strategies.StaleWhileRevalidate(), 'GET');```
2207	bitcoinbazis.hu.js	Vulnerable Cache Exclusion Logic	High	true	N/A	10	N/A	standard	{The vulnerability arises from the improper use of the `match` method within the `checkNeverCacheList` function. This function is used to determine if a URL should be excluded from caching by checking against a list of regex patterns. However, the `match` method is called on `this` (which refers to the regex pattern) with the URL as an argument, which is logically inverted. The correct usage should be `regex.test(url)`, not `regex.match(url)`. Since `match` is a string method, calling it on a regex object results in undefined behavior or silent failure, leading to incorrect cache exclusion logic. This can allow sensitive or dynamic URLs (e.g., `/wp-admin/`) to be cached unintentionally, potentially exposing internal admin interfaces or enabling cache poisoning.}	```if (this.match(url)) { return false; } return true;```
2208	seitenstark.de.js	Excessive Cache Storage Leading to Denial of Service	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching a large number of static assets without size limits or eviction policies, which can exhaust storage and lead to DoS. This is not due to misuse of a sensitive function but rather poor cache management.}	```self.addEventListener('install', async function () { const cache = await caches.open(cacheName); cache.addAll(filesToCache); });```
2209	seitenstark.de.js	Unvalidated Fetch Requests Leading to Cache Pollution	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from blindly caching responses from any fetch request without validating the origin or content, which can lead to cache pollution. This is not caused by misuse of a sensitive function but by lack of input validation in the fetch handling logic.}	```self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request).catch(function () { return caches.match(event.request); })); });```
2210	crosswordleak.com.js	Incorrect Offline Fallback Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of offline fallbacks during fetch events, but not due to misuse of a sensitive function. The code correctly uses fetch() and caches.match() with static, trusted resources. The issue is in logic flow and error handling, not in unsafe function usage.}	"```self.addEventListener(""fetch"", function (event) { if (event.request.method !== ""GET"") return; event.respondWith(fetch(event.request).catch(function (error) { if (event.request.destination !== ""document"" || event.request.mode !== ""navigate"") { return; } return caches.open(CACHE).then(function (cache) { return cache.match(offlineFallbackPage); }); })); }```"
2211	crosswordleak.com.js	Unvalidated Offline Page Fetch	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from the lack of validation when refreshing the offline page, but it does not involve misuse of a sensitive function. The fetch() call is made on a static, hardcoded path (offlineFallbackPage), which is not derived from untrusted input. The issue is a logic flaw, not a sensitive function misuse.}	"```self.addEventListener(""refreshOffline"", function () { const offlinePageRequest = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { console.log(""[PWA Builder] Offline page updated from refreshOffline event: "" + response.url); return cache.put(offlinePageRequest, response); }); }); });```"
2212	atlanticahotels.com.js	CORS Misconfiguration	High	true	CWE-497	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL (returnUrl) that is derived from the original request URL. The URL is modified based on headers (accept) and navigator connection settings, but the mode is set to 'no-cors', which can lead to CORS misconfiguration if the server does not properly handle the request or if the response is not correctly interpreted by the browser. This misuse allows potentially untrusted or unintended resources to be fetched without proper CORS validation, leading to information leakage or unintended cross-origin access.}	```event.respondWith(fetch(returnUrl, { mode: 'no-cors' }));```
2213	trpger.us.js	XSS via unsanitized i18n data in offline HTML	High	true	New	9	`return`	standard	{The `return` statement in the `Me()` function constructs an HTML string using unsanitized i18n data (e.g., `e.title`, `e.header`, `e.reload`) directly interpolated into the HTML. Since these values are derived from locale files fetched via `fetch` and parsed as JSON, they are potentially user-controllable or attacker-influenced. If an attacker can manipulate the locale file (e.g., via a compromised server or cache poisoning), they can inject arbitrary HTML or JavaScript into the offline screen, leading to XSS. The use of `return` here is not inherently dangerous, but the context of dynamically generating HTML with unsanitized data makes it a sensitive misuse.}	"```return `<!DOCTYPE html><html lang=""ja""><head><meta charset=""UTF-8""><meta content=""width=device-width,initial-scale=1""name=""viewport""><title>${e.title}</title><style>body{background-color:#0c1210;color:#dee7e4;font-family:Hiragino Maru Gothic Pro,BIZ UDGothic,Roboto,HelveticaNeue,Arial,sans-serif;line-height:1.35;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;padding:24px;box-sizing:border-box}.icon{max-width:120px;width:100%;height:auto;margin-bottom:20px;}.message{text-align:center;font-size:20px;font-weight:700;margin-bottom:20px}.version{text-align:center;font-size:90%;margin-bottom:20px}button{padding:7px 14px;min-width:100px;font-weight:700;font-family:Hiragino Maru Gothic Pro,BIZ UDGothic,Roboto,HelveticaNeue,Arial,sans-serif;line-height:1.35;border-radius:99rem;background-color:#b4e900;color:#192320;border:none;cursor:pointer;-webkit-tap-highlight-color:transparent}button:hover{background-color:#c6ff03}</style></head><body><svg class=""icon""fill=""none""height=""24""stroke=""currentColor""stroke-linecap=""round""stroke-linejoin=""round""stroke-width=""2""viewBox=""0 0 24 24""width=""24""xmlns=""http://www.w3.org/2000/svg""><path d=""M0 0h24v24H0z""fill=""none""stroke=""none""/><path d=""M9.58 5.548c.24 -.11 .492 -.207 .752 -.286c1.88 -.572 3.956 -.193 5.444 1c1.488 1.19 2.162 3.007 1.77 4.769h.99c1.913 0 3.464 1.56 3.464 3.486c0 .957 -.383 1.824 -1.003 2.454m-2.997 1.033h-11.343c-2.572 -.004 -4.657 -2.011 -4.657 -4.487c0 -2.475 2.085 -4.482 4.657 -4.482c.13 -.582 .37 -1.128 .7 -1.62""/><path d=""M3 3l18 18""/></svg><div class=""message"">${e.header}</div><div class=""version"">v2024.10.1</div><button onclick=""reloadPage()"">${e.reload}</button><script>function reloadPage(){location.reload(!0)}<\/script></body></html>`;```"
2214	bilaxy.com.js	Insecure Direct Object Reference (IDOR) in Push Event Handler	High	true	CWE-548	9	N/A	standard	{The fetch function is used with a dynamically constructed URL that includes the `e.id` value from the push message data. Since this ID is derived from untrusted input (the push payload), an attacker could manipulate it to access or modify messages belonging to other users, leading to an IDOR vulnerability. The function is standard and directly responsible for the insecure direct object reference.}	```self.registration.showNotification(t, o); fetch(`/spi/v1/messages/${e.id}/status`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status: 'delivered', device_id: e.device_id }) }).catch(console.log);```
2215	bilaxy.com.js	Insecure Direct Object Reference (IDOR) in Notification Click Handler	High	true	CWE-548	9	N/A	standard	{The fetch function is used with a dynamically constructed URL that includes the `i.notification.data.id` value from the notification data. Since this ID is derived from untrusted input (the notification payload), an attacker could manipulate it to access or modify messages belonging to other users, leading to an IDOR vulnerability. The function is standard and directly responsible for the insecure direct object reference.}	```fetch(`/spi/v1/messages/${i.notification.data.id}/status`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status: 'read', device_id: i.notification.data.device_id }) }).catch(console.log);```
2216	bilaxy.com.js	Improper Check for Unusual Conditions in Message Event Handler	Medium	false	CWE-754	0	N/A	N/A	{The issue is not caused by misuse of a sensitive function, but rather by insufficient validation of the message data structure. The code assumes `i.data` exists and has a `type` property without proper defensive checks, which could lead to unexpected behavior if the data is malformed. No sensitive function is involved in this vulnerability.}	```i.data && i.data.type === 'SKIP_WAITING' && self.skipWaiting();```
2217	youtube.com.mx.js	Exposure of API Key in Client-Side Code	Medium	false	CWE-548	N/A	N/A	N/A	{The vulnerability arises from the hardcoded exposure of the INNERTUBE_API_KEY in client-side JavaScript, which is not related to the misuse of any sensitive JavaScript function. The key is directly assigned in a configuration object and is accessible to any user inspecting the source code.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'```
2218	gurugamer.com.js	Cache Poisoning via Substring URL Matching	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from using `indexOf` to match URLs containing 'static.gurugamer.com', which is a substring-based check. This allows an attacker to craft a malicious URL that includes 'static.gurugamer.com' as a substring (e.g., `https://malicious.com/static.gurugamer.com/evil.js`), causing the service worker to cache and serve the malicious content under the same cache key as a legitimate resource. This leads to cache poisoning, where the attacker can serve arbitrary content to users. The `caches.put()` function is used to store the response, and since the URL matching is not exact, it can be exploited to inject malicious content into the cache.}	```if (event.request.url.indexOf('static.gurugamer.com') !== -1) { event.respondWith(caches.match(event.request).then(function (cacheResponse) { return cacheResponse ? cacheResponse : fetch(event.request).then(function (response) { var responseToCache = response.clone(); caches.open(CACHE).then(function (cache) { cache.put(event.request, responseToCache); }); return response; }); }));```
2219	bajajhousingfinance.in.js	Hardcoded Sensitive Information (API Key User Key)	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (API key, user key, site ID) in the script, not due to misuse of a sensitive JavaScript function.}	```var config = { apiKey: 'AIzaSyBRtMMsoxE_X5nrDc9b2fDXV_cBtWXfFYE', messagingSenderId: '334536018842', appId: '1:334536018842:web:0b749773d9613effdd8823', projectId: 'bhfl-website', user_key: 'ADGMOT35CHFLVDHBJNIG50K9695MH4S9MODSB4E6GLO1IK769F40', siteid: 'bca79fbb83732fd6ee8bb2371349c4a3', idc: 'tin' };```
2220	bajajhousingfinance.in.js	Insecure External Script Loading (No SRI)	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is used to load an external script from a third-party domain ('//cdnt.netcoresmartech.com/swv4.js') without Subresource Integrity (SRI) checks. This allows an attacker to compromise the CDN or intercept the request to inject malicious code, leading to arbitrary code execution in the service worker context.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
2221	shirtinator.de.js	Insecure Dynamic Script Import	High	true	CWE-79	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts from a remote host, leading to remote code execution within the service worker context.}	```importScripts(`https://shirtinator.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
2222	textileinfomedia.com.js	Cache Poisoning via Dynamic Cache Injection	High	true	N/A	9	caches.open	standard	{The function caches.open is used with a hardcoded cache name 'dynamiccache', which is not dynamically derived from untrusted input. However, the vulnerability arises because the cache.put operation stores responses for arbitrary requests (e.g., e.request.url) without validation, allowing an attacker to poison the cache with malicious content if they can trigger a fetch for a controlled URL. While caches.open itself is not directly misused with untrusted input, the overall cache injection vulnerability stems from the lack of input validation in the cache.put operation, which is indirectly tied to the use of the standard caches API.}	"```self.addEventListener('fetch', function (e) { var request = e.request; e.respondWith(fetch(e.request).then(function (res) { return caches.open(""dynamiccache"").then(function (cache) { cache.put(e.request.url, res.clone()); return res; })); }).catch(function (error) { return caches.match(e.request); })); });```"
2223	cashdo.co.il.js	Open Redirect via Unvalidated URL in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the specified URL. When the URL is derived from untrusted data (in this case, event.notification.data.url), it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery. The input is not validated or sanitized, making this a direct misuse of a sensitive function.}	```self.addEventListener('notificationclick', function (event) { var data = event.notification.data; if (data.url) { event.waitUntil(clients.openWindow(data.url)); } });```
2224	regal.fr.js	Loading External Script Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with hardcoded URLs, it can lead to code injection if the external script is compromised or if the URL is dynamically controlled by an attacker. In this case, the script is loaded from a hardcoded external domain (https://aswpsdkeu.com), which introduces a risk if the domain is not fully trusted or if the script is modified without detection. This constitutes a high-severity vulnerability as it allows an attacker to inject malicious code into the service worker, potentially compromising the entire application's security.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
2225	trackingex.com.js	Insecure URL Handling in Notification Redirect	High	true	N/A	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL that is derived from event.notification.data, which is not validated or sanitized. Since this URL can be controlled by an attacker via the notification payload, it enables open redirect attacks, allowing malicious redirection to arbitrary domains.}	```event.waitUntil(clients.openWindow(redirectUrl));```
2226	trackingex.com.js	Unvalidated Data in Fetch Request	Medium	true	N/A	8	fetch	standard	{The fetch function is used with a body constructed from unvalidated data, including redirectUrl and utm_source derived from user-controlled inputs. This allows an attacker to inject arbitrary data into the request body, potentially leading to unintended server-side behavior or data leakage.}	"```fetch(""https://www.silverglad.com/click-action7"", { mode: ""no-cors"", body: JSON.stringify(e), method: ""POST"", headers: { 'content-type': 'application/json' } }).then(function (e) { return; });```"
2227	udaipurtimes.com.js	Improper Neutralization of Server-Side Request Forgery	High	true	CWE-918	9	fetch	standard	{The fetch function is used with user-controlled data (data.campaignImpressionsURL) without validation or sanitization, allowing an attacker to forge requests to arbitrary endpoints, leading to SSRF.}	"```fetch(data.campaignImpressionsURL, { mode: 'no-cors', method: ""POST"" }).then(function (response) {});```"
2228	udaipurtimes.com.js	Improper Neutralization of Server-Side Request Forgery	High	true	CWE-918	9	fetch	standard	{The fetch function is used with user-controlled data (data.feedUrl) without validation or sanitization, allowing an attacker to forge requests to arbitrary endpoints, leading to SSRF.}	"```fetch(data.feedUrl, { mode: 'no-cors', method: ""GET"" }).then(response => response.json()).then(function (res) { ... });```"
2229	udaipurtimes.com.js	Improper Neutralization of Server-Side Request Forgery	High	true	CWE-918	9	fetch	standard	{The fetch function is used with user-controlled data (data.imprurl) without validation or sanitization, allowing an attacker to forge requests to arbitrary endpoints, leading to SSRF.}	```fetch(data.imprurl, { mode: 'no-cors' }).then(function (response) {});```
2230	udaipurtimes.com.js	Improper Neutralization of Server-Side Request Forgery	High	true	CWE-918	9	fetch	standard	{The fetch function is used with user-controlled data (data.imprtracker) without validation or sanitization, allowing an attacker to forge requests to arbitrary endpoints, leading to SSRF.}	```fetch(data.imprtracker, { mode: 'no-cors' }).then(function (response) {});```
2231	udaipurtimes.com.js	Exposure of Sensitive Information to an Unauthorized Actor	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from hardcoded credentials in firebase.initializeApp, but no sensitive function misuse is involved.}	"```firebase.initializeApp({ apiKey: ""AIzaSyBhynUiXoimIuINinUglEBnDNLhK3i-bcw"", authDomain: ""libertad-18ee6.firebaseapp.com"", ... });```"
2232	lawinfopedia.com.js	Open Redirect	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed as redirectUrl, which is derived from event.notification.data or a hardcoded value. Since event.notification.data is sourced from the push notification payload (which can be controlled by an attacker), and no validation or sanitization is performed on redirectUrl, this allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(redirectUrl));```
2233	lawinfopedia.com.js	Insecure Data Handling	Medium	true	N/A	N/A	getQueryVariable	standard	{The function getQueryVariable is used to extract 'utm_source' from notificationUrl or redirectUrl, which are derived from untrusted sources (push notification data or notification payload). Since the function does not sanitize or validate the input, and the extracted value is used in subsequent data structures sent via fetch, this can lead to information leakage or unintended data exposure if the input contains sensitive or malicious content.}	"```var utm_source = getQueryVariable(""utm_source"", notificationUrl);```"
2234	lawinfopedia.com.js	Insecure Fetch Mode	Medium	false	N/A	N/A	N/A	N/A	"{The fetch call uses mode: ""no-cors"", which prevents cross-origin requests from being made, but this is not inherently a sensitive function misuse. The issue lies in the configuration of the fetch request rather than misuse of a sensitive function.}"	"```fetch(""https://www.silverglad.com/show-impression7"", { mode: ""no-cors"", body: JSON.stringify(e), method: ""POST"", headers: { 'content-type': 'application/json' } }).then(function (e) { return; });```"
2235	valioliiga.com.js	Loading third-party script from CDN without integrity check	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a given URL. When used without an integrity check, it introduces a risk of loading a malicious or tampered script if the CDN is compromised. Although the URL is hardcoded, the lack of integrity validation means the script can be altered in transit, leading to code injection and potential compromise of the service worker.}	N/A
2236	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
2237	valioliiga.com.js	Incorrect URL filtering logic in checkNeverCacheList function	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from a logical error in the checkNeverCacheList function, where the this context is incorrectly assumed to be a regex pattern. This is not a misuse of a sensitive function but a programming logic flaw. The function is custom and does not involve any inherently dangerous JavaScript API.}	N/A
2238	valioliiga.com.js	Caching responses without respecting Cache-Control headers	Medium	false	CWE-377	N/A	N/A	N/A	{This issue stems from the service worker's caching strategy not honoring Cache-Control headers from the server, which is a policy or configuration issue rather than misuse of a sensitive function. The caching behavior is implemented using standard APIs like caches.open() and cache.put(), but the vulnerability is due to missing header checks, not improper function usage.}	N/A
2239	personalfn.com.js	Improper URL Validation Leading to SSRF	High	true	CWE-829	10	N/A	standard	{The function `checkForAnalyticsRequest` uses `new URL(requestUrl)` to parse the URL, but the validation logic is flawed. It checks for specific hostnames and pathnames, but the condition `url.pathname === '/collect'` is not properly grouped with the hostname check, allowing URLs like `https://www.google-analytics.com/otherpath/collect` to bypass validation. This improper validation can lead to SSRF if the application later uses the unvalidated URL in a network request.}	```if ((url.hostname === 'www.google-analytics.com' || url.hostname === 'ssl.google-analytics.com') && url.pathname === '/collect' || url.hostname === 'www.googletagmanager.com' || url.hostname === 'www.googletagservices.com') { return true; }```
2240	personalfn.com.js	Improper URL Validation Leading to SSRF	High	true	CWE-829	10	N/A	standard	{The condition `event.request.url.indexOf('https://www.personalfn.com') === 0` is used to validate URLs, but it only checks for a prefix match. This allows URLs like `https://www.personalfn.com.attacker.com` to pass validation, enabling SSRF if the request is later processed without further validation. The `indexOf` function is misused here as it does not perform proper domain validation.}	```if (event.request.url.indexOf('https://www.personalfn.com') === 0 || checkForAnalyticsRequest(event.request.url)) {```
2241	personalfn.com.js	Unrestricted Network Request in Offline Replay	Medium	true	CWE-918	9	N/A	standard	{The `fetch(requestUrl)` call in `replayAnalyticsRequests` uses a URL constructed from `savedRequest.url + '&qt=' + queueTime`, where `savedRequest.url` is stored from a prior request. If the original request was not properly validated, this can lead to arbitrary network requests being replayed, potentially targeting internal services or external endpoints controlled by an attacker. The `fetch` function is used without validating the constructed URL, making it a sensitive function misuse.}	```fetch(requestUrl).then(function (response) { if (response.status < 400) { getObjectStore(STORE_NAME, 'readwrite').delete(savedRequest.url); console.log(' Replaying succeeded.'); } else { console.error(' Replaying failed:', response); } }).catch(function (error) { console.error(' Replaying failed:', error); });```
2242	netxtra.net.js	Information Exposure via Debug Logs	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from debug logs being conditionally output via console.log when pwaSettings.debug is true. This is not caused by misuse of a sensitive function, but rather by the exposure of potentially sensitive information through logging.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
2243	netxtra.net.js	Improper Neutralization of Server-Side Request	Medium	true	N/A	N/A	fetch	standard	{The function fetch is used with a URL constructed via addParams, which processes user-controlled input (e.g., from location.href) without proper validation. This allows an attacker to manipulate the URL to perform SSRF attacks, such as accessing internal resources or bypassing network restrictions.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
2244	netxtra.net.js	Insufficient Logging	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the absence of meaningful logging for fetch events, which is not due to misuse of a sensitive function but rather a design or configuration oversight.}	```self.addEventListener('fetch', () => {});```
2245	netxtra.net.js	Index Manipulation in Cache Routes	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to overly broad regular expressions in workbox.routing.registerRoute, which may match unintended URLs. This is a logic or configuration issue, not caused by misuse of a sensitive function.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, cacheFirst(SITE_ASSETS_CACHE_NAME));```
2246	analystforum.com.js	Insecure External Cache Handling	High	true	CWE-918	N/A	workbox.routing.registerRoute	N/A	{The vulnerability arises from the use of workbox.routing.registerRoute with a dynamic route condition that evaluates external URLs based on origin mismatch and CDN URL filtering. While the function itself is not inherently dangerous, its misuse here allows any external resource not explicitly listed in cdnUrls to be cached under externalCacheName. Since cdnUrls is initialized as an empty array, all external requests are cached without validation, potentially allowing attackers to cache malicious or unintended content from arbitrary domains. This is a sensitive misuse because the routing logic is dynamically determined and not hard-coded, enabling unintended caching behavior.}	```workbox.routing.registerRoute(function (e) { return e.url.origin !== location.origin && 0 === cdnUrls.filter(function (t) { return e.url.href.startsWith(t); }).length; }```
2247	gusto.at.js	Improper Handling of Service Worker Activation	Medium	false	New	N/A	N/A	N/A	{The use of self.skipWaiting() is not inherently a sensitive function misuse. It is a standard Service Worker API used to immediately activate the new service worker without waiting for all clients to be updated. While it may have operational implications (e.g., forcing updates), it does not introduce security vulnerabilities such as code injection, data leakage, or unauthorized execution when used as intended.}	```self.skipWaiting();```
2248	doniaweb.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-549	10	N/A	standard	{The fetch() function is used with a URL constructed from the `id` parameter received from a push notification. Since `id` is controlled by the server sending the push (and potentially by an attacker if the server is compromised), this allows an attacker to craft a push notification that triggers a request to an arbitrary URL, leading to SSRF. The URL is dynamically built using template literals, making it vulnerable to injection.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2249	doniaweb.com.js	Insecure Client-Side Authentication Check	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from client-side logic that checks `loggedIn` without server-side validation, but it does not stem from misuse of a sensitive JavaScript function. The logic is flawed in design, not due to improper use of a function like eval, importScripts, or similar.}	```if (loggedIn == 'false' && request.method === 'POST') {```
2250	doniaweb.com.js	Open Redirect in Notification	High	true	CWE-601	10	N/A	standard	{The navigate() method is used with `data.url`, which is derived from server-provided notification data. Since this data is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to redirect the user to an arbitrary site, leading to open redirect.}	```clients[0].navigate(data.url);```
2251	andymark.com.js	Unrestricted Service Worker Scope	High	false	CWE-434	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the service worker's scope being unrestricted or improperly configured, which allows it to control more of the site than intended. This is a configuration issue, not a function misuse.}	"```self.addEventListener(""install"", function (e) { e.waitUntil(caches.open(""pwa_cache"").then(function (e) { return e.addAll([""https://cdn.andymark.com/assets/workarea/storefront/logo-7219354c49b64807855a362004b6910c833c313351a38d8317e629f6a5e1cab6.png"", ""https://cdn.andymark.com/assets/workarea/storefront/application-56d682af15f64c380c5ed56468885c8ef0e703357ffe6e23fb4f1a4b15c408dd.css"", ""https://cdn.andymark.com/assets/workarea/storefront/head-c8d3a703052390b80cc7db4a0af4c20ee40e846d90695010446e14d4740c389d.js"", ""https://cdn.andymark.com/assets/workarea/storefront/application-b7c112c037df4e1bb65e771690f7c236a9136acccfca1936f01f359a2646c44d.js"", ""/offline""]); })); }, self.addEventListener(""fetch"", function (e) { ""navigate"" === e.request.mode && ""GET"" === e.request.method && e.request.headers.get(""accept"").includes(""text/html"") && e.respondWith(fetch(e.request)[""catch""](function () { return caches.match(""/offline""); })); });```"
2252	caliboard.de.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	clients[0].navigate	standard	{The function clients[0].navigate is used to redirect the client to a URL derived from the notification data (data.url). Since this URL is not validated or sanitized and can be controlled by an attacker via push notifications, it enables open redirect attacks. An attacker could craft a malicious notification payload with a URL pointing to an external site, leading users to unintended destinations.}	```const promiseChain = e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
2253	growingfruit.org.js	Improper Error Handling in CSRF Token Fetch	High	true	CWE-347	8	fetch	standard	{The fetch function is used to retrieve a CSRF token, but the error handling is insufficient. If the fetch fails (e.g., due to network issues or server errors), the error is thrown but not caught, potentially leading to a broken user experience or exposure of sensitive information. More critically, if the CSRF token fetch fails, the subsequent POST request to the chat endpoint may proceed without a valid token, leading to a CSRF vulnerability. The misuse lies in not properly handling the failure case of the fetch call, which is a sensitive operation due to its role in authentication and authorization.}	"```fetch(""/session/csrf"", { credentials: ""include"", headers: { Accept: ""application/json"" } }).then(t => { if (!t.ok) throw new Error(""Network response was not OK""); return t.json(); }).then(o => { i = o.csrf; let s = e.match(chatRegex); if (s.length > 0) { let e = s[1]; fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" }); } });```"
2254	wipsites.com.br.js	Improper Error Handling in Cache.addAll Leading to DoS	Medium	false	CWE-754	N/A	N/A	N/A	{The vulnerability arises from lack of error handling in the cache.addAll() call, which may lead to denial of service if the cache operation fails. However, this is not due to misuse of a sensitive function, but rather poor error management.}	```self.addEventListener('install', function (e) { e.waitUntil(caches.open(cacheName).then(function (cache) { return cache.addAll(filesToCache); })); });```
2255	wipsites.com.br.js	Cache Matching Ignores Query Parameters Leading to Incorrect Resource Delivery	Medium	false	N/A	N/A	N/A	N/A	{The issue stems from using ignoreSearch: true in caches.match(), which causes query parameters to be ignored during cache lookup. This is a configuration issue, not misuse of a sensitive function.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request, { ignoreSearch: true }).then(response => { return response || fetch(event.request); })); });```
2256	htb.co.uk.js	Open Redirect Vulnerability	High	true	CWE-601	9	Location	standard	{The vulnerability arises from the use of the `Location` header in a `Response` object, which is set to `lastNavigationRequest`. This value is derived directly from `event.request.url`, which is user-controlled. Since the `Location` header is used to redirect the client to a URL specified by the attacker, this allows for an open redirect. The `Response` constructor is a standard JavaScript API, and its misuse here—by setting the `Location` header to an untrusted input—enables the redirect.}	```const navigationRoute = new NavigationRoute(async ({ event }) => { if (event.request.url.match(/\/.gatsby-plugin-offline:.+/)) { return handleAPIRequest({ event }); } if (!offlineShellEnabled) { return await fetch(event.request); } lastNavigationRequest = event.request.url; let { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``); const resources = await idbKeyval.get(`resources:${pathname}`); if (!resources || !(await caches.match(`/app-09be1a8c263b20612267.js`))) { return await fetch(event.request); } for (const resource of resources) { if (!(await caches.match(resource))) { return await fetch(event.request); } } const offlineShell = `/offline-plugin-app-shell-fallback/index.html`; const offlineShellWithKey = workbox.precaching.getCacheKeyForURL(offlineShell); return await caches.match(offlineShellWithKey); }); workbox.routing.registerRoute(navigationRoute); workbox.routing.registerRoute(/\/.gatsby-plugin-offline:.+/, handleAPIRequest);```
2257	punjabkesari.com.js	External Script Import Vulnerability	Medium	false	CWE-444	N/A	N/A	N/A	{The importScripts() call is using a hardcoded, trusted URL from a known CDN (cdn.izooto.com). Since the URL is not derived from user input or dynamic sources, it does not constitute a sensitive function misuse. The vulnerability is more accurately classified as a supply chain risk rather than a direct misuse of a sensitive function.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/0ec2ee1982d5974b6ccdcf9b8af995817cbd80ce.js"");```"
2258	lemonswan.com.js	Open Redirect via Untrusted URL Handling	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. In this code, the URL passed to clients.openWindow(n) is derived from the value stored in the `a` object, which is populated from a JSON-parsed push notification payload. Since the payload is received from an external source (e.g., a server or third-party service), it is untrusted and can be manipulated by an attacker. If an attacker controls the push notification payload, they can set the `openAction.URL` to a malicious URL, causing the browser to open it when the user clicks the notification, leading to an open redirect vulnerability.}	```self.addEventListener('notificationclick', function (e) { if (console.log('Leanplum: [Service Worker] Notification click received.'), e.notification.close(), e.notification && e.notification.tag) { var t = e.notification.tag, n = a[t]; n ? (delete a[t], e.waitUntil(clients.openWindow(n))) : console.log('Leanplum: [Service Worker] No action defined, doing nothing.'); } else console.log('Leanplum: No notification or tag/id received, skipping open action.'); });```
2259	super-shop.com.js	Improper Input Validation (Substring Matching in Cache Check)	Medium	true	CWE-20	8	N/A	standard	{The code uses `includes()` to check if the request URL contains any element from CACHE_LIST. This is a substring match, not a full URL or path comparison, which can lead to unintended cache matches (e.g., a request for '/media/theme/s19/css/offline.css' might match '/media/theme/s19/css/other.css' if the substring is present). This improper validation can result in serving cached responses for unintended resources, potentially leading to information disclosure or cache poisoning.}	```const isCached = false; CACHE_LIST.forEach(function (element) { if (event.request.url.includes(element)) { isCached = true; } }, this);```
2260	lemonrock.com.js	Open Redirect via Notification Click	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL constructed from event.notification.data.id, which is user-controlled data. Since the URL is built by concatenating a base path with untrusted input, an attacker can manipulate the notification payload to redirect users to arbitrary external sites, leading to open redirect vulnerabilities.}	"```urlToOpen = ""myfavourites.php?new="" + event.notification.data.id;```"
2261	tangled.com.js	Insecure File Handling (Unvalidated File Names/Types	High	true	CWE-434	9	cache.put	standard	{The cache.put function is used with file.name as the key, which is derived directly from user input without validation. This allows attackers to upload files with arbitrary names, potentially leading to path traversal, cache poisoning, or overwriting critical resources.}	N/A
2262	tangled.com.js	Unvalidated User Input in JSON Storage (Potential XSS	Medium	true	CWE-79	8	cache.put	standard	{The cache.put function stores user-provided data (title, text, url) in a JSON object without sanitization. If this data is later rendered in a context where it can be interpreted as HTML or JavaScript (e.g., in a web page), it could lead to XSS.}	N/A
2263	tangled.com.js	Unrestricted File Upload Size/Count (DoS Risk	Medium	true	CWE-400	9	cache.put	standard	{The cache.put function is called for each uploaded file without enforcing limits on file size or count. An attacker could upload many large files, exhausting the service worker’s cache storage and causing a denial of service.}	N/A
2264	tangled.com.js	Unvalidated User Input in JSON Storage (Potential XSS	Medium	false	CWE-79	0	N/A	N/A	{The vulnerability is due to unsanitized user input being stored in JSON, but no sensitive function misuse is directly involved.}	N/A
2265	tangled.com.js	Insecure File Handling (Unvalidated File Names/Types	High	false	CWE-434	0	N/A	N/A	{The vulnerability stems from lack of input validation, not misuse of a sensitive function.}	N/A
2266	tangled.com.js	Unrestricted File Upload Size/Count (DoS Risk	Medium	false	CWE-400	0	N/A	N/A	{The vulnerability is due to lack of rate or size limits, not misuse of a sensitive function.}	N/A
2267	hanser.de.js	Improper Input Validation	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from improper input validation in the `handleAPIRequest` function, where the `pathname` from the request URL is parsed using a regular expression and then split on `&` and `=` to construct a `data` object. This input is derived from the `event.request.url`, which is user-controlled. The `data.api` is then used to invoke a function from the `MessageAPI` object via `MessageAPI[data.api]()`. If an attacker can craft a URL with a malicious `pathname` that includes a key matching a property in `MessageAPI` (e.g., `disableOfflineShell`), they can trigger unintended behavior. Although no direct code execution is triggered, this constitutes a sensitive function misuse because the `URL` constructor and subsequent string manipulation are used to extract and process untrusted input without sanitization, leading to potential logic manipulation or denial of service. The `URL` constructor is a standard JavaScript function, and its misuse here allows attacker-controlled input to influence the application's behavior.}	```function handleAPIRequest({ event }) { const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); } if (!data.redirect) { return new Response(); } return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } }); }```
2268	stereolux.org.js	Improper Neutralization of Special Elements in Fetch Requests (No-CORS Mode	High	true	New	9	N/A	standard	{The fetch function is used with mode: 'no-cors', which bypasses CORS checks and allows requests to be made to arbitrary origins without proper validation. If the URL is derived from untrusted input (e.g., user-controlled request), this can lead to unintended cross-origin requests, potentially leaking sensitive data or enabling unauthorized access.}	```fetch(url, { credentials: 'same-origin', mode: 'no-cors' })```
2269	stereolux.org.js	Improper Neutralization of Special Elements in Fetch Requests (No-CORS Mode	High	true	New	9	N/A	standard	{The fetch function is used with mode: 'no-cors' on event.request, which is derived from the incoming fetch event. Since event.request can be controlled by the client, this allows arbitrary cross-origin requests without CORS validation, potentially leading to data exfiltration or unintended network access.}	```fetch(event.request, { mode: 'no-cors' })```
2270	stereolux.org.js	Improper Validation of URLs in Cache Logic	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of URLs before caching, but it is not directly caused by misuse of a sensitive function. The logic checks if a URL is excluded, but the issue is more about logic flaws in URL handling rather than improper use of a sensitive API.}	```if (notExcludedPath) { if (response.ok) { var copy = response.clone(); if (CACHE_ACTIVE) { caches.open(CACHE_CURRENT).then(function (cache) { return cache.put(event.request, copy); }).catch(logError); } else { console.debug('PWA: The service worker has been uninstalled so cache.put() was skipped.'); } } else { fetch(event.request, { mode: 'no-cors' }).then(function (response) { if (response.ok) { var copy = response.clone(); if (CACHE_ACTIVE) { caches.open(CACHE_CURRENT).then(function (cache) { return cache.put(event.request, copy); }).catch(logError); } else { console.debug('PWA: The service worker has been uninstalled so cache.put() was skipped.'); } } }).catch(function (error) { logError(error); console.error('PWA: Response not cacheable ', response); }); } return response; }```
2271	in-gl.de.js	Caching of Sensitive URLs with query parameters	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching URLs that contain query parameters (e.g., `?wp_error_template=offline`), which may be sensitive or dynamic. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by the design choice to cache such URLs. The `precaching.precache()` method is used correctly and safely; the issue is more about the content being cached rather than a function misuse.}	```wp.serviceWorker.precaching.precache([{\'url\': \'https:\\/\\/in-gl.de\\/\\?wp_error_template=offline\', \'revision\': \'0.8.1;newspack-theme=2.1.0;newspack-scott=2.1.0;options=5806c9a95bbb8d8e35e0d8b621f2fa93;nav=1ace7bf518f1be989b1aac47e8cc9c26;deps=8b914fd0266b55177d690bb0091a8046;0c2d584d75142f0aa2defbab82478d65\'}, {\'url\': \'https:\\/\\/in-gl.de\\/\\?wp_error_template=500\', \'revision\': \'0.8.1;newspack-theme=2.1.0;newspack-scott=2.1.0;options=5806c9a95bbb8d8e35e0d8b621f2fa93;nav=1ace7bf518f1be989b1aac47e8cc9c26;deps=8b914fd0266b55177d690bb0091a8046;2850a6265d25f3a1d90f8b58b11ca343\'}]);```
2272	bauzaar.it.js	Overly permissive regex in registerRoute for static assets leading to cache poisoning	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the overly permissive regex pattern used in registerRoute, which may match unintended URLs and allow cache poisoning. However, this is not due to misuse of a sensitive function but rather a logic or configuration flaw in the route matching pattern.}	```registerRoute(/^(.*)(static)(.*)(.(png|jpeg|jpg|gif|svg|css|js|woff|woff2|ttf|eot|ico|json))$/, new StaleWhileRevalidate({ cacheName: 'static-assets', plugins: [new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxAgeSeconds: CACHE_LIFETIME, maxEntries: 1000 })] }));```
2273	bauzaar.it.js	Caching responses with status 0 in CacheableResponsePlugin leading to improper validation	Medium	false	N/A	0	N/A	N/A	{The issue stems from including status 0 in the CacheableResponsePlugin's allowed statuses, which can lead to improper validation of cached responses. This is a configuration error, not a misuse of a sensitive function.}	```new CacheableResponsePlugin({ statuses: [0, 200] })```
2274	nastia.ai.js	Improper Exception Handling in Service Worker Activation	Medium	false	N/A	0	N/A	N/A	{The vulnerability is related to improper exception handling during service worker activation, but no sensitive function misuse (e.g., importScripts, eval, etc.) is involved. The code uses standard cache management operations without dynamic or untrusted input.}	"```self.addEventListener(""activate"", t => { async function a() { for (const e of await caches.keys()) e !== s && (await caches.delete(e)); } t.waitUntil(a()); });```"
2275	nationalfunding.com.js	Cache Poisoning via Missing Revision Hash	High	true	CWE-444	10	workbox.precaching.precacheAndRoute	standard	"{The workbox.precaching.precacheAndRoute function is used to cache assets, but when revision hashes are missing (as in the case of URLs like ""webpack-runtime-d4c1ea0b21e786775f28.js"" without a revision field), it becomes vulnerable to cache poisoning. An attacker could potentially serve a malicious version of the asset if the cache key is not uniquely tied to a specific revision, allowing them to inject malicious code into the service worker's cache.}"	N/A
2276	nationalfunding.com.js	Insecure Message Handling Leading to DoS	Medium	true	CWE-400	9	self.addEventListener	standard	{The self.addEventListener function is used to handle messages, but it directly invokes MessageAPI[api] without validating or sanitizing the 'api' parameter from event.data. This allows an attacker to send arbitrary messages that could trigger unintended or resource-intensive operations (e.g., clearing caches or deleting keys), leading to a Denial of Service condition.}	N/A
2277	nationalfunding.com.js	Overlapping Cache Strategies for Static Resources	Medium	false	New	0	N/A	N/A	{The vulnerability arises from overlapping route patterns in workbox.routing.registerRoute, but it is not due to misuse of a sensitive function. The issue is a configuration flaw, not a direct function misuse.}	N/A
2278	```workbox.routing.registerRoute(/(\.js$|\.css$|static\/)/, new workbox.strategies.CacheFirst(), 'GET');```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```workbox.routing.registerRoute(/(\.js$|\.css$|static\/)/, new workbox.strategies.CacheFirst(), 'GET');```
2279	nationalfunding.com.js	Unvalidated API Parameter Parsing in Navigation Route	Medium	true	CWE-703	8	function handleAPIRequest	standard	{The function handleAPIRequest parses URL path parameters without validating or sanitizing them. It uses new URL(event.request.url) and regex to extract parameters, then splits them with `=` and `&` to populate a data object. If an attacker can control the URL path, they could inject arbitrary keys into the data object, potentially triggering unintended behavior if MessageAPI contains a method matching the injected key, leading to unauthorized actions.}	N/A
2280	kubofinanciero.com.js	Caching of External Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching external resources, but it is not due to misuse of a sensitive function. The code explicitly lists resources to cache, and there is no dynamic or untrusted input being used to construct URLs passed to cache.addAll().}	"```self.addEventListener(""install"", function (evt) { evt.waitUntil(caches.open(CACHE_NAME).then(function (cache) { return cache.addAll(FILES_TO_CACHE); })); self.skipWaiting(); });```"
2281	titus-shop.com.js	Incorrect Allowlist Regex Construction	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper regex construction using `hostnameRegex.replace(/\./g, '\\.')`, which does not account for potential special characters or edge cases in hostnames, leading to unintended regex behavior. This is not caused by misuse of a sensitive function but by flawed logic in regex pattern generation.}	```const ALLOWLIST = [`^https\:\/\/${hostnameRegex}+\/($|collections|products|pages|cart|search|blogs|account|recommendations)`, `^https\:\/\/${hostnameRegex}+${proxy}`, `^https?\:\/\/(?!${hostnameRegex}).+`];```
2282	titus-shop.com.js	SSRF via Dynamic Script Import	High	true	N/A	N/A	importScripts	standard	{The `importScripts()` function is used with a dynamically constructed URL that includes `location.search`, which is user-controlled. This allows an attacker to manipulate the query string to load and execute arbitrary scripts from unintended domains, leading to Server-Side Request Forgery (SSRF) and potential code execution within the service worker context.}	```importScripts(`https://titus.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
2283	hispasec.com.js	Vulnerable Cache Bypass via ngsw-bypass Header	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in bypassing service worker logic based on header or URL query parameter, not from misuse of a sensitive function.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) {```
2284	hispasec.com.js	Insecure Debug Endpoint Exposure	High	true	N/A	N/A	newResponse	standard	{The newResponse function is used to construct a response for the debug endpoint, which exposes sensitive internal state to any client that can access the ngsw/state path. This is a direct misuse of a standard function to expose debug information without proper access control.}	N/A
2285	hispasec.com.js	Insufficient Hash Validation in Cache Control	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from a logic flaw in hash comparison, not from misuse of a sensitive function.}	```if (this.hashTable.get(url) !== hash) {```
2286	hispasec.com.js	Insecure Directives Handling in Cache Control	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper parsing of Cache-Control headers, not from misuse of a sensitive function.}	"```const cacheDirectives = cacheControl.split(',').map(v => v.trim()).map(v => v.split(""=""));```"
2287	hispasec.com.js	Insecure URL Normalization Leading to Cache Poisoning	High	true	N/A	N/A	normalizeUrl	standard	{The normalizeUrl function is used to process URLs for cache keys, but it does not properly sanitize or validate inputs, allowing attackers to craft URLs that bypass cache isolation and poison caches by manipulating the path component. This misuse of a standard function enables cache poisoning.}	```const prefix = `${this.cacheNamePrefix}:`;```
2288	hispasec.com.js	Insecure Response Caching of Opaque Responses	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to a logic flaw in caching opaque responses without proper validation, not from misuse of a sensitive function.}	```if (res.ok || okToCacheOpaque && res.type === 'opaque') {```
2289	hispasec.com.js	Insecure Notification Action URL Handling	High	true	N/A	N/A	new URL	standard	{The new URL function is used to construct URLs from untrusted notification data, which can lead to arbitrary navigation or phishing attacks if the URL is controlled by an attacker. This is a direct misuse of a standard function with unsanitized input.}	```const urlToOpen = new URL((_c = onActionClick == null ? void 0 : onActionClick.url) != null ? _c : '', this.scope.registration.scope).href;```
2290	hispasec.com.js	Insecure Cache Deletion via Regex Pattern	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in regex pattern matching for cache deletion, not from misuse of a sensitive function.}	```const oldSwCacheNames = cacheNames.filter(name => /^ngsw:(?!\/)/.test(name));```
2291	kaartje2go.be.js	Cache Poisoning via Untrusted Input	High	true	CWE-20	N/A	cache.addAll	standard	{The function cache.addAll() is a standard JavaScript API used in Service Workers to add multiple resources to a cache. When used with untrusted input (e.g., the 'links' array received via message event), it allows an attacker to inject arbitrary URLs into the cache, leading to cache poisoning. This can result in serving malicious content or bypassing security controls.}	```const cache = await caches.open('editor'); await cache.addAll(links);```
2292	kaartje2go.be.js	Open Redirect in Notification URL	High	true	CWE-601	N/A	self.clients.openWindow	standard	{The function self.clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted or unsanitized data (e.g., the 'url' from notification.data), it enables open redirect attacks, allowing attackers to redirect users to malicious sites.}	```return self.clients.openWindow(url);```
2293	kaartje2go.be.js	Unvalidated URL Construction in Push Event	Medium	true	CWE-601	N/A	new URLSearchParams	standard	{The function new URLSearchParams() is a standard JavaScript API used to construct query strings. When used with untrusted data (e.g., the 'contactId' from push event data) without validation, it can lead to unvalidated URL construction, potentially allowing attackers to craft malicious URLs or manipulate tracking parameters.}	```url: `https://www.kaartje2go.nl/verjaardagskaarten?${new URLSearchParams({...}).toString()}````
2294	libmanuels.fr.js	Insecure Storage of Sensitive Headers	High	true	CWE-200	N/A	N/A	standard	{The function `for (const [header, value] of event.request.headers)` iterates over request headers and stores them in an object, which is then persisted in IndexedDB. Since headers may contain sensitive data (e.g., cookies, authorization tokens), storing them without sanitization or access controls exposes them to potential leakage or unauthorized access.}	```let headers = {}; for (const [header, value] of event.request.headers) { headers[header] = value; } let requestInfo = { url: event.request.url, referrer: event.request.referrer, method: event.request.method, referrerPolicy: event.request.referrerPolicy, headers: headers, created: Date.now() };```
2295	libmanuels.fr.js	Incorrect String Manipulation in Request Body	Medium	true	CWE-707	N/A	N/A	standard	{The `replace()` method is used on `init.body` with a hardcoded string pattern `&idsite=`. This is unsafe because it assumes the body always contains this exact string, and may cause incorrect or unintended modifications if the body format varies, leading to malformed requests or data corruption.}	```init.body = init.body.replace('&idsite=', '&cdo=' + secondsQueuedAgo + '&idsite=');```
2296	libmanuels.fr.js	Potential Denial of Service via Large Queue	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from setting a large queue limit (5000) and long time limit (31 days), which can exhaust storage or processing resources. This is not caused by misuse of a sensitive function but by configuration choices.}	```matomoAnalytics.initialize({ queueLimit: 5000, timeLimit: 3600 * 24 * 31 * 3 });```
2297	libmanuels.fr.js	Reliance on navigator.onLine for Online Status	Medium	false	N/A	N/A	N/A	N/A	{This is a logic flaw in online detection, not a misuse of a sensitive function. The `navigator.onLine` property is used correctly, but its reliability is questionable.}	```let isOnline = navigator.onLine;```
2298	libmanuels.fr.js	Insecure Use of IndexedDB Without Error Handling	Medium	false	N/A	N/A	N/A	N/A	{While IndexedDB is used, the error handling is present (via `onerror`). The issue is more about incomplete error recovery than misuse of a sensitive function.}	```if (!indexedDB) { reject(new Error('No support for IndexedDB')); return; }```
2299	libmanuels.fr.js	Caching of Sensitive Resources	Medium	true	CWE-921	N/A	N/A	standard	{The `caches.open()` and `cache.put()` functions are used to cache responses, including potentially sensitive resources. Without proper validation or sanitization, this can lead to unintended exposure of sensitive data through cache reuse or leakage.}	```caches.open('matomo').then(function (cache) { return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { cache.put(event.request, response.clone()); return response; }); }); });```
2300	cosmocheats.com.js	CSRF Token Handling Based on Client-Controlled Parameter	High	true	N/A	9	fetch	standard	{The vulnerability arises because the service worker intercepts POST requests based on a client-controlled `loggedIn` parameter from the URL. The `fetch` function is used to retrieve a CSRF token dynamically, but the URL for this fetch is constructed using the `path` from the intercepted request, which is derived from the client's request URL. This allows an attacker to manipulate the `path` parameter to trigger unintended CSRF token fetching, potentially leading to token leakage or misuse. The `fetch` function is misused by accepting a dynamically constructed URL without proper validation.}	"```const curRequest = request.clone(); log(""Intercepting guest post request""); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
2301	cosmocheats.com.js	SSRF via Unvalidated Push Data ID	High	true	N/A	10	fetch	standard	{The `fetch` function is used to make a request to a URL constructed from the `id` field in the push notification data. Since this `id` is derived from untrusted external input (push message payload), an attacker can craft a push message with a malicious `id` value to trigger a request to an arbitrary internal or external endpoint, leading to SSRF. The `fetch` function is misused by accepting a dynamically constructed URL without validating or sanitizing the `id` parameter.}	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: ""POST"", credentials: ""include"" })```"
2302	cosmocheats.com.js	Unvalidated Notification URL Leading to Open Redirect/XSS	High	true	N/A	9	clients[0].navigate	standard	{The `navigate` method is called on a client object with a URL derived from the `data.url` field in the notification payload. Since this URL is sourced from untrusted push notification data, an attacker can inject a malicious URL, leading to open redirect or XSS if the URL is interpreted as a script or if it redirects to a phishing site. The `navigate` function is misused by accepting a dynamically constructed URL without validation.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
2303	cosmocheats.com.js	Offline Cache Access Control Bypass	Medium	true	N/A	8	cache.match	standard	{The `cache.match` function is used to retrieve a cached response for the `OFFLINE_URL`, which is a hardcoded value. However, since the service worker does not validate whether the request is legitimate or if the user is authorized to access offline content, an attacker could potentially trigger this logic inappropriately if the service worker is misconfigured or if the `OFFLINE_URL` is exposed via other means. The `cache.match` function is misused by being called without proper context or access control checks.}	```return cache.match(OFFLINE_URL);```
2304	youtube.com.gr.js	Insecure Script Import in Service Worker	Low	false	N/A	N/A	N/A	N/A	N/A	```importScripts('https:\/\/www.youtube.com\/s\/desktop\/d96517c3\/jsbin\/serviceworker-notifications.vflset\/serviceworker-notifications.js');```
2305	qha.com.tr.js	Improper Input Validation (Potential XSS via Untrusted Payload)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing an untrusted payload with JSON.parse(), which is not inherently dangerous unless the parsed data is later used in a context that can execute code (e.g., eval, Function constructor, or DOM injection). In this case, the parsed payload is used to construct a notification object, and the values are passed directly to showNotification(), which does not execute arbitrary code. Therefore, while the input is untrusted, the function JSON.parse() itself is not misused in a way that leads to direct code execution or XSS.}	```const notification = JSON.parse(payload);```
2306	tiktits.com.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamic URL derived from the `url` parameter passed from a client message. Since this URL is not validated or sanitized, an attacker can supply arbitrary URLs (including internal or external endpoints) to trigger SSRF attacks, allowing unauthorized access to internal systems or services.}	```const send = (e, t) => fetch(e, this.getSendOptions(t));```
2307	tiktits.com.js	Insecure IndexedDB Storage	Medium	false	N/A	N/A	N/A	N/A	{The IndexedDB usage is not inherently vulnerable to sensitive function misuse; it is a configuration or design issue related to data storage without proper security controls (e.g., encryption, access restrictions). No sensitive function is misused here.}	```new V('PwaHealthcheckDB', 'PwaHealthcheckStore')```
2308	tiktits.com.js	Insecure Cache Handling	Medium	false	N/A	N/A	N/A	N/A	{The cache handling involves `caches.open` and `e.add`, but these are used with hard-coded, trusted paths (`oe.pwaOffline`, `oe.pwaLoaderMirror`). There is no dynamic or untrusted input involved, so no sensitive function misuse occurs.}	```caches.open(O).then(e => { let t = [e.add(oe.pwaOffline), e.add(oe.pwaLoaderMirror)].map(n => n.catch(i => { console.error(i); })); return Promise.all(t); });```
2309	la1ere.fr.js	Insecure Cache Regex Pattern	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of a broad regex pattern `/\/assets\/.*.js/` to match JavaScript assets for caching. While not caused by a sensitive function misuse, it allows unintended files to be cached, potentially leading to cache poisoning or serving stale content.}	```(0, a.registerRoute)(/\/assets\/.*.js/, new i.StaleWhileRevalidate({ cacheName: l.js, plugins: h() }));```
2310	la1ere.fr.js	Long-Term Cache Without Validation	High	false	N/A	0	N/A	N/A	{This vulnerability stems from setting a very long cache duration (e.g., 31536000 seconds = 1 year) for fonts without proper validation or refresh mechanisms. It is not caused by misuse of a sensitive function but by poor caching policy design.}	```(0, a.registerRoute)(/\/assets\/fonts\/.*.*/, new i.CacheFirst({ cacheName: l.fonts, plugins: h(31536e3) }));```
2311	high-stone.pro.js	Improper Validation of CSRF Token Path	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from the use of the `fetch` function with a dynamically constructed URL derived from `request.url`. The `path` variable is extracted from the URL of the intercepted request, which is user-controlled. This path is then directly interpolated into the URL used to fetch a CSRF token, allowing an attacker to manipulate the `path` parameter to request tokens for unintended endpoints. Since the `fetch` function is used without proper validation or sanitization of the constructed URL, it enables an attacker to potentially forge requests to sensitive endpoints by controlling the `path` parameter, leading to CSRF attacks.}	```const curRequest = request.clone(); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```
2312	cushyspa.com.js	Improper Path Exclusion in Cache Control	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the hardcoded list of paths to ignore (`ignorePaths`) being insufficient or improperly configured, leading to unintended caching of sensitive or administrative paths. This is not due to misuse of a sensitive JavaScript function, but rather a logic or configuration flaw in the cache exclusion policy.}	"```var ignorePaths = [""wp-admin"", ""wp-login"", ""wp-json"", ""wp-includes"", "".txt""];```"
2313	cushyspa.com.js	Insecure Caching of Sensitive Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the route matching logic that allows caching of requests based on URL inclusion checks (`includes`) and hostname matching, which may not be robust enough to prevent caching of sensitive resources. This is a logic flaw in the route definition, not misuse of a sensitive JavaScript function.}	"```j(function (e) { if (!e.url) return !1; var t = e.url.href; return !!t && ""GET"" === e.request.method && !!t.includes(""https"") && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname; }, new F({ plugins: [new Q({ statuses: [0, 200] })] }));```"
2314	szybko.pl.js	Improper URL Filtering in Cache Bypass	High	true	CWE-79	9	N/A	standard	{The vulnerability arises from the improper use of the `every` method on the `neverCacheUrls` array, which is passed the `checkNeverCacheList` function with `e.request.url` as the `this` context. The `checkNeverCacheList` function uses `this.match(url)` to check if the URL matches any of the never-cache patterns. However, `this` is `e.request.url`, a string, and `String.prototype.match` is not designed to perform pattern matching against an array of strings in this context. This leads to incorrect filtering behavior, potentially allowing URLs that should be excluded from caching to be cached. The misuse of `every` with an improperly bound `this` context in a string context causes the vulnerability.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { return; }```
2315	obamacareplans.com.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a risk if the script source is untrusted or compromised. In this case, the script is imported from 'https://api.pushnami.com', which is an external domain. If the domain is compromised or the script is malicious, it can lead to unauthorized code execution within the service worker context, potentially enabling data exfiltration, cache manipulation, or interception of network requests.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5ba1853bf0efd91adca1af0c"");```"
2316	companyofmen.org.js	CSRF Vulnerability due to Flawed Authentication Check	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter, which is then used to conditionally skip CSRF protection. Since this value is derived from the URL (user-controlled input) and not validated against a secure session state, an attacker can manipulate the URL to bypass authentication checks, leading to CSRF attacks. The `match()` function itself is not inherently dangerous, but its misuse with untrusted input to control security logic constitutes sensitive function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2317	companyofmen.org.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	10	N/A	standard	{The `navigate()` method is used with `data.url`, which is derived from a push notification payload. Since this payload is controlled by the server and potentially by an attacker (if the server is compromised or if notifications are spoofed), the `navigate()` function can be exploited to redirect users to arbitrary URLs, leading to open redirect vulnerabilities. The `navigate()` method is a standard browser API and is sensitive when used with untrusted input.}	```clients[0].navigate(data.url);```
2318	companyofmen.org.js	Insecure CSRF Token Handling	High	true	CWE-352	8	N/A	standard	{The `fetch()` function is used to retrieve a CSRF token from the server using a URL constructed from `path`, which is derived from the request URL. Since `path` is user-controlled (via the original request), an attacker can manipulate it to trigger unintended CSRF token generation or retrieval, potentially leading to token leakage or misuse. The `fetch()` function is standard but becomes sensitive when used with untrusted input to make server requests.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key);```
2319	fikriyat.com.js	Open Redirect via Unvalidated Notification URLs	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL provided in the notification payload without validation. Since the URL is derived from user-controlled data (event.notification.data.payload.FirstButtonLink, SecondButtonLink, or url), an attacker can craft a notification with a malicious URL, leading to open redirect and potential phishing or malware delivery.}	N/A
2320	fikriyat.com.js	Open Redirect via Unvalidated Notification URLs	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL provided in the notification payload without validation. Since the URL is derived from user-controlled data (event.notification.data.payload.SecondButtonLink), an attacker can craft a notification with a malicious URL, leading to open redirect and potential phishing or malware delivery.}	N/A
2321	fikriyat.com.js	Open Redirect via Unvalidated Notification URLs	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL provided in the notification payload without validation. Since the URL is derived from user-controlled data (url), an attacker can craft a notification with a malicious URL, leading to open redirect and potential phishing or malware delivery.}	N/A
2322	fikriyat.com.js	Improper Handling of Malicious Image URL	Medium	true	CWE-80	8	notificationOptionImage = notification.Image;	custom	{The notification.Image value is assigned to notificationOptionImage without sanitization or validation. If an attacker supplies a malicious URL (e.g., a data URI or script-injecting image), it could lead to XSS or other client-side attacks when rendered in the notification.}	N/A
2323	fikriyat.com.js	Exposure of Sensitive Information via API Key	Medium	false	CWE-532	0	N/A	N/A	{The API key is hardcoded in the script and exposed in the source code, but this is not caused by misuse of a sensitive function. It is a static data exposure issue.}	N/A
2324	88db.com.hk.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (API key, authDomain, etc.) in the script, not from misuse of a sensitive JavaScript function.}	"```var config = { apiKey: ""AIzaSyDBR82k9-Fl8ylwzxQG_CYyRx3VYjxI2sw"", authDomain: ""db88dekstop.firebaseapp.com"", databaseURL: ""https://db88dekstop.firebaseio.com"", storageBucket: ""db88dekstop.appspot.com"", messagingSenderId: ""796251515607"" };```"
2325	88db.com.hk.js	Open Redirect Vulnerability	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamically constructed URL derived from untrusted input (payloadCustom.inviteID, payloadCustom.responseID, etc.), allowing an attacker to craft a malicious URL that redirects users to arbitrary domains, leading to open redirect.}	```if (clients.openWindow) return clients.openWindow(data.url);```
2326	88db.com.hk.js	Insecure URL Handling	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a URL that is derived from untrusted input (data.url), which may be manipulated by an attacker to redirect users to unintended or malicious sites, resulting in insecure URL handling.}	```if (clients.openWindow) return clients.openWindow(data.url);```
2327	88db.com.hk.js	Improper Input Validation	Medium	true	N/A	N/A	JSON.parse	standard	{The function JSON.parse is used on untrusted input (payload.data.notification and payload.data.payload) without validation or sanitization, which may lead to injection or unexpected behavior if the input is malformed or malicious.}	```var notification = JSON.parse(payload.data.notification); var payloadCustom = JSON.parse(payload.data.payload);```
2328	agoradesk.com.js	Case-Sensitive Header Check Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a case-sensitive check for the 'content-security-policy' header, which can be bypassed by using a differently cased header name (e.g., 'Content-Security-Policy'). This is not caused by misuse of a sensitive JavaScript function, but rather by a logic flaw in header validation.}	```if (!headers.has('content-security-policy')) {```
2329	gamezy.com.js	"Cache Poisoning via CacheFirst Strategy for ""/_nuxt/"""	High	true	CWE-209	9	N/A	standard	"{The use of workbox.routing.registerRoute with a CacheFirst strategy for the ""/_nuxt/"" pattern without proper validation or sanitization of the URL pattern allows an attacker to potentially cache malicious content if the pattern is exploited via crafted requests, leading to cache poisoning. The sensitive function workbox.routing.registerRoute is standard and is misused by applying a broad, unvalidated pattern that could be manipulated to cache unintended or malicious resources.}"	```workbox.routing.registerRoute(urlPattern, strategy, method);```
2330	gamezy.com.js	Information Leakage via Detailed Error Logging	Medium	true	CWE-209	8	N/A	standard	{The console.error function is used to log detailed error messages including ctx.error and ctx details, which may expose sensitive internal information such as stack traces, request URLs, or server-side logic to the console. This is a misuse of the standard console.error function, which should not be used to log sensitive data in production environments, especially when errors are triggered by user-controlled inputs.}	```console.error(ctx.error, 'Details:', ctx);```
2331	gamezy.com.js	Cache First Without Validation	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not directly caused by misuse of a sensitive function but rather by the lack of validation in the CacheFirst strategy configuration. The code does not use any inherently dangerous functions with untrusted input; instead, the issue stems from a design flaw in the caching strategy.}	```self.addEventListener(fetch```
2332	visit.bg.js	Race Condition in Cache Deletion During Service Worker Activation	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the improper handling of cache deletion during activation, where all caches are deleted without checking if they are outdated or unnecessary. This is not due to misuse of a sensitive function, but rather a logic flaw in cache management.}	```self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (names) { for (let name of names) caches.delete(name); })); });```
2333	mylupusteam.com.js	Improper Handling of Dynamic Content in Cache	High	true	CWE-921	10	N/A	standard	{The vulnerability arises from the use of `cache.addAll()` with a hardcoded list of URLs, including '/users/get_badge_count', which is fetched and cached during installation. While the URLs are not dynamic in this specific case, the vulnerability classification implies a risk if such URLs were derived from untrusted sources. However, since the URLs are hardcoded and not influenced by user input or external parameters, the misuse is not directly caused by a sensitive function. Therefore, the initial detection may be misleading. But if we interpret the vulnerability as a potential for future dynamic URL injection (e.g., if the URL were derived from a variable), then `cache.addAll()` could be considered sensitive in such a context. Given the current code, the function is not misused with dynamic input, so the vulnerability is not truly sensitive.}	```self.addEventListener('install', function (e) { e.waitUntil(caches.open('mht-pwa').then(function (cache) { return cache.addAll(['/pwa_offline.html', '/users/get_badge_count']); })); });```
2334	livejumping.com.js	Weak Hashing Algorithm	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of SHA-1, a cryptographic hash function that is considered weak and susceptible to collision attacks. While SHA-1 is not a sensitive function in the context of direct input sanitization or dynamic execution (like importScripts or eval), its misuse here constitutes a cryptographic weakness rather than a direct sensitive function misuse. The function `sha1` is custom and used to hash the manifest, but the issue is the algorithm choice, not improper use of a sensitive API.}	```const hashManifest = (manifest) => sha1(JSON.stringify(manifest));```
2335	colmar.fr.js	Code Injection via Untrusted importScripts	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to importScripts() is constructed using untrusted or dynamic input (e.g., from query parameters or user-controlled data), it allows an attacker to inject and execute arbitrary scripts. In this case, although the URL is hardcoded, the presence of a query parameter (e.g., ?sjngpv) suggests potential for dynamic input in similar contexts. However, since the URL is static and not derived from untrusted sources, the risk is mitigated. But if this pattern were extended to dynamic inputs (e.g., from location.search), it would become a critical vulnerability.}	"```importScripts(""/modules/custom/advanced_pwa/js/service_worker.js?sjngpv"");```"
2336	bezokularow.pl.js	Insecure External Script Loading	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (cdn.pushpushgo.com). If the remote script is compromised or modified, it can execute arbitrary code within the context of the service worker, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the use of importScripts with any external source is considered sensitive due to the trust boundary it crosses.}	```importScripts('https://cdn.pushpushgo.com/593e63bd367290002dbccae8/worker.js');```
2337	fordedgeforum.com.js	Improper Input Validation in Authentication Check	High	true	CWE-20	9	RegExp.prototype.match	standard	{The code uses `match(/loggedIn=(true|false)/)` on `e.currentTarget.location.href`, which is a dynamic URL string. This is not inherently a sensitive function misuse, but the vulnerability arises from improper validation of the extracted `loggedIn` value. However, since the `match` function is being used to parse untrusted input (the URL) and the result is directly used in a conditional without sanitization or validation, it qualifies as sensitive function misuse due to the potential for injection or bypass if the URL is manipulated. For example, an attacker could craft a URL with `loggedIn=1` or `loggedIn=true&other=malicious`, causing `matches[1]` to be `1` or `true`, but the code does not validate that the value is strictly 'true' or 'false'. This could lead to bypassing authentication checks.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2338	youtube.ee.js	Exposure of Sensitive Information (API Key in Client-Side Code)	High	true	CWE-532	10	N/A	N/A	{The vulnerability arises from hardcoding the INNERTUBE_API_KEY directly in the client-side JavaScript code. This is not caused by misuse of a sensitive function like importScripts() or eval(), but rather by exposing sensitive credentials in plaintext within the script. Since no dynamic or unsafe function is being misused to inject or load the key, this is not a case of sensitive function misuse.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', 'INNERTUBE_API_VERSION': 'v1', 'INNERTUBE_CLIENT_NAME': 'WEB', 'INNERTUBE_CLIENT_VERSION': '2.20241111.01.00', ... });```
2339	lyra-network.in.js	Improper Cache Validation (Cache Poisoning Risk)	High	true	N/A	N/A	JSON.parse	standard	{The JSON.parse() function is used to parse a string containing a list of regex patterns, which are then converted into RegExp objects. While JSON.parse() itself is not inherently dangerous, its misuse here introduces a risk: if the string being parsed is derived from untrusted or dynamic input (e.g., from a configuration file or user-controlled source), it could be manipulated to inject malicious regex patterns. These patterns could then be used to match unintended URLs, leading to cache poisoning where attackers can force the service worker to cache malicious or unintended responses. Although the string is hardcoded in this case, the pattern of using JSON.parse() on potentially dynamic strings is a known vector for injection attacks.}	"```const c = JSON.parse('[""lyra-network\\\\.in(?:/.*)?/ola/services/.*"",""lyra-network\\\\.in/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://a8208cf3-3daa-4a5e-b92c-2c928929b61f\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e))```"
2340	lyra-network.in.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly long cache expiration times (1 year and 30 days) which increase the risk of serving stale or outdated content. However, this is not caused by the misuse of a sensitive JavaScript function. The ExpirationPlugin is used correctly, and the issue is a configuration flaw rather than a functional misuse.}	```new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })```
2341	lyra-network.in.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly long cache expiration times (30 days) which increase the risk of serving stale or outdated content. However, this is not caused by the misuse of a sensitive JavaScript function. The ExpirationPlugin is used correctly, and the issue is a configuration flaw rather than a functional misuse.}	```new n.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 2592e3 })```
2342	aufamily.com.js	Vulnerable Login Status Check	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of the `loggedIn` state derived from the URL query parameter, not from misuse of a sensitive JavaScript function. The code checks `loggedIn == 'true'` without validating or sanitizing the source of the value, which could be manipulated via URL tampering. However, no sensitive function like `eval`, `importScripts`, `fetch` with dynamic URLs, or similar is misused here. The issue is a logic flaw in state validation, not a sensitive function misuse.}	```const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2343	youtube.co.ma.js	Incorrect use of self.document and self.window in Service Worker	High	false	New	N/A	N/A	N/A	{The assignment of self.document and self.window to self is a misconfiguration in a Service Worker context, as Service Workers do not have access to the DOM or window object. This does not involve misuse of a sensitive function but rather incorrect assumptions about the Service Worker environment.}	```self.document = self; self.window = self;```
2344	youtube.co.ma.js	Hardcoded API key in client-side code	Medium	false	CWE-532	N/A	N/A	N/A	{The hardcoded API key is a security issue due to exposure in client-side code, but it is not caused by misuse of a sensitive JavaScript function. It is a static data exposure issue.}	```'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'```
2345	youtube.co.ma.js	Trusted Types policy with fixed URL	Medium	true	CWE-116	N/A	importScripts	standard	{The importScripts function is used to load a script, and although the URL is fixed and not derived from untrusted input, the use of Trusted Types policy with a hardcoded URL does not prevent misuse if the policy is bypassed or misconfigured. However, since the URL is fixed and not dynamic, the risk is mitigated. The function itself is sensitive because it can execute arbitrary scripts if given a dynamic URL.}	```var policy = self.trustedTypes.createPolicy('youtubeServiceWorkerPolicy', { createScriptURL: function (unused) { return 'https:\/\/www.youtube.com\/s\/desktop\/d96517c3\/jsbin\/serviceworker-notifications.vflset\/serviceworker-notifications.js'; } }); importScripts(policy.createScriptURL(''));```
2346	roocket.ir.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL that is dynamically constructed from the notification data. Since the URL is derived from user-controlled data (t.url), an attacker can manipulate the notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	"```self.addEventListener(""notificationclick"", function (i) { var t = i.notification.data; i.notification.close(); var o = ""https://user.roocket.ir/notifications""; t.hasOwnProperty(""url"") && (o = t.url), clients.openWindow(o); });```"
2347	nordicoil.co.uk.js	Loading untrusted external script without integrity check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to load a script from a remote CDN with a dynamically appended timestamp parameter (t=last_updated). While the URL is hardcoded to a trusted domain (cdn.pushalert.co), the lack of an integrity check (e.g., Subresource Integrity) means that if the CDN is compromised or the script is tampered with, the service worker could execute malicious code. This constitutes a high-risk vulnerability because the script is loaded without verification, and the dynamic parameter does not introduce user-controlled input but still allows for potential supply chain attacks.}	"```importScripts(""https://cdn.pushalert.co/sw-external-payload.js?t="" + last_updated);```"
2348	halodoctor.pl.js	External Script Import Without Integrity Check	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is imported from a third-party domain (pushpushgo.com), which could be compromised or malicious, leading to arbitrary code execution within the service worker context. This is a high-risk vulnerability because the service worker can intercept network requests, manipulate cache, and potentially exfiltrate data.}	```importScripts('https://s-eu-1.pushpushgo.com/67220ed9f85cd441bd818708/worker.js');```
2349	wallester.com.js	Improper Neutralization of Special Elements in Regular Expressions (Regex Injection)	High	true	CWE-73	9	N/A	standard	{The vulnerability arises from the use of `new RegExp()` with a string constructed from `location.origin`, which is user-controllable via the URL. Since `location.origin` is directly interpolated into the regex pattern without sanitization, an attacker can craft a URL with malicious characters (e.g., `.` or `*`) that alter the intended regex behavior, leading to unintended matches or denial of service. This misuse of the standard `RegExp` constructor with untrusted input constitutes a regex injection vulnerability.}	"```if (!self.define) { let e, s = {}; const n = (n, t) => (n = new URL(n + "".js"", t).href, s[n] || new Promise(s => { if (""document"" in self) { const e = document.createElement(""script""); e.src = n, e.onload = s, document.head.appendChild(e); } else e = n, importScripts(n), s(); }).then(() => { let e = s[n]; if (!e) throw new Error(`Module ${n} didn’t register its module`); return e; })); self.define = (t, o) => { const i = e || (""document"" in self ? document.currentScript.src : """") || location.href; if (s[i]) return; let r = {}; const c = e => n(e, i), a = { module: { uri: i }, exports: r, require: c }; s[i] = Promise.all(t.map(e => a[e] || c(e))).then(e => (o(...e), r)); }; } define([""./workbox-e790ac22""], function (e) { ""use strict""; e.setCacheNameDetails({ prefix: ""wa"" }), self.skipWaiting(), e.clientsClaim(), e.registerRoute(({ request: e, url: s }) => new RegExp(`^(${location.origin})(\\/(?:js|css)\\/.*)\\.(?:css|js)(\\?.*)?$`).test(e.url), new e.CacheFirst({ cacheName: ""wa-1721819839-assets"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 3600, maxEntries: 60 }), new e.CacheableResponsePlugin({ statuses: [200, 206] })] }), ""GET""), e.registerRoute(({ request: e, url: s }) => new RegExp(`^(${location.origin})(\\/img\\/.*)\\.(svg)(\\?|.#)?(.*)?$`).test(e.url), new e.CacheFirst({ cacheName: ""wa-1721819839-svg"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 3600, maxEntries: 60 }), new e.CacheableResponsePlugin({ statuses: [200, 206] })] }), ""GET""), e.registerRoute(({ request: e, url: s }) => new RegExp(`^(${location.origin})(\\/svg\\/.*)\\.(json)(\\?.*)?$`).test(e.url), new e.CacheFirst({ cacheName: ""wa-1721819839-json-svg"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 3600, maxEntries: 40 }), new e.CacheableResponsePlugin({ statuses: [200, 206] })] }), ""GET""), e.registerRoute(({ request: e, url: s }) => new RegExp(`^(${location.origin})(\\/font\\/.*)\\.(woff2?)(\\?.*)?$`).test(e.url), new e.CacheFirst({ cacheName: ""wa-1721819839-font"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 3600, maxEntries: 20 }), new e.CacheableResponsePlugin({ statuses: [200, 206] })] }), ""GET""), self.__WB_DISABLE_DEV_LOGS = !0; });```"
2350	industrialcamera.com.js	Improper Validation of Cache Keys Leading to Cache Poisoning	High	true	N/A	N/A	URL	standard	{The URL constructor is used to parse a potentially untrusted URL from the request, and the origin is extracted without validating whether it matches the expected origin. This allows an attacker to supply a malicious origin, leading to cache poisoning where responses from unintended domains are cached under the service worker's control.}	```const s = new URL(e.url).origin;```
2351	industrialcamera.com.js	Insecure Handling of Request URLs Leading to SSRF	High	true	N/A	N/A	Request	standard	{The Request constructor is used with untrusted input (t) without validation, allowing an attacker to craft a request to internal or external resources. This can lead to Server-Side Request Forgery (SSRF) if the service worker makes network requests on behalf of the client to unintended destinations.}	```const s = new Request(...t);```
2352	industrialcamera.com.js	Insufficient Validation of Precached URLs	Medium	true	N/A	N/A	i	standard	{The function i is used to process precache entries, which may include untrusted URLs. The function parses and normalizes URLs without sufficient validation, potentially allowing attackers to inject malicious URLs into the precache, leading to cache poisoning or unintended resource loading.}	```const { cacheKey, url } = i(s);```
2353	industrialcamera.com.js	Insecure Cache Key Generation from Untrusted Input	High	true	N/A	N/A	URL	standard	{The URL constructor is used to generate a cache key from an untrusted input (e), which is derived from the request URL. Without proper sanitization or validation, this allows attackers to manipulate the cache key, leading to cache poisoning or bypassing cache integrity checks.}	```const s = new URL(e, location.href);```
2354	industrialcamera.com.js	Insecure Use of Dynamic Cache Names	Medium	true	N/A	N/A	undefined	standard	{The cacheName is dynamically derived from configuration or input without validation, and is used directly in cache operations. This allows an attacker to manipulate the cache name, potentially leading to cache poisoning or unauthorized access to cache data if the cache name is derived from untrusted sources.}	```const { cacheName } = this._strategy;```
2355	elitefourum.com.js	Improper Neutralization of User Input for Web Page (XSS)	High	true	CWE-79	N/A	fetch	standard	{The `fetch` function is used to send a POST request with user-provided `t.reply` directly interpolated into the request body without sanitization. This allows an attacker to inject malicious content (e.g., script tags) into the message payload, which may be rendered in the context of the target application, leading to XSS if the response is reflected in the UI.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
2356	elitefourum.com.js	Missing CSRF Token in Request	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of a CSRF token in the request headers. The `fetch` call does include the token when available, but the logic depends on prior successful retrieval of the token, which may not always occur. This is a logic or design flaw, not a direct misuse of a sensitive function.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
2357	hostlico.com.js	Improper Input Validation Leading to Denial of Service	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper validation of the 'range' header in HTTP requests, specifically when parsing the byte range using a regex and converting it to a number. While the `Number()` function is used, it is not inherently sensitive in this context — the issue stems from insufficient input sanitization and lack of bounds checking on the parsed value, which could lead to out-of-bounds memory access or excessive resource consumption if maliciously crafted range headers are sent. This is not misuse of a sensitive function per se, but rather a logic flaw in input handling.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
2358	ean.org.js	External Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to load a script from a hardcoded external domain (https://api.signalize.com/sw.js). While the URL is hardcoded and not dynamically constructed from untrusted input, the act of loading and executing external code in a Service Worker context introduces a high-risk vulnerability. If the external script is compromised or controlled by an attacker, it can subvert the service worker’s behavior, leading to cache manipulation, network interception, or data exfiltration. This constitutes a sensitive function misuse because importScripts() inherently executes arbitrary code, and its use with any external source—regardless of static URL—poses a security risk.}	"```self.importScripts(""https://api.signalize.com/sw.js"");```"
2359	malikmobile.com.js	Improper Validation of Dynamic Offline Fallback Page	High	true	CWE-790	N/A	self.addEventListener('refreshOffline', function (event) { const offlineFallbackPage = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { console.log('PWA Builder' + response.url); return cache.put(offlineFallbackPage, response); }); }); });	standard	{The `fetch` function is used with a dynamically constructed `Request` object derived from the `offlineFallbackPage` variable, which is defined at the top-level scope. If this variable is manipulated or overridden (e.g., via a malicious script injection or dynamic assignment), it could point to an arbitrary URL, allowing an attacker to fetch and cache unintended or malicious content. This misuse of `fetch` with untrusted input leads to improper validation of the offline fallback page, potentially enabling cache poisoning or unauthorized resource loading.}	```self.addEventListener('refreshOffline', function (event) { const offlineFallbackPage = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { console.log('PWA Builder' + response.url); return cache.put(offlineFallbackPage, response); }); }); });```
2360	youtube.com.co.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the hardcoded exposure of the INNERTUBE_API_KEY in the ytcfg object, which is not due to misuse of any sensitive JavaScript function. The key is directly embedded in the source code, making it accessible to anyone inspecting the script. This is a static secret leakage issue, not a dynamic function misuse.}	```var ytcfg = { 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... }```
2361	bmw-motorsport.com.js	Cache Poisoning via Improper Regex Construction	High	true	CWE-434	9	RegExp	standard	{The code constructs a regular expression dynamically by concatenating a string literal (bmwcomRegExp) with additional pattern components. Since the base pattern is hardcoded and not derived from untrusted input, the vulnerability is not due to direct user-controlled input. However, the improper construction of the regex via string concatenation introduces a risk of unintended pattern matching or cache poisoning if the base pattern were to be modified or if similar logic were applied to user-supplied data. The use of RegExp with concatenated strings is considered a sensitive operation because it can lead to regex injection or unintended behavior if not properly sanitized.}	```const bmwcomRegExp = '/(bmwcom|marketBMWCOM|marketBMW_M)/.+'; workbox.routing.registerRoute(new RegExp(bmwcomRegExp + '\.(?:woff|woff2)$'), new workbox.strategies.CacheFirst({ cacheName: 'fonts-cache' }));```
2362	youtube.ly.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the hardcoded API key in the configuration object, not due to misuse of a sensitive JavaScript function. The API key is stored directly in the code and is not dynamically constructed or passed to a function that could lead to injection or execution of untrusted code.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
2363	rapidwebapp.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it imports a script from a hardcoded, trusted domain (https://www.rapidwebapp.com). However, since the URL is not dynamically constructed from untrusted input (e.g., user-controlled parameters), the risk of remote code execution via untrusted script import is mitigated. The vulnerability reported is based on the assumption that the imported script may be compromised, but the function misuse itself is not sensitive due to lack of dynamic, untrusted input. Therefore, while the vulnerability exists, it is not caused by sensitive function misuse.}	```importScripts('https://www.rapidwebapp.com/wp-content/plugins/letspush/js/letspush_service_worker.min.js');```
2364	youtube.tn.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the hardcoded exposure of the INNERTUBE_API_KEY in client-side JavaScript, which is not due to misuse of a sensitive function but rather poor configuration management. The key is directly embedded in the code and accessible to any user inspecting the script, enabling unauthorized access to YouTube’s backend APIs.}	```var ytcfg = { 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'```
2365	espatial.com.js	Improper Input Validation - Untrusted URL Handling	High	true	CWE-20	9	decodeURIComponent	standard	{The decodeURIComponent function is used to decode a URL parameter value obtained from the query string (paramsList['site-url']), which is derived from self.location.href. While decodeURIComponent itself is not inherently dangerous, its misuse here stems from the fact that the decoded value is stored in siteURL without any validation or sanitization. This allows an attacker to supply a malicious URL via the query parameter, potentially leading to unintended behavior if siteURL is later used in a context that executes or loads remote resources (e.g., importScripts, fetch, or dynamic script loading). Although no direct sensitive function is called with siteURL in this snippet, the improper handling of untrusted input via decodeURIComponent creates a foundation for future exploitation, especially if siteURL is used in a context that triggers remote code execution or resource loading.}	"```var siteURL = !0 === paramsList.hasOwnProperty(""site-url"") ? decodeURIComponent(paramsList[""site-url""]) : """";```"
2366	hannoversche.de.js	Remote Code Execution via Dynamic Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a given URL. In this case, the URL is constructed by concatenating a base URL with location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts, leading to remote code execution within the service worker context.}	```importScripts(`https://hannoversche.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
2367	friscowebsites.com.js	Broad Regex Pattern in Cache Strategy	High	true	New	N/A	RegExp	standard	{The use of a broad regex pattern /.*?jquery.*?(?:\.min)?\.js.*?/ in workbox.routing.registerRoute can unintentionally match and cache unintended resources, potentially leading to cache poisoning or serving stale content. The regex is overly permissive and may match URLs not intended for caching, which is a misuse of the RegExp API in a security-sensitive context.}	```workbox.routing.registerRoute(/.*?jquery.*?(?:\.min)?\.js.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
2368	friscowebsites.com.js	Insecure URL Handling in addParams	Medium	true	CWE-601	N/A	URL	standard	{The function addParams uses the URL constructor with untrusted input, which can lead to open redirects or unintended URL manipulations if the input is not properly validated. The URL API is sensitive because it can be abused to construct malicious URLs when given untrusted data, especially when combined with searchParams.set.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
2369	friscowebsites.com.js	No-CORS Mode in Prefetch Request	Medium	true	CWE-434	N/A	fetch	standard	{The fetch API is used with mode: 'no-cors', which prevents the browser from sending credentials and limits the response to opaque, potentially leading to data leakage or unexpected behavior when handling cross-origin requests. This misuse of fetch with no-cors mode can result in unintended data exposure or failure to handle responses properly.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
2370	friscowebsites.com.js	Empty Fetch Event Listener Override	High	true	New	N/A	addEventListener	standard	{The addEventListener for 'fetch' is overridden with an empty function, which can lead to bypassing intended caching or security logic in the service worker. This misuse of addEventListener with a no-op handler can disable critical network interception and caching behavior, creating a denial-of-service or security bypass.}	```self.addEventListener('fetch', () => {});```
2371	friscowebsites.com.js	Debug Logging in Production	Low	false	CWE-200	N/A	N/A	N/A	{The log function conditionally outputs debug information, but since pwaSettings.debug is set to true, it may leak sensitive information in production. However, this is not caused by misuse of a sensitive function, but rather by misconfiguration.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
2372	vixo.store.js	Caching responses with status 0 (non-HTTP responses) for Google Fonts	Medium	false	New	0	N/A	N/A	{The vulnerability arises from the configuration of the CacheableResponsePlugin to accept responses with status 0, which corresponds to non-HTTP responses (e.g., from service workers or opaque responses). While this is not caused by misuse of a sensitive function like importScripts or eval, it is a misconfiguration that could allow unintended caching of non-HTTP responses, potentially leading to inconsistent behavior or security issues if such responses are later used inappropriately.}	```const a = new a.CacheableResponsePlugin({ statuses: [0, 200] })```
2373	oneskin.co.js	Improper URL Validation Leading to SSRF and Cache Poisoning	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of regular expressions (CDN_URL_REGEX and LEGACY_URL_REGEX) to validate URLs without proper sanitization or context-aware checks. While no direct sensitive function like importScripts() or eval() is used, the fetch() function is invoked with unvalidated URLs that may be controlled by an attacker. Since fetch() is a standard JavaScript API that can make network requests to arbitrary endpoints, and the code caches responses without validating the origin or content, an attacker could craft a malicious URL that tricks the service worker into fetching and caching data from internal or unintended endpoints (SSRF) or injecting malicious content (cache poisoning). The lack of strict URL validation allows bypasses, making this misuse of the fetch() function a sensitive operation when combined with untrusted input.}	```if (CDN_URL_REGEX.test(url) || LEGACY_URL_REGEX.test(url)) {```
2374	thexpos.net.js	Vulnerable Cache Busting Mechanism	High	true	N/A	N/A	cacheBust	custom	{The cacheBust function constructs a URL by appending a random string to the input URL without validating or sanitizing the input. This allows an attacker to manipulate the base URL to trigger unintended cache-busting behavior, potentially leading to cache poisoning or bypassing security checks. The function uses dynamic input (url) to build a URL, which is a classic case of unsafe URL construction.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
2375	thexpos.net.js	Insufficient URL Normalization	Medium	false	N/A	N/A	N/A	N/A	{The normalizeUrl function parses and normalizes URLs, but it does not adequately validate or sanitize inputs, potentially allowing for URL manipulation. However, this is not due to misuse of a sensitive function, but rather a design flaw in URL handling logic.}	```normalizeUrl(url) { const parsed = this.parseUrl(url, this.scopeUrl); return parsed.origin === this.origin ? parsed.path : url; }```
2376	thexpos.net.js	Debug Endpoint Information Disclosure	Medium	false	N/A	N/A	N/A	N/A	{The debug endpoint exposes internal state and logs, but this is not caused by misuse of a sensitive function. It is a design decision to expose debug information, not a function misuse vulnerability.}	```handleFetch(req) { const [state, versions, idle] = await Promise.all([this.driver.debugState(), this.driver.debugVersions(), this.driver.debugIdleState()]); const msgState = `NGSW Debug Info:...```
2377	thexpos.net.js	Insecure Hash Validation	Medium	false	N/A	N/A	N/A	N/A	{The hash validation checks if the hash from the manifest matches the fetched resource, but this is not due to misuse of a sensitive function. It is a logic flaw in validation, not a function misuse.}	```if (this.hashTable.get(url) !== hash) { return null; }```
2378	thexpos.net.js	Unvalidated Redirect Handling	Medium	false	N/A	N/A	N/A	N/A	{The fetchFromNetwork function handles redirects recursively, but this is not due to misuse of a sensitive function. It is a design choice to follow redirects, not a function misuse vulnerability.}	"```async fetchFromNetwork(req, redirectLimit = 3) { const res = await this.cacheBustedFetchFromNetwork(req); if (res[""redirected""] && !!res.url) { if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`); } return this.fetchFromNetwork(this.newRequestWithMetadata(res.url, req), redirectLimit - 1); } return res; }```"
2379	thexpos.net.js	Insecure Error Logging	Low	false	N/A	N/A	N/A	N/A	{The error logging function logs errors without sanitizing or filtering sensitive data, but this is not due to misuse of a sensitive function. It is a design flaw in logging, not a function misuse.}	"```log(value, context = """") { if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) { this.debugLogB = this.debugLogA; this.debugLogA = []; } if (typeof value !== ""string"") { value = this.errorToString(value); } this.debugLogA.push({ value, time: this.adapter.time, context }); }```"
2380	trace.moe.js	XSS via cached user-controlled content	High	true	CWE-79	10	Response	standard	{The Response constructor is used to create a response object from a user-controlled file stream without sanitization. Since the file content is directly streamed into the response and cached, an attacker can inject malicious content (e.g., JavaScript) into the file, which may be executed when the cached resource is later served to users, leading to XSS.}	```const response = new Response(file.stream(), { headers });```
2381	trace.moe.js	Open Redirect via malformed URL	Medium	true	CWE-601	10	Response.redirect	standard	{The Response.redirect function is used with a URL constructed from user-controlled input (event.request.url), which is concatenated with a hardcoded string. This allows an attacker to craft a request URL that results in a redirect to an arbitrary location, potentially leading to phishing or open redirect attacks.}	```return Response.redirect(`${event.request.url}?url=${event.request.url}temp.image`, 302);```
2382	sviesolutions.com.js	Insecure Cache Name (HTTP instead of HTTPS	High	false	N/A	N/A	N/A	N/A	{The cache name is hardcoded with an HTTP scheme, which may lead to insecure caching behavior or misdirection in environments enforcing HTTPS. However, this is not caused by misuse of a sensitive function, but rather a configuration issue.}	```const cacheName = 'http://www.sviesolutions.com-superpwa-2.2.31';```
2383	sviesolutions.com.js	Potential Cache Poisoning via Improper URL Validation	High	false	N/A	N/A	N/A	N/A	{The URL origin check uses new URL(e.request.url).origin, which is a standard and safe operation. The vulnerability arises from the logic not being comprehensive enough to prevent cache poisoning, not from misuse of a sensitive function.}	```if (new URL(e.request.url).origin !== location.origin) return;```
2384	sviesolutions.com.js	Improper Range Request Handling Leading to DoS	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from improper parsing of the Range header using a regex, which could lead to DoS if malformed inputs are processed. However, this is not due to misuse of a sensitive function, but rather flawed input handling logic.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
2385	sviesolutions.com.js	Caching Sensitive Non-GET Requests	High	false	N/A	N/A	N/A	N/A	{The code caches responses for non-GET requests only if they fail, but the issue is in the logic design, not in the misuse of a sensitive function. The fetch() and caches.match() functions are used appropriately.}	```if (e.request.method !== 'GET') { e.respondWith(fetch(e.request).catch(function () { return caches.match(offlinePage); })); return; }```
2386	asppa.org.js	Improper Route Matching	High	true	N/A	9	match	standard	{The use of `match()` with a dynamic route pattern derived from `routesToIgnoreArray[i]` allows for improper or incomplete URL matching. Since the routes are constructed from a string split from a hardcoded list and not validated or sanitized, an attacker could potentially craft a URL that bypasses the intended route filtering, leading to unintended resource access or cache manipulation.}	```if (request.url.match(routesToIgnoreArray[i])) { return false; }```
2387	asppa.org.js	Open Redirect via Notification URL	High	true	N/A	10	clients.openWindow	standard	{The `clients.openWindow(url)` function is called with a URL derived from the `payload.url` field in a push notification, which is user-controlled via the `event.data.text()` and `JSON.parse()`. This allows an attacker to inject arbitrary URLs, leading to open redirect vulnerabilities where users are redirected to malicious sites.}	```event.waitUntil(clients.openWindow(url));```
2388	asppa.org.js	Insecure Handling of Push Payload	Medium	true	N/A	9	JSON.parse	standard	{The `JSON.parse(payload)` function is used to parse untrusted data from a push notification payload without validation or sanitization. This can lead to injection or logic manipulation if the payload contains malicious or malformed JSON, potentially affecting downstream operations like URL redirection or notification display.}	```var parsedData = JSON.parse(payload);```
2389	wgihuntsmart.com.js	Insecure External Script Import	High	true	New	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (https://aswpsdkus.com/notify/v1/ua-sdk.min.js), it introduces a risk if the external script is compromised or if the domain is not fully trusted. Although the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing external code from a third-party domain still constitutes a security risk, especially if the script can be modified by an attacker. This is considered a sensitive function misuse because it allows execution of untrusted code in the context of the service worker.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
2390	wgihuntsmart.com.js	Hardcoded Sensitive Information	Medium	false	CWE-798	N/A	N/A	N/A	{The appKey and token values are hardcoded in the script, but they are not the result of misuse of a sensitive function. These are static values embedded in the code, and their exposure is due to poor secret management rather than improper use of a JavaScript function.}	```appKey: 'F261oqUIRIqVY4g5K7vzrA',```
2391	wgihuntsmart.com.js	Hardcoded Sensitive Information	Medium	false	CWE-798	N/A	N/A	N/A	{The token value is hardcoded in the script, but it is not the result of misuse of a sensitive function. This is a static secret embedded in the code, and its exposure is due to poor secret management rather than improper use of a JavaScript function.}	```token: 'MTpGMjYxb3FVSVJJcVZZNGc1Szd2enJBOnQ3TEl3Ty1XRDNsQ2NQOXI1SE9VSm5ZSEZJN1hTVnh4V3pjdVdMbFFuVDQ',```
2392	i-active.be.js	Improper Validation of URL in Notification Data Leading to Open Redirect	Medium	true	CWE-601	9	fetch	standard	{The fetch function is used with a URL derived from event.notification.data.update, which is user-controlled data. Since no validation or sanitization is performed on this URL, an attacker can supply a malicious URL, leading to an open redirect or unintended network requests.}	```hurl = event.notification.data.update; if (hurl) { hurl = hurl + '&paction=CLICKED'; fetch(hurl).then(function (response) {}).catch(function (err) {});```
2393	i-active.be.js	Improper Validation of URL in Notification Data Leading to Open Redirect	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with event.notification.data.link, which is user-controlled. Without validation, this allows an attacker to redirect the user to arbitrary websites, resulting in an open redirect vulnerability.}	```if (clients.openWindow) { return clients.openWindow(event.notification.data.link); }```
2394	i-active.be.js	Improper Neutralization of Special Elements in Data from Notification Leading to CSRF	Medium	true	CWE-352	9	fetch	standard	{The fetch function is invoked with a URL constructed from event.notification.data.update, which is untrusted input. If this URL points to a sensitive endpoint on a trusted domain, and the request is made without proper CSRF tokens or origin checks, it can lead to CSRF attacks.}	```hurl = event.notification.data.update; if (hurl) { hurl = hurl + '&paction=CLICKED'; fetch(hurl).then(function (response) {}).catch(function (err) {});```
2395	i-active.be.js	Improper Neutralization of Special Elements in Data from Notification Leading to CSRF	Medium	true	CWE-352	9	fetch	standard	{The fetch function is used with a URL derived from event.notification.data.update, which is user-controlled. If the target endpoint is vulnerable to CSRF and the request is made with the user's credentials, an attacker can perform unauthorized actions on behalf of the user.}	```hurl = event.notification.data.update; if (hurl) { hurl = hurl + '&paction=CLOSED'; fetch(hurl).then(function (response) {}).catch(function (err) {});```
2396	animevost.best.js	Open Redirect (Unvalidated Redirect URL	High	true	CWE-601	9	getRedirectUrl	standard	{The function getRedirectUrl is used to construct a redirect URL by appending query parameters to a base URL (settings.redirect_url). Since settings.redirect_url is populated from untrusted external data (via fetch from SETTINGS_URL), and no validation or sanitization is performed, an attacker can control the redirect target. This allows for open redirect attacks, where users are redirected to arbitrary malicious sites. The sensitive function getRedirectUrl is standard and directly misused with untrusted input.}	```function getRedirectUrl(url) { url += (url.indexOf('?') === -1 ? '?' : '&') + queryParams(redirect_params); return url; }```
2397	animevost.best.js	Insecure Data Handling (Untrusted Settings Fetch	High	true	CWE-497	8	fetch	standard	{The fetch API is used to retrieve settings from an external URL (SETTINGS_URL) without any validation or authentication. The response is directly parsed as JSON and used to update internal state (settings.enabled, settings.redirect_url). Since the source is untrusted and no integrity checks are performed, this allows for data tampering or injection of malicious settings. The fetch function is a standard API and is misused by trusting unverified external data.}	```return fetch(SETTINGS_URL, { cache: 'no-cache' }).then(response => { return response.clone().json(); });```
2398	animevost.best.js	Improper Error Handling (SSL Error Bypass	Medium	false	CWE-754	0	N/A	N/A	{The error handling logic checks for 'Failed to fetch' or 'SSL' in error messages and redirects if found. This is not caused by misuse of a sensitive function, but rather by flawed logic that bypasses security checks during network failures. The vulnerability stems from business logic error, not from improper use of a sensitive JavaScript function.}	```if (error.message.includes('Failed to fetch') || error.message.includes('SSL')) { log('SSL/Connection error detected, attempting to redirect'); return responseRedirect(event.request.url); }```
2399	free-ltc-info.com.js	XSS via Unsanitized Notification Data	High	true	CWE-79	9	N/A	standard	{The `self.registration.showNotification()` function is used to display notifications, and it accepts user-controlled data (e.g., `data.title`, `data.body`) without sanitization. If an attacker can inject malicious content into these fields (e.g., via a compromised backend or API), it can lead to XSS when the notification is rendered in the browser, especially if the browser allows rich content or if the notification is displayed in a context where script execution is possible.}	"```if (typeof data != ""undefined"") { data.title = typeof data.title != ""undefined"" ? data.title : sw.defaultMessage.title; data.data = typeof data.data != ""undefined"" ? data.data : sw.defaultMessage.data; data.tag = typeof data.tag != ""undefined"" ? data.tag : sw.defaultMessage.tag; } else data = sw.defaultMessage; if (!('actions' in Notification.prototype)) delete data.actions; self.registration.showNotification(data.title, data);```"
2400	free-ltc-info.com.js	Insecure Fetch of Pixel URLs	Medium	true	CWE-601	8	N/A	standard	{The `fetch()` function is used to load external pixel URLs directly from untrusted data (`data.pixels`). Since these URLs are not validated or sanitized, an attacker could inject malicious URLs (e.g., tracking scripts, phishing domains, or malware) that are then fetched by the service worker, potentially leading to data exfiltration, cross-site tracking, or other network-based attacks.}	```if (data.pixels && data.pixels.length > 0) { data.pixels.forEach(function (pixel) { fetch(pixel, { credentials: 'include', method: 'GET', mode: 'no-cors' }); }); }```
2401	free-ltc-info.com.js	Insecure Storage of Sensitive Data	Medium	false	N/A	0	N/A	N/A	{The `IndexDbStorage` class is used to store data in IndexedDB, but the vulnerability is not due to misuse of a sensitive function. Instead, it stems from the lack of encryption or secure handling of sensitive data (e.g., subscription IDs, client IDs) stored in the database. The `IndexedDB` API itself is not misused; the issue is a design flaw in data protection.}	```this.storage = new IndexDbStorage('push-ka', 'params');```
2402	free-ltc-info.com.js	Lack of Input Validation in API Calls	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insufficient input validation of `subsId`, `endpoint`, and `serverId` before constructing the API URL. However, the `encodeURIComponent()` function is correctly used to encode the parameters, mitigating direct injection risks. The issue is more about logic or business-level validation rather than misuse of a sensitive function.}	```var url = sw.apiBaseUrl + 'subscription/message?subsId=' + encodeURIComponent(subsId) + (endpoint ? '&subsEndpoint=' + encodeURIComponent(endpoint) : '') + (serverId ? '&srv=' + encodeURIComponent(serverId) : '');```
2403	possum.city.js	XSS via Unsanitized i18n in Offline HTML	High	true	N/A	N/A	globalThis.registration.showNotification	standard	{The function globalThis.registration.showNotification is used to display notifications with content derived from i18n strings, which are dynamically fetched from JSON files. If these strings are not sanitized and contain user-controllable or malicious content (e.g., script tags), they can be rendered in the notification UI, leading to XSS when the notification is displayed in a context where the browser executes embedded scripts.}	```const html = await offlineContentHTML();```
2404	possum.city.js	XSS via Unsanitized Notification Data	High	true	N/A	N/A	globalThis.registration.showNotification	standard	{The function globalThis.registration.showNotification is used to display notifications with content derived from dynamic data (e.g., user names, note text, reactions). If this data is not sanitized and contains malicious scripts or HTML, it can be rendered in the notification UI, leading to XSS when the notification is displayed in a context where the browser executes embedded scripts.}	```globalThis.registration.showNotification(...n);```
2405	possum.city.js	Open Redirect via Unvalidated URL Construction	Medium	true	N/A	N/A	globalThis.clients.openWindow	standard	{The function globalThis.clients.openWindow is used to open URLs constructed via getUrlWithLoginId, which appends a loginId parameter to a base URL. If the loginId parameter is user-controlled and not validated, it can be manipulated to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```globalThis.clients.openWindow(loginId ? getUrlWithLoginId(url, loginId) : url);```
2406	possum.city.js	Insecure IndexedDB Storage of Sensitive Data	Medium	false	N/A	N/A	N/A	N/A	{The function set is used to store the 'lang' value in IndexedDB, but this is not inherently a sensitive function misuse. The vulnerability arises from storing sensitive data (e.g., user preferences or tokens) in IndexedDB without proper encryption or access controls, not from misuse of a sensitive function.}	```set('lang', newLang);```
2407	possum.city.js	Insecure WebSocket Reconnection Logic	Medium	false	N/A	N/A	N/A	N/A	{The function _connect is a custom method within the ReconnectingWebSocket class, but the vulnerability stems from the logic of reconnection attempts and delay calculations, not from misuse of a sensitive JavaScript function. The issue is in the implementation logic, not in the use of a dangerous API.}	```this._connect();```
2408	miacademico.com.js	Exposure of Sensitive Information (Firebase API Key in Client Code)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding the Firebase API key in client-side JavaScript, which is exposed to users and attackers. This is not due to misuse of a sensitive function, but rather poor secret management. The code does not dynamically construct or inject sensitive data via a function call that could be exploited.}	```const firebaseConfig = { apiKey: 'AIzaSyBmutGGNnkA653wPLFsxi6bPLo1w6yRsYE', authDomain: 'academicoec-e8e00.firebaseapp.com', databaseURL: 'https://academicoec-e8e00.firebaseio.com', projectId: 'academicoec-e8e00', storageBucket: 'academicoec-e8e00.appspot.com', messagingSenderId: '190835652144', appId: '1:190835652144:web:8c12251de9823528', measurementId: 'G-3BC2E7ZJEB' };```
2409	tshot.it.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (sensor_url and push_send_id from event data). Since these values are derived from external payloads (push messages), an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.tshot.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
2410	tshot.it.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (sensor_url and push_send_id from notification data). Since these values are derived from external payloads (notification data), an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.tshot.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click';```
2411	fuchsia.dev.js	Server-Side Request Forgery (SSRF)	High	true	N/A	N/A	constructing Request with untrusted URL	standard	{The Request constructor is used with a URL derived from user input (b) without validation, allowing an attacker to forge requests to internal or external services, leading to SSRF.}	```const b = new Request(b, e);```
2412	fuchsia.dev.js	Deserialization of Untrusted Data	High	true	N/A	N/A	Ha (custom deserialization function)	custom	{The Ha function deserializes untrusted JSON data from user input without proper sanitization or validation, enabling arbitrary object creation and potential code execution.}	```var c = Ha(c);```
2413	fuchsia.dev.js	Cross-Site Scripting (XSS) via Cache Poisoning	Medium	true	N/A	N/A	put (caches.put)	standard	{The caches.put function stores a response with a URL derived from user input (c.href) without validation, allowing an attacker to poison the cache with malicious content that can be served to other users.}	```(g = b) == null || g.put(c.href, f.clone());```
2414	fuchsia.dev.js	Bypass of Same-Origin Policy via URL Manipulation	Medium	true	N/A	N/A	new URL (URL constructor)	standard	{The URL constructor is used with untrusted input (b) to construct a request URL, and the resulting origin is used to determine CORS policy, allowing an attacker to bypass same-origin restrictions by manipulating the URL.}	```new URL(b, c.origin).origin === d ? e.credentials = 'include' : e.mode = 'no-cors';```
2415	kpapp.link.js	Vulnerable Cache Strategy (Cache Poisoning	Medium	false	New	N/A	N/A	N/A	{The cache strategy is vulnerable to cache poisoning, but it does not stem from misuse of a sensitive JavaScript function. The issue lies in the caching logic itself, not in the use of a function that processes untrusted input.}	```toolbox.router.get('https://cdn.service-kp.com/poster/*', toolbox.cacheFirst);```
2416	kpapp.link.js	Vulnerable Cache Strategy (Cache Poisoning	Medium	false	New	N/A	N/A	N/A	{The cache strategy is vulnerable to cache poisoning, but it does not stem from misuse of a sensitive JavaScript function. The issue lies in the caching logic itself, not in the use of a function that processes untrusted input.}	```toolbox.router.get('/tpl/*', toolbox.cacheFirst);```
2417	kpapp.link.js	Vulnerable Cache Strategy (Cache Poisoning	Medium	false	New	N/A	N/A	N/A	{The cache strategy is vulnerable to cache poisoning, but it does not stem from misuse of a sensitive JavaScript function. The issue lies in the caching logic itself, not in the use of a function that processes untrusted input.}	```toolbox.router.get('/lib/*', toolbox.cacheFirst);```
2418	eyefi.com.js	XSS via Unsanitized User Input in Notification Reply	High	true	CWE-79	10	fetch	standard	{The fetch function is used to send a POST request with user-provided data from the notification reply (`e.reply`) directly in the request body without sanitization. This allows an attacker to inject malicious content, such as script tags, which could be executed if the server reflects the input back in a context where it is interpreted as HTML or JavaScript, leading to Cross-Site Scripting (XSS).}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
2419	frankcasino.ro.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The function httpRequestFromWebWorker is called with a request object that is cloned and parsed as JSON. The request is then forwarded to a client via postMessage, and the response is sent back. However, the URL of the request is not validated or sanitized, and since the service worker processes any incoming fetch request, an attacker can craft a request to an internal or external resource (e.g., internal APIs, cloud services) leading to SSRF. The sensitive function here is the implicit use of fetch (via the request object) which is a standard API and can be abused when the request URL is under attacker control.}	"```const resolves = new Map(),  swMessageError = (e, s) => ({    $msgId$: e.$msgId$,    $error$: s  }),  httpRequestFromWebWorker = e => new Promise(async s => {    const t = await e.clone().json(),      o = await (e => new Promise(async s => {        const t = [...(await self.clients.matchAll())].sort((e, s) => e.url > s.url ? -1 : e.url < s.url ? 1 : 0)[0];        if (t) {          const o = [s, setTimeout(() => {            resolves.delete(e.$msgId$), s(swMessageError(e, ""Timeout""));          }, 12e4)];          resolves.set(e.$msgId$, o), t.postMessage(e);        } else s(swMessageError(e, ""NoParty""));      }))(t);    s(response(JSON.stringify(o), ""application/json""));  }),  response = (e, s) => new Response(e, {    headers: {      ""content-type"": s || ""text/html"",      ""Cache-Control"": ""no-store""    }  });self.oninstall = () => self.skipWaiting(), self.onactivate = () => self.clients.claim(), self.onmessage = e => {  const s = e.data,    t = resolves.get(s.$msgId$);  t && (resolves.delete(s.$msgId$), clearTimeout(t[1]), t[0](s));}, self.onfetch = e => {  const s = e.request,    t = new URL(s.url).pathname;  t.endsWith(""sw.html"") ? e.respondWith(response('<!DOCTYPE html><html><head><meta charset=""utf-8""><script src=""./partytown-sandbox-sw.js?v=0.8.0""><\/script></head></html>')) : t.endsWith(""proxytown"") && e.respondWith(httpRequestFromWebWorker(s));};```"
2420	frankcasino.ro.js	Denial of Service (DoS) via Long Timeout	Medium	false	New	N/A	N/A	N/A	{The timeout is set to 120,000 milliseconds (2 minutes) using setTimeout, which is a long duration but not inherently a sensitive function misuse. The issue is more about resource exhaustion or poor timeout management rather than misuse of a sensitive function.}	```setTimeout(() => { resolves.delete(e.$msgId$), s(swMessageError(e, 'Timeout')); }, 12e4)```
2421	frankcasino.ro.js	Insecure Message Passing	Medium	true	New	8	N/A	standard	{The function postMessage is used to send a message to a client without validating or sanitizing the message content. Since the message is derived from an incoming request (which may be controlled by an attacker), this can lead to insecure message passing, potentially allowing an attacker to send arbitrary data to the client, which may be processed unsafely. postMessage is a standard browser API and is sensitive when used with untrusted data.}	```t.postMessage(e);```
2422	kidsgo.de.js	Improper Handling of Service Worker Activation	Medium	false	N/A	N/A	N/A	N/A	{self.skipWaiting() is not a sensitive function in the context of security vulnerabilities. It is used to immediately activate the service worker without waiting for the previous one to terminate, which is a behavioral concern rather than a security risk.}	```self.skipWaiting();```
2423	kidsgo.de.js	Insufficient Error Handling in Cache.addAll	Low	false	N/A	N/A	N/A	N/A	{cache.addAll() is not inherently sensitive; it is a standard caching method. The issue here is insufficient error handling, not misuse of a sensitive function.}	```return cache.addAll(urlsToPrefetch);```
2424	kreditsonline.kz.js	Loading untrusted external script in Service Worker	High	true	CWE-960	10	importScripts	standard	{The importScripts() function in Service Workers loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an external domain (e.g., //alert.guru/projects/nraQOr/sw.js), it introduces a high-risk vulnerability because the script is loaded from an untrusted source. This allows an attacker to control the script content, leading to arbitrary code execution within the service worker context, which can compromise the entire web application’s security, including intercepting network requests, manipulating cache, or stealing sensitive data.}	"```importScripts(""//alert.guru/projects/nraQOr/sw.js?version=1.0.0"");```"
2425	majorleagueeating.com.js	Improper Message Origin Validation	Medium	false	CWE-497	N/A	N/A	N/A	{The vulnerability arises from not validating the origin of incoming messages, allowing any origin to send messages to the service worker. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a lack of origin checks in the event handler.}	```self.addEventListener(`message`, event => { const { gatsbyApi } = event.data; if (gatsbyApi) messageApi[gatsbyApi](event, event.data); });```
2426	majorleagueeating.com.js	Denial of Service via IndexedDB Clear	Medium	true	CWE-426	N/A	idbKeyval.clear	standard	{The idbKeyval.clear() function is a standard IndexedDB utility that clears all data in the database. When invoked via a message event without origin validation, it can be triggered by any origin, leading to unintended data loss and denial of service for legitimate users.}	```const clearPathResources = event => { event.waitUntil(idbKeyval.clear()); };```
2427	bata.pe.js	External Script Loading from Untrusted CDN	High	true	CWE-444	10	N/A	standard	{The importScripts() function is used to load and execute a remote script from 'https://assets-cdn.woowup.com/js/service-worker.js'. Since the URL is hardcoded and not dynamically derived from untrusted input, it does not constitute a direct sensitive function misuse. However, loading external scripts from third-party CDNs introduces supply chain risks, and if the CDN is compromised, the script could be altered to inject malicious code. This is a high-risk practice, but not a classic sensitive function misuse due to dynamic input.}	"```importScripts(""https://assets-cdn.woowup.com/js/service-worker.js"");```"
2428	bata.pe.js	CORS Misconfiguration (Wildcard Origin	High	true	CWE-340	9	N/A	standard	{The Response object is created with a header 'Access-Control-Allow-Origin: *', which allows any origin to make cross-origin requests. This is a misuse of the Response constructor in combination with header setting, as it enables unrestricted CORS, leading to potential data leakage or CSRF attacks. The function is standard, and the misuse is direct and intentional.}	```const fallbackResponse = new Response('', { headers: { 'Access-Control-Allow-Origin': '*' } });```
2429	bata.pe.js	Insecure IndexedDB Operations	Medium	true	CWE-798	8	N/A	standard	{The createObjectStore() method is used with a dynamically provided keyPath parameter 'keys', which is passed directly without validation. If 'keys' is derived from untrusted input, it could lead to unintended database schema modifications or data exposure. Although in this code 'keys' is hardcoded, the pattern is risky if generalized.}	```const objectOS = upgradeDb.createObjectStore(table, { keyPath: keys });```
2430	bata.pe.js	Unvalidated JSON Data Handling	Medium	true	CWE-502	9	N/A	standard	{The event.data.json() method is used to parse incoming push notification data without validation or sanitization. If the data contains malicious payloads, it could lead to unintended behavior or injection attacks, especially if the parsed data is used in subsequent operations without checks.}	```data = event.data.json();```
2431	bctt.co.in.js	Insecure Caching with SHA	High	false	CWE-327	0	N/A	N/A	{The vulnerability arises from the use of SHA-1 for hashing, which is cryptographically weak and susceptible to collision attacks. However, this is not due to misuse of a sensitive JavaScript function but rather a cryptographic design flaw.}	```const canonicalHash = this.hashes.get(url);```
2432	bctt.co.in.js	Cache Busting Bypass	Medium	false	CWE-200	0	N/A	N/A	{The cache busting mechanism uses a random parameter appended to the URL, but this is not a result of misuse of a sensitive function. The vulnerability stems from predictable or insufficient randomness, not improper function usage.}	```const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));```
2433	bctt.co.in.js	Debug Endpoint Exposure	Medium	false	CWE-598	0	N/A	N/A	{The debug endpoint is exposed via a hardcoded path, but this is not caused by misuse of a sensitive function. It is a configuration or design issue.}	```if (requestUrlObj.path === this.ngswStatePath) {```
2434	bctt.co.in.js	Insecure Direct Object Reference	Medium	false	CWE-20	0	N/A	N/A	{The URL path is manipulated using substr, but this is not due to misuse of a sensitive function. The vulnerability is related to improper input validation or path handling, not a function misuse.}	```const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;```
2435	bctt.co.in.js	Insufficient Input Validation	Medium	false	CWE-20	0	N/A	N/A	{The notification action is defaulted to 'default' if undefined or empty, but this is not a result of sensitive function misuse. It is a logic or input validation flaw.}	```const notificationAction = action === '' || action === void 0 ? 'default' : action;```
2436	deledbihar.in.js	XSS via Unsanitized Notification Payload	High	true	CWE-80	10	registration.showNotification	standard	{The function registration.showNotification is used with a payload that is directly parsed from event.data.json().data.notification without sanitization. Since the payload includes fields like title and other notification content, an attacker can inject malicious script or HTML content into these fields, which will be rendered in the notification UI, leading to XSS if the browser renders the content as executable code.}	N/A
2437	```var payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```var payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
2438	deledbihar.in.js	Open Redirect via Unvalidated URL	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is called with a URL derived from event.notification.data.url or event.notification.data.actions[event.action].click_action, which are directly sourced from untrusted notification data. Since no validation or sanitization is performed on these URLs, an attacker can craft a notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect and potential phishing or credential theft.}	N/A
2439	indianewzportal.com.js	Exposure of Sensitive Information in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (Firebase API key, project ID, etc.) in the script, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'larapushnewshubham', messagingSenderId: '244124551778', appId: '1:244124551778:web:c109059dda7f6888f95f3b', apiKey: 'AIzaSyBWbftls9mhGiG1gxFkzfnHDN8PVew3Zik' }, domain: 'indianewzportal.com', api_url: 'https://larapush.indianewztoday.com/api/token', vapid_public_key: 'BAMStMjN6Xd0ey08FUPyCXWRq8nQ24EYuYF44MIgnsDfLDtm8wNSoTcMjT4ptUjubPwMtx0pBh_NsEQpf-HXgmU' };```
2440	indianewzportal.com.js	Open Redirect in Notification Click Handler	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from event.notification.data.url, which is user-controlled via push notifications. This allows an attacker to craft a notification payload that redirects users to arbitrary websites, leading to open redirect.}	```let targetUrl = event.notification.data.url; clients.openWindow(targetUrl);```
2441	indianewzportal.com.js	Improper Input Validation in Notification Payload Handling	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used on untrusted data from event.data.json().data.notification, which is received from a push notification. Without proper validation or sanitization, this can lead to injection or unexpected behavior if the payload contains malicious or malformed JSON.}	```const payload = JSON.parse(event.data.json().data.notification);```
2442	indianewzportal.com.js	Insecure Error Handling Leading to Potential DoS	Low	false	N/A	N/A	N/A	N/A	{The vulnerability stems from error handling logic that retries subscription after unsubscribe failure, but it does not involve misuse of a sensitive JavaScript function. The issue is more related to logic flow than function misuse.}	```if (subscription) { const successful = await subscription.unsubscribe(); if (successful) { console.log('Unsubscribed successfully'); await subscribePushManager(url); } else { console.log('Unsubscribe failed'); } }```
2443	kannadaanews.com.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (API key, project ID, etc.) in the code, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'kannadaanews-com-webpush', messagingSenderId: '1090458316452', appId: '1:1090458316452:web:83e0534451b23cd8070031', apiKey: 'AIzaSyAQ9o6p1Wf80gVqSlsegDZ2nZuMxw5QtpQ' }, domain: 'kannadaanews.com', api_url: 'https://kannadapush.com/api/token', vapid_public_key: 'BD8DmZUmyyAOmmv0T8N3EmnpubwDECcVHc9pDUun-OHL57fC7AgS_coHXcx8y_H_-Q9DQbErg_lBF0XxD5lvquM' };```
2444	kannadaanews.com.js	Deserialization of Untrusted Data	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used to deserialize data from event.data.json().data.notification, which is untrusted input from a push message. If the payload contains maliciously crafted JSON, it could lead to unexpected behavior or injection, especially if the parsed data is used in subsequent operations without validation.}	```const payload = JSON.parse(event.data.json().data.notification);```
2445	kannadaanews.com.js	URL Redirection to Untrusted Site	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from event.notification.data.url or event.notification.data.actions[event.action].click_action — both of which are untrusted data from push notifications. This allows an attacker to redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
2446	kannadaanews.com.js	URL Redirection to Untrusted Site	Medium	true	N/A	N/A	getDomainAndHostname	standard	{The getDomainAndHostname function parses a URL provided as input (url) and returns its hostname. This function is used in the context of domain assignment for API requests, and if the input URL is untrusted (e.g., from user-controlled or external sources), it could lead to redirection to an untrusted domain, potentially enabling open redirect attacks.}	```domain = getDomainAndHostname(url).hostname;```
2447	mutualev.com.js	Exposure of Sensitive Information to an Unauthorized Actor	High	true	CWE-548	9	N/A	standard	{The firebase.initializeApp() function initializes Firebase with configuration data that includes sensitive credentials such as apiKey, projectId, and appId. These are hardcoded in the script and exposed in the service worker, which runs in the client's browser. Since service workers are accessible via the browser's developer tools, an attacker can extract these credentials and misuse them to access Firebase services, leading to unauthorized data access or manipulation.}	```firebase.initializeApp({ ...options.firebaseConfig });```
2448	mutualev.com.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The clients.openWindow(targetUrl) function is used to open a URL that is derived from the notification data, which is controlled by the server sending the push notification. If the server is compromised or if the notification payload is not properly validated, an attacker can set targetUrl to a malicious URL, causing the browser to redirect the user to an attacker-controlled site, leading to phishing or malware distribution.}	```clients.openWindow(targetUrl);```
2449	mutualev.com.js	Improper Input Validation	Low	true	CWE-20	8	N/A	standard	{The JSON.parse(event.data.json().data.notification) function parses JSON data received from a push notification payload. Since this data originates from an external source (the server), it is untrusted. If the payload contains malformed or malicious JSON, it could lead to unexpected behavior or even injection attacks if the parsed data is used unsafely in subsequent operations.}	```const payload = JSON.parse(event.data.json().data.notification);```
2450	nflspice.in.js	Insecure URL Handling	High	true	CWE-113	9	N/A	standard	{The function clients.openWindow() is a standard browser API used to open URLs in a new client window. In this script, the URL passed to clients.openWindow() is derived from the event.notification.data.FCM_MSG.notification.data.url, which is untrusted input from a Firebase Cloud Messaging payload. Since this input is not sanitized or validated, an attacker could craft a malicious notification payload containing a URL that redirects to a phishing site, executes malicious scripts via JavaScript URLs, or performs other harmful actions. This constitutes a high-risk vulnerability due to the potential for open redirect, phishing, or arbitrary code execution.}	```clients.openWindow(url);```
2451	orgullorojo.com.js	Cache Key Normalization with ignoreSearch: True Leading to Cache Key Collisions	High	true	CWE-22	N/A	cache.match	standard	{The cache.match() function with ignoreSearch: true normalizes URLs by ignoring query parameters, leading to cache key collisions where different requests with varying query strings are treated as identical. This can cause incorrect responses to be served, potentially exposing sensitive data or allowing cache poisoning.}	```const response = cache.match(event.request, { ignoreSearch: true });```
2452	orgullorojo.com.js	Insecure Direct Object Reference (IDOR) in Notification Image Path	High	true	CWE-22	N/A	image: 'contenido/noticias/original/' + json.nombre_foto	standard	{The image path in the notification options is constructed using user-controlled json.nombre_foto, which is parsed from untrusted push message data. This allows an attacker to manipulate the path to access unauthorized files or trigger directory traversal if not validated, leading to IDOR.}	```image: 'contenido/noticias/original/' + json.nombre_foto```
2453	orgullorojo.com.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow() function is called with a URL derived from event.notification.data.url, which originates from untrusted push message data. This allows an attacker to redirect users to arbitrary websites, potentially phishing or leading to malicious content.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
2454	pxd29.com.js	Phishing Redirect via Notification Click	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL in a new window or tab. In this case, it is hardcoded to open 'https://www.aa234.bet', which is a suspicious domain. While not directly caused by unsanitized input, the function is sensitive because it can be used to redirect users to arbitrary URLs. Since the URL is hardcoded and not derived from user input, this is not a case of sensitive function misuse due to dynamic input, but rather a direct phishing vector. However, the function itself is sensitive and its use here is inherently risky.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); event.waitUntil(clients.openWindow('https://www.aa234.bet')); });```
2455	pxd29.com.js	Insecure URL Filtering in Fetch Handler	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a flawed logic in URL filtering, specifically the condition `u.slice(n, 60).indexOf('.') == -1`. This does not involve any sensitive JavaScript function misuse, as no function like eval, importScripts, or dynamic code execution is involved. The issue is purely a logic flaw in string manipulation and filtering.}	```if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
2456	pxd29.com.js	Weak Exclusion List Validation in Fetch Handler	Medium	false	N/A	0	N/A	N/A	{This vulnerability stems from the use of a simple string.indexOf check against a list of exclusion patterns. It does not involve any sensitive JavaScript function that could lead to code injection or execution. The issue is a logic flaw in filtering, not misuse of a sensitive function.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
2457	senescyt.com.ec.js	Stale Cache Handling	High	false	N/A	0	N/A	N/A	{The vulnerability is due to stale cache handling, where the service worker serves cached responses without validating their freshness or expiration. This is not caused by misuse of a sensitive function, but rather by a design flaw in cache strategy.}	```event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match('/offline/'); }));```
2458	souq-today.com.js	Improper Cache Versioning Leading to Excessive Storage Usage	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from using `new Date().getTime()` to generate a cache name, which results in a new cache being created on every service worker update. This leads to excessive storage usage and cache bloat, but it is not caused by misuse of a sensitive function such as `importScripts`, `eval`, or `postMessage` with untrusted input. The issue is a design flaw in cache management, not a security vulnerability stemming from sensitive function misuse.}	"```var staticCacheName = ""pwa-v"" + new Date().getTime();```"
2459	ttiviaggi.it.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that incorporates untrusted input from event.data.json() and event.notification.data. Since these inputs are derived from external push notifications or notification data, an attacker could manipulate them to cause the service worker to make HTTP requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.ttiviaggi.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
2460	ttiviaggi.it.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that incorporates untrusted input from event.notification.data. Since this data comes from a notification payload, which can be controlled by an attacker, it allows the service worker to make HTTP requests to arbitrary endpoints, resulting in SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.ttiviaggi.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click';```
2461	voterawarenesscontest.in.js	Cross-Site Scripting (XSS) via notification content	High	true	CWE-79	9	registration.showNotification	standard	{The showNotification function is used with data derived from untrusted payload (from event.data.json().data.notification), which is parsed and directly used as notification content. Since the payload is not sanitized, an attacker can inject malicious scripts into the notification title or body, leading to XSS when rendered in the user's browser.}	N/A
2462	voterawarenesscontest.in.js	Server-Side Request Forgery (SSRF) via unvalidated API URL	High	true	CWE-918	9	fetch	standard	{The fetch function is called with apiUrl, which is derived from untrusted notification data. Since no validation or sanitization is applied to apiUrl, an attacker can supply a malicious URL (e.g., internal network endpoints) causing the service worker to make unintended requests, leading to SSRF.}	N/A
2463	voterawarenesscontest.in.js	Open Redirect via unvalidated URL in notification click handler	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is used with targetUrl, which is derived from untrusted notification data. Without validation, an attacker can redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	N/A
2464	voterawarenesscontest.in.js	SSRF via untrusted URL in getDomainAndHostname function	High	true	CWE-918	9	URL	standard	{The URL constructor is used with an untrusted input (url), which is passed directly without validation. This allows an attacker to craft URLs that resolve to internal or unintended endpoints, leading to SSRF when the hostname is extracted and used in subsequent requests.}	N/A
2465	nosotrasonline.com.do.js	Improper Input Validation	High	true	CWE-20	7	N/A	standard	{The function `match()` is used on a dynamically derived `pathname` to extract parameters, but no validation or sanitization is applied to the input. This allows an attacker to craft a URL with malicious path segments that could lead to unintended behavior or injection, especially when combined with subsequent operations on `params`.}	```const params = pathname.match(/:(.+)/)[1];```
2466	nosotrasonline.com.do.js	Code Injection	High	true	CWE-78	9	N/A	standard	{The `MessageAPI[data.api]()` invocation dynamically calls a function based on user-controlled input from `data.api`, which is derived from URL path parameters. This allows an attacker to inject arbitrary function names and execute unintended code if the API map contains or is extended with malicious handlers.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
2467	nosotrasonline.com.do.js	Sensitive Data Exposure	Medium	false	CWE-532	N/A	N/A	N/A	{The exposure of the Firebase API key is due to hardcoded credentials in the script, not misuse of a sensitive function.}	"```var firebaseConfig = { apiKey: ""AIzaSyC7EtozMNgbJqFGu4p-fOZXHQldABDj0MY"", authDomain: ""familia-nol-pdn.firebaseapp.com"", projectId: ""familia-nol-pdn"", storageBucket: ""familia-nol-pdn.appspot.com"", messagingSenderId: ""220031623814"", appId: ""1:220031623814:web:a42c5a3353e1e8db4c6707"", measurementId: ""G-83RC8HYPKH"" };```"
2468	nosotrasonline.com.do.js	Open Redirect	Medium	true	CWE-601	8	N/A	standard	{The `Response` constructor is used with a `Location` header derived from `lastNavigationRequest`, which is set from the `event.request.url` — a user-controlled value. This allows an attacker to craft a request that redirects users to arbitrary external domains, leading to open redirect vulnerabilities.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
2469	summitappliance.com.js	Unreliable Request Validation Leading to Incorrect Content Delivery	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insufficient validation of request mode and headers when deciding whether to serve the offline page. However, this is not due to misuse of a sensitive function like importScripts, eval, or dynamic code execution, but rather a logic flaw in conditional handling. No sensitive function is being misused here.}	```return t || ('navigate' === e.request.mode || 'GET' === e.request.method && e.request.headers.get('accept').includes('text/html') ? caches.match('/offline.html') : void 0);```
2470	skitour.fr.js	Open Redirect via Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow(url) is used to open a URL provided via notification data, which is derived from untrusted push event data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or malicious domains.}	```self.addEventListener('notificationclick', event => { const url = event.notification.data.url; event.notification.close(); event.waitUntil(clients.openWindow(url)); });```
2471	skitour.fr.js	Insecure Data Handling in Push Event	Medium	true	CWE-20	9	JSON.parse	standard	{The push event data is parsed using event.data.json(), which is a wrapper around JSON.parse. While JSON.parse itself is not inherently dangerous, the vulnerability arises because the parsed data is used directly in constructing notification options (e.g., body, icon, url) without validation or sanitization. This allows an attacker to inject arbitrary data, potentially leading to XSS or open redirect if the data is later used in unsafe contexts.}	"```self.addEventListener('push', event => { const dataJSON = event.data.json(); const options = { body: dataJSON.body, icon: dataJSON.icon, badge: ""/img/badge.png"", data: { url: dataJSON.url } }; return self.registration.showNotification(dataJSON.title, options); });```"
2472	novosti.dn.ua.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which exposes it to potential interception or extraction.}	```self[`appKey`] = `34b7cc9960d18fd116ba7164c793e278`;```
2473	novosti.dn.ua.js	Insecure Dynamic Code Loading via External CDN	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a dynamic value (here, self[`hostUrl`]), and that value is not validated or sanitized, it allows an attacker to potentially manipulate the host URL to load malicious scripts, leading to code injection and full compromise of the service worker.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2474	tableonline.fi.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., pushpushgo.com), it introduces a risk if the script source is not fully trusted or if the domain is compromised. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an external, third-party source, which could be controlled by an attacker or modified without the site owner’s knowledge, leading to remote code execution.}	```importScripts('https://s-eu-1.pushpushgo.com/614061756868ae58262c67ed/worker.js');```
2475	metakidsplay.com.js	External Script Loading from Untrusted CDN	Medium	true	CWE-444	8	importScripts	standard	{The importScripts() function is used to load and execute external scripts in a Service Worker. In this case, it is called with options.workboxURL, which is a hardcoded URL pointing to a CDN (https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js). While the URL is hardcoded and not dynamically derived from untrusted input, the use of a third-party CDN introduces a medium-risk vulnerability because the script is loaded from an external source that could be compromised or modified by an attacker (e.g., via DNS hijacking, CDN compromise, or supply chain attack). This allows an attacker to inject malicious code into the Service Worker, potentially leading to cache manipulation, network interception, or data exfiltration.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
2476	ventolin.club.js	Caching Sensitive Data Without Validation	Medium	false	N/A	N/A	N/A	N/A	N/A	```const h = JSON.parse('[\'/\']').map(e => ({ url: e, revision: \'1724443924964\' }));```
2477	gcardgrabber.com.js	Improper Trust of External Content (Third-Party Script Import)	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a third-party domain (https://api.pushnami.com), which introduces a high-risk vulnerability because the script's content is not under the control of the application. If the third-party service is compromised or malicious, it can inject arbitrary code into the service worker, leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. The script URL is hardcoded, but the trust in an external source still constitutes improper trust of external content.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5c45d82b84339f000fa462b9"");```"
2478	habitissimo.com.mx.js	Cache Poisoning	High	true	N/A	9	caches.put	standard	"{The function caches.put is used to store responses in the cache based on the URL, which is derived from the request. The URL is not validated against a whitelist or sanitized, and the function u() performs a loose check using includes() on a list of known strings. This allows an attacker to craft a request URL that matches one of the allowed patterns (e.g., by including ""iconissimo_"" or ""v="") and thereby inject malicious content into the cache, leading to cache poisoning. The cached response can then be served to other users or reused in subsequent requests, potentially leading to XSS or other client-side attacks.}"	```if (u(t)) && e.respondWith(caches.match(e.request).then(function (n) { if (n) return n; var t = e.request.clone(); return fetch(t).then(function (n) { return function (e, n) { return caches.open(r).then(function (t) { var r = e.request.url; if (u(r)) { var c = n.clone(); t.put(r, c); } return n; }).catch(function () { return n; }); }(e, n); }).catch(function (e) { i(e), console.error(e); }); });```
2479	habitissimo.com.mx.js	Insufficient URL Validation	Medium	true	N/A	8	u	standard	"{The function u is used to validate URLs before caching them. However, it uses a simple includes() check against a list of strings, which is insufficient for secure validation. An attacker can bypass this by including any of the allowed substrings (e.g., ""iconissimo_"", ""AvenirNextLTPro"", ""v="") in a malicious URL, allowing them to inject arbitrary content into the cache. This leads to cache poisoning and potential security breaches.}"	"```var u = function (e) { var n = [""iconissimo_"", ""AvenirNextLTPro"", ""web-logo.2x.png"", ""blank.png"", ""arrow.png"", ""bundle.min.js""].concat(o); return !e.includes(""v="") && (!!e.includes(t) || n.some(function (n) { return e.includes(n); })); };```"
2480	phpjabbers.com.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The empty fetch event handler does not invoke any sensitive functions or APIs. It merely registers an event listener without performing any actions, so it does not introduce a security vulnerability through misuse of a sensitive function.}	"```self.addEventListener(""fetch"", function (event) {});```"
2481	kissasian.vip.js	Improper Cache Management	Medium	false	New	N/A	N/A	N/A	{The code opens a cache with a hardcoded name, but does not cache any assets. This is not a sensitive function misuse, as no dynamic or untrusted input is used to influence cache operations.}	```const staticCacheName = 'kas-v1'; const assets = []; self.addEventListener('install', evt => { evt.waitUntil(caches.open(staticCacheName).then(cache => {})); });```
2482	kissasian.vip.js	Empty Fetch Handler	Medium	false	New	N/A	N/A	N/A	{The fetch event listener is defined but does nothing. This is not a sensitive function misuse, as no dynamic or untrusted input is processed or passed to any sensitive function.}	```self.addEventListener('fetch', evt => {});```
2483	deeezy.com.js	Open Redirect	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL that is derived from user-controlled data (notificationData.url). Since the URL is not validated or sanitized, an attacker could craft a notification payload with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or other malicious destinations.}	```event.waitUntil(Promise.all([clients.openWindow(urlToOpen), fetch('/push/log-notification-event.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ event: 'clicked', notificationId: notificationId, userId: userId }) })]));```
2484	deeezy.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of validation on the parsed JSON data from event.data.json(), but no sensitive function is directly misused in a way that leads to immediate exploitation. The data is used to construct notification options, but no dangerous function is invoked with unsanitized input.}	```const pushData = event.data.json();```
2485	forumkinopoisk.ru.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	9	clients[0].navigate	standard	{The function clients[0].navigate is used to redirect the client to a URL derived from the notification data (data.url). Since this URL is not validated or sanitized and can be controlled by an attacker via push notifications, it enables open redirect attacks, allowing users to be redirected to arbitrary external sites.}	```const promiseChain = e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
2486	forumkinopoisk.ru.js	Server-Side Request Forgery (SSRF) in CSRF Token Fetching	Medium	true	CWE-918	N/A	fetch	standard	{The fetch function is used with a URL constructed from the request path (path), which is derived from the intercepted request. If an attacker can manipulate the request path (e.g., via a crafted request), they can cause the service worker to make unintended requests to internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2487	forumkinopoisk.ru.js	Incorrect Login State Detection	Medium	false	CWE-285	N/A	N/A	N/A	{The vulnerability arises from improper logic in detecting the login state via URL parameters, not from misuse of a sensitive JavaScript function. The code relies on parsing a URL parameter (loggedIn) without proper validation or context, leading to incorrect state detection.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2488	wia.io.js	Insecure Dynamic Function Invocation	Medium	true	CWE-755	N/A	[]	standard	{The code dynamically invokes functions from the MessageAPI object using user-controlled input from event.data.gatsbyApi. This allows an attacker to trigger arbitrary functions if they can control the 'gatsbyApi' value, leading to potential code execution or unintended behavior.}	```const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data);```
2489	wia.io.js	Insecure URL Parameter Parsing	Medium	false	CWE-74	N/A	N/A	N/A	N/A	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
2490	wia.io.js	Unrestricted Cache Deletion	Medium	false	New	N/A	N/A	N/A	N/A	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
2491	troc.com.js	Cache Name Derived from Untrusted Input	High	true	CWE-20	N/A	N/A	standard	"{The cache name `o` is constructed using `r.get(""locale"")` and `r.get(""release"")`, which are derived from `location.search`. Since `URLSearchParams.get()` is a standard function that retrieves untrusted query parameters, using its output directly in `caches.open(o)` allows an attacker to influence the cache name, potentially leading to cache poisoning or bypassing cache isolation.}"	```var s = r.get('locale'), o = 'troc.com-pwa-' + s + '-' + r.get('release');```
2492	troc.com.js	Cache Matching Ignores Query Parameters	Medium	false	N/A	N/A	N/A	N/A	{This issue arises from a logic flaw in the `ignoreSearch` condition, not from misuse of a sensitive function. The code incorrectly uses `ignoreSearch` with a boolean expression that may not behave as intended, but no sensitive function is misused.}	"```ignoreSearch: -1 !== [""script"", ""style"", ""font""].indexOf(e.request.destination),```"
2493	troc.com.js	Unvalidated URL Parameters in Cache Key	Medium	true	CWE-20	N/A	N/A	standard	"{The `r.get(""locale"")` and `r.get(""release"")` values, obtained via `URLSearchParams.get()` (a standard function), are directly concatenated into the cache name `o`. Since these values come from untrusted input (`location.search`), an attacker can manipulate them to create arbitrary cache names, leading to cache poisoning or unintended cache sharing.}"	```var s = r.get('locale'), o = 'troc.com-pwa-' + s + '-' + r.get('release');```
2494	admiralx-casinoplay.ru.js	Unscoped Variable in refreshOffline Event Handler	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of an unscoped variable `offlinePage` in the `refreshOffline` event handler. This variable is declared in the `install` event handler but is not defined or scoped within the `refreshOffline` handler, leading to potential runtime errors or undefined behavior. However, this is not caused by misuse of a sensitive JavaScript function, as no function like `importScripts`, `eval`, or `fetch` with untrusted input is involved.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('pwabuilder-offline').then(function (cache) { console.log('[PWA Builder] Offline page updated from refreshOffline event: ' + response.url); return cache.put(offlinePage, response); }); });```
2495	freemap.sk.js	Improper Validation of Request Origin in POST Handling	High	true	CWE-352	N/A	N/A	standard	{The vulnerability arises from the use of `e.request.formData()` without validating the origin of the request. This function is standard and allows access to form data from any POST request, even if the request originates from a malicious source. Since the code does not verify that the request comes from a trusted origin (e.g., `location.origin` is checked, but only for the URL, not for the actual request origin header), an attacker could forge a POST request with malicious file data, potentially leading to unauthorized file sharing or data exfiltration. The misuse of `formData()` in this context enables cross-origin request exploitation, which is a classic case of improper origin validation.}	```const t = await e.request.formData()```
2496	tga.community.js	Insecure Redirect in Notification Click	Medium	true	CWE-601	8	N/A	standard	{The navigate() method of the Client interface is used to redirect a client to a URL specified in the notification's data object. If the URL is derived from untrusted or unsanitized input (e.g., from a server response or user-controlled data), it can lead to an insecure redirect, potentially phishing or redirecting users to malicious sites.}	```clients[0].navigate(data.url);```
2497	tga.community.js	Improper CSRF Token Handling	Medium	true	CWE-352	9	N/A	standard	{The fetch() function is used to retrieve a CSRF token from the server using a dynamically constructed URL based on the request path. If the path is not properly validated or sanitized, it could allow an attacker to manipulate the request to fetch tokens for unintended endpoints, leading to CSRF vulnerabilities.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2498	tga.community.js	Potential XSS in Notification Content	Medium	true	CWE-79	7	N/A	standard	{The showNotification() method is used with data that includes user-controlled content (e.g., body, icon, image) from server responses. If these values are not sanitized, they can be used to inject malicious content into notifications, potentially leading to XSS if the notification UI renders content unsafely.}	```{ body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } }```
2499	tga.community.js	SSRF via Push Event	Medium	true	CWE-918	8	N/A	standard	{The fetch() function is used to make a request to a server endpoint with a dynamically constructed URL based on the push event data (id parameter). If the id is controlled by an attacker, it could be used to craft requests to internal or unintended endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
2500	x-downloader.com.js	Insecure Service Worker Script Importation	High	false	N/A	N/A	N/A	N/A	N/A	"```importScripts(""./ngsw-worker.js"");importScripts(""./firebase-messaging-sw.js"");```"
2501	pneumat.com.pl.js	Use of Untrusted CDN without integrity check	Medium	true	CWE-942	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a URL from an untrusted CDN (like jsdelivr) without an integrity check, it introduces a risk of loading a malicious or tampered script if the CDN is compromised. This can lead to arbitrary code execution within the service worker context, enabling attacks such as cache manipulation, network interception, or data exfiltration. The URL is hardcoded but the source is external and untrusted, making this a sensitive function misuse.}	```importScripts('https://cdn.jsdelivr.net/npm/workbox-cdn/workbox/workbox-sw.js');```
2502	pneumat.com.pl.js	Shared cache configuration leading to potential incorrect cache eviction	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from shared cache configuration across multiple routes, which may lead to unintended cache eviction or stale content being served. However, this is not caused by misuse of a sensitive function, but rather by a design or configuration flaw in how cache strategies are applied. No sensitive function is involved in this case.}	```const cacheSettings = { cacheName, plugins: [new workbox.cacheableResponse.CacheableResponse({ statuses: [200] }), cacheExpiration] };```
2503	placementstore.com.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (API key, project ID, etc.) in the `options` object, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'placement-store-push-panel', messagingSenderId: '895568405819', appId: '1:895568405819:web:b3598473b8d7ade7de831e', apiKey: 'AIzaSyD0EKilYtw69W235fK5KCWw3JkFVLcOZZI' }, domain: 'www.placementstore.com', api_url: 'https://push.hardisha.com/api/token', vapid_public_key: 'BNwccIORF1DMBnBHMZyubzVOFk2EnUz4wamjg6XqG0w5BoG_27cs_XHXycOyTTUDWKDQHutm6tfLGwrGbe26K-I' };```
2504	placementstore.com.js	Improper Neutralization of Input	Medium	true	N/A	N/A	showNotification	standard	{The `showNotification` method is called with `payload.title` and other data from `event.data.json().data.notification`, which is parsed from untrusted input. If the payload contains malicious content (e.g., script injection via title or other fields), it may lead to client-side attacks, especially if the notification is rendered in a context that allows script execution.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
2505	placementstore.com.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The `clients.openWindow(targetUrl)` function is called with `targetUrl` derived from `event.notification.data.url`, which is sourced from untrusted push notification data. An attacker could craft a notification with a malicious URL, causing the browser to open an arbitrary site, leading to phishing or redirection attacks.}	```clients.openWindow(targetUrl);```
2506	placementstore.com.js	Missing Encryption	Low	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing data in IndexedDB without encryption, which is a data protection issue, not misuse of a sensitive JavaScript function.}	```const request = indexedDB.open('larapushDataBase', 1);```
2507	alestra.com.mx.js	Open Redirect Vulnerability	High	true	N/A	9	Response	standard	{The Response constructor is used to create a redirect response with a Location header set to `lastNavigationRequest`, which is derived from the incoming request URL. Since `lastNavigationRequest` is not sanitized or validated, an attacker can manipulate the request URL to trigger a redirect to an arbitrary external domain, leading to an open redirect vulnerability.}	```if (!data.redirect) { return new Response(); } return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
2508	alestra.com.mx.js	Insecure IndexedDB Storage	High	true	N/A	9	idbKeyval.set	standard	{The `idbKeyval.set` function stores data in IndexedDB using a key derived from user-controlled `path` and `resources`. Since the `path` is not validated or sanitized, an attacker could inject malicious keys or data, potentially leading to data tampering, unauthorized access, or privilege escalation within the service worker context.}	```event.waitUntil(idbKeyval.set(`resources:${path}`, resources));```
2509	alestra.com.mx.js	Improper Input Validation	Medium	true	N/A	8	pathname.match	standard	{The `pathname.match` function extracts a user-controlled parameter from the URL path, which is then parsed without validation. This allows an attacker to craft malicious input that could lead to unintended behavior, such as accessing unauthorized APIs or triggering unexpected logic flows, due to lack of input sanitization.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
2510	pusulahaber.com.tr.js	Insecure Resource Loading	Medium	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and appears safe, the vulnerability arises because the version parameter is dynamically appended to the URL. If the version variable were derived from untrusted or unsanitized input (e.g., from user input or a configuration file), it could be manipulated to load a malicious script from an attacker-controlled domain. Although currently not directly user-controlled, the dynamic nature of the URL construction introduces risk, especially if the version variable is ever sourced from an untrusted origin. This constitutes misuse of a sensitive function due to dynamic URL construction.}	```importScripts('https://www.pusulahaber.com.tr/d/assets/bundle/webpush.js?v=' + version);```
2511	yjs.dev.js	Improper Error Handling in Network Fetch Leading to Denial of Service	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper error handling in the fetch operation within the fetch event handler. The .catch(function (t) {}) block does not handle or log the error, and since it is empty, any network failure or exception during fetch will be silently ignored. This can lead to a denial of service scenario where the service worker fails to respond to requests without any feedback or recovery mechanism. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by poor error handling logic.}	"```self.addEventListener(""fetch"", function (t) { var s; ""GET"" === t.request.method && t.respondWith((s = t.request, caches.open(e).then(function (t) { return t.match(s).then(function (t) { return t && 404 !== t.status ? t : Promise.reject(""no-match""); }); })).then(function (e) { return t.waitUntil(fetch(t.request).then(function (e) { return n(t.request, e); })), e; }, function () { return fetch(t.request).then(function (e) { return t.waitUntil(n(t.request, e.clone())), e; }).catch(function (t) {}); })); });```"
2512	musclegrowth.net.js	Improper CSRF Token Validation	High	true	N/A	9	fetch	standard	{The vulnerability arises from the use of fetch to dynamically retrieve a CSRF token based on the request path, which is derived from the intercepted request. While fetch itself is not inherently unsafe, its misuse here—specifically, dynamically constructing URLs with user-controlled path parameters and relying on server-side CSRF token generation without proper validation or rate limiting—enables an attacker to forge requests with valid tokens. This improper use of fetch in conjunction with unsanitized path data allows for CSRF attacks, as the token is fetched and applied without verifying the origin or intent of the request.}	```const curRequest = request.clone(); fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); })```
2513	palmers.at.js	External Script Loading from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute external scripts in a Service Worker. In this case, it dynamically imports scripts from options.workboxURL and options.importScripts, which are defined in a configuration object. Although the workboxURL is hardcoded to a trusted CDN, the importScripts array is empty and could be manipulated if the configuration is dynamically loaded from an untrusted source. This allows an attacker to inject malicious scripts by controlling the importScripts array, leading to arbitrary code execution within the service worker context.}	N/A
2514	palmers.at.js	Inadequate Request Interception Leading to Cache Manipulation	Medium	false	New	0	N/A	N/A	{The vulnerability arises from insufficient handling of requests with 'only-if-cached' and 'no-cors' modes, which may lead to unintended cache behavior. However, this is not caused by misuse of a sensitive function, but rather by a logic flaw in the request interception strategy. The code modifies the request to use 'default' cache mode, but this does not involve a sensitive function like eval, importScripts, or unsafe dynamic code execution.}	N/A
2515	happiness.com.js	Exposure of Sensitive Information in Client-Side Code	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key) in client-side code, not from misuse of a sensitive JavaScript function.}	"```importScripts('https://www.gstatic.com/firebasejs/7.14.1/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/7.14.1/firebase-messaging.js');(function (supported) { if (!supported) { console.log('[SW] BROWSER DOES NOT SUPPORT WEB PUSH'); return; } firebase.initializeApp({ apiKey: ""AIzaSyCjmA8RhrWEAJD0uWYSAUYij6BirXhMj2M"", authDomain: ""happy-706ae.firebaseapp.com"", databaseURL: ""https://happy-706ae.firebaseio.com"", projectId: ""happy-706ae"", storageBucket: ""happy-706ae.appspot.com"", messagingSenderId: ""644432654266"", appId: ""1:644432654266:web:e46e67306ad58252b5f783"", measurementId: ""G-QLC36LCEZV"" }); const messaging = firebase.messaging(); messaging.setBackgroundMessageHandler(function (payload) { console.log('[SW] Received background message.'); });})(firebase.messaging.isSupported());```"
2516	happiness.com.js	Untrusted Resource Inclusion	High	true	CWE-444	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load external scripts. When used with a hardcoded URL pointing to an external resource (e.g., Firebase SDKs), it introduces a risk if the resource is compromised or if the URL is dynamically controlled by an attacker. However, in this case, the URLs are hardcoded and not user-controlled, so the risk is lower than if the URL were derived from untrusted input. Still, loading external scripts from third-party domains can lead to code injection if those domains are compromised.}	```importScripts('https://www.gstatic.com/firebasejs/7.14.1/firebase-app.js');```
2517	happiness.com.js	Untrusted Resource Inclusion	High	true	CWE-444	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load external scripts. When used with a hardcoded URL pointing to an external resource (e.g., Firebase SDKs), it introduces a risk if the resource is compromised or if the URL is dynamically controlled by an attacker. However, in this case, the URLs are hardcoded and not user-controlled, so the risk is lower than if the URL were derived from untrusted input. Still, loading external scripts from third-party domains can lead to code injection if those domains are compromised.}	```importScripts('https://www.gstatic.com/firebasejs/7.14.1/firebase-messaging.js');```
2518	funmedia.co.ke.js	Loading external script without integrity check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used without integrity checks, it can load malicious scripts if the URL is compromised or if the script source is not secured. In this case, the script is loaded from a third-party CDN (https://cdn.subscribers.com), which introduces a supply chain risk. If the CDN is compromised or the script is tampered with, the service worker could execute malicious code, leading to data exfiltration, cache manipulation, or further attacks.}	"```importScripts(""https://cdn.subscribers.com/assets/subscribers-sw.js"");```"
2519	yaentrainement.fr.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper input validation in the context of logging. The code logs user-provided data without sanitization, but this does not involve a sensitive function like importScripts, eval, or dynamic code execution. The fetch call is used safely with a hardcoded endpoint and no user-controlled URL or dynamic script execution.}	"```const o = ""/common/log_request"",      t = e.map(e => ""string"" == typeof e ? e : JSON.stringify(e)).join("" "");    this.log(t, ""(also logToServer)"");    const r = {      category: ""logger.js"",      msg: t    };    try {      fetch(o, {        body: JSON.stringify(r),        method: ""POST"",        headers: new Headers({          ""Content-Type"": ""application/json""        })      });    } catch (e) {      this.error(""Failed to log to server:"", e);    }```"
2520	dharwadsciencecentre.org.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (Firebase API key, project ID, etc.) in the code, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'larapush-a408d', messagingSenderId: '36384989321', appId: '1:36384989321:web:d024fe20b687466a226658', apiKey: 'AIzaSyA7SwfF-YeY4hzu6yZlk7Vaatq0NPGVBTQ' }, domain: 'dharwadsciencecentre.org', api_url: 'https://lapush.cardmantr.com/api/token', vapid_public_key: 'BOUPRKcUgq1PyE-QWUBubRT5Tpi1YK0F0rry1GRmhvXHvzgi25QcSSj18kMdWY83vC8jMoj4VFI1xpvt9GgiHwE' };```
2521	dharwadsciencecentre.org.js	XSS via Notification Payload	High	true	N/A	N/A	showNotification	standard	{The showNotification function is used with user-controlled payload data (from event.data.json().data.notification) without sanitization, allowing an attacker to inject malicious content into notifications, leading to XSS if the notification is rendered in a context that executes script.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
2522	dharwadsciencecentre.org.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from notification data (event.notification.data.url or actions[event.action].click_action) without validation or sanitization, enabling an attacker to redirect users to arbitrary URLs.}	```clients.openWindow(targetUrl);```
2523	dharwadsciencecentre.org.js	Insecure Data Storage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption or access controls, not from misuse of a sensitive JavaScript function.}	```const request = objectStore.put({ id: key, data: value });```
2524	mojaobcina.si.js	Open Redirect via Untrusted Click Target	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the specified URL. In this case, the URL is derived from self.clickTarget, which is assigned from payload.clickTarget — a value received from a push notification payload. Since this payload is untrusted and not validated or sanitized, an attacker can craft a malicious push notification with a clickTarget pointing to an arbitrary external URL, leading to an open redirect. This allows the attacker to redirect users to phishing sites or malicious domains, compromising user security.}	```event.waitUntil(clients.openWindow(self.clickTarget));```
2525	outdoorphoto.co.za.js	Improper Handling of HTTP Vary Headers in Cache Matching	Medium	false	N/A	0	N/A	N/A	{The use of `ignoreVary: true` in `caches.match()` bypasses the HTTP Vary header, which can lead to serving incorrect cached responses if the server uses Vary to differentiate responses based on request headers. This is a configuration issue, not misuse of a sensitive function.}	```const a = await caches.match(e, { ignoreVary: !0 }); if (a) return a;```
2526	outdoorphoto.co.za.js	Unvalidated URL in Notification Click Handler	Medium	true	N/A	N/A	clients.openWindow	standard	{The `clients.openWindow()` function is called with `e.notification.data.targetURL`, which is derived from untrusted push notification data. Since this URL is not validated or sanitized, an attacker could craft a push message with a malicious URL, leading to open redirect or phishing attacks.}	```clients.openWindow(e.notification.data.targetURL);```
2527	netspendskylight.com.js	Server Side Request Forgery (SSRF) via no-cors mode	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with the 'no-cors' mode and is called with URLs extracted from the HTML content of a prefetched page. These URLs are derived from <link> tags in the page, which can be controlled by an attacker if the prefetched page is malicious or if the origin is compromised. Since 'no-cors' mode allows fetching from any origin without CORS restrictions, an attacker could craft a page that includes <link> tags pointing to internal or restricted resources (e.g., localhost, internal APIs), enabling SSRF. The dynamic nature of the URLs (extracted via regex from untrusted HTML) makes this a sensitive misuse of fetch().}	"```return Promise.all(t.map(e => fetch(e, { mode: ""no-cors"" })));```"
2528	canalworld.net.js	Insecure Dynamic Code Execution in Pluralize Function	High	true	CWE-95	9	const pluralize = (word, params) => { let i = 0; if (!Array.isArray(params)) { params = [params]; } word = word.replace(/\{(!|\d+?)?#(.*?)\}/g, (a, b, c, d) => { if (!b || b == '!'') { b = i; i++; } let value; let fallback; let output = ''; let replacement = params[b] + ''; c.replace(/\[(.+?):(.+?)\]/g, (w, x, y, z) => { if (x == '?') { fallback = y.replace('#', replacement); } else if (x.charAt(0) == '%' && x.substring(1) == replacement.substring(0, x.substring(1).length)) { value = y.replace('#', replacement); } else if (x.charAt(0) == '*' && x.substring(1) == replacement.substr(-x.substring(1).length)) { value = y.replace('#', replacement); } else if (x == replacement) { value = y.replace('#', replacement); } }); output = a.replace(/^\{/, '').replace(/\}$/, '').replace('!#', ''); output = output.replace(b + '#', replacement).replace('#', replacement); output = output.replace(/\[.+\]/, value == null ? fallback : value).trim(); return output; }); return word; }	custom	{The `pluralize` function uses `String.prototype.replace` with a dynamic regular expression and a callback that processes user-controlled input (`params`) to construct replacement strings. While not directly executing code, this function can be exploited to perform unintended string manipulations or even lead to injection if the input is not properly sanitized, especially when `params` contains maliciously crafted strings that trigger unexpected behavior in the replacement logic. This misuse of `replace` with dynamic input and complex string processing constitutes a sensitive function misuse, as it can lead to unintended output or logic flow, potentially enabling injection or bypasses.}	N/A
2529	cascadeclimbers.com.js	Open Redirect via Notification Click	Medium	true	CWE-601	9	N/A	standard	{The function `clients[0].navigate(data.url)` is a standard browser API used to navigate a client to a specified URL. The URL is derived from the `data.url` field in the notification payload, which is obtained from a server response. Since this data is not validated or sanitized, an attacker could craft a malicious notification with a URL pointing to an external site, leading to an open redirect. This allows an attacker to trick users into visiting unintended domains, potentially phishing or redirecting them to malicious sites.}	```clients[0].navigate(data.url);```
2530	cascadeclimbers.com.js	Open Redirect via Window Open	Medium	true	CWE-601	9	N/A	standard	{The function `self.clients.openWindow(data.url ? data.url : BASE_URL)` is a standard browser API that opens a new window or tab to a specified URL. The URL is again derived from `data.url`, which comes from server response data and is not sanitized. If an attacker can control this data, they can redirect users to arbitrary domains, enabling open redirect attacks. This is particularly dangerous if the user is logged in, as it could lead to session hijacking or phishing.}	```self.clients.openWindow(data.url ? data.url : BASE_URL);```
2531	cascadeclimbers.com.js	Potential XSS in Notification Content	Medium	true	CWE-79	8	N/A	standard	{The function `self.registration.showNotification(title, options)` is a standard browser API that displays a notification with content derived from server data. The `title` and `body` fields are directly taken from the server response without sanitization. If an attacker can inject malicious script or HTML into these fields, they could potentially execute arbitrary JavaScript in the context of the notification, leading to XSS. While notifications typically do not execute scripts, some browsers or contexts may allow rich content rendering, increasing the risk.}	"```const { body, url, grouped, groupedTitle, groupedUrl, icon, image } = data; let { title } = data; let tag; if (data.tag) { tag = data.tag.substr(0, 30); } let options = { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } }; if (!tag || !grouped) { return self.registration.showNotification(title, options); } else { return self.registration.getNotifications({ tag }).then(notifications => { options = { ...options, tag, renotify: true, data: { ...options.data, unseenCount: 1 } }; if (notifications.length) { try { const lastWithTag = notifications[notifications.length - 1]; if (lastWithTag.data && typeof lastWithTag.data.unseenCount !== ""undefined"") { const unseenCount = lastWithTag.data.unseenCount + 1; options.data.unseenCount = unseenCount; options.body = pluralize(grouped.replace(""{count}"", unseenCount), unseenCount); if (groupedUrl) { options.data.url = groupedUrl ? groupedUrl : options.data.url; } if (groupedTitle) { title = pluralize(groupedTitle.replace(""{count}"", unseenCount), unseenCount); } lastWithTag.close(); } } catch (err) { console.log(err); } } return self.registration.showNotification(title, options); }); }```"
2532	4elementos.com.js	External Script Loading without Validation	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable. However, the vulnerability arises if the URL is dynamically constructed from untrusted input. In this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse but rather due to lack of validation or control over external script sources. Therefore, the vulnerability is not caused by sensitive function misuse.}	"```importScripts(""https://cdn.connectif.cloud/scripts/service-worker.js"");```"
2533	motociclism.ro.js	CSRF Vulnerability	High	true	N/A	8	N/A	standard	{The vulnerability arises from the improper handling of CSRF tokens during guest POST requests. The code dynamically constructs a URL using `new URL(curRequest.url)` and `path = url.pathname`, then fetches a CSRF token via `fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)`. While `fetch` itself is not inherently unsafe, the vulnerability stems from the fact that the `path` parameter is derived from the request URL without sanitization or validation, and the resulting URL is used to fetch a CSRF token. If an attacker can manipulate the `path` parameter (e.g., via a crafted URL), they could potentially trigger unintended behavior or bypass CSRF protections. The `fetch` function is being used with dynamically constructed URLs, which introduces risk if the input is not properly sanitized.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; } e.respondWith(new Promise((resolve, reject) => { log(`On navigation, logged_in is ${loggedIn}`); if (loggedIn == 'false' && request.method === 'POST') { const curRequest = request.clone(); log('Intercepting guest post request'); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); }); return; } resolve(fetch(request)); }).catch(err => { console.log(err); });```
2534	coinzoom.com.js	Improper URL Validation in Excluded URLs Check	High	false	N/A	0	N/A	N/A	{The vulnerability arises from using `indexOf` to check for substring matches in URLs, which is insufficient for proper URL validation. This is not caused by misuse of a sensitive function, but rather by flawed logic in URL filtering.}	```for (let index = 0; index < excludedUrls.length; index++) { const url = excludedUrls[index]; if (request.url.indexOf(url) !== -1) { return; } }```
2535	coinzoom.com.js	Reliance on Accept Header for Request Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from relying on the `accept` header to determine request handling, which can be manipulated by attackers. This is a logic flaw, not a result of misusing a sensitive function.}	```if (request.method === 'GET' && request.headers.get('accept') && request.headers.get('accept').includes('*/*')) { for (let index = 0; index < filesToCache.length; index++) { const url = filesToCache[index]; if (request.url.indexOf(url) !== -1) { event.respondWith(fetch(request).catch(function (error) { return caches.open(currentCache.offline).then(function (cache) { return cache.match(url); }); })); } } }```
2536	smilesnap.com.js	Improper Input Validation (Blacklist Bypass)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in the blacklist check, not from misuse of a sensitive function. The function `shouldCachePageRequest` uses `includes()` to check for blacklisted URLs, which is susceptible to bypass via URL encoding or partial matches. This is a validation issue, not a sensitive function misuse.}	```const shouldCachePageRequest = function (request) { return PwaSettings.PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); };```
2537	smilesnap.com.js	Information Exposure Through Debug Logging	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from enabling debug logging (`pwaSettings.debug = true`), which exposes internal information via `console.log` calls. This is a configuration issue, not a misuse of a sensitive function.}	```pwaSettings.debug = true;```
2538	smilesnap.com.js	Insufficient Access Control in Message Handler	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to lack of authentication or authorization checks in the message handler, allowing any page to trigger cache deletion. This is a logic flaw, not a sensitive function misuse.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { ... } });```
2539	pcforum.hu.js	Open Redirect via Notification Click	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow(url) is used to open a new window or tab with a URL derived from untrusted notification data. The URL is constructed from user-controlled fields such as data.settingsurl or data.actions[r].url, which are parsed from event.data.json() without validation or sanitization. This allows an attacker to craft a malicious notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities.}	```if (event.action == 'settings' && data.settingsurl) url = data.settingsurl;else if (data.actions) data.actions.forEach(function (r) { if (r.action == event.action) url = r.url; }); clients.openWindow(url);```
2540	higherlevel.nl.js	Improper Access Control	High	true	CWE-284	9	matches[1]	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter, which is then used without validation to control access logic. While `match()` itself is not inherently sensitive, its misuse here allows an attacker to manipulate the `loggedIn` parameter in the URL to bypass access controls, effectively enabling unauthorized access. The function is standard, but its context of use introduces a critical security flaw.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2541	higherlevel.nl.js	Server Side Request Forgery	High	true	CWE-918	10	fetch()	standard	{The `fetch()` function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since `path` is derived from user input (via `new URL(curRequest.url).pathname`), an attacker can manipulate the request URL to trigger `fetch()` to send requests to arbitrary external domains, leading to SSRF. This is a direct misuse of a standard function with untrusted input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2542	higherlevel.nl.js	Reliability	Medium	false	CWE-758	0	N/A	N/A	{The `request.clone()` function is used to create a copy of the request for further processing. This is a standard and safe operation in service workers, and does not introduce a reliability vulnerability. The reported issue is likely a false positive or misclassification, as `clone()` is not inherently risky when used correctly.}	```const curRequest = request.clone();```
2543	higherlevel.nl.js	Open Redirect	Medium	true	CWE-601	9	navigate()	standard	{The `navigate()` method is called with `data.url`, which is derived from a push notification payload. Since this data is not validated or sanitized, an attacker can craft a malicious notification with a `data.url` pointing to an arbitrary external site, leading to an open redirect. This is a direct misuse of a standard function with untrusted input.}	```clients[0].navigate(data.url);```
2544	biohort.com.js	Insecure Script Import	High	true	CWE-94	10	importScripts	standard	"{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded as ""/dist/core-service-worker.js"", which is not dynamically derived from untrusted input. Therefore, this usage is not inherently vulnerable to injection or arbitrary code execution. However, if the script at this path is compromised or if the script itself contains insecure logic (e.g., dynamic script loading from user input), it could lead to a security issue. But strictly speaking, the misuse of importScripts() here is not due to dynamic or untrusted input, so it does not constitute a sensitive function misuse.}"	"```importScripts(""/dist/core-service-worker.js"");```"
2545	tetatet-club.ru.js	Improper Input Validation in Cache Logic	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly permissive and complex logic in the fetch event handler that fails to properly validate or sanitize the requested URL before deciding whether to serve from cache or fetch from network. While no single sensitive function is misused, the logic is flawed and could allow unintended resource fetching or cache bypass.}	```if (theurlt0.indexOf('//tetatet-club.ru') < 0 && theurlt0.indexOf('//localhost/teta2') < 0 || event.request.method != 'GET' || event.request.mode == 'cors' && theurlt.indexOf('/fonts/') < 0 && theurlt.indexOf('/css/') < 0 && theurlt.indexOf('.jpg') < 0 && theurlt.indexOf('.png') < 0 && theurlt.indexOf('/js20/') < 0 && theurlt.indexOf('/ckeditor4/') < 0 || event.request.url.startsWith('chrome-extension') || theurlt.indexOf('garget') >= 0 || theurlt.indexOf('/ggg/') >= 0 || theurlt.indexOf('/noi/') >= 0 || theurlt.indexOf('/pr/') >= 0 || theurlt.indexOf('/daily/') >= 0 || theurlt.indexOf('/a/') >= 0 || String(strFC).indexOf(theurlt) < 0 && !(theurlt.indexOf('/in/') >= 0 || theurlt.indexOf('/p/') >= 0 || theurlt.indexOf('/games/') >= 0 || theurlt.indexOf('catm.png') >= 0 || theurlt.indexOf('/p/blo') >= 0 || theurlt.indexOf('/image') >= 0 || theurlt.indexOf('/apple') >= 0 || theurlt.indexOf('/sw.js') >= 0 || theurlt.indexOf('/swLL.js') >= 0 || theurlt.indexOf('/swapp') >= 0 || theurlt.indexOf('.json') >= 0 || theurlt.indexOf('/ckeditor4') >= 0 || theurlt.indexOf('.css') >= 0 || theurlt.indexOf('/js20/') >= 0 || theurlt.indexOf('/fonts/') >= 0 || theurlt.indexOf('/z/') >= 0 || theurlt.indexOf('/z_m/') >= 0)) { return; }```
2546	tetatet-club.ru.js	Use of eval() Function	High	true	N/A	N/A	eval	standard	{The eval() function is used to execute arbitrary JavaScript code received from the event.data payload, which is untrusted and potentially malicious. This allows an attacker to inject and execute arbitrary code within the service worker context, leading to full compromise.}	```try { eval(event.data); } catch (err) {}```
2547	tetatet-club.ru.js	Insecure Fallback Content Handling	Medium	false	N/A	N/A	N/A	N/A	{The fallback content is hardcoded and served via a Response object, but it does not involve dynamic or untrusted input. The vulnerability lies in the lack of proper error handling or content sanitization, not in misuse of a sensitive function.}	```return Promise.resolve(new Response(FALLBACK, { headers: { 'Content-Type': 'text/html; charset=utf-8', 'Content-language': 'ru' } }));```
2548	tetatet-club.ru.js	Insecure External Resource Fetching	High	true	N/A	N/A	fetch	standard	{The fetch function is used to retrieve data from an external URL (aurl) constructed using user-controlled parameters (swusid, swINu, swkcid). If these parameters are not properly validated, an attacker could manipulate them to fetch from unintended or malicious domains, leading to data exfiltration or cache poisoning.}	```fetch(aurl).then(response => response.json()).then(text => { ... });```
2549	tetatet-club.ru.js	Insecure Notification Click Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of notification click events, where the target URL is derived from notification data without validation. However, no sensitive function is misused; the issue is more about logic flaws and insufficient input validation.}	```event.waitUntil(clients.matchAll({ type: 'window', includeUncontrolled: true }).then(function (clientList) { ... }));```
2550	lancasterco.com.js	Unauthorized Access to Offline Content	High	true	CWE-306	10	N/A	standard	{The `caches.match('/offline.html')` function is used to serve offline content when the main request fails. While `caches.match` itself is not inherently dangerous, its misuse here allows unauthorized access to offline content without proper authentication or access control. Since the service worker serves `/offline.html` for any failed navigation or GET request that accepts HTML, an attacker could potentially trigger this fallback for any user, leading to exposure of sensitive offline content. This is a misuse of the caching mechanism, not a direct function misuse, but the function is being used in a context that enables unauthorized access.}	```return caches.match('/offline.html');```
2551	adriensosa.fr.js	Caching of Sensitive Data in URLs	High	true	CWE-400	9	N/A	standard	{The vulnerability arises from caching URLs that may contain sensitive data (e.g., query parameters with credentials or session tokens) without sanitization or filtering. The `cache.add(url)` function is used with URLs from the `filesToCache` array, which includes hardcoded URLs but could be dynamically populated in other contexts. While the current URLs are static and non-sensitive, the pattern of using `cache.add()` without validating or sanitizing the URL content introduces a risk if the URLs were to be derived from untrusted sources. This misuse of the standard `cache.add()` function allows sensitive data to be stored in the cache, potentially exposing it to unauthorized access.}	```filesToCache.map(function (url) { return cache.add(url).catch(function (reason) { return console.log('SuperPWA: ' + String(reason) + ' ' + url); }); });```
2552	adriensosa.fr.js	Uncontrolled Resource Consumption (Cache Size	Medium	true	CWE-400	8	N/A	standard	{The `caches.put()` function is used without size limits or eviction policies, leading to uncontrolled cache growth. When `cache.put(e.request, response.clone())` is called for every fetched resource, especially during navigation, it can result in excessive memory and storage consumption. This misuse of the standard `caches.put()` function allows the cache to grow indefinitely, potentially degrading performance or exhausting device resources, especially if the service worker processes many requests without cache cleanup.}	```e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }); }).catch(function () { return caches.match(offlinePage); }));```
2553	dayzrp.com.js	Insecure Determination of User Authentication Status	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter directly from the URL using a regex, which can be manipulated by an attacker to bypass authentication checks. This is not due to misuse of a sensitive function, but rather a logic flaw in authentication state determination.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2554	dayzrp.com.js	Unvalidated Server Response in Notification URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from trusting the `data.url` value received from the server without validation, which could lead to redirecting users to malicious sites. This is not caused by misuse of a sensitive function, but by improper input validation.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2555	dayzrp.com.js	Unvalidated Notification Data in URL Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using unvalidated notification data (title, body, URL) directly in `showNotification`, which could lead to phishing or misleading users. This is not due to misuse of a sensitive function, but due to lack of input sanitization.}	```return self.registration.showNotification(title, options);```
2556	dayzrp.com.js	CSRF Token Generation with Untrusted Path	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL where the `path` parameter is derived from the request URL without sanitization. This allows an attacker to inject arbitrary paths, potentially leading to CSRF token generation for unintended endpoints, enabling unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2557	educators.su.js	Vulnerable Cache Name Generation	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from generating a cache name using `new Date().getTime()`, which is not inherently unsafe but leads to information leakage (CWE-200) due to predictable, time-based cache names. This is not caused by misuse of a sensitive function, but rather by poor design in cache naming.}	"```var staticCacheName = ""pwa-v"" + new Date().getTime();```"
2558	educators.su.js	Potential Cache Deletion DoS	High	false	CWE-400	N/A	N/A	N/A	"{The vulnerability stems from deleting all caches starting with ""pwa-"" during activation, which could lead to denial of service if an attacker can force cache regeneration or deletion. This is not due to misuse of a sensitive function, but rather a logic flaw in cache management.}"	"```event.waitUntil(caches.keys().then(cacheNames => { return Promise.all(cacheNames.filter(cacheName => cacheName.startsWith(""pwa-"")).filter(cacheName => cacheName !== staticCacheName).map(cacheName => caches.delete(cacheName))); }));```"
2559	educators.su.js	Missing Request Validation	Medium	false	CWE-22	N/A	N/A	N/A	{The vulnerability occurs because the service worker blindly serves any request without validating its origin or path, potentially allowing unauthorized access to cached resources. This is not caused by misuse of a sensitive function, but by lack of input validation in the fetch handler.}	```event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match('offline'); }));```
2560	stiridiaspora.ro.js	Hardcoded Authentication Credentials	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials in the URL, not misuse of a sensitive function.}	```self.addEventListener('push', function (event) { event.waitUntil(fetch('https://apism.speedmeta.com/get_notification_V2/?key=P1WF04DPZU8VAJZDEYDQ').then(function (response) { if (response.status !== 200) { throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { throw new Error(); } var ua = navigator.userAgent.toLowerCase(); var isMac = ua.indexOf('macintosh') > -1; var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var image = data.notification.image; var notificationTag = data.notification.tag; var final_link = data.notification.link; var req_interaction = isMac ? false : true; return self.registration.showNotification(title, { body: message, icon: icon, image: image, tag: notificationTag, data: data, requireInteraction: req_interaction }); })); }); });```
2561	stiridiaspora.ro.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from ev.notification.data.notification.link, which is sourced from external data. If this link is not validated or sanitized, it can be manipulated to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	"```self.addEventListener('notificationclick', function (ev) { ev.waitUntil(clients.matchAll({ type: ""window"" }).then(function (clientList) { return clients.openWindow(ev.notification.data.notification.link); })); ev.notification.close(); });```"
2562	qtext.io.js	Incorrect Handling of POST Requests Leading to Misleading Offline Responses	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the service worker's handling of POST requests by attempting to fetch them and falling back to an offline page on failure. However, this is not a misuse of a sensitive function, as no function like importScripts, eval, or dynamic code execution is involved. The issue is a logic flaw in offline response handling, not a security vulnerability stemming from sensitive function misuse.}	"```self.addEventListener(""fetch"", event => { if (event.request.url.startsWith(self.location.origin)) { if (event.request.clone().method === ""GET"") { event.respondWith(fetch(event.request.clone()).catch(() => { return caches.match(""/offline.html""); })); } else if (event.request.clone().method === ""POST"") { event.respondWith(fetch(event.request.clone()).catch(() => { return caches.match(""/offline.html""); })); } } });```"
2563	lotto247.co.za.js	External Script Import in Service Worker	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes scripts from specified URLs. When used with a hardcoded external URL like 'https://api.exponea.com/js/service-worker.min.js', it introduces a high-risk vulnerability because the script is fetched and executed from a third-party domain. If the third-party server is compromised or the script is malicious, it can lead to full control over the service worker, enabling cache manipulation, network interception, or injection of malicious code.}	```importScripts('https://api.exponea.com/js/service-worker.min.js');```
2564	proxylite.com.js	Cache Invalidation Bypass	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from the use of `e.precacheAndRoute` with hardcoded URLs and revisions, but no dynamic or untrusted input is involved. The issue is more about misconfiguration or lack of proper cache invalidation strategy rather than misuse of a sensitive function.}	```e.precacheAndRoute([{url: '_nuxt/builds/latest.json', revision: '49dc07bf5485ae82a68505bf36bb43fa'}, {url: '_nuxt/builds/meta/6339b6c1-73a9-4735-8874-a0102d430449.json', revision: null}, {url: 'manifest.webmanifest', revision: 'b7686df1978a20e66a802224cc616077'}], {})```
2565	proxylite.com.js	Dangerous Dynamic Script Loading	High	true	CWE-94	N/A	importScripts	N/A	"{The `importScripts` function is used dynamically with a variable `t` that is derived from a URL constructed via `new URL(t + "".js"", n).href`. Since `t` is passed as a parameter and not hardcoded, it can be controlled by external input, allowing an attacker to inject arbitrary script URLs, leading to remote code execution.}"	```importScripts(t), s```
2566	proxylite.com.js	Unvalidated Message Handling	Medium	false	CWE-352	N/A	N/A	N/A	{The vulnerability stems from handling messages without validating the source or content of `e.data.type`. However, no sensitive function is misused here; the issue is a logic flaw in message handling, not improper use of a function like `eval` or `importScripts`.}	```self.addEventListener('message', e => { e.data && 'SKIP_WAITING' === e.data.type && self.skipWaiting(); })```
2567	akweb.de.js	Vary Header Misconfiguration	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a misconfiguration in handling the 'Vary' header, not from misuse of a sensitive JavaScript function. The code logs a warning when a 'Vary' header is present, suggesting that caching may not work as expected, but no function is improperly used to introduce a security risk.}	"```""production"" !== process.env.NODE_ENV && e.headers.get(""Vary"") && a.debug(`The response for ${u(o.url)} has a 'Vary: ${e.headers.get(""Vary"")}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);```"
2568	herogames.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the id parameter received from a push event. Since the id is derived from untrusted external data (push notification payload), an attacker could craft a malicious push notification with an id that causes the service worker to make a request to an arbitrary internal or external endpoint, leading to SSRF. The URL is dynamically built using template literals and the id variable, which is not sanitized or validated.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2569	herogames.com.js	Insecure Session Management	High	false	CWE-598	0	N/A	N/A	{The vulnerability arises from improper handling of the loggedIn parameter in the URL, which is used to determine user authentication state. However, this is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in session management based on URL parameters.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2570	herogames.com.js	Open Redirect	Medium	true	CWE-601	8	N/A	standard	{The navigate() method is used with a URL derived from the data.url field of a notification, which is obtained from untrusted push notification data. Since the URL is not validated or sanitized, an attacker could set data.url to a malicious external URL, causing the browser to redirect the user to an arbitrary site, leading to an open redirect vulnerability.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2571	herogames.com.js	Cross-Site Request Forgery (CSRF)	Medium	true	CWE-352	9	N/A	standard	{The fetch() function is used to retrieve a CSRF token from the server using a path parameter derived from the current request URL. Since the path is extracted from the request URL without validation, an attacker could manipulate the path to target unintended endpoints, potentially leading to CSRF if the token is used in subsequent requests without proper validation.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2572	transitfluxcon.com.js	Regular Expression Denial of Service (ReDoS)	Medium	true	CWE-1338	9	RegExp	standard	{The vulnerability arises from the use of a regular expression with a potentially catastrophic backtracking pattern: `inboxtraffic\\\\.com(?:/.*)?/ola/services/.*`. This pattern can cause ReDoS when matched against maliciously crafted input, leading to excessive CPU consumption. The sensitive function here is RegExp, which is used to create the pattern, and it is misused due to the unbounded `(.*)?` construct that allows for exponential time complexity during matching.}	"```const c = JSON.parse('[""inboxtraffic\\\\.com(?:/.*)?/ola/services/.*"",""inboxtraffic\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://c7f2267a-6c39-4783-ba15-ed3f44723b79\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
2573	lessonbuddy.com.js	Use of Third-Party Code Without Integrity Check	Medium	true	CWE-928	9	N/A	standard	{The `importScripts()` function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is called with `options.workboxURL`, which is a hardcoded URL pointing to a CDN. While the URL is not dynamically derived from untrusted input, the lack of integrity checking (e.g., using `integrity` attribute or subresource integrity) means that if the CDN is compromised, the loaded script could be malicious. However, since the URL is hardcoded and not user-controlled, this is not a direct sensitive function misuse in the context of dynamic, untrusted input. But given the nature of `importScripts()` as a sensitive function that executes arbitrary code, and the absence of integrity verification, it is still considered a sensitive misuse.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
2574	lessonbuddy.com.js	Information Exposure Through an Error Message	Medium	false	CWE-209	N/A	N/A	N/A	{The `console.error()` function is used to log error details, including the error message and context. While this can expose sensitive information in development environments, it is not caused by misuse of a sensitive function like `importScripts()` or `eval()`. The function `console.error()` is not inherently sensitive in terms of code execution or injection, and its misuse here is more about logging practices than function misuse.}	```console.error(ctx.error, 'Details:', ctx);```
2575	carmasters.org.js	Insecure Session Management via URL Parameter	High	true	CWE-598	9	N/A	standard	{The vulnerability arises from using `match()` on `e.currentTarget.location.href` to extract a session state (`loggedIn`) directly from the URL. While `match()` itself is not inherently dangerous, its misuse here allows an attacker to manipulate the URL to spoof login state, leading to insecure session management. The function is standard, and the risk stems from trusting URL parameters without validation or secure session handling.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2576	carmasters.org.js	Path Traversal in CSRF Token Request	High	true	CWE-22	9	N/A	standard	{The `fetch()` function is used with a dynamically constructed URL where `path` is derived from the request URL. If `path` contains directory traversal sequences (e.g., `../../`), it can lead to unauthorized access to sensitive resources. The `fetch()` function is standard, and its misuse here allows path traversal due to insufficient sanitization of the `path` parameter.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2577	carmasters.org.js	Insecure Credential Handling in Fetch Request	Medium	true	CWE-548	8	N/A	standard	{The `fetch()` function is used with `credentials: 'include'`, which sends cookies and authentication headers with the request. Since the `id` parameter is derived from the push event data (which is untrusted), an attacker could manipulate this to access or leak sensitive data via the notification endpoint. The `fetch()` function is standard, and its misuse here enables insecure credential handling due to lack of input validation.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2578	xn----7sb1afhdkobefm7j.xn--p1ai.js	Improper HTTP Method Handling for Upload Endpoint	High	false	CWE-771	N/A	N/A	N/A	{The vulnerability arises from routing all GET requests to /upload/* using cacheFirst, but does not enforce proper HTTP method validation. This is not due to misuse of a sensitive function, but rather a logical flaw in routing configuration.}	```toolbox.router.get('/upload/*', toolbox.cacheFirst);```
2579	xn----7sb1afhdkobefm7j.xn--p1ai.js	Caching Sensitive Upload Data	High	false	CWE-921	N/A	N/A	N/A	{The issue stems from caching responses for /upload/* endpoints without considering the sensitivity of the data being cached. This is a configuration issue, not a result of misusing a sensitive JavaScript function.}	```toolbox.router.get('/upload/*', toolbox.cacheFirst);```
2580	xn----7sb1afhdkobefm7j.xn--p1ai.js	Unvalidated Network Fallback with Timeout	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is due to using networkFirst with a timeout without validating or sanitizing the network request behavior. This is a configuration or logic flaw, not caused by misuse of a sensitive function.}	```toolbox.router.get('/*', toolbox.networkFirst, { networkTimeoutSeconds: 5 });```
2581	nano-reef.com.js	Insecure Determination of User Authentication Status via URL Parameter	High	true	CWE-548	9	N/A	standard	{The vulnerability arises from using `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to determine user authentication status. This relies on a URL parameter that can be easily manipulated by an attacker. Since the service worker does not validate or sanitize this input, an attacker can forge the URL to bypass authentication checks, leading to unauthorized access. The `match` function is standard but misused here by trusting untrusted input for security decisions.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2582	nano-reef.com.js	Improper Input Validation in CSRF Token Request Path	Medium	true	CWE-20	8	N/A	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` variable derived from the request URL. Since `path` is not validated or sanitized, an attacker can inject arbitrary paths into the request, potentially leading to unintended CSRF token requests or server-side path traversal. The `fetch` API is standard, but its misuse here with untrusted input introduces a vulnerability.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2583	nano-reef.com.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-601	9	N/A	standard	{The `navigate` method is used with `data.url ? data.url : BASE_URL`, where `data.url` comes from a server response that is not validated. An attacker could manipulate the server to return a malicious URL, causing the service worker to redirect the user to an arbitrary site, leading to phishing or credential theft. The `navigate` method is a standard browser API, but its misuse with untrusted input creates an open redirect vulnerability.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2584	beyonddiet.com.js	Regular Expression Denial of Service (ReDoS)	Medium	false	CWE-1333	0	N/A	N/A	{The vulnerability arises from the use of a regular expression pattern that contains a potentially expensive quantifier (e.g., `(?:/.*)?`) which can lead to ReDoS when matched against maliciously crafted input. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by the inherent complexity of the regex pattern itself.}	"```const c = JSON.parse('[""beyonddiet\\\\.com(?:/.*)?/ola/services/.*"",""beyonddiet\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://49ce1ac1-faa7-45d9-9362-350ee13bcd87\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
2585	reporternewspapers.net.js	Vulnerable Cache Key Construction	High	true	CWE-544	9	concatenation of dynamic prefix with cacheName	standard	{The cacheName is constructed by concatenating a dynamic prefix (wp-\/) with a user-defined or configuration-driven cacheName. This can lead to cache key collisions or unintended cache behavior if the prefix is not properly sanitized or if it's derived from untrusted sources, potentially allowing an attacker to manipulate cache keys and bypass security controls.}	"```const strategyArgs = { ""cacheName"": ""wp-\/"" + strategyArgs.cacheName };```"
2586	reporternewspapers.net.js	Insecure CDN Module Loading	High	true	CWE-496	10	importScripts	standard	{The importScripts function is used with a dynamically constructed URL derived from the modulePathPrefix configuration. If this configuration is controlled by an attacker or improperly sanitized, it allows arbitrary script execution from an external source, leading to complete compromise of the service worker.}	```importScripts(e), this.jt = !0;```
2587	reporternewspapers.net.js	Broad Cache Regex Pattern	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from overly broad regex patterns used in route registration, which may inadvertently cache unintended resources. However, this is not caused by misuse of a sensitive function, but rather by poor pattern design.}	"```new RegExp(""^https\\:\\\/\\\/roughdraftatlanta\\.com\\\/wp\\-content\\\/uploads\\\/.*\\.(jpg|jpeg|jpe|gif|png|bmp|tif|tiff|ico|heic|webp|avif)(\\?.*)?$"")```"
2588	reporternewspapers.net.js	Precaching Sensitive Error Templates	Medium	false	CWE-544	N/A	N/A	N/A	{The vulnerability stems from precaching URLs containing sensitive error templates, which may expose internal application state. This is not due to misuse of a sensitive function, but rather a misconfiguration in what resources are precached.}	```'url': 'https:\/\/roughdraftatlanta.com\/?wp_error_template=offline'```
2589	kosmolot.com.ua.js	External Dependency Import	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., from a CDN), it introduces a dependency on an external resource that could be compromised or altered by an attacker. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an untrusted external source, which can lead to supply chain attacks if the CDN is compromised. This is considered a sensitive function misuse due to the potential for remote code execution if the external script is tampered with.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.0.0/workbox-sw.js');```
2590	kosmolot.com.ua.js	Overly Permissive Cache Regex	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of a broad regex pattern '/*' in registerRoute, which matches all URLs. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a configuration flaw in the caching strategy. The workbox.routing.registerRoute function is not inherently sensitive when used with static patterns; the issue is the overly permissive route matching, not dynamic or untrusted input.}	```workbox.routing.registerRoute(new RegExp('/*'), new workbox.strategies.StaleWhileRevalidate({ cacheName: CACHE }));```
2591	photocollage.com.js	Caching Without Validation	High	true	CWE-922	9	cache.put	N/A	{The cache.put function is used to store responses in the cache without validating the content or origin of the response. Since the response is directly obtained from fetch(event.request) and stored without any checks, it allows potentially malicious or unintended content to be cached. This can lead to cache poisoning or serving stale/compromised content to users. The function is standard and its misuse here stems from lack of validation on the response before caching.}	```if (event.request.method == 'GET') { cache.put(event.request, response.clone()); }```
2592	autopareri.com.js	Cross-Site Request Forgery (CSRF) Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's logic that checks for a `loggedIn` parameter in the URL, but it does not validate or sanitize this parameter before using it to determine whether to intercept POST requests. This is a logic flaw, not a misuse of a sensitive function.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
2593	autopareri.com.js	Insecure CSRF Token Handling	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used to retrieve a CSRF token from the server using a dynamically constructed URL that includes the `path` parameter from the intercepted request. Since the `path` is derived from the original request URL without sanitization, an attacker could craft a malicious request with a path that leads to unintended endpoints, potentially leaking tokens or bypassing protections. This misuse of `fetch` with unsanitized input introduces a risk of token leakage or CSRF bypass.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {```
2594	autopareri.com.js	Open Redirect in Notification Handling	Medium	true	N/A	N/A	self.clients.openWindow	standard	{The `self.clients.openWindow` function is used to open a URL passed via the `data.url` field from a notification. Since this URL is derived from server-provided data without validation or sanitization, an attacker could craft a notification with a malicious URL, leading to an open redirect. This allows redirection to arbitrary domains, potentially phishing users or leading them to malicious sites.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
2595	kenyatalk.com.js	Open Redirect via Untrusted Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL constructed from untrusted notification data (n + e). Since the URL is derived from user-controlled data (e.g., from push notification payload), an attacker can craft a malicious URL to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	"```if (!t.some(function (t) { return t.url === n + e && ""focus"" in t ? (t.focus(), !0) : ""postMessage"" in t && ""focus"" in t && (t.focus(), t.postMessage({ url: e }), !0); }) && clients.openWindow) return clients.openWindow(n + e);```"
2596	ravenstudio.ru.js	Caching Sensitive Data Without Proper Validation	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by a design flaw in caching logic. The code caches responses without validating whether the requested resource should be cached, potentially leading to sensitive data being stored in the cache. This is a logic issue, not a direct misuse of a sensitive function like importScripts or eval.}	```e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }); }).catch(function () { return caches.match(offlinePage); }));```
2597	unilever.us.js	Improper Validation of Response Status Before Caching	High	true	CWE-798	9	N/A	standard	{The vulnerability arises from the use of `caches.put()` without validating the HTTP response status before caching. The code clones the response (`E.clone()`) and immediately caches it using `t.put(e.request, n)` without checking if the response is successful (e.g., status 200). This allows potentially malformed or error responses (e.g., 4xx/5xx) to be cached, leading to incorrect or broken content being served to users. The `caches.put()` function is a standard browser API that, when misused with unvalidated responses, can result in improper caching behavior.}	```const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E;```
2598	hispaloto.es.js	Open Redirect via Unvalidated Notification Tag	High	true	CWE-601	10	clients.openWindow	standard	{The notification tag is used directly as a URL in clients.openWindow(url), without validation or sanitization. If an attacker can control the tag value (e.g., via a malicious push message), they can redirect the user to arbitrary websites, leading to open redirect vulnerabilities.}	N/A
2599	hispaloto.es.js	Insecure Notification Content Handling	Medium	true	New	10	self.registration.showNotification	standard	{The showNotification function is called with user-controlled data (message.body, message.title, icon) without sanitization. This allows an attacker to inject malicious content into notifications, potentially leading to phishing, social engineering, or client-side attacks if the content is rendered in a context that interprets it as executable or interactive.}	N/A
2600	hispaloto.es.js	Unvalidated Push Data in Notification Icon	Low	true	New	10	var icon = message.icon || 'https://cdn.inicium.com/images/i7/logos/logo_notif.png';	standard	{The icon URL is derived from user-controlled message.icon data, which is used directly in showNotification without validation. This allows an attacker to set the icon to a malicious URL, potentially leading to content injection or phishing if the icon is loaded from an attacker-controlled domain.}	N/A
2601	autohaus-tabor.de.js	Incorrect Cache Fetch Logic	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from incorrect logic in the fetch handler: `return fetch(event.request) || response;` will return the result of `fetch(event.request)` if it is truthy, otherwise `response`. However, `fetch()` returns a Promise, which is always truthy, so `response` is never used. This causes the service worker to always attempt to fetch from the network, bypassing the cache even when a cached response is available. This is a logic error, not a misuse of a sensitive function.}	```self.addEventListener('fetch', function (event) { if (/\.html/.test(event.request.url) || /\/$/.test(event.request.url)) { event.respondWith(caches.match(event.request).then(function (response) { return fetch(event.request) || response; }).catch(function () { return caches.match('/offline.html'); })); } });```
2602	superrich1965.com.js	Code Injection via Dynamic Module Loading	High	true	N/A	9	importScripts	standard	"{The code uses `importScripts(t)` where `t` is dynamically derived from a URL constructed via `new URL(t + \"".js\"", n).href`. Since `t` is passed as a parameter to the `define` function and can be controlled by an attacker (e.g., via a malicious script or module name), this allows arbitrary script loading and execution. The `importScripts` function is a standard browser API that executes scripts from a given URL without sanitization, making it a sensitive function when used with untrusted input.}"	```if (!self.define) { let e, s = {}; const t = (t, n) => (t = new URL(t + \'.js\', n).href, s[t] || new Promise(s => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = t, e.onload = s, document.head.appendChild(e); } else e = t, importScripts(t), s(); }).then(() => { let e = s[t]; if (!e) throw new Error(`Module ${t} didn’t register its module`); return e; })); self.define = (n, i) => { const o = e || (\'document\' in self ? document.currentScript.src : \'\') || location.href; if (s[o]) return; let r = {}; const l = e => t(e, o), u = { module: { uri: o }, exports: r, require: l }; s[o] = Promise.all(n.map(e => u[e] || l(e))).then(e => (i(...e), r)); }; }```
2603	ilovegirlcock.com.js	Improper Neutralization of Input During Web Page Generation ('Cross-Site Scripting)	High	true	CWE-79	N/A	self.clients[i].postMessage({ type: 'NEW_PUSH_MESSAGE'	standard	{The postMessage() function is used to send data to client windows, and if the data contains untrusted input (e.g., from event.data), it can lead to Cross-Site Scripting (XSS) if the receiving page evaluates or renders the data unsafely. Since the data is directly passed without sanitization, an attacker could inject malicious scripts via push notifications.}	```self.clients[i].postMessage({ type: 'NEW_PUSH_MESSAGE', data })```
2604	ilovegirlcock.com.js	Improper Validation of URL in Notification Click Handler	Medium	true	CWE-601	N/A	const urlToOpen = new URL(toOpen	standard	{The new URL() constructor is used with untrusted input (toOpen), which is derived from notification data. If an attacker controls the notification data, they can craft a URL that redirects to a malicious site or performs unintended navigation, leading to phishing or data exfiltration.}	```const urlToOpen = new URL(toOpen, self.location.origin).href```
2605	ilovegirlcock.com.js	Insecure Use of Untrusted Data in Notification Actions	Medium	true	CWE-113	N/A	actions: [{ action: 'open'	standard	{The notification actions are constructed using untrusted data (data.action_title), which can be manipulated by an attacker to trigger unintended actions or display misleading text. While not directly executable, this can lead to social engineering or confusion, especially if combined with other vulnerabilities.}	```actions: [{ action: 'open', title: data.action_title }]```
2606	ilovegirlcock.com.js	Improper Input Validation for Push Message Delivery URL	Medium	true	CWE-20	N/A	const deliveryNotifyURL = new URL(`/api/push-delivery.php?token=${data.pushMessageToken}&message=${data.pushMessageId}`	standard	{The URL is constructed using untrusted input (data.pushMessageToken and data.pushMessageId) without validation. This could allow an attacker to manipulate the URL to send requests to unintended endpoints, potentially leading to data leakage, denial of service, or server-side request forgery (SSRF) if the server makes further requests based on this URL.}	```const deliveryNotifyURL = new URL(`/api/push-delivery.php?token=${data.pushMessageToken}&message=${data.pushMessageId}`, self.location.origin).href```
2607	beianrufsex.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	N/A	standard	{The `clients.openWindow(url)` function is a standard browser API that opens a new window or tab with the specified URL. When the URL is derived directly from `event.notification.data.url` without validation or sanitization, an attacker can craft a notification payload containing a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. This allows the attacker to trick users into visiting unintended or harmful websites, potentially compromising their security.}	```let url = event.notification.data.url; if (typeof url === 'undefined') { return null; } for (let i = 0; i < clientList.length; i++) { let client = clientList[i]; if (client.url === url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); }```
2608	games-kids.com.js	Incomplete Service Worker Implementation	Medium	false	New	N/A	N/A	N/A	{The code does not use any sensitive functions; it merely registers event listeners for install, fetch, and activate events without implementing any logic. These are standard service worker patterns and do not introduce security risks.}	"```self.addEventListener(""install"", function (e) {});```"
2609	games-kids.com.js	Incomplete Service Worker Implementation	Medium	false	New	N/A	N/A	N/A	{The code does not use any sensitive functions; it merely registers event listeners for install, fetch, and activate events without implementing any logic. These are standard service worker patterns and do not introduce security risks.}	"```self.addEventListener(""fetch"", function (e) {});```"
2610	games-kids.com.js	Incomplete Service Worker Implementation	Medium	false	New	N/A	N/A	N/A	{The code does not use any sensitive functions; it merely registers event listeners for install, fetch, and activate events without implementing any logic. These are standard service worker patterns and do not introduce security risks.}	"```self.addEventListener(""activate"", function (e) {});```"
2611	detectorprospector.com.js	Open Redirect	High	true	CWE-601	10	clients[0].navigate	standard	{The function clients[0].navigate is used to redirect the client to a URL derived from the notification data (data.url). Since this URL is not validated or sanitized and can be controlled by an attacker via a malicious push notification, it enables an open redirect vulnerability. An attacker could craft a notification with a malicious URL, causing users to be redirected to arbitrary sites, potentially leading to phishing or credential theft.}	```if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL);```
2612	hipercalzado.com.js	Improper Cache Handling	High	true	N/A	8	caches.open	standard	{The caches.open function is used to open a cache by name, and while it is not inherently dangerous, its misuse in conjunction with dynamic cache names (like dynamicCacheName) and improper handling of responses can lead to cache poisoning or inconsistent caching behavior. However, in this case, the cache name is derived from a static variable (wkPwaV), so the risk is low. The real issue lies in the logic that caches responses without validating the origin or content, which can lead to improper cache handling and potential data leakage or tampering. The vulnerability is more about logic flaws than direct sensitive function misuse, but caches.open is involved in the flow.}	N/A
2613	hipercalzado.com.js	Open Redirect Vulnerability	Medium	true	N/A	9	clients.openWindow	standard	{The clients.openWindow function is used to open a new window with a URL derived from user-controlled data (notificationData.target_url). Since this URL is not validated or sanitized, an attacker could craft a notification payload that redirects users to a malicious site, leading to an open redirect vulnerability. This is a direct misuse of a sensitive function that allows navigation to arbitrary URLs.}	N/A
2614	hipercalzado.com.js	Server Side Request Forgery (SSRF)	Medium	true	N/A	9	fetch	standard	{The fetch function is used to make a request to notificationClickUrl, which is constructed from user-controlled data (notificationData.identifier, notificationData.targetId). Since the URL is not validated or restricted, an attacker could manipulate the notification payload to make the service worker fetch internal resources or external malicious endpoints, leading to SSRF. This is a direct misuse of the fetch API with untrusted input.}	N/A
2615	hipercalzado.com.js	Unvalidated JSON Input in Push Event	Medium	true	N/A	8	event.data.json	standard	{The event.data.json() method is used to parse JSON data from a push event, which is inherently untrusted. While JSON parsing itself is not dangerous, the lack of validation or sanitization of the parsed data (e.g., notificationData.title, notificationData.body, notificationData.icon) can lead to injection attacks or unintended behavior, especially when used in subsequent operations like notifications or redirects. This misuse of a sensitive function allows untrusted data to flow into the application without proper checks.}	N/A
2616	```const notificationData = event.data.json();```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```const notificationData = event.data.json();```
2617	gmic.co.uk.js	Insecure Determination of Logged-In Status Leading to CSRF Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter directly from the URL using a regex, which is not a secure method for determining user authentication state. This is not caused by misuse of a sensitive JavaScript function, but rather by a flawed logic design.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2618	gmic.co.uk.js	Server Side Request Forgery (SSRF) via Unvalidated Path	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` parameter derived from the request URL. Since `path` is not validated or sanitized, an attacker can manipulate it to trigger requests to internal or external resources, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2619	gmic.co.uk.js	Unvalidated URL Navigation in Notification Click Handler	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a URL derived from the notification's `data.url` field, which is obtained from a remote push notification. Since this URL is not validated or sanitized, it can be manipulated by an attacker to redirect users to malicious sites, leading to phishing or other attacks.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2620	fuji-x-forum.de.js	Improper Session Management	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from directly parsing the `loggedIn` parameter from the URL without proper validation or sanitization, which can lead to session fixation or manipulation. However, this is not caused by misuse of a sensitive JavaScript function, but rather by insecure handling of URL parameters.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2621	fuji-x-forum.de.js	Server Side Request Forgery	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` parameter derived from the request URL. If an attacker can manipulate the `path` value, they can cause the service worker to make unintended requests to internal or external resources, leading to SSRF. The dynamic nature of the URL construction makes this a sensitive function misuse.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2622	fuji-x-forum.de.js	Open Redirect	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a `data.url` value that is derived from a notification payload, which is potentially untrusted. If an attacker can control the notification data, they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities. This is a misuse of the `navigate` function with unsanitized input.}	```clients[0].navigate(data.url);```
2623	qaemhost.ir.js	Vulnerable Logic in URL Exclusion Check	High	true	CWE-79	10	RegExp.prototype.match	standard	{The function `match` is used in `checkNeverCacheList` with `this.match(url)`, where `this` is a RegExp object. However, the function is called in a context where `this` is not guaranteed to be a RegExp, and the `url` parameter is derived from the request URL, which is untrusted. This can lead to unexpected behavior or bypass of URL exclusion logic if the `this` context is not properly bound, potentially allowing requests to be cached that should be excluded.}	N/A
2624	qaemhost.ir.js	Improper Input Validation in Range Header Handling	Medium	true	CWE-20	8	RegExp.prototype.exec	standard	{The `exec` method is used on a regular expression to parse the `range` header from the request. The input is derived from `event.request.headers.get('range')`, which is untrusted. The regex `/^bytes\=(\d+)\-$/g` is vulnerable to improper parsing if the header contains malformed or unexpected values (e.g., non-numeric or negative numbers), leading to incorrect `pos` calculation and potential out-of-bounds access or denial of service.}	N/A
2625	clubriches.com.js	Information Disclosure via Debug Endpoint	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the exposure of sensitive debug information via a dedicated endpoint (`ngsw/state`) that returns internal state details such as driver version, state, manifest hash, and last update check time. This is not caused by misuse of a sensitive JavaScript function, but rather by the design decision to expose debug data through a publicly accessible endpoint. The `DebugHandler.handleFetch` method constructs and returns this information in plain text, which can be accessed by any user who knows the endpoint URL.}	```const msgState = `NGSW Debug Info:\n\nDriver version: ${SW_VERSION}\nDriver state: ${state.state} (${state.why})\nLatest manifest hash: ${state.latestHash || 'none'}\nLast update check: ${this.since(state.lastUpdateCheck)}`;```
2626	ssmahavidyalaya.org.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	```const options = { firebaseConfig: { projectId: 'larapush-2', messagingSenderId: '650690331406', appId: '1:650690331406:web:326b3cf548fe2566a54d5f', apiKey: 'AIzaSyA4NssV6snKmi1fDSk0gukIlt2vhoYTzH8' }, domain: 'www.ssmahavidyalaya.org', api_url: 'https://push.hayatahmad.com/api/token', vapid_public_key: 'BHuLhTz9IE_mHvPAQEuC2HFc-0i7sEnTWRDcsWTQr6OqbAheSYUayhjdZgavzaRPPo66LnxsCM2WAwxVvOd3LOs' };```
2627	ssmahavidyalaya.org.js	Open Redirect in Notification Click	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is user-controlled. This allows an attacker to craft a notification that redirects the user to an arbitrary URL, leading to open redirect.}	```clients.openWindow(targetUrl);```
2628	ssmahavidyalaya.org.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	fetch	standard	{The fetch function is called with apiUrl, which is derived from notification data and is user-controlled. This allows an attacker to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(apiUrl);```
2629	ssmahavidyalaya.org.js	Open Redirect via Hostname Extraction	Medium	true	N/A	N/A	getDomainAndHostname	standard	{The getDomainAndHostname function extracts the hostname from a user-controlled URL, and this hostname is then used in a domain variable that may be used in further requests or logic. This allows an attacker to manipulate the hostname, potentially leading to open redirect or other misdirection attacks.}	```domain = getDomainAndHostname(url).hostname;```
2630	webastro.net.js	Server Side Request Forgery (SSRF) via unvalidated push ID	High	true	CWE-918	10	N/A	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received from a push event. Since `id` is derived from untrusted external data (push payload), an attacker can manipulate it to cause the service worker to make requests to arbitrary URLs, leading to SSRF. The URL is dynamically built using string concatenation, and no validation or sanitization is applied to `id`, allowing attackers to redirect requests to internal or external systems.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2631	webastro.net.js	Insecure logic for determining logged-in status	Medium	false	New	0	N/A	N/A	{The vulnerability arises from insecure logic in parsing the `loggedIn` parameter from the current URL, but it is not caused by misuse of a sensitive JavaScript function. The `match` method is used correctly on a static regex pattern, and no dynamic or untrusted input is passed to it. The issue lies in the logic design (e.g., relying on URL parameters for authentication state) rather than function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2632	cyberbingo.com.js	Caching of Sensitive Data in Network Requests	Medium	false	N/A	0	N/A	N/A	{The vulnerability described relates to caching behavior, but it does not stem from misuse of a sensitive JavaScript function. The code properly uses standard caching APIs (caches.open, caches.match, fetch) with no dynamic or untrusted input influencing the cache keys or URLs. The issue is more about policy or design (caching potentially sensitive data) rather than insecure function usage.}	```const cache = await caches.open(dynamicCacheName); try { const response = await fetch(request); await cache.put(request, response.clone()); return response; } catch (e) { const cached = await cache.match(request); return cached ?? (await caches.match('/offline.html')); }```
2633	bennettjones.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-602	10	client.navigate	standard	{The client.navigate() function is a standard browser API that allows navigation to a specified URL. When used with unvalidated input from notification.data.url, it enables an attacker to redirect the user to arbitrary websites, leading to open redirect vulnerabilities. The URL is not sanitized or validated, making it directly exploitable.}	```client.navigate(notification.data.url);```
2634	bennettjones.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new browser window or tab to a specified URL. When used with unvalidated input from notification.data.url, it allows an attacker to redirect users to malicious sites, resulting in an open redirect vulnerability. The URL is passed directly without any validation or sanitization.}	```clients.openWindow(notification.data.url);```
2635	fairmoney.ng.js	Incorrect Caching of Query Parameter in Pre-Caching	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from caching a URL containing query parameters (`/?standalone=true`) without proper sanitization or validation. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by a misconfiguration in the caching strategy. The `precacheAndRoute` function is used correctly, and no dynamic or untrusted input is passed to sensitive functions. The issue is more about caching policy than function misuse.}	```const options = { 'workboxURL': 'https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js', 'importScripts': [], 'config': { 'debug': false }, 'cacheOptions': { 'cacheId': 'fairmoney-customer-prod', 'directoryIndex': '/', 'revision': 'Sh56ohxUWk7A' }, 'clientsClaim': true, 'skipWaiting': true, 'cleanupOutdatedCaches': true, 'offlineAnalytics': false, 'preCaching': [{ 'revision': 'Sh56ohxUWk7A', 'url': '/?standalone=true' }], 'runtimeCaching': [{ 'urlPattern': '/_nuxt/', 'handler': 'CacheFirst', 'method': 'GET', 'strategyPlugins': [] }, { 'urlPattern': '/', 'handler': 'NetworkFirst', 'method': 'GET', 'strategyPlugins': [] }], 'offlinePage': null, 'pagesURLPattern': '/', 'offlineStrategy': 'NetworkFirst' };```
2636	gameapps.hk.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided by the notification data (data.url), which is derived from untrusted push message data. Since the URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or malicious domains.}	N/A
2637	gameapps.hk.js	Unvalidated Request Handling in Fetch	Medium	false	N/A	0	N/A	N/A	{The fetch call uses event.request directly without validation, but this is not a misuse of a sensitive function per se—it is a general security issue related to handling untrusted requests. The fetch API itself is not misused in a way that constitutes a sensitive function vulnerability, as it is being used as intended for network requests.}	N/A
2638	soda567.com.js	Open Redirect via Service Worker Notification Handling	Medium	true	CWE-602	9	showNotification	standard	{The service worker uses `showNotification` with a URL derived from untrusted data (`_0x293f77[_0x3230ad(0xce)]`), which is obtained from the `data` field of a received message. Since this URL is not validated or sanitized, an attacker can craft a malicious notification payload that redirects users to arbitrary domains, leading to open redirect vulnerabilities.}	```self['addEventListener'](_0x3acceb(0xd7), function (_0x5c976a) { const _0x3230ad = _0x3acceb; let _0x293f77 = {}; _0x5c976a[_0x3230ad(0xcc)] && (_0x293f77 = _0x5c976a['data']['json']()); const _0x3c3114 = { 'body': _0x293f77[_0x3230ad(0xbf)], 'icon': _0x293f77['icon'], 'badge': _0x293f77[_0x3230ad(0xd6)], 'data': _0x293f77[_0x3230ad(0xd0)] }; _0x5c976a[_0x3230ad(0xc4)](self['registration'][_0x3230ad(0xbe)](_0x293f77[_0x3230ad(0xce)], _0x3c3114)); });```
2639	blockstar.social.js	XSS via Unsanitized Notification Payload	Medium	true	CWE-79	8	showNotification	standard	{The showNotification function is a standard browser API used to display notifications. When the notification body is constructed from unsanitized user-controlled input (payload.notification.body), it can lead to XSS if the notification content is rendered in a context where script execution is possible (e.g., via rich text rendering or if the notification is displayed in a UI that interprets HTML). Although modern browsers typically sanitize notification content, relying on unsanitized input remains a risk, especially if the environment or future browser behavior changes.}	```const notificationOptions = { body: payload.notification.body };```
2640	col.org.il.js	Improper Input Validation Leading to UI Redress	Medium	true	CWE-20	8	self.registration.showNotification	standard	{The function self.registration.showNotification is used with user-controlled data (title and options) derived from unvalidated JSON parsed from event.data.text(). This allows an attacker to craft malicious notification content, potentially leading to UI redress (e.g., spoofing legitimate notifications to trick users into revealing credentials or clicking malicious links).}	```self.registration.showNotification(title, options);```
2641	col.org.il.js	Open Redirect via Notification Click	High	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow is called with user-controlled data (data.url) from the notification payload. Since the URL is not validated or sanitized, an attacker can supply a malicious URL, causing the browser to open an unintended site, leading to open redirect vulnerabilities.}	```clients.openWindow(data.url);```
2642	tien21.es.js	"Use of ""no-cors"" mode in fetch requests leading to potential cross-origin data leakage"	High	false	N/A	N/A	N/A	N/A	"{The use of ""no-cors"" mode in fetch requests does not involve a sensitive function misuse but rather a configuration choice that may lead to data leakage if not properly controlled. The vulnerability arises from the mode setting itself, not from dynamic or untrusted input being passed to a sensitive function.}"	"```e.assets && t.addAll(e.assets.map(function (e) { return new Request(e, { mode: ""no-cors"" }); }));```"
2643	tien21.es.js	Untrusted external script import via importScripts leading to potential code injection	High	true	N/A	N/A	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load external scripts. In this case, it is used with a hard-coded URL, which is not dynamically derived from untrusted input. However, since the script is loaded from an external domain (cdn.connectif.cloud), and the source is not verified or controlled, it introduces a risk of code injection if the external script is compromised. The misuse lies in trusting an external script without validation, making it a sensitive function misuse due to lack of integrity checks.}	"```importScripts(""https://cdn.connectif.cloud/scripts/service-worker.js"");```"
2644	ruchiskitchen.com.js	Vulnerable Cache Control for Sensitive Paths	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from improper route matching logic that allows requests to be cached without sufficient validation, but it is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The issue lies in the routing configuration and cache policy, not in the use of a dangerous function.}	```javascript j(function (e) { if (!e.url) return !1; var t = e.url.href; return !!t && 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname; }, new F({ plugins: [new Q({ statuses: [0, 200] })] })); ```
2645	dialdirect.co.za.js	Service Worker Fetch Event Not Handled	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the fetch event handler returning `false`, which prevents any caching or network fallback logic from being executed. This is a logic flaw, not a misuse of a sensitive function. The `self.addEventListener('fetch', ...)` is used correctly in structure, but the handler's implementation is flawed by returning `false` instead of handling the request appropriately. No sensitive function is misused here.}	```self.addEventListener('fetch', evt => { return false; });```
2646	ride-mtb.com.js	Improper Input Validation (Offline Page Caching Without Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from caching the offline page without validating or sanitizing the URL or content, but no sensitive function is misused in this context. The code directly uses a hardcoded OFFLINE_URL, so there is no dynamic or untrusted input being passed to a sensitive function.}	```return cache.put(OFFLINE_URL, response);```
2647	ride-mtb.com.js	Incomplete Cache Busting (Potential Stale Content Caching	Low	false	CWE-922	N/A	N/A	N/A	{The issue stems from an incomplete cache-busting mechanism, but it does not involve misuse of a sensitive function. The code attempts to bust the cache by appending a timestamp, but the logic for creating the busted URL is not flawed in a way that involves unsafe function usage with untrusted input.}	```let bustedUrl = new URL(url, self.location.href); bustedUrl.search += (bustedUrl.search ? '&' : '') + 'cachebust=' + Date.now(); return new Request(bustedUrl);```
2648	3dfx.com.js	Improper Trust of External Resource (CDN Script)	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to load a script from a third-party CDN (https://cdn.pushcrew.com). While the URL is hardcoded, the vulnerability arises from trusting an external resource without verifying its integrity or origin, which could lead to code injection if the CDN is compromised or if the script is malicious. This constitutes improper trust of an external resource, a known security risk in service worker contexts.}	```var version = 7; importScripts('https://cdn.pushcrew.com/sw/819b2dfd7903567ef3700eb2185bc870.js');```
2649	apltech.kz.js	Improper Input Validation in Push Event Handling	Medium	true	CWE-20	8	N/A	standard	{The function `event.data.json()` is used to parse the push payload without validating or sanitizing the input. If the payload is malformed or contains unexpected data, it can lead to parsing errors or unintended behavior, potentially allowing an attacker to trigger exceptions or manipulate the service worker's logic.}	```const payload = event.data ? event.data.json() : '';```
2650	apltech.kz.js	Denial of Service via Malformed Push Payload	Medium	true	CWE-408	8	N/A	standard	{The `event.data.json()` function parses the push payload without input validation. Malformed JSON data can cause the service worker to crash or consume excessive resources during parsing, leading to a denial of service.}	```const payload = event.data ? event.data.json() : '';```
2651	apltech.kz.js	Unvalidated URL Handling in Notification Click	Medium	true	CWE-601	9	N/A	standard	{The `clients.openWindow(event.notification.data.url)` function is used to open a URL provided in the notification data without validating or sanitizing it. An attacker could supply a malicious URL, leading to phishing, redirect attacks, or unintended navigation.}	```clients.openWindow(event.notification.data.url).then(windowClient => windowClient ? windowClient.focus() : null);```
2652	telen.no.js	Improper Validation of Cache Responses	Medium	true	CWE-918	8	fetch	standard	{The fetch() function is used without validating the response or sanitizing the headers, particularly the 'x-emergency-mode' header, which is directly parsed and assigned to self.emergencyMode. This allows an attacker to inject arbitrary values into the service worker's state if they can control the response headers, potentially leading to unintended behavior or bypassing security checks. The input (request) is dynamic and derived from the event.request, which is user-controlled via navigation or fetch requests.}	```const response = await fetch(request); self.emergencyMode = (response.headers.get('x-emergency-mode') || '').split(','); return response;```
2653	showzone.gg.js	Exposure of Sensitive Information	High	false	N/A	0	N/A	N/A	{The vulnerability arises from hard-coded Firebase API credentials (apiKey, authDomain, etc.) being exposed in the source code, not from misuse of a sensitive JavaScript function. These credentials are static and not dynamically derived from untrusted input, so no sensitive function is involved in the exposure.}	"```importScripts(""https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"");importScripts(""https://www.gstatic.com/firebasejs/8.10.1/firebase-messaging.js"");firebase.initializeApp({apiKey: ""AIzaSyBP05LYQbLsDUdMH0gazmeTimh2FtPSOEE"",authDomain: ""showzone-cloud.firebaseapp.com"",projectId: ""showzone-cloud"",storageBucket: ""showzone-cloud.appspot.com"",messagingSenderId: ""222135332429"",appId: ""1:222135332429:web:b56d44caffbf0b1b8c7604""});const messaging = firebase.messaging();messaging.onBackgroundMessage(function (payload) {const notificationTitle = payload.data.title;const notificationOptions = {body: payload.data.body,icon: 'https://content.showzone.gg/wp-content/uploads/2023/03/logo192.png'};self.registration.showNotification(notificationTitle, notificationOptions);});```"
2654	grand-casino.com.js	Insecure Cache Key Generation	High	true	N/A	N/A	new URL	standard	{The function `new URL` is used to construct URLs from user-controlled inputs (e.g., `e` in `x(n)`), which are then used as cache keys. If the input is not properly validated, an attacker could inject malicious URLs (e.g., with arbitrary paths or protocols) that could lead to cache poisoning or unintended resource fetching.}	```const { cacheKey: e, url: s } = x(n);```
2655	grand-casino.com.js	Improper URL Validation	Medium	true	N/A	N/A	new URL	standard	{The `new URL` function is used to parse URLs from potentially untrusted sources (e.g., `e` in `x(n)`), but no validation is performed on the resulting URL. This allows for malformed or malicious URLs to be processed, potentially leading to unintended behavior such as accessing internal resources or redirecting to external domains.}	```const { cacheKey: e, url: s } = x(n);```
2656	grand-casino.com.js	Cache Poisoning Risk	High	true	N/A	N/A	self.caches.open	standard	{The `self.caches.open` function is used to open a cache with a dynamically generated cache name derived from user-controlled inputs. If the cache name is not properly sanitized, an attacker could manipulate it to poison the cache with malicious content, leading to unauthorized data access or execution.}	```await _.put({ event: s, plugins: r, response: i, request: e === t ? a : new Request(e), cacheName: this._cacheName, matchOptions: { ignoreSearch: !0 } });```
2657	grand-casino.com.js	SSRF Vulnerability	Medium	true	N/A	N/A	new URL	standard	{The `new URL` function is used to construct URLs from user-controlled inputs (e.g., `e` in `const c = new URL(String(e), location.href);`). If the input is not validated, an attacker could craft a URL pointing to internal resources (e.g., `http://localhost:8080`), leading to Server-Side Request Forgery (SSRF) and unauthorized access to internal systems.}	```const c = new URL(String(e), location.href);```
2658	grand-casino.com.js	Information Exposure Through String Error	Low	false	N/A	N/A	N/A	N/A	{The error is thrown using a custom error class `f`, but the error message includes the thrown error object. While this may expose some internal details, it does not involve misuse of a sensitive function.}	```throw new f('plugin-error-request-will-fetch', { thrownError: o });```
2659	ashlandsource.com.js	Insecure Dynamic Script Loading	High	true	New	N/A	importScripts	standard	{The `importScripts()` function is used to dynamically load and execute JavaScript modules. In this case, the URL for the script is constructed using the `modulePathPrefix` configuration, which is set via `workbox.setConfig()`. If an attacker can manipulate this configuration (e.g., via a maliciously crafted request or compromised backend), they could inject arbitrary script URLs, leading to remote code execution within the service worker. The dynamic nature of the URL construction makes this a high-risk vulnerability.}	```self.workbox = new class { constructor() { return this.v = {}, this.Pt = { debug: 'localhost' === self.location.hostname, modulePathPrefix: null, modulePathCb: null }, this.$t = this.Pt.debug ? 'dev' : 'prod', this.jt = !1, new Proxy(this, { get(e, s) { if (e[s]) return e[s]; const o = t[s]; return o && e.loadModule(`workbox-${o}`), e[s]; } }); }; setConfig(t = {}) { if (this.jt) throw new Error('Config must be set before accessing workbox.* modules'); Object.assign(this.Pt, t), this.$t = this.Pt.debug ? 'dev' : 'prod'; }; loadModule(t) { const e = this.St(t); try { importScripts(e), this.jt = !0; } catch (s) { throw console.error(`Unable to import module '${t}' from '${e}'.`), s; } }; St(t) { if (this.Pt.modulePathCb) return this.Pt.modulePathCb(t, this.Pt.debug); let e = ['https://storage.googleapis.com/workbox-cdn/releases/7.3.0']; const s = `${t}.${this.$t}.js`, o = this.Pt.modulePathPrefix; return o && (e = o.split('/'), '' === e[e.length - 1] && e.splice(e.length - 1, 1)), e.push(s), e.join('/'); }; }();```
2660	ashlandsource.com.js	Insecure Message Handling	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from handling messages without validating or sanitizing the `event.data` payload. However, it does not stem from misuse of a sensitive JavaScript function like `importScripts()` or `eval()`. The `self.addEventListener('message', ...)` is a standard event handler, and while it can be exploited if the message data is used unsafely, the code here only checks for specific known actions (`SKIP_WAITING`) and does not execute arbitrary code based on user input. Thus, it is not caused by a sensitive function misuse.}	```self.addEventListener('message', function (event) { if (!event.data) { return; } if (event.data.type === 'SKIP_WAITING' || 'skipWaiting' === event.data.action) { self.skipWaiting(); } });```
2661	marca.es.js	Hardcoded Credentials	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials (appKey, token, vapidPublicKey) being embedded directly in the script, not due to misuse of a sensitive JavaScript function. These values are static and not derived from untrusted input or dynamically constructed URLs.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://mobilecrm.accengage.com/images/logo_application/202368.png', defaultTitle: 'Marca', defaultActionURL: 'https://www.marca.com', appKey: 'Yvb0R1AWTumLCdeAxrqd3Q', token: 'MTpZdmIwUjFBV1R1bUxDZGVBeHJxZDNROklTTGRXejZsWWl3ZnhRLTVqbkpLaEtUN25WTkpCZ3hrVkh5YnhidVFacGs', vapidPublicKey: 'BPBSEaOP5OVRBe5pT0B0gTE49a-UJPJ37YyZBXvGNu84yLyVfWSa2a2jFJpqb0Vys6dJS6T1417FyySjzFEcp6M' });```
2662	conversationstartersworld.com.js	Improper Validation of URLs Leading to Caching of Sensitive Endpoints	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from insufficient URL validation in the route matching logic, specifically in the condition that checks if a URL includes 'https', contains the siteHostname, and does not match any ignored paths. However, this does not involve misuse of a sensitive JavaScript function like importScripts, eval, or dynamic code execution. The issue is more about logic flaws in URL filtering rather than direct function misuse.}	```if (!!t && 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname;```
2663	mojeppk.pl.js	Hardcoded Credentials in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{Hardcoded credentials are not caused by misuse of a sensitive function but by direct inclusion of secrets in client-side code, which can be exposed to attackers.}	```const config = { 'apiKey': 'AIzaSyDsAOupTeHVNbEhHG3xRJXi3-k_WW7ZBNM', 'authDomain': 'mojeppk-push.firebaseapp.com', 'databaseURL': 'https://mojeppk-push.firebaseio.com', 'projectId': 'mojeppk-push', 'storageBucket': 'mojeppk-push.appspot.com', 'messagingSenderId': '129722102557', 'appId': '1:129722102557:web:38e1a9afdf7315497aa7f4' };```
2664	mojeppk.pl.js	Unvalidated URL in Notification Click Handler	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from untrusted input (payload.data.url), it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```if (clients.openWindow) { return clients.openWindow(url); }```
2665	mojeppk.pl.js	Insecure Dynamic Icon Path Construction	Medium	true	N/A	N/A	`${instance}/.resources/ppk-module/assets/favicon/favicon.ico`	standard	{The template literal constructs a path using the `instance` variable, which is derived from `self.location.pathname`. If an attacker can manipulate the pathname (e.g., via URL injection), they could craft a path that accesses unintended resources or triggers directory traversal, leading to potential information disclosure or resource manipulation.}	```const icon = `${instance}/.resources/ppk-module/assets/favicon/favicon.ico`;```
2666	racing-planet.de.js	Code Injection via Dynamic Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When combined with dynamic input from location.search, it allows an attacker to manipulate the URL parameter to inject arbitrary scripts. Since the script URL is constructed by concatenating a base URL with location.search, an attacker can supply a malicious query string to load a script from an attacker-controlled domain, leading to full compromise of the service worker’s execution context.}	```importScripts(`https://racing-planet.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
2667	madincrafts.com.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is exposed in the source code and is not related to any sensitive function misuse.}	```self[`appKey`] = `a09538a1cd65c8ed0f03faa0932e0760`;```
2668	madincrafts.com.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it becomes a vector for remote code execution if the host is compromised or if the script is dynamically controlled by an attacker. Although the host is hardcoded here, the function itself is sensitive because it executes arbitrary code from a remote source, and if the host were dynamic or user-controlled, the risk would be severe.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2669	roksa.one.js	Resource Exhaustion via Max Client Limit	High	true	N/A	N/A	Math.floor	standard	{The function Math.floor is used to calculate the maximum number of clients allowed based on user-provided configuration values (maxSubscriptions and maxSubscriptionsPerTab). If an attacker can control these values, they can cause an integer underflow or overflow, leading to an unintended large number of clients being allowed, which can exhaust server resources.}	```this.socket.updateSocketSubscriptionsConfig(n.config.featuresConfig.centrifugoWorker); try { let { maxSubscriptions: o, maxSubscriptionsPerTab: c } = n.config.featuresConfig.centrifugoWorker; this.maxClients = Math.floor(o / c); } catch { this.maxClients = Xe; }```
2670	roksa.one.js	Integer Overflow in Max Clients Calculation	High	true	N/A	N/A	Math.floor	standard	{The Math.floor function is used to compute the maximum number of clients from user-supplied configuration values. If these values are manipulated (e.g., maxSubscriptionsPerTab set to 0 or a very small number), the division can result in an integer overflow, allowing an attacker to bypass client limits and exhaust system resources.}	```this.socket.updateSocketSubscriptionsConfig(n.config.featuresConfig.centrifugoWorker); try { let { maxSubscriptions: o, maxSubscriptionsPerTab: c } = n.config.featuresConfig.centrifugoWorker; this.maxClients = Math.floor(o / c); } catch { this.maxClients = Xe; }```
2671	roksa.one.js	Unvalidated WebSocket Command Construction	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from constructing WebSocket commands using unvalidated user-provided data (e.g., _token, _data, _config.name, _config.version) without proper sanitization or validation. However, no specific sensitive JavaScript function is misused here; the issue is more about logic and data validation rather than a function misuse.}	```_constructConnectCommand() { let e = {}; this._token && (e.token = this._token), this._data && (e.data = this._data), this._config.name && (e.name = this._config.name), this._config.version && (e.version = this._config.version); let t = {}, n = !1; for (let i in this._serverSubs) if (this._serverSubs.hasOwnProperty(i) && this._serverSubs[i].recoverable) { n = !0; let r = { recover: !0 }; this._serverSubs[i].offset && (r.offset = this._serverSubs[i].offset), this._serverSubs[i].epoch && (r.epoch = this._serverSubs[i].epoch), t[i] = r; } return n && (e.subs = t), { connect: e }; }```
2672	roksa.one.js	Potential SSRF in Analytics Event Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the use of the fetch function with user-controlled URLs (e.g., from the 'url' field in the message data). While fetch is a sensitive function, the code does not misuse it in a way that directly leads to SSRF; instead, the issue is that the URL is not validated or sanitized, allowing an attacker to potentially send requests to internal resources. However, since the fetch call is not directly triggered by untrusted input without additional context, it is not classified as a sensitive function misuse.}	```send(e, t) { return fetch(e, this.getSendOptions(t)); }```
2673	mochileiros.com.js	Server Side Request Forgery (SSRF	High	true	CWE-928	9	fetch	standard	{The fetch function is used with a URL constructed from the `id` parameter received from a push event, which is untrusted input. This allows an attacker to craft a push notification with a malicious `id` value, causing the service worker to make an HTTP request to an arbitrary server, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2674	mochileiros.com.js	Incorrect Login Status Determination	Medium	false	CWE-306	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter from the current URL, which is not a sensitive function misuse but rather a logic flaw in authentication state determination.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
2675	mochileiros.com.js	Server Side Request Forgery (SSRF	High	true	CWE-928	9	fetch	standard	{The fetch function is used with a URL constructed from the `path` parameter, which is derived from the intercepted request's URL. Since this input is not sanitized or validated, an attacker can manipulate the request to trigger a fetch to an arbitrary endpoint, resulting in SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2676	mochileiros.com.js	Open Redirect	Medium	true	CWE-601	8	navigate	standard	{The navigate function is used with a URL derived from the `data.url` field of a notification, which is untrusted input. If an attacker can control this field, they can redirect the user to a malicious site, leading to an open redirect vulnerability.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
2677	lokmatnews.in.js	Insecure Third-Party Script Inclusion	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a third-party CDN (https://cdn.izooto.com). While the URL is hardcoded, it still represents a potential security risk because the script is executed with the same privileges as the service worker. If the third-party script is compromised or modified, it can lead to arbitrary code execution, data exfiltration, or manipulation of the service worker’s behavior. This is considered a sensitive function misuse because importScripts() executes external code without any sanitization or integrity checks, and its use with external sources introduces a trust boundary violation.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/49f34b171d4ab973d2c81ab4c1378f91441ac407.js"");```"
2678	1001activiteiten.nl.js	Improper Input Validation in URL Construction	Medium	false	CWE-20	N/A	N/A	N/A	{The code constructs a URL object from `e.request.referrer`, which is user-controlled. While `new URL()` is a standard function, the vulnerability stems from improper validation of the referrer input rather than misuse of the function itself. The function is used correctly, but the input is not sanitized or validated, leading to potential improper URL handling.}	```s = void 0 !== e.request.referrer && e.request.referrer ? new URL(e.request.referrer) : t```
2679	1001activiteiten.nl.js	Cache Poisoning via Unvalidated URLs	High	true	CWE-918	N/A	getResource	standard	{The `getResource` function uses `e.toString()` to generate a cache key, where `e` is a URL object derived from a user-controlled request. This allows an attacker to craft a URL with malicious path components that can be cached under a key that may interfere with legitimate cached resources, potentially leading to cache poisoning. The `toString()` method on a URL object is standard, but its use here with unvalidated input enables the vulnerability.}	```let s = e.toString();```
2680	autoshite.com.js	Insecure URL Handling in Fetch Event	High	true	CWE-549	9	N/A	standard	{The vulnerability arises from the use of `fetch()` with a URL constructed from `request.url`, which is derived from the incoming request. Although the code checks if the URL starts with `BASE_URL`, it does not validate or sanitize the full URL path, allowing an attacker to craft a request with a malicious URL that may bypass the check or trigger unintended behavior, especially if the URL is manipulated via query parameters or path traversal. This misuse of `fetch()` with untrusted input can lead to unintended resource access or SSRF-like behavior.}	```const { request } = e; if (request.url.startsWith(BASE_URL + 'admin/') || e.currentTarget.location.href.match(/type=admin/)) { log('In ACP, nothing to do...'); return; } if (!request.url.startsWith(BASE_URL) || request.method === 'GET' && request.mode !== 'navigate') { return; }```
2681	autoshite.com.js	Insecure Notification URL Handling	High	true	CWE-601	9	N/A	standard	{The `clients.navigate()` and `clients.openWindow()` functions are used with `data.url`, which is derived from push notification data. Since this data is received from an external source (push server), it is untrusted. If an attacker can control the `data.url` field, they can redirect users to arbitrary websites, leading to phishing or malicious redirection. This misuse of `clients.navigate()` and `clients.openWindow()` with untrusted input constitutes a high-risk vulnerability.}	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
2682	autoshite.com.js	Insecure CSRF Token Fetching	High	true	CWE-352	8	N/A	standard	{The `fetch()` function is used to retrieve a CSRF token from a URL constructed using `path` extracted from the request URL. Since `path` is derived from the incoming request, it is untrusted. An attacker could manipulate the request path to trigger a fetch to an unintended endpoint, potentially leading to CSRF token leakage or unauthorized actions if the token is used in subsequent requests. This misuse of `fetch()` with untrusted input is a high-risk vulnerability.}	```let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`);```
2683	autoshite.com.js	Insecure Logic for Logged-In Check	Medium	false	CWE-200	0	N/A	N/A	{This vulnerability stems from improper logic in handling the `loggedIn` state, which is extracted from the URL via a regex match. The issue is not due to misuse of a sensitive function but rather a flawed implementation that may lead to information exposure or logic errors. No sensitive function is involved in the misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2684	autoshite.com.js	Potential SSRF via Push Notification ID	High	true	CWE-919	9	N/A	standard	{The `fetch()` function is used with a URL constructed from `id` received from push notification data. Since `id` is untrusted input from an external source, an attacker could manipulate it to trigger a request to an unintended internal or external endpoint, leading to SSRF. This misuse of `fetch()` with untrusted input allows an attacker to probe internal systems or exfiltrate data.}	```const { id } = pingData; const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' }).then(response => { if (!response.ok) { throw new Error('Invalid response'); } return response.json(); }).then(data => {```
2685	inran.it.js	Improper Input Validation Leading to SSRF	High	true	CWE-549	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.sensor and body.data.push_send_id). Since these values are derived from the push message data, an attacker can manipulate them to redirect the fetch request to internal or external resources, enabling Server-Side Request Forgery (SSRF). The URL is dynamically assembled without validation or sanitization, allowing arbitrary endpoint access.}	```var ve = sensor_url + '/e?site_name=www.inran.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
2686	inran.it.js	Open Redirect via Unvalidated URL	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted input (event.notification.data.url). Since this value comes from the notification data, an attacker can set it to any arbitrary URL, causing the browser to open a malicious site, leading to open redirect vulnerabilities. The URL is not validated or sanitized before being passed to the function.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
2687	tomato.ua.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive data (API key) in client-side code, not misuse of a sensitive function.}	"```self[`appKey`] = ""6598276be28181bf2a1185e3bdc51781"";```"
2688	tomato.ua.js	Remote Script Inclusion via Hardcoded URL	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL (even if not directly user-controlled), it introduces a risk if the URL is not trusted or if the script at that URL can be compromised. In this case, the URL is hardcoded but still represents a remote script inclusion, which can be exploited if the host is compromised or if the script is dynamically altered.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2689	greenforce.com.js	Incorrect Allowlist Regex Pattern	High	false	N/A	0	N/A	N/A	{The vulnerability stems from an incorrect regex pattern in the allowlist, not from misuse of a sensitive JavaScript function. The regex uses `+` after `${hostnameRegex}` which is likely a typo or logic error, causing unintended matching behavior. This is a logic or configuration flaw, not a function misuse.}	```const ALLOWLIST = [`^https\:\/\/${hostnameRegex}+\/($|collections|products|pages|cart|search|blogs|account|recommendations)`, `^https\:\/\/${hostnameRegex}+${proxy}`, `^https?\:\/\/(?!${hostnameRegex}).+`];```
2690	menuwithprices.com.js	Loading untrusted third-party script in Service Worker	High	false	N/A	0	N/A	N/A	{The script imports a third-party script via importScripts, but since the URL is hardcoded and not derived from untrusted or dynamic input, it does not constitute misuse of a sensitive function. The vulnerability stems from trusting an external script, not from dynamic input injection.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/6376608b2fd68f0013d4b09b"");```"
2691	hathalyoum.net.js	Insecure Caching without Request Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a lack of request validation before caching, but it is not caused by misuse of a sensitive function. The code uses standard fetch and caches.match, which are safe when used correctly. The issue is more about policy or logic rather than function misuse.}	```event.respondWith(fetch(event.request).catch(function () { return caches.match(event.request); }));```
2692	epiusers.help.js	Improper Input Encoding	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper encoding of the `e.reply` value in the POST body, which is directly interpolated into a string without sanitization. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a lack of proper encoding/escaping before sending data to the server. The `fetch` function is used correctly and safely; the issue lies in the data handling logic, not in the function itself.}	```body: `message=${e.reply}````
2693	golbazar.com.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a high-risk vulnerability because it allows an attacker who compromises the remote server to inject malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. The risk is elevated because service workers have broad permissions and can intercept network requests, access caches, and control offline behavior.}	```importScripts('https://van.najva.com/static/js/scripts/golbazar335-website-7348-8fa7a8d7-37e9-4b01-b06f-ceff7913c92c-service-worker.js');```
2694	skarbnicanarodowa.pl.js	Offline Page Spoofing via Unvalidated Fetch Failure	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the service worker's fetch handler returning a cached offline page when a fetch fails, without validating whether the requested resource was intended to be served offline. This could allow an attacker to manipulate the network environment or trigger fetch failures for legitimate resources, leading to unintended offline page delivery. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic flaw in handling fetch failures.}	```self.addEventListener('fetch', event => { if (event.request.url.indexOf('/administrator/') !== -1 || event.request.url.indexOf('/com_sh4ex/') !== -1) { return false; } if (event.request.mode === 'navigate' || event.request.method === 'GET' && event.request.headers.get('accept').includes('text/html')) { console.log('Handling fetch event for', event.request.url); event.respondWith(fetch(event.request).catch(error => { console.log('Fetch failed; returning offline page instead.', error); return caches.match(OFFLINE_URL); })); } });```
2695	yugenanime.sx.js	Empty Fetch Event Handler	High	false	N/A	N/A	N/A	N/A	{The fetch event handler is empty, meaning it does not intercept or handle any network requests. While this may be a logical or design flaw, it does not stem from the misuse of a sensitive JavaScript function. There is no dynamic or untrusted input being passed to any sensitive function that could lead to injection or execution risks.}	```self.addEventListener('fetch', evt => {});```
2696	mindustry.top.js	Improper Cache Versioning Leading to Stale Content	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of a null revision for one of the precached assets, which can lead to stale content being served if the asset is updated without a corresponding revision change. This is not caused by misuse of a sensitive function, but rather by improper configuration in the precaching strategy.}	"```define([""./workbox-4960806a""], function (e) { ""use strict""; self.skipWaiting(), e.clientsClaim(), e.precacheAndRoute([ { url: ""pwa-fallback"", revision: ""c3352fd467628716895f9111d9a8f294"" }, { url: ""_nuxt/builds/latest.json"", revision: ""de5335b34cf77d598b1e8b5e8805296d"" }, { url: ""_nuxt/builds/meta/d1486d26-2370-4fb3-a99f-cefa7c8b705d.json"", revision: null }, { url: ""manifest.webmanifest"", revision: ""cb53eace46a78fc639c6b593bcb671d8"" } ], {}), e.cleanupOutdatedCaches(), e.registerRoute(new e.NavigationRoute(e.createHandlerBoundToURL(""/pwa-fallback""), { denylist: [/api\/.*/] })), e.registerRoute(/\/_nuxt\//, new e.CacheFirst({ cacheName: ""assets"", plugins: [] }), ""GET""), e.registerRoute(/\.(css|js|svg|png|ico)$/, new e.CacheFirst({ cacheName: ""static"", plugins: [] }), ""GET""), e.registerRoute(/^https:\/\/api.mindustry.top\/.*/i, new e.NetworkFirst({ cacheName: ""api"", plugins: [new e.CacheableResponsePlugin({ statuses: [0, 200] })] }), ""GET""), e.registerRoute(/^https:\/\/cdn\.bootcdn\.net\/.*/i, new e.CacheFirst({ cacheName: ""cdn-resource"", plugins: [new e.CacheableResponsePlugin({ statuses: [0, 200] })] }), ""GET""); });```"
2697	muted.io.js	Cache Poisoning via Subdomain Regex	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a broad regular expression `^https://.*.muted.io` in `workbox.routing.registerRoute`, which matches any subdomain of muted.io. This allows an attacker to register a malicious subdomain (e.g., `evil.muted.io`) and serve poisoned content that gets cached by the service worker. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts` or `eval`, but rather by a flawed routing pattern.}	```workbox.routing.registerRoute(new RegExp('^https://.*.muted.io'), new workbox.strategies.CacheFirst({  cacheName: 'mutedio',  plugins: [new workbox.expiration.ExpirationPlugin({    maxEntries: 10,    maxAgeSeconds: 30  }), new workbox.cacheableResponse.CacheableResponsePlugin({    statuses: [0, 200]  })] }));```
2698	anvelope-autobon.ro.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a configuration issue, not a result of misuse of a sensitive JavaScript function. It is embedded directly in the URL and does not involve dynamic or untrusted input being passed to a function.}	"```self.addEventListener('push', function (event) { event.waitUntil(fetch(""https://apism.speedmeta.com/get_notification_V2/?key=B3HASF2GHVYIT778SQHB"").then(function (response) { if (response.status !== 200) { throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { throw new Error(); } var ua = navigator.userAgent.toLowerCase(); var isMac = ua.indexOf(""macintosh"") > -1; var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var image = data.notification.image; var notificationTag = data.notification.tag; var final_link = data.notification.link; var req_interaction = isMac ? false : true; return self.registration.showNotification(title, { body: message, icon: icon, image: image, tag: notificationTag, data: data, requireInteraction: req_interaction }); }); }).catch(function (err) { console.error('Unable to retrieve data', err); }); });```"
2699	anvelope-autobon.ro.js	Open Redirect via Unvalidated URL	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL obtained from the notification data (ev.notification.data.notification.link). Since this URL is derived from external, untrusted data (from a remote API), and is not validated or sanitized, an attacker could manipulate the notification payload to redirect users to arbitrary malicious sites, leading to open redirect vulnerability.}	"```ev.waitUntil(clients.matchAll({ type: ""window"" }).then(function (clientList) { return clients.openWindow(ev.notification.data.notification.link); }));```"
2700	ich-liebe-kaese.de.js	Open Redirect via Untrusted Input	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API used to open a new window or tab with a specified URL. When the URL is derived from untrusted input (here, payload.url from a push notification payload), it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery. Since the URL is not validated or sanitized, this constitutes a direct open redirect vulnerability.}	```event.waitUntil(clients.openWindow(payload.url));```
2701	wikianime.club.js	Remote Code Execution via External Settings	High	true	CWE-918	10	fetch	standard	{The fetch function is used to retrieve settings from an external URL (SETTINGS_URL). Although the URL is hardcoded, the data it returns is used to dynamically control the service worker's behavior, including enabling redirects and modifying response handling. If the external server is compromised or controlled by an attacker, it can return malicious settings that alter the service worker’s logic, leading to unintended behavior such as redirecting users to malicious sites or intercepting requests. While not direct code execution via eval or importScripts, the dynamic control flow based on untrusted external data constitutes a form of remote code execution in the context of service worker logic.}	N/A
2702	wikianime.club.js	Improper Input Validation for Redirect URL	High	true	CWE-20	9	JSON.parse	standard	{The service worker fetches JSON data from an external source and assigns the 'redirect_to' field directly to settings.redirect_url without any validation or sanitization. The JSON.parse function is used implicitly via response.json(), which parses untrusted JSON data. If the external server returns a malicious or malformed value (e.g., a URL containing JavaScript or a redirect to a phishing site), it can be used to redirect users without proper checks, leading to open redirect or phishing attacks. The lack of input validation on the parsed data makes this a sensitive misuse of the standard JSON parsing API.}	N/A
2703	wikianime.club.js	Open Redirect Vulnerability	High	true	CWE-601	10	encodeURIComponent	standard	{The queryParams function uses encodeURIComponent to encode parameters, but the getRedirectUrl function appends these parameters to a base URL without validating or sanitizing the base URL itself. Since settings.redirect_url is derived from untrusted external data, an attacker can set it to a malicious domain. The concatenation of this untrusted base URL with encoded parameters (which may also be derived from user input via getUrlParams) allows for open redirect attacks. The use of encodeURIComponent is safe for parameter encoding, but the overall misuse lies in the lack of validation of the base URL, which is controlled by untrusted data.}	N/A
2704	greenhousepeople.co.uk.js	Improper Handling of Asynchronous Operations in Service Worker Activation	Medium	false	New	N/A	N/A	N/A	{The issue stems from improper handling of asynchronous operations during service worker activation, specifically the use of event.waitUntil with a Promise chain that does not properly return a resolved Promise. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic or control flow issue in Promise handling. No sensitive function is being misused here.}	```event.waitUntil(caches.keys().then(cacheNames => { cacheNames.forEach(value => { if (value.indexOf(version) < 0) { caches.delete(value); } }); return; }));```
2705	goamplify.com.js	Improper Validation of Cached Content	High	true	CWE-352	N/A	caches.match	standard	{The caches.match function retrieves a response from the cache based on the provided request. If the cached content is not validated before being served, it may contain malicious or outdated data, leading to potential security issues such as serving tampered content or bypassing security controls. The function is misused here because it assumes the cached response is safe without any integrity or freshness checks.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
2706	goamplify.com.js	Caching with 'cache: 'reload'' Without Validation	Medium	true	CWE-352	N/A	caches.add	standard	{The caches.add function is used to add a resource to the cache, and when combined with the 'cache: 'reload'' option, it forces a fresh fetch from the network. However, if the fetched resource is not validated before being cached, it may introduce untrusted or malicious content into the cache. This misuse allows potentially harmful content to be stored and served later without proper validation.}	```await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
2707	goamplify.com.js	Missing Cache Versioning/Lifetime Management	Low	false	N/A	N/A	N/A	N/A	{This issue is not caused by misuse of a sensitive function but rather by a lack of cache management practices. The cache is not versioned or expired, which can lead to stale content being served, but it does not involve a sensitive function being misused with untrusted input.}	```const CACHE_NAME = 'offline';```
2708	skarb.com.ua.js	Improper Cache Control for Admin Resources	High	false	New	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in the conditional that determines whether to cache a resource. The condition `!/^admin/.test(uri) && !/^(404|403|401|301)/.test(uri) || /(png|jpg|svg|ttf|eot|woff|woff2|gif|js|css|json)$/.test(file)` is improperly structured due to operator precedence, allowing admin resources to be cached if they match the file extension pattern. This is not caused by misuse of a sensitive function but by flawed logic.}	```if (!/^admin/.test(uri) && !/^(404|403|401|301)/.test(uri) || /(png|jpg|svg|ttf|eot|woff|woff2|gif|js|css|json)$/.test(file)) {```
2709	skarb.com.ua.js	Cache Poisoning via URL Parsing	High	true	New	N/A	replace	standard	{The `replace` method is used on `event.request.url` with a regex pattern to extract a file path. Since the URL is derived from user-controlled input (via the fetch event), and the replacement is used to construct a cache key or path, an attacker could craft a URL that bypasses intended restrictions or causes unintended caching behavior, leading to cache poisoning. The function is standard but misused with untrusted input.}	```let file = event.request.url.replace(/^http(s?):\/\/(.+)\//, '').split('?')[0];```
2710	skarb.com.ua.js	Cache Duration Based on Untrusted Server Date	Medium	true	New	N/A	get	standard	{The `get` method of the `Headers` object is used to retrieve the 'date' header from a network response. Since this header is controlled by the server and potentially manipulated by an attacker, relying on it to calculate cache expiration introduces a timing-based vulnerability. The function is standard but misused by trusting unverified server-provided timestamps.}	```let expires = Date.parse(response.headers.get('date'));```
2711	skarb.com.ua.js	Improper Error Handling in Promise Chains	Medium	false	CWE-754	N/A	N/A	N/A	{The vulnerability stems from a flawed promise chain structure where an error in the `fromCache` function is caught, but the subsequent `fromNetwork` call does not properly handle errors, potentially leading to uncaught exceptions or inconsistent behavior. This is a logic or design flaw, not misuse of a sensitive function.}	```}).catch(err => { fromNetwork(event.request).then(response => { resolve(response); }).catch(err => { reject(err); }); });```
2712	dynamicpapers.com.js	External Script Import Without Validation	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, in this case, the URL is hardcoded to a third-party CDN (https://cdn.pushmaster-cdn.xyz), which is not under the control of the site owner. This introduces a risk if the CDN is compromised or if the script is malicious, allowing an attacker to inject arbitrary code into the service worker. While the input is not dynamic, the lack of validation or integrity checks on the external script source constitutes a misuse of the sensitive function, leading to potential code injection and compromise of the service worker's execution context.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/64f0b0782630b60008917723/service-worker.js"");```"
2713	bour.so.js	Improper URL Validation Leading to Bypassable Blacklist	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of `indexOf` to check for substring presence in the URL, which is inherently imprecise and can be bypassed by URL encoding or using different URL structures (e.g., `https://evil.com/powerlinks.com/path`). This is not due to misuse of a sensitive function, but rather a logical flaw in validation logic.}	```var t = !!s.find(function (n) { return !!~e.request.url.indexOf(n); });```
2714	yeticasino.com.js	Cache Poisoning via Dynamic Asset Inclusion	High	true	CWE-352	10	assets.push	standard	{The service worker dynamically adds URLs matching a regex pattern to the `assets` array during fetch events, which are then cached during installation. Since `evt.request.url` is derived from incoming network requests (potentially controlled by an attacker), this allows arbitrary URLs to be added to the cache. The `caches.open` and `cache.addAll` functions are then used to cache these dynamically added assets, leading to cache poisoning. The sensitive function `assets.push` is not inherently dangerous, but its misuse in conjunction with untrusted input (`evt.request.url`) and subsequent caching via standard cache APIs enables the vulnerability.}	```const skinCache = 'skin-static'; let regex = /(js|css|svg|webp|png|jp(e*)g|woff2|)/; let assets = []; self.addEventListener('fetch', evt => { evt.request.url.match(regex) && assets.push(evt.request.url); assets = [...new Set(assets)]; evt.respondWith(caches.match(evt.request).then(cacheRes => { return cacheRes || fetch(evt.request); })); });```
2715	roci.biz.js	Improper Validation of Click Action Leading to Open Redirect	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used with a URL derived from untrusted notification data (event.notification.data.click_action). Since this URL is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or executing unintended actions.}	N/A
2716	roci.biz.js	Exposure of Sensitive Firebase Configuration Data	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data (including API key) in the service worker script, which is accessible to attackers. This is not caused by misuse of a sensitive function, but rather by insecure data exposure.}	N/A
2717	roci.biz.js	Potential Denial of Service via Undefined Data Access	Medium	false	CWE-754	N/A	N/A	N/A	{The vulnerability stems from accessing potentially undefined properties (e.g., event.notification.data.FCM_MSG.data.click_action) without proper checks, which could lead to runtime errors or unexpected behavior. This is not due to misuse of a sensitive function, but rather improper error handling or data validation.}	N/A
2718	ourweekly.com.js	Code Injection via Dynamic Script Import	High	true	CWE-94	10	N/A	standard	{The `importScripts()` function is used with a dynamically constructed URL (`e`) derived from `self.Pt.modulePathPrefix` and `this.$t`. Since `modulePathPrefix` is set via `workbox.setConfig()` with a user-controlled or potentially untrusted value (e.g., from a configuration source), an attacker could manipulate this prefix to import malicious scripts from arbitrary domains, leading to code injection.}	```self.importScripts(e)```
2719	ourweekly.com.js	Information Exposure Through Cache	Medium	false	CWE-200	N/A	N/A	N/A	{The precache URLs are hardcoded and do not involve dynamic or untrusted input. While the URLs contain query parameters, they are static and not derived from user input, so no sensitive function misuse is present.}	"```wp.serviceWorker.precaching.precache([{""url"": ""https:\/\/www.ourweekly.com\/?wp_error_template=offline"", ""revision"": ""0.8.2;newspack-theme=2.2.0;options=22f2624e13e156044de4664c191a8939;nav=311263e55b8f6cc1e0e13ab9fc929bb5;deps=504f782249d6cb9c666e15414f6be55c;0c2d584d75142f0aa2defbab82478d65""}])```"
2720	ourweekly.com.js	Denial of Service via Service Worker Activation	Medium	false	CWE-408	N/A	N/A	N/A	{The `skipWaiting()` and `clientsClaim()` functions are standard Service Worker APIs used for activation. Their misuse does not stem from sensitive function misuse with untrusted input, but rather from improper timing or deployment strategy.}	```self.skipWaiting(); workbox.core.clientsClaim();```
2721	ourweekly.com.js	Information Exposure Through Cache Poisoning	Medium	false	CWE-200	N/A	N/A	N/A	{The `registerRoute` function is used with a static regular expression and fixed cache configuration. There is no dynamic or untrusted input involved in constructing the route or cache name, so no sensitive function misuse occurs.}	```wp.serviceWorker.routing.registerRoute(new RegExp('^https:\\/\\/www\\.ourweekly\\.com\\/wp\\-content\\/uploads\\/.*\\.(jpg|jpeg|jpe|gif|png|bmp|tif|tiff|ico|heic|webp|avif)(\\?.*)?$'), new wp.serviceWorker.strategies['StaleWhileRevalidate'](function () { const strategyArgs = { 'cacheName': 'uploaded-images' }; ... }))```
2722	nadlancenter.co.il.js	Improper Input Validation for FCM Payload	Medium	true	CWE-20	9	JSON.parse	standard	{The function JSON.parse is used to parse the FCM payload, which is received from an untrusted source (Firebase Cloud Messaging). If the payload is not properly validated and contains malicious or malformed JSON, it could lead to unexpected behavior or potential injection attacks, especially if the parsed data is later used in dynamic contexts (e.g., constructing notification content). Although the payload is typically controlled by Firebase, improper validation can still allow unintended data flows.}	```messaging.setBackgroundMessageHandler(function (payload) { console.log(payload); const notification = JSON.parse(payload); const notificationOption = { body: notification.body, icon: notification.icon }; return self.registration.showNotification(payload.notification.title, notificationOption); });```
2723	behestandarou.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL, which does not involve dynamic or untrusted input. However, the vulnerability arises because the script being imported is from an external domain (van.najva.com), which may not be fully trusted or controlled by the application owner. While the URL is static, the act of importing a script from an external source introduces a risk of remote code execution if that external script is compromised or malicious. The misuse lies in trusting an external script without proper integrity verification or origin validation.}	```importScripts('https://van.najva.com/static/js/scripts/behestandarou395-website-35173-8fe30fe6-c7aa-4b6b-a704-69946ef12425-service-worker.js');```
2724	tourplay.net.js	Information Exposure via Debug Endpoint	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the debug endpoint returning sensitive internal state information (e.g., driver version, state, cache names, idle task queue, and debug logs) to any client that requests it. This is not caused by misuse of a sensitive JavaScript function, but rather by the design decision to expose internal state via a public endpoint. The function `newResponse()` is used correctly to construct the response, but the content being returned is the issue, not the function itself.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}````
2725	tourplay.net.js	Use of Weak Cryptographic Algorithm (SHA)	Low	false	N/A	N/A	N/A	N/A	{The use of SHA-1 for hashing manifests is a cryptographic weakness, but it is not due to misuse of a sensitive JavaScript function. The `sha1()` function is implemented internally and used appropriately for its intended purpose (hashing manifest data for versioning). The vulnerability stems from the inherent insecurity of SHA-1, not from improper or unsafe usage of the function.}	```return sha1(JSON.stringify(manifest));```
2726	boody.co.uk.js	External Script Import Without Integrity Check	High	false	N/A	0	N/A	N/A	{The importScripts() call uses a hardcoded, trusted URL and does not involve dynamic or user-controlled input. While importing external scripts without integrity checks is a security concern, it is not considered a sensitive function misuse in this context because the URL is static and not derived from untrusted sources.}	"```self.importScripts(""https://assets.emarsys.net/web-emarsys-sdk/4.2.0/web-emarsys-service-worker.js"");```"
2727	hubsystems.com.au.js	Broad POST route interception leading to potential data leakage	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from registering a broad route for all POST requests without proper validation or filtering, which could allow interception of sensitive data. However, this is not caused by misuse of a sensitive JavaScript function but rather by a design flaw in route configuration.}	```wp.serviceWorker.routing.registerRoute(/.*/, offlinePostRequestHandler, 'POST');```
2728	hubsystems.com.au.js	XSS via unsanitized error message injection in iframe	High	true	N/A	10	`<iframe>`	standard	{The `iframe` element is dynamically constructed using user-controlled error text via `src` and `srcdoc` attributes without sanitization. This allows an attacker to inject arbitrary HTML or JavaScript into the page, leading to XSS. The `btoa` and string replacement operations do not sanitize the input, making the `iframe` tag a direct vector for exploitation.}	"```const iframe = `<iframe style=""width:100%"" src=""${src}"" srcdoc=""${srcdoc}""></iframe>`;```"
2729	hubsystems.com.au.js	Unvalidated message origin in skipWaiting trigger	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from accepting any message event without validating the sender's origin, which could allow malicious clients to trigger `skipWaiting()`. However, this is not due to misuse of a sensitive function but rather a lack of origin validation in event handling.}	```self.addEventListener('message', function (event) { if (!event.data) { return; } if (event.data.type === 'SKIP_WAITING' || 'skipWaiting' === event.data.action) { self.skipWaiting(); } });```
2730	ottomotors.com.js	Improper Input Validation in Dynamic API Handling	High	true	CWE-20	9	new URL(event.request.url)	standard	{The URL constructor is used to parse the request URL, which is then used to extract a dynamic path parameter. This parameter is split and used as a key to access a function in the MessageAPI object. Since the input is derived from the request URL without validation or sanitization, an attacker can craft a URL that triggers arbitrary function calls via MessageAPI, leading to unauthorized actions.}	```const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
2731	ottomotors.com.js	Insecure Resource Storage in IndexedDB	Medium	true	CWE-200	8	idbKeyval.set	custom	{The idbKeyval.set function is used to store arbitrary resources in IndexedDB, with the key derived from a user-supplied path. Since the path is not validated or sanitized, an attacker could inject malicious keys or data, leading to data leakage or tampering. The function is custom (from idb-keyval library) and its misuse allows untrusted data to be stored under potentially predictable or exploitable keys.}	```MessageAPI.setPathResources = (event, { path, resources }) => { event.waitUntil(idbKeyval.set(`resources:${path}`, resources)); };```
2732	ottomotors.com.js	Denial of Service via Cache Clearing	Medium	true	CWE-400	9	caches.delete	standard	{The caches.delete function is called on cache keys that are derived from the result of caches.keys(), filtered by a string match for 'runtime'. Since this operation is triggered by a message event without input validation, an attacker could send a message to trigger the deletion of multiple caches, potentially disrupting the service worker’s functionality and causing a denial of service.}	```MessageAPI.clearPathResources = event => { event.waitUntil(idbKeyval.clear()); event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); })); };```
2733	vrutal.com.js	Improper URL Normalization Leading to Cache Poisoning	High	true	New	9	URL.createObjectURL	standard	{The code uses URL.createObjectURL to generate URLs from potentially untrusted inputs, but does not validate or sanitize the input. This can lead to cache poisoning if attackers can manipulate the URL to point to malicious resources, allowing them to inject or overwrite cached content.}	```const parsed = this.parseUrl(url, relativeTo); return { origin: parsed.origin, path: parsed.path, search: parsed.search };```
2734	zahratalkhaleej.ae.js	Improper Input Validation (Untrusted URL Parameters for Firebase Config)	High	true	CWE-20	N/A	firebase.initializeApp	standard	{The firebase.initializeApp function is being called with configuration values directly extracted from URL query parameters via queryParams.get(). Since these values are not validated or sanitized, an attacker could manipulate the URL to inject malicious configuration data, such as a rogue API key or database URL, potentially leading to unauthorized access to Firebase resources, data leakage, or server-side code execution if the Firebase SDK is misconfigured. This constitutes a sensitive function misuse because the function is designed to initialize a powerful backend service with potentially sensitive credentials, and its inputs are derived from untrusted sources.}	```firebase.initializeApp({ 'projectId': queryParams.get('projectId'), 'appId': queryParams.get('appId'), 'databaseURL': queryParams.get('databaseURL'), 'storageBucket': queryParams.get('storageBucket'), 'apiKey': queryParams.get('apiKey'), 'authDomain': queryParams.get('authDomain'), 'messagingSenderId': queryParams.get('messagingSenderId'), 'measurementId': queryParams.get('measurementId') });```
2735	wp-s.ru.js	Path Traversal in Media File Caching	High	true	CWE-22	9	N/A	standard	{The URL constructor is used with a dynamically generated path that includes user-controlled mediaFile.name. If the name contains path traversal sequences (e.g., '../'), the resulting cacheKey could point to unintended resources, enabling path traversal attacks.}	```const cacheKey = new URL('/_share-target/image_' + Date.now() + '_' + mediaFile.name, self.location).href;```
2736	wp-s.ru.js	Cache Poisoning via Unvalidated Media Files	High	true	CWE-444	9	N/A	standard	{The Response constructor is used to wrap user-uploaded mediaFile without validation, allowing attackers to inject malicious content (e.g., scripts, redirects) into the cache. This enables cache poisoning, where the service worker serves harmful content to users.}	```await cache.put(cacheKey, new Response(mediaFile, { headers: { 'content-length': mediaFile.size, 'content-type': mediaFile.type } }));```
2737	wp-s.ru.js	Header Manipulation in Cache Freshness Check	Medium	false	CWE-20	0	N/A	standard	{The Date.parse() function is used to parse the 'Date' header from a cached response, but the vulnerability arises from improper handling of stale or malformed headers, not from misuse of a sensitive function.}	```const dateAsMillis = Date.parse(dateAsString);```
2738	dercocenter.cl.js	External Script Import from Untrusted CDN	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is called with options.workboxURL, which is a hardcoded URL pointing to a CDN. While the URL is hardcoded and not user-controlled, the vulnerability arises because the script is loaded from an external, potentially untrusted source (CDN). If the CDN is compromised or the script is tampered with, it could lead to arbitrary code execution within the service worker. This is a high-risk scenario because service workers have broad access to network requests, caching, and client interactions.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
2739	dercocenter.cl.js	Dynamic Code Execution via getProp	High	true	CWE-94	9	getProp	custom	{The getProp function is a custom utility that dynamically accesses nested object properties using a string path (e.g., 'a.b.c'). In the runtimeCaching function, it is used to resolve strategy plugins via getProp(workbox, p.use), where p.use is derived from user-defined configuration. If an attacker can control the configuration (e.g., via a maliciously crafted options object), they could inject arbitrary plugin names, leading to dynamic instantiation of potentially malicious classes or functions. This constitutes dynamic code execution, which can be exploited to bypass security controls or execute arbitrary logic within the service worker.}	```plugins.unshift(requestInterceptor); const strategyOptions = { ...entry.strategyOptions, plugins }; const strategy = new workbox.strategies[entry.handler](strategyOptions);```
2740	powersportsupport.com.js	Code Injection	High	true	CWE-96	10	[]	standard	{The vulnerability arises from the use of `MessageAPI[api](event, event.data)` where `api` is derived from `event.data.gatsbyApi`, which is user-controlled. This allows an attacker to invoke arbitrary functions in the `MessageAPI` object by sending a message with a malicious `gatsbyApi` value, leading to code injection. The `[]` operator dynamically accesses and executes a function based on user input, which is a classic case of unsafe dynamic function invocation.}	```const { api } = event.data; if (api) MessageAPI[api](event, event.data);```
2741	tehnoskarb.ua.js	Host Header Spoofing via URL Includes	High	true	CWE-829	9	replace	standard	{The code uses `r.request.url.replace(/^http(s?):\/\/(.+)\//, '')` to extract a path from the request URL, but this operation is performed without validating or sanitizing the input. The regex pattern `(.+)` is overly permissive and can match any hostname, including malicious or spoofed ones. This allows an attacker to craft a request with a manipulated host header (e.g., via HTTP Host header spoofing) that bypasses the intended domain checks, leading to unintended resource caching or serving. The vulnerability arises because the `replace` function is used to process untrusted input (the request URL) without proper validation, enabling host header spoofing.}	```(r.request.url.includes('//develop.tehnoskarb') || r.request.url.includes('//tehnoskarb.ua') || r.request.url.includes('//ua.tehnoskarb.ua') || r.request.url.includes('//fl1.tehnoskarb.ua')) && 'GET' === r.request.method && (s = r.request.url.replace(/^http(s?):\/\/(.+)\//, '').split('?')[0], e = r.request.url.replace(/^http(s?):\/\/(.[^\/]+)\//, '').split('?')[0], /^docs\/?$/.test(e) || (/^(json\/)?\/?$/.test(e) || /^(json\/)?news(\/category\/(\d+)-([a-z0-9_\-]+))?\/?$/.test(e) || /^(json\/)?news\/((\d+)-([a-zA-Z0-9_\-]+))\/?$/.test(e) || /^(json\/)?shops\/(\d+)-([0-9a-z\-]+)\/?$/.test(e) || /^(json\/)?(shops|shops_list)(\/(.+))?\/?$/.test(e) || /^(json\/)?(services|about|delivery|news|guest-book)(\/(.+))?\/?$/.test(e) || /(webp|png|jpg|svg|ttf|eot|woff|woff2|gif|js|css|json)$/.test(s)) && r.respondWith(new Promise(function (o, t)```
2742	nolio.io.js	Cache Poisoning via Substring Matching	High	true	CWE-352	10	caches.put	standard	{The caches.put function is used to store a network response in the cache under a URL derived from the cleaned request URL. Since the decision to cache is based on substring matching (STATIC_TO_CACHE_INCLUDE.some(...)), an attacker could craft a request URL that includes a substring matching one of the allowed domains (e.g., 'nolio-static.s3.eu-west-3.amazonaws.com'), causing the service worker to cache a malicious response under a legitimate-looking key. This allows cache poisoning, where subsequent requests for the legitimate resource may return the attacker-controlled response.}	```if (should_use_cache) { event.respondWith(caches.open(CACHE_NAME).then(function (cache) { return cache.match(cleaned_url).then(function (response) { return response || fetch(event.request).then(function (networkResponse) { cache.put(cleaned_url, networkResponse.clone()); return networkResponse; }); }); }));```
2743	nolio.io.js	Open Redirect in Notification Handler	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from event.notification.data.url, which is not validated or sanitized. An attacker could trigger a push notification with a malicious URL, causing the service worker to open an arbitrary webpage in a new window, leading to an open redirect vulnerability.}	```if (clients.openWindow) { return clients.openWindow(url); }```
2744	vikiwat.com.js	Improper Neutralization of Query Parameters in a Web Page Request	Medium	false	N/A	N/A	N/A	N/A	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function. The code uses `caches.match()` and `fetch()` in a standard, safe manner to handle requests. There is no dynamic input being passed to a sensitive function that could lead to injection or unauthorized behavior. The issue may stem from a misclassification or misunderstanding of the vulnerability type, as no sensitive function misuse is evident.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request, { ignoreSearch: true }).then(response => { return response || fetch(event.request); })); });```
2745	unilever.co.id.js	Improper Check for Excluded URLs	Medium	false	CWE-20	N/A	N/A	N/A	"{The vulnerability arises from a flawed logic in filtering excluded URLs. The code checks if the request URL contains any of the excluded paths using `e.request.url.indexOf(t) > -1`, which is a string-based substring search. This can lead to false negatives or positives if the excluded path is not properly anchored (e.g., ""/api"" might match ""/api-key""). However, this is not caused by misuse of a sensitive function like `importScripts()` or `eval()`, but rather by a logical flaw in string matching.}"	```if (IGNORED_HOSTS.indexOf(t) >= 0 || EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || 'PUT' === e.request.method || 'POST' === e.request.method || e.request.headers.get('range'))```
2746	unilever.co.id.js	Case-Insensitive Hostname Comparison	Medium	false	CWE-20	N/A	N/A	N/A	"{The vulnerability stems from using `indexOf` to check for hostname matches, which performs a case-sensitive comparison. Since hostnames are case-insensitive in practice (e.g., ""Example.com"" vs ""example.com""), this can lead to bypasses. However, this is not due to misuse of a sensitive function such as `importScripts()` or `eval()`, but rather a logical flaw in string comparison.}"	```if (IGNORED_HOSTS.indexOf(t) >= 0```
2747	tektra.one.js	Improper Input Validation in Route Regex	High	true	N/A	N/A	RegExp	standard	{The use of `new RegExp(e)` with user-controlled or dynamically parsed strings from `JSON.parse()` allows for arbitrary regex patterns to be injected, potentially leading to ReDoS or unintended route matching. The input is derived from a hardcoded JSON string, but the dynamic construction of regexes from parsed data introduces risk if the source were user-controllable.}	"```const c = JSON.parse('[""tektra\\\\.one(?:/.*)?/ola/services/.*"",""tektra\\\\.one/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://5123aca4-3777-4b5b-9415-18a65908a7b0\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e))```"
2748	tektra.one.js	Cache Poisoning via Insecure Cache Strategies	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability arises from the use of `NetworkOnly` strategy without proper validation or sanitization of URLs, but it is not caused by misuse of a sensitive function. The issue is more about strategy misconfiguration than function misuse.}	```(0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkOnly())```
2749	tektra.one.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{This is a configuration issue with `ExpirationPlugin` parameters, not a misuse of a sensitive function. The function `new n.ExpirationPlugin()` is used correctly; the vulnerability stems from overly permissive settings, not improper function usage.}	```new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })```
2750	tektra.one.js	SSRF Vulnerability in Network-First Strategy	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the `NetworkFirst` strategy being applied to URLs that may be controlled by an attacker (e.g., via `o.some(t => t.test(e.href))`), but no sensitive function is misused. The issue is in the route matching logic, not in how a function is called.}	```(0, e.registerRoute)(({ url: e }) => o.some(t => t.test(e.href)), new t.NetworkFirst({ cacheName: 'network-first' }))```
2751	tektra.one.js	Insecure Cache Name Management	Low	false	N/A	N/A	N/A	N/A	{The use of `e.startsWith('tektra.one-')` is a simple string operation and does not involve any sensitive function. The vulnerability is due to lack of validation, not misuse of a function.}	```e.filter(e => e.startsWith('tektra.one-'))```
2752	oxfordplayhouse.com.js	Insecure Message Handling in Service Worker	Medium	false	New	N/A	N/A	N/A	"{The vulnerability arises from handling messages without validating or sanitizing the incoming data, but it is not caused by misuse of a sensitive function like importScripts or eval. The code listens for messages and skips waiting if the message type is ""SKIP_WAITING"", which is a legitimate and safe use of self.addEventListener. There is no dynamic or untrusted input being passed to a sensitive function.}"	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); }), e.precacheAndRoute([...], {}), e.registerRoute(/\.(?:png|jpg|jpeg|svg)$/, new e.CacheFirst({ cacheName: ""images"", plugins: [new e.ExpirationPlugin({ maxEntries: 10, purgeOnQuotaError: !0 })] }), ""GET"");```"
2753	luisacerano.com.js	Allowlist Check Does Not Block Requests	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in the allowlist implementation, not from misuse of a sensitive function. The allowlist regex patterns are constructed using hostnameRegex, but they are not properly escaped or validated, and the regex patterns may not cover all intended cases, allowing unintended URLs to pass through. This is a configuration or logic issue, not a direct misuse of a sensitive function.}	```function safeHandler(event) { if (!isAllowlisted(event.request.url)) { return console.debug(`FETCH EVENT BLOCKED: Cannot execute fetch event handler on following request: ${event.request.url}`); } return handler.call(this, event); }```
2754	luisacerano.com.js	User-Controlled Input in importScripts URL	Medium	true	N/A	N/A	importScripts	standard	{The importScripts function is used with a URL that includes location.search, which is user-controlled. This allows an attacker to inject arbitrary query parameters into the URL, potentially causing the service worker to load and execute a malicious script from an unintended source. Since importScripts executes scripts from the provided URL without validation, this constitutes a direct misuse of a sensitive function.}	```importScripts(`https://luisacerano.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
2755	nestlenutrition-institute.org.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from using `event.notification.data.url` directly without validation or sanitization, but it is not caused by misuse of a sensitive JavaScript function. The code does not invoke any function that inherently introduces risk (like `eval`, `importScripts`, or `setTimeout` with untrusted input). The risk is purely from improper input handling, not from a sensitive function call.}	```var url = event.notification.data.url || '/';```
2756	detentejardin.com.js	Insecure External Script Import	Medium	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (as in this case: 'https://aswpsdkeu.com/notify/v1/ua-sdk.min.js'), it introduces a medium-risk vulnerability because the script is loaded from an untrusted third-party domain. While the URL is hardcoded and not dynamically constructed from user input, the origin is external and potentially controlled by an attacker, leading to script injection or compromise of the service worker's execution context. This is considered a sensitive function misuse due to the inherent risk of loading remote code without proper validation or integrity checks.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
2757	sig.pl.js	External Script Without Integrity Check	Medium	false	N/A	0	N/A	N/A	{The use of importScripts() to load an external script from a CDN is not inherently a sensitive function misuse, as the URL is hardcoded and not derived from untrusted input. While it lacks integrity checks, this does not constitute a sensitive function misuse in the context of dynamic, user-controlled input.}	```importScripts('https://cdn.jsdelivr.net/npm/workbox-cdn/workbox/workbox-sw.js');```
2758	anarim.az.js	XSS in Notification Actions	High	true	CWE-79	N/A	self.registration.showNotification	N/A	N/A	```self.registration.showNotification(data.title, data);```
2759	anarim.az.js	Insecure API Communication	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of credentials and lack of secure transport validation, not from misuse of a sensitive function. The fetch call includes credentials: 'include' but does not validate the API endpoint or enforce HTTPS, which is a configuration issue rather than a sensitive function misuse.}	"```fetch(url, { headers: { 'Content-Type': 'application/json; charset=UTF-8' }, credential: ""include"" })```"
2760	anarim.az.js	Improper Subscription Endpoint Validation	High	true	CWE-800	N/A	self.registration.pushManager.getSubscription	N/A	N/A	```self.registration.pushManager.getSubscription().then(function (subscription) { fetchAndShowMessage(subsId, subscription.endpoint, srvId); })```
2761	anarim.az.js	Insecure IndexedDB Storage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the lack of encryption or access control on IndexedDB, not from misuse of a sensitive function. The IndexDbStorage class is custom, but its use does not inherently involve unsafe function calls; the issue is in the design and implementation of data protection, not in how a sensitive function is used.}	```this.storage = new IndexDbStorage('push-ka', 'params');```
2762	anarim.az.js	Unvalidated Notification Data	Medium	true	CWE-79	N/A	self.registration.showNotification	N/A	N/A	"```data.title = typeof data.title != ""undefined"" ? data.title : sw.defaultMessage.title;```"
2763	hereisthecity.com.js	Vulnerable Cache Handling	High	true	CWE-497	9	N/A	standard	{The vulnerability arises from the use of `caches.open()` with dynamically constructed cache names derived from version variables. While not directly user-controlled, these cache names are built from string concatenation and could be manipulated if version values were derived from untrusted sources, leading to unintended cache operations or cache name collisions. However, in this case, the versions are hardcoded, so the risk is low. But since the function `caches.open()` is a standard API and its misuse with dynamic inputs can lead to cache manipulation, it qualifies as sensitive function misuse.}	"```const version = ""1.15.16"", childVersion = ""1.1.28"", expectedCaches = [""grv-parent-"" + version, ""grv-child-"" + childVersion""];```"
2764	hereisthecity.com.js	Cache Poisoning Risk	High	true	CWE-306	9	N/A	standard	{The `fetch()` function is used without proper validation or sanitization of the request, and the response is cached and served without checking for integrity or origin. This allows an attacker to potentially inject malicious content into the cache if the fetch request is manipulated (e.g., via a crafted request or intercepted network call), leading to cache poisoning. The `fetch()` function is a standard API and its misuse with untrusted or unsanitized inputs introduces this risk.}	"```(e.headers.get(""Accept"").includes(""text/css"") || e.headers.get(""Accept"").includes(""text/javascript"")) && t.respondWith(async function () { var e = await caches.match(t.request); return e || (await t.preloadResponse) || fetch(t.request); }());```"
2765	hereisthecity.com.js	Offline Page Exposure	Medium	false	CWE-285	0	N/A	standard	{The vulnerability is due to the exposure of the offline page via `caches.match('/offline/')` when a fetch fails. This is not caused by misuse of a sensitive function, but rather by design choice in handling failed requests. The `caches.match()` function is used correctly here, and no sensitive function misuse is present.}	"```t.respondWith(fetch(e).then(function (e) { return e; }).catch(function (e) { return caches.match(""/offline/""); })),```"
2766	westwing.sk.js	Improper Error Handling in Cache Cleanup Leading to Forced Reload	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling during cache cleanup, where an error in deleting caches is logged but the page is still forced to reload. This does not stem from misuse of a sensitive JavaScript function, but rather from flawed logic in the cleanupHandler's error handling. The code does not involve dynamic or untrusted input being passed to sensitive functions like importScripts, eval, or similar.}	```const cleanupHandler = () => Promise.all([assetsExpirationPlugin.deleteCacheAndMetadata(), imagesExpirationPlugin.deleteCacheAndMetadata(), apiExpirationPlugin.deleteCacheAndMetadata()]); if (res) { cleanupHandler().then(() => { event.ports[0].postMessage(RELOAD_PAGE_MESSAGE_TYPE); }).catch(() => { console.error('Error deleting caches'); event.ports[0].postMessage(RELOAD_PAGE_MESSAGE_TYPE); }); }```
2767	polishtrains.eu.js	Improper Neutralization of Dynamic Cache Generation Leading to Cache Poisoning	High	true	CWE-918	10	N/A	standard	{The function `new URL(location).searchParams.get('lang')` is used to dynamically construct the `HTMLToCache` variable, which is then concatenated into URLs for caching (e.g., `HTMLToCache + '/public/train/js/jquery.min.js'`). Since the `lang` parameter is directly extracted from the URL query string without sanitization or validation, an attacker can manipulate it to inject arbitrary paths or domains, leading to cache poisoning where malicious or unintended resources are cached and served to users. This misuse of dynamic URL construction via `URL` and `searchParams` is a standard JavaScript API that becomes dangerous when used with untrusted input.}	```const HTMLToCache = new URL(location).searchParams.get('lang'); const MY_FILES = [...] HTMLToCache + '/...'```
2768	polishtrains.eu.js	Server-Side Request Forgery (SSRF) via Unrestricted Fetch	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of input validation on the `event.request` object in the fetch handler. The `fetch(event.request)` call is not inherently unsafe; the SSRF arises because the service worker does not validate or restrict the URLs being fetched, allowing an attacker to trigger requests to internal or external resources via crafted requests. Since no sensitive function is misused, this is not a case of sensitive function misuse.}	```return (await caches.match(event.request)) || (await caches.match(OFFLINE_URL));```
2769	tinroid.ir.js	Insecure External Resource Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (van.najva.com). This allows an attacker who controls the external resource to inject malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the vulnerability is still considered sensitive because the function itself is inherently dangerous when used with any external source, especially without integrity checks or origin validation.}	```importScripts('https://van.najva.com/static/js/scripts/new-website666-website-42801-e581e237-3aa4-4162-b27e-7a4f2bc6516b-service-worker.js');```
2770	notorious-mag.com.js	Vulnerability of loading external script via importScripts without validation leading to potential remote code execution	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, the vulnerability arises from the fact that the URL is hardcoded and potentially controlled by an external entity (e.g., CDN), which could be compromised or redirected to malicious content. While the input is not dynamic, the lack of validation or integrity checks on the external script source allows for potential remote code execution if the CDN is compromised. This misuse is considered sensitive because importScripts() executes code from the specified URL without any sandboxing or integrity verification.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/64f59fee5897d70008581212/service-worker.js"");```"
2771	dotalkhalij.com.js	Hardcoded API Key in Firebase Configuration	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded credentials, not from misuse of a sensitive JavaScript function. The API key is embedded directly in the code, which is a configuration issue rather than a functional misuse.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyCBVh6JDf415THSifKl_lvdYxQQVDU6fc8' } };```
2772	dotalkhalij.com.js	Unvalidated URL in Notification Click Leading to SSRF	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamic URL (apiUrl) derived from notification data, which is user-controlled. Since no validation or sanitization is applied, an attacker can manipulate the notification payload to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(apiUrl);```
2773	dotalkhalij.com.js	Storing Sensitive Data in Plaintext in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from insecure data storage practices, not from misuse of a sensitive JavaScript function. The data is stored in IndexedDB without encryption, which is a data protection issue, not a functional misuse.}	```const request = objectStore.put({ id: key, data: value });```
2774	24live.com.js	XSS via unsanitized push notification data	High	true	CWE-79	10	showNotification	standard	{The showNotification function is used to display a notification with content derived from untrusted push data (e.g., body.msg, body.title). Since these values are not sanitized or escaped, an attacker can inject malicious scripts or HTML into the notification, leading to XSS when rendered in the user's browser.}	```self.addEventListener('push', function (e) { console.log('New Push notification ', JSON.stringify(e.data.json())); var body = ''; if (e.data) { body = e.data.json(); } else { body = JSON.stringify(e); } var options = { body: body.msg, icon: body.icon, badge: body.badge, vibrate: [100, 50, 100], data: { primaryKey: body.id, host: body.hostname, path: body.path } }; e.waitUntil(self.registration.showNotification(body.title, options)); });```
2775	24live.com.js	Open Redirect via unvalidated notification data	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL constructed from unvalidated notification data (host and path). Since these values are directly concatenated into a URL without validation or sanitization, an attacker can supply a malicious host (e.g., attacker.com) to redirect users to arbitrary sites, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', function (e) { var notification = e.notification; var host = notification.data.host; var id = notification.data.primaryKey; var path = notification.data.path; clients.openWindow('https://' + host + path); notification.close(); });```
2776	24live.com.js	Cache poisoning via insufficient URL validation	Medium	false	CWE-434	0	N/A	N/A	{The vulnerability arises from insufficient URL validation in the fetch handler, but it is not caused by misuse of a sensitive function. The issue lies in the logic that determines which URLs to cache, not in the use of a dangerous API.}	```self.addEventListener('fetch', async event => { var url = event.request.url; const inCache = url.includes('offline') || url.includes('24live.png') || url.includes('page'); if (event.request.method !== 'GET' || !inCache) { return; } event.respondWith((async () => { try { const serverResponse = await fetch(event.request); return serverResponse; } catch (e) { if (event.request.mode === 'navigate') { const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match(OFFLINE_URL); return cachedResponse; } else { return caches.match(event.request); } } })()); });```
2777	anbariloche.com.ar.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-602	9	N/A	standard	{The function `clients.openWindow(url)` is used with a URL constructed from untrusted notification data. The URL is derived from `event.notification.data.FCM_MSG.data.link` or parsed from `event.notification.data`, which can be controlled by an attacker. Since `new URL()` is used to parse the input, it may still allow redirection to arbitrary domains if the input is not validated, leading to open redirect vulnerabilities. The `clients.openWindow()` function is a standard browser API that opens a new window or tab, and when given a malicious URL, it can redirect users to phishing or malicious sites.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); event.waitUntil(async function () { try { const url = new URL(event.notification.data.FCM_MSG.data.link).toString(); if (url) { c = await clients.openWindow(url); } } catch (e) { try { let data = JSON.parse(event.notification.data); const url = new URL(data.link).toString(); if (url) { c = await clients.openWindow(url); } } catch (e) { console.error('Error al manejar el evento de clic en la notificación:', e); } } }());```
2778	anbariloche.com.ar.js	Exposure of Sensitive Firebase Configuration in Client-Side Code	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data (including API key) in client-side JavaScript. This is not caused by misuse of a sensitive function, but rather by insecure data exposure. No function is being misused here; the issue is static data leakage.}	"```const firebaseConfig = { ""apiKey"": ""AIzaSyDafz7KOob1Cb7KNW3thV-wVUr5q1bhwSA"", ""authDomain"": ""cms-troop-anb.firebaseapp.com"", ""projectId"": ""cms-troop-anb"", ""storageBucket"": ""cms-troop-anb.appspot.com"", ""messagingSenderId"": ""4641836571"", ""appId"": ""1:4641836571:web:d7468c7628f4736f84b2be"", ""measurementId"": ""G-B0WX0QJZWT"" };```"
2779	tankbillig.in.js	Unscoped Variable in refreshOffline Event	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of an unscoped variable `offlinePage` in the `refreshOffline` event handler. This variable is declared in the `install` event handler but is not defined or accessible in the `refreshOffline` event context, leading to a runtime error or undefined behavior. This is not a result of misuse of a sensitive function, but rather a scoping issue.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('pwabuilder-offline').then(function (cache) { console.log('[Service Worker] Offline page updated from refreshOffline event: ' + response.url); return cache.put(offlinePage, response); }); });```
2780	demel.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded path '/a/d/sw.js', which does not involve dynamic or untrusted input. However, since the vulnerability was previously detected as ""Remote Code Execution via Untrusted Script Import"", it implies that the script path may be dynamically constructed or controlled by an attacker in a broader context. Given the static nature of the provided code, the risk is low unless the path is derived from user input or configuration. But since the vulnerability was flagged, we assume the context involves dynamic input, making this a sensitive misuse.}"	```importScripts('/a/d/sw.js');```
2781	erb.pw.js	Caching of Relative Path Resource Leading to Potential Misdirection	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching relative paths such as '/assets/style.css' and 'style.css' without ensuring they resolve to intended resources. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() or eval(), but rather by improper path handling in cache.addAll(). The function cache.addAll() is not inherently sensitive in this context, as it does not execute arbitrary code or load external scripts based on untrusted input.}	```self.addEventListener('install', event => {  event.waitUntil(caches.open('v1').then(cache => {    return cache.addAll(['/', '/index.html', '/assets/style.css', 'style.css', '/img/icons/icon-192x192.png', '/img/icons/icon-512x512.png']);  }));});self.addEventListener('fetch', event => {  event.respondWith(caches.match(event.request).then(response => {    return response || fetch(event.request);  }));});```
2782	inalmaty.kz.js	Vulnerable Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static credential exposed in the script, but it is not the result of misuse of a sensitive function.}	```self[`appKey`] = `bc572ba9ae0ac9aeea240ebf87ff8ce9`;```
2783	inalmaty.kz.js	Insecure Dynamic Code Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded value (self.hostUrl), it is not inherently dangerous. However, if self.hostUrl were derived from untrusted or dynamic input (e.g., user-controlled parameters), it could lead to arbitrary script execution. In this case, since self.hostUrl is hardcoded to a trusted domain (https://cdn.gravitec.net/sw), the risk is mitigated, but the use of importScripts with dynamic URL construction still represents a potential vector if the source were not controlled. The vulnerability is classified as High due to the nature of the function, but the current context reduces the immediate risk.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2784	troypointinsider.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	N/A	standard	{The `clients.openWindow(n + e)` function is used to open a URL constructed from untrusted data (`n` and `e` from notification data). Since `n` (baseUrl) and `e` (url) are derived from push notification payloads, which can be controlled by an attacker, this allows for open redirect attacks. The `clients.openWindow()` function is a standard browser API that executes navigation to arbitrary URLs, and its misuse here enables redirection to malicious sites.}	"```if (!t.some(function (t) { return t.url === n + e && ""focus"" in t ? (t.focus(), !0) : ""postMessage"" in t && ""focus"" in t && (t.focus(), t.postMessage({ url: e }), !0); }) && clients.openWindow) return clients.openWindow(n + e);```"
2785	troypointinsider.com.js	CSRF Vulnerability via Untrusted Base URL in Fetch Request	High	true	CWE-352	9	N/A	standard	{The `fetch(`${n}/chat/${e}.json`...)` call constructs a URL using `n` (baseUrl) from notification data, which is untrusted. Although a CSRF token is included, the base URL `n` can be manipulated by an attacker to point to a malicious domain, leading to CSRF attacks where the victim’s session is exploited to perform actions on a different domain. The `fetch()` function is a standard API, and its misuse here allows unauthorized requests to be made under the victim’s credentials.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
2786	drahtlos-dsl.de.js	Insecure Fetch with No-CORS Mode	High	true	CWE-807	9	N/A	standard	{The fetch() function is used with mode: 'no-cors', which bypasses CORS checks and may allow the service worker to make requests to arbitrary origins without proper validation, potentially leading to unintended data exposure or cross-origin attacks. The URL is constructed dynamically via addParams(), which may be influenced by untrusted input, increasing the risk of fetching from unintended or malicious domains.}	```const networkResponse = await fetch(new Request(url, { mode: 'no-cors' }));```
2787	drahtlos-dsl.de.js	Improper URL Validation in addParams	Medium	true	CWE-113	8	N/A	standard	{The URL constructor is used without validating the input URL, which can lead to malformed or malicious URLs being processed. If the input URL is derived from untrusted sources, this could result in unintended behavior such as redirecting to malicious domains or leaking sensitive information.}	```const ur = new URL(url);```
2788	drahtlos-dsl.de.js	Debug Logging of Sensitive Information	Medium	false	CWE-200	0	N/A	N/A	{The console.log() function is used for debugging, but it does not involve any sensitive function misuse. The vulnerability arises from logging potentially sensitive data in debug mode, not from improper use of a sensitive function.}	```console.log('RTSW:', ...args);```
2789	drahtlos-dsl.de.js	Unvalidated Message Handling in Service Worker	High	false	CWE-347	0	N/A	N/A	{The service worker listens for messages, but the vulnerability stems from insufficient validation of incoming messages, not from misuse of a sensitive function. The handler does not validate the command or data, which could allow an attacker to trigger unintended actions.}	```self.addEventListener('message', async function handler(event) {```
2790	drahtlos-dsl.de.js	Caching of Sensitive Endpoints	Medium	false	CWE-921	0	N/A	N/A	{The vulnerability arises from the decision to cache certain endpoints, not from misuse of a sensitive function. The workbox.routing.registerRoute() function is used correctly; the issue is the policy of caching endpoints that may contain sensitive or dynamic data.}	```workbox.routing.registerRoute(/_dm\/s\/rt\/dist.*?\.js/, cacheFirst(RUNTIME_CACHE_NAME));```
2791	alfredforum.com.js	Insecure Navigation in Notification Click Handler	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed via notification data, which is derived from untrusted input. If the notification data contains a malicious URL, it can lead to open redirect or phishing attacks.}	N/A
2792	alfredforum.com.js	Insecure CSRF Token Handling	Medium	true	CWE-918	N/A	fetch	standard	{The fetch function is used to retrieve a CSRF token from a URL constructed using a dynamic path parameter. If the path parameter is not properly validated, it could lead to unintended requests or CSRF token leakage.}	N/A
2793	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
2794	alfredforum.com.js	Insecure Regex for Admin Request Check	Low	false	CWE-20	N/A	N/A	N/A	{The vulnerability is due to improper regex matching on the URL, not misuse of a sensitive function.}	N/A
2795	alfredforum.com.js	Potential XSS in Pluralize Function	Low	false	CWE-79	N/A	N/A	N/A	{The vulnerability arises from unsanitized string interpolation in the pluralize function, not from misuse of a sensitive function.}	N/A
2796	alfredforum.com.js	Insecure Caching of Sensitive Data	Low	false	CWE-921	N/A	N/A	N/A	{The vulnerability is due to caching sensitive assets without proper validation, not misuse of a sensitive function.}	N/A
2797	vuxen.se.js	Cache Poisoning	High	true	CWE-444	10	replace	standard	{The `replace` function is used to inject dynamically generated JavaScript code into the response body by replacing hardcoded strings with values derived from `JSON.stringify(c)` and `JSON.stringify(a)`. If these values are not properly sanitized and contain malicious payloads (e.g., script injection), the resulting response can execute arbitrary JavaScript in the client's context, leading to cache poisoning and potential cross-site scripting (XSS) attacks. The use of `m()` to escape certain characters is insufficient to prevent all forms of injection, especially if the data contains untrusted or user-controlled content.}	```return e.text().then(function (e) { var t = e.replace(/window\.CURRENT_PAGE = .*?;/, 'window.CURRENT_PAGE = ' + m(JSON.stringify(c)) + ';window.IS_RENDERED_FROM_CACHE = true;').replace(/window\.APP_SHELL_DATA = .*?;/, 'window.APP_SHELL_DATA = ' + m(JSON.stringify(a)) + ';'); return new Response(t, l); });```
2798	xn--mgbaaanvhpcdt8npbvj3aa47pnpia.com.js	Remote Code Execution via Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a hardcoded external URL. While the URL is fixed and not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain (even if trusted) introduces a risk of remote code execution if the script is compromised or if the domain is later taken over. This is considered a sensitive function misuse because it allows execution of arbitrary code from an external source, which can lead to full compromise of the service worker's context.}	```importScripts('https://www.xn--mgbaaanvhpcdt8npbvj3aa47pnpia.com/wp-content/plugins/letspush/js/letspush_service_worker.min.js');```
2799	yotaab.com.js	Loading external script without integrity checks	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used without integrity checks, it introduces a risk if the script at the URL is compromised or modified by an attacker. Although the URL is hardcoded in this case, the vulnerability arises from the lack of integrity verification, which could allow an attacker to serve a malicious script if the server is compromised. However, since the URL is not dynamically constructed from untrusted input, the risk is mitigated but still present due to potential supply chain attacks.}	```importScripts('https://van.najva.com/static/js/scripts/yotaab-758-ee25e978-6aca-40f3-9ea7-30c76effc230-service-worker.js');```
2800	zonenet.ca.js	Improper Error Handling in Push Event Leading to Denial of Service	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper error handling in the push event handler, where errors during fetch or JSON parsing are caught and handled by showing a default notification. However, this does not involve misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic flaw in error recovery.}	```const pingData = e.data.json();```
2801	zonenet.ca.js	Insecure CSRF Token Handling	High	true	N/A	N/A	Headers.set	standard	{The sensitive function Headers.set is misused by dynamically setting the 'X-Csrf-Token' header based on a server response, which is fetched using a URL constructed from the request's pathname. While the header setting itself is not inherently dangerous, the dynamic construction of the URL and reliance on server-provided tokens without proper validation or origin checks can lead to CSRF token leakage or misuse if the server is compromised or if the token is not properly scoped.}	"```headers.set(""X-Csrf-Token"", response.key);```"
2802	zonenet.ca.js	Open Redirect via Notification URL	Medium	true	N/A	N/A	navigate	standard	{The navigate function is misused by passing the 'data.url' value directly from the notification payload without validation or sanitization. Since this value is derived from server responses or potentially user-controlled data, an attacker could craft a malicious notification with a URL pointing to an external site, leading to an open redirect and potential phishing or credential theft.}	```clients[0].navigate(data.url);```
2803	uit.be.js	Improper Validation of Message Origin in Service Worker	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the service worker listening to messages without validating the origin of the message. While the code checks for a specific message type ('SKIP_WAITING'), it does not verify that the message originates from a trusted source. This could allow a malicious page or script to send a message to the service worker and trigger unintended behavior, such as skipping waiting state. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a lack of origin validation in event handling.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
2804	classlifestyle.com.js	Open Redirect in Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API that opens a new window or tab with the provided URL. When used with event.notification.data.url, which is derived from untrusted push notification data, it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. The URL is not validated or sanitized, enabling phishing or malicious redirection.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
2805	classlifestyle.com.js	Missing Authentication for Subscription Update	Medium	false	CWE-306	0	N/A	N/A	{The vulnerability arises from lack of authentication when updating subscription data, not from misuse of a sensitive JavaScript function. The fetch call is used correctly, but the server endpoint does not validate the client's identity, which is a server-side issue, not a function misuse.}	```return fetch('https://push.mediadesk.al/go/', { method: 'POST', body: JSON.stringify(subscription) });```
2806	akelius.com.js	Improper Input Validation	High	true	CWE-20	N/A	parseUrl	standard	{The parseUrl function uses the standard URL constructor with user-controlled input (url) without validation. If the input is a malicious URL (e.g., with a data: scheme or javascript: URL), it could lead to improper parsing or unintended behavior, especially when combined with subsequent operations like normalizeUrl that rely on parsed components. This misuse allows attackers to manipulate the URL structure and potentially bypass security checks.}	N/A
2807	akelius.com.js	Caching of Sensitive Data	Medium	false	CWE-531	N/A	N/A	N/A	{The safeFetch function does not directly misuse a sensitive function; it merely wraps fetch with error handling. The caching of sensitive data arises from the broader application logic and configuration, not from improper use of a specific sensitive function.}	N/A
2808	akelius.com.js	Exposure of Debug Information	High	false	CWE-532	N/A	N/A	N/A	{The debug information exposure is due to the design of the DebugHandler class and its handleFetch method, which returns detailed internal state. This is not caused by misuse of a sensitive function but by intentional logging and response generation.}	N/A
2809	akelius.com.js	Insecure Cache Busting	Medium	false	CWE-327	N/A	N/A	N/A	{The cacheBust function appends a random string to the URL, but it does not use a sensitive function improperly. The risk stems from predictable or insufficient randomness, not from misuse of a JavaScript API.}	N/A
2810	akelius.com.js	Cross-Site Scripting (XSS) Risk	High	false	CWE-79	N/A	N/A	N/A	{The isNavigationRequest function checks request method and mode, but does not involve any sensitive function misuse. The XSS risk is theoretical and arises from potential misconfiguration or external input handling, not from a specific function misuse.}	N/A
2811	akelius.com.js	Denial of Service (DoS) Risk	Medium	false	CWE-400	N/A	N/A	N/A	{The handleFetchWithPerformance function uses Promise.race and timeout, but these are used correctly. The DoS risk is due to configuration or external factors (e.g., long timeouts), not misuse of a sensitive function.}	N/A
2812	akelius.com.js	Insecure Direct Object Reference (IDOR)	High	false	CWE-200	N/A	N/A	N/A	{The lookupResourceWithHash function checks hash values against a known table, but it does not misuse a sensitive function. The IDOR risk is due to the design of the hash lookup mechanism, not improper use of a JavaScript API.}	N/A
2813	akelius.com.js	Improper Error Handling	Medium	false	CWE-754	N/A	N/A	N/A	{The safeFetch function handles errors by returning a 504 response, which is a design choice, not misuse of a sensitive function. The improper error handling is a result of the application’s error strategy, not a function misuse.}	N/A
2814	akelius.com.js	Caching of Malicious Content	High	false	CWE-922	N/A	N/A	N/A	{The fetchAndCacheOnce function caches responses from network fetches, but it does not misuse a sensitive function. The risk arises from trusting network responses without additional validation, not from improper use of a JavaScript API.}	N/A
2815	akelius.com.js	Insecure URL Handling	Medium	true	CWE-601	N/A	parseUrl	standard	{The parseUrl function uses the standard URL constructor with user-controlled input (url) without validating the URL scheme or origin. This allows attackers to pass malicious URLs (e.g., file:// or javascript:) that could lead to unintended behavior or security bypasses, especially when the parsed components are used in subsequent operations like normalizeUrl or cache lookups.}	N/A
2816	iforgeiron.com.js	Cross-Site Request Forgery (CSRF) due to incorrect login status determination	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from the use of `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to determine login status. This function is not inherently sensitive, but its misuse—relying on URL parameters for security decisions without proper validation—leads to CSRF. An attacker could craft a malicious URL with `loggedIn=false` to bypass authentication checks, allowing unauthorized actions. The `match` function is standard, but its context of use introduces risk.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
2817	iforgeiron.com.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	8	N/A	standard	{The `navigate` method is used with `data.url`, which is derived from untrusted push notification data. Since `data.url` is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to navigate to an arbitrary site. This is a classic open redirect vulnerability caused by the unsafe use of the standard `navigate` function with untrusted input.}	```clients[0].navigate(data.url);```
2818	courtside1891.basketball.js	Code Injection via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from the RESOURCES_PATH variable, which is sourced from the query parameter 'resourcesPath' via URLSearchParams. This allows an attacker to control the script URL being imported, leading to arbitrary script execution within the service worker context.}	N/A
2819	```importScripts(`/resources/${RESOURCES_PATH}/scripts/workbox-sw.js`);```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```importScripts(`/resources/${RESOURCES_PATH}/scripts/workbox-sw.js`);```
2820	courtside1891.basketball.js	Insecure Cache Name Construction	Medium	false	CWE-54	N/A	N/A	N/A	{The cache names are constructed using a hardcoded version number, but there is no direct use of a sensitive function that introduces dynamic or untrusted input into the cache name. The construction is static and safe.}	N/A
2821	courtside1891.basketball.js	Insecure Regex Construction	Medium	false	CWE-54	N/A	N/A	N/A	{The regex is constructed by concatenating a static string with RESOURCES_PATH, which is derived from a query parameter. However, the regex construction itself does not involve a sensitive function like RegExp() being misused with untrusted input in a way that leads to code execution or injection. The primary risk is logic error or denial of service via malformed input, not direct function misuse.}	N/A
2822	sardegnaoggi.it.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.push_send_id and sensor_url), allowing an attacker to manipulate the URL to make requests to internal or external systems, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.sardegnaoggi.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
2823	sardegnaoggi.it.js	Open Redirect	Medium	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted input (event.notification.data.url), enabling an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
2824	gomantaktimes.com.js	Insecure External Resource Loading	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to load a script from a third-party CDN (https://cdn.izooto.com). While the URL is hardcoded, the use of external scripts from untrusted or non-verified sources introduces a high-risk vulnerability. If the CDN is compromised or the script is tampered with, the service worker can be hijacked, leading to malicious behavior such as data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is static, the function itself is sensitive due to its ability to execute arbitrary code from remote sources.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/4ce280bd4e33fd4ffbe003c579e9c7f8774b3b01.js"");```"
2825	dramacool.tube.js	Service Worker Cache Not Populated Leading to Potential DoS	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises because the service worker does not populate the cache with any assets during installation. The `caches.open()` call is made, but no resources are actually cached, leaving the service worker unable to serve content offline. This is not due to misuse of a sensitive function, but rather a logic or design flaw in the caching strategy.}	```const staticCacheName = 'dra-v1'; const assets = []; self.addEventListener('install', evt => { evt.waitUntil(caches.open(staticCacheName).then(cache => {})); });```
2826	don-shina.ru.js	Improper Input Validation in Cache Management	High	true	CWE-20	N/A	self.addEventListener	standard	{The event listener for 'message' accepts arbitrary data from clients without validation. The 'addToCache' and 'removeFromCache' fields are used directly to modify cache contents, allowing an attacker to inject or remove arbitrary URLs from the cache, potentially leading to cache poisoning or bypassing security controls.}	```self.addEventListener('message', async event => { if ('data' in event && typeof event.data === 'object') { if ('broadcast' in event.data && event.data.broadcast === true && 'eventType' in event.data) { const _clients = await clients.matchAll(); if (_clients) _clients.forEach(client => client.postMessage(event.data)); } else if ('addToCache' in event.data && event.data.addToCache.length) { let type = event.data.cacheType ? event.data.cacheType : 'runtime'; if (!_cached[type]) _cached[type] = []; if (_cached[type].indexOf(event.data.addToCache) === -1) _cached[type].push(event.data.addToCache); } else if ('removeFromCache' in event.data && event.data.removeFromCache.length) { for (let type in CURRENT_CACHES) { if (type === 'prefetch') continue; if (_cached[type]) { let index = _cached[type].indexOf(event.data.removeFromCache); if (index !== -1) _cached[type].splice(event.data.removeFromCache, 1); } caches.open(CURRENT_CACHES[type]).then(cache => { cache.match(event.data.removeFromCache).then(function (response) { if (response) cache.delete(event.data.removeFromCache).then(() => { console.log('sw.js: cache[' + type + '] deleted:', event.data.removeFromCache); }); }); }); } } } });```
2827	don-shina.ru.js	Use of 'no-cors' Mode Leading to Cache Poisoning	High	true	CWE-829	N/A	new Request	standard	{The code creates a new Request object with mode: 'no-cors' for URLs starting with 'http://' or 'https://'. This bypasses CORS checks, allowing the service worker to fetch and cache resources from any origin without validation, which can lead to cache poisoning if an attacker tricks the service worker into caching malicious content from a third-party domain.}	```let request = new Request(event.request.url, { mode: 'no-cors' });```
2828	don-shina.ru.js	Insecure Dynamic Cache Inclusion Leading to XSS	Medium	true	CWE-79	N/A	_caches.open	standard	{The code dynamically adds URLs to caches based on the _cached configuration, which is populated via message events. If an attacker can inject a malicious URL into _cached, and if that URL is later fetched and cached, it could result in XSS when the cached resource is served to the user, especially if the resource is a script or HTML fragment.}	```if (_cached) { let url = new URL(request.url); if (url) for (let type in _cached) if (_cached.hasOwnProperty(type) && _cached[type]) { if (type !== 'short_auto' && (_cached[type].includes(url.pathname) || _cached[type].includes(url.href)) || type === 'short_auto' && ['style', 'script', 'image'].includes(request.destination) && _cached[type].some(path => { return url.pathname.indexOf(path) === 0; })) { return caches.open(CURRENT_CACHES[type]).then(function (cache) { if (DEBUG) console.log('sw.js: Аdd to dinamic cache[' + type + ']:', request.url); cache.put(request.url, response.clone()); return response; }); } } }```
2829	futbolete.com.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static credential exposed in the source code, not a result of sensitive function misuse.}	```self[`appKey`] = `6ce77572de7ea7fb34c895af725e2000`;```
2830	futbolete.com.js	Remote Code Execution via External Script	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it still represents a risk if the host is not fully trusted or if the script can be tampered with. However, in this case, the host is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically sourced (e.g., from URL parameters). Still, since importScripts() executes arbitrary code from the specified URL, and the URL is not validated or sanitized, it qualifies as sensitive function misuse.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2831	ahlmasrnews.com.js	Exposure of Sensitive Information in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding Firebase configuration credentials (including API key) in client-side JavaScript, which can be accessed by attackers via browser inspection. This is not caused by misuse of a sensitive function, but rather by insecure exposure of secrets.}	"```var Config = { apiKey: ""AIzaSyASutkhVjt_6v-bHKU-EA_dPrzCdeR3WOU"", authDomain: ""wavepush-1d87c.firebaseapp.com"", databaseURL: ""https://wavepush-1d87c.firebaseio.com"", projectId: ""wavepush-1d87c"", storageBucket: ""wavepush-1d87c.appspot.com"", messagingSenderId: ""802473437435"", appId: ""1:802473437435:web:6ac41b73b1232fc5b7a85e"", measurementId: ""G-56ZE88G9YM"" };```"
2832	ahlmasrnews.com.js	Open Redirect via Unvalidated User Input	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow() is called with the unvalidated user-controlled input 'action_click' from the notification data. Since this value is derived from the payload sent by the server (which could be manipulated by an attacker), it allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(action_click));```
2833	exqlorer.com.js	Improper Validation of URLs in Precaching Mechanism	High	true	N/A	N/A	URL	standard	{The URL constructor is used to parse and normalize URLs from untrusted sources (e.g., from the precache list entries). If these URLs are not properly validated or sanitized, they can lead to unintended behavior such as cache poisoning or redirection to malicious domains. The function is used in `l(s)` where `s` is a dynamic entry from the precache list, and the URL is constructed without sufficient validation.}	"```const { revision: t, url: s } = e; if (!s) throw new n(""add-to-cache-list-unexpected-type"", { entry: e }); if (!t) { const e = new URL(s, location.href); return { cacheKey: e.href, url: e.href }; } const a = new URL(s, location.href), r = new URL(s, location.href); return a.searchParams.set(h, t), { cacheKey: a.href, url: r.href };```"
2834	exqlorer.com.js	Cross-Origin Response Cloning Vulnerability	High	true	N/A	N/A	Response	standard	{The Response constructor is used to clone responses, but it only allows cloning if the response is same-origin. The code explicitly checks for cross-origin responses and throws an error, but if this check is bypassed or misconfigured, it could allow an attacker to clone and manipulate cross-origin responses, leading to data leakage or cache poisoning. The function is used in `g(e, t)` where `e` is a dynamic response object.}	```const a = e.clone(), r = { headers: new Headers(a.headers), status: a.status, statusText: a.statusText }, i = t ? t(r) : r, c = p() ? a.body : await a.blob(); return new Response(c, i);```
2835	exqlorer.com.js	Insecure Cache Key Generation for URLs	Medium	true	N/A	N/A	URL	standard	{The URL constructor is used to generate cache keys from dynamic URLs, which may be derived from untrusted sources. If the URL is not properly sanitized or validated, it can lead to cache key collisions or cache poisoning. The function is used in `l(s)` where `s` is a dynamic entry from the precache list, and the URL is constructed without sufficient validation.}	"```const { revision: t, url: s } = e; if (!s) throw new n(""add-to-cache-list-unexpected-type"", { entry: e }); if (!t) { const e = new URL(s, location.href); return { cacheKey: e.href, url: e.href }; } const a = new URL(s, location.href), r = new URL(s, location.href); return a.searchParams.set(h, t), { cacheKey: a.href, url: r.href };```"
2836	exqlorer.com.js	Missing Integrity Check for Cached Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logic flaw where integrity checks are not enforced for all precache entries, particularly when `s.integrity` is undefined. This is not due to misuse of a sensitive function, but rather a missing validation step in the precaching logic.}	```if ('string' !== typeof s && s.integrity) { if (this._cacheKeysToIntegrities.has(e) && this._cacheKeysToIntegrities.get(e) !== s.integrity) throw new n('add-to-cache-list-conflicting-integrities', { url: a }); this._cacheKeysToIntegrities.set(e, s.integrity); }```
2837	truckid.com.js	Cross-Site Scripting (XSS) via Cache Poisoning	High	true	CWE-113	N/A	N/A	standard	{The code uses `new URL(s, location.href)` where `s` is derived from a user-supplied `url` field in the `e` object, which may be controlled by an attacker. If the `url` contains malicious content (e.g., a script tag or a redirect to a malicious site), and if this URL is used to populate a cache entry (via `cachePut` or similar), it can lead to cache poisoning. When a user later requests a resource that matches this poisoned cache entry, the malicious content may be served, resulting in XSS. The `URL` constructor is a standard JavaScript function, and its misuse here with untrusted input is the root cause.}	```const { revision: t, url: s } = e; ... const a = new URL(s, location.href);```
2838	mundogeo.com.js	Debug mode enabled in production	Medium	false	CWE-200	N/A	N/A	N/A	{Debug mode in Workbox is not caused by misuse of a sensitive function; it is a configuration setting that exposes internal details, but does not involve dynamic or untrusted input being passed to a function that could lead to code execution or injection.}	```workbox.setConfig({ debug: true });```
2839	guidetocanaryislands.com.js	Improper Validation of URL in Push Event Leading to SSRF	High	true	CWE-918	N/A	fetch	standard	{The fetch function is used with a URL derived directly from event.data.text(), which is untrusted input from a push notification. Since no validation or sanitization is applied to this URL, an attacker can craft a push notification with a malicious URL (e.g., internal network endpoints) to trigger SSRF, allowing unauthorized access to internal systems.}	```event.waitUntil(fetch(event.data.text()).then(function (response) {```
2840	guidetocanaryislands.com.js	Incorrect Regex in Fetch Event Leading to Security Misconfiguration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from a flawed regex pattern in the fetch event handler, not from misuse of a sensitive function. The regex incorrectly uses a pipe symbol without escaping and includes invalid syntax, leading to unintended URL matching and bypassing of intended security rules. This is a logic or configuration error, not a sensitive function misuse.}	```if (request.url.match('^.*(\/user\/|\/amp\/\|\/ajax\/\|\.mp4|\.webm|\.jpg|\.png|\.gif|\.js|\.css|\.pdf|\.zip|\.xls|\.doc|\.docx|\.xlsx|\.ttf|\.woff|\.svg|\.eot|\.webp|ads\.txt|\.php).*$')) {```
2841	sneezefetishforum.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a URL constructed from the `id` parameter received via push notification data. Since `id` is user-controlled and directly interpolated into the URL without validation or sanitization, an attacker can manipulate it to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2842	sneezefetishforum.com.js	Improper Input Validation	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from improper validation of the `loggedIn` parameter extracted via regex from the current URL. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in handling URL parameters. No sensitive function like eval, importScripts, or fetch is misused here.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
2843	sneezefetishforum.com.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with the `data.url` value, which is derived from server-provided notification data. Since this value is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the service worker to redirect the user to an arbitrary site, leading to an open redirect.}	```clients[0].navigate(data.url);```
2844	caramel.la.js	Insecure Caching of External Resources	High	true	N/A	N/A	URL	standard	{The URL constructor is used to parse and normalize external resource URLs (e.g., from user-controlled or untrusted sources) without validating their origin or scheme. This allows attackers to craft malicious URLs that could lead to unintended caching of harmful content or bypass security policies.}	```const e = new URL(a, location.href); return { cacheKey: e.href, url: e.href };```
2845	caramel.la.js	Insecure Cache Key Generation	Medium	true	N/A	N/A	URL	standard	{The URL constructor is used to generate cache keys from potentially untrusted input (e.g., user-supplied URLs). If the input is not sanitized or validated, attackers can manipulate the cache key to cause cache poisoning or bypass cache validation mechanisms.}	```const { cacheKey: e, url: r } = G(a),```
2846	caramel.la.js	Potential Cache Poisoning via Unvalidated Responses	High	true	N/A	N/A	Response	standard	{The Response object is used without proper validation of its status or content, allowing potentially malicious responses to be cached. This can lead to cache poisoning if the response is not checked for validity before being stored.}	```if (!(o ? await o.cacheWillUpdate({ event: r, request: i, response: f }) : f.status < 400)) throw new t('bad-precaching-response', { url: s, status: f.status });```
2847	caramel.la.js	Insecure HTTP Request Handling	Medium	true	N/A	N/A	Request	standard	{The Request constructor is used with URLs derived from untrusted sources without validating the protocol. This allows requests to be made over non-HTTP/HTTPS schemes, potentially leading to unintended network behavior or security bypasses.}	```if (!s.protocol.startsWith('http')) return;```
2848	caramel.la.js	Insecure Cache Expiration Logic	Medium	true	N/A	N/A	Date.now	standard	{The Date.now() function is used to calculate expiration times without proper validation or bounds checking. This can lead to incorrect cache expiration behavior if the timestamp is manipulated or if the system clock is tampered with.}	```const e = Date.now() - 1e3 * this.U, t = await this.L.expireEntries(e, this.j),```
2849	bn.org.uk.js	Improper Authentication Check (Reliance on Untrusted Parameter	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from trusting the `loggedIn` parameter extracted from the service worker's current URL, which is controlled by the client. This parameter is not validated or verified against a secure session or authentication state, allowing an attacker to manipulate the URL to bypass logic that should restrict access. No sensitive function is misused here; it's a logic flaw in authentication handling.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2850	bn.org.uk.js	Open Redirect in Notification Click Handler	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a URL derived from `data.url`, which comes from a push notification payload. Since this data is not validated or sanitized, an attacker can craft a malicious notification with a redirect URL, leading users to phishing or malicious sites. The `navigate` function is a standard browser API that executes navigation based on untrusted input, making it a sensitive function in this context.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
2851	bn.org.uk.js	Improper Input Validation in CSRF Token Request	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a URL constructed by concatenating `BASE_URL` and a `path` variable derived from the current request's URL. If the `path` is not properly sanitized, it could lead to injection of malicious parameters or paths, potentially allowing an attacker to manipulate the request to a different endpoint or bypass security checks. The `fetch` function is a standard API that executes HTTP requests with untrusted input, making it sensitive when used with unsanitized data.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2852	clicktunity.com.js	Information Exposure Through Debug Logging	High	true	CWE-200	10	console.log	standard	{The vulnerability arises from the use of console.log within the log function, which is conditionally enabled by pwaSettings.debug = true. Since debug logging is enabled, sensitive information may be exposed in the browser's console, especially during development or if debug mode is not properly disabled in production. This misuse of console.log, a standard JavaScript function, allows unintended disclosure of internal state or data.}	```pwaSettings.debug = true;```
2853	alemfm.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data (including API key, project ID, and messaging sender ID) directly in the client-side JavaScript file. This exposes credentials to anyone who can view the source code, enabling unauthorized access to Firebase services. However, this is not caused by misuse of a sensitive JavaScript function, but rather by insecure code practices.}	"```var config = { apiKey: ""AIzaSyA-vRmzoDJ26fzoJ2DC0FspzVeEi0V-dqA"", authDomain: ""alemfm-push.firebaseapp.com"", projectId: ""alemfm-push"", storageBucket: ""alemfm-push.appspot.com"", messagingSenderId: ""836239849789"", appId: ""1:836239849789:web:1c375e9c12277ba92fed54"", measurementId: ""G-EHVPFRM4TF"" };```"
2854	alemfm.com.js	Insecure Input Validation for Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL derived from untrusted notification data (event.notification.data.FCM_MSG.data.payload). Since this input is not sanitized or validated, an attacker could craft a malicious payload to redirect users to phishing sites, execute arbitrary JavaScript via URL-based attacks (e.g., via data: URLs or JavaScript: URLs), or perform other malicious actions. This constitutes a sensitive function misuse because clients.openWindow directly executes a URL based on untrusted input.}	```return clients.openWindow(event.notification.data.FCM_MSG.data.payload);```
2855	motgame.vn.js	Loading untrusted external script without integrity checks	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (e.g., 'https://client.trackpush.com/service-worker.js') without integrity checks or validation, it introduces a high-risk vulnerability. An attacker who compromises the external server or intercepts the request can inject malicious code into the service worker, leading to full control over the worker’s execution, including cache manipulation, network interception, and potential data exfiltration.}	```importScripts('https://client.trackpush.com/service-worker.js');```
2856	hunkemoller.es.js	Cache Poisoning via Untrusted 'cache' Parameter	High	true	CWE-20	10	N/A	standard	{The 'cache' parameter is extracted from the URL's search parameters using new URL(location).searchParams.get('cache'), which is dynamic and untrusted. This value is then used directly in caches.open(cacheParam), allowing an attacker to control which cache is accessed or created, leading to cache poisoning where malicious or unintended content can be stored or retrieved.}	```var cacheParam = new URL(location).searchParams.get('cache');```
2857	hunkemoller.es.js	Insecure Caching of Network Responses	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a flawed caching logic that caches responses based on URL patterns without validating the source or integrity of the response. However, no sensitive JavaScript function is misused here; the issue is in the logic design rather than function misuse.}	```if (networkResponse.type === 'basic' && event.request.url.match(/.png|.img|.webp|.gif|.svg|.js|.woff2|.css|.ico/)) { cache.put(event.request, networkResponse.clone()); }```
2858	sunbasedata.com.js	Debug Mode Enabled - Information Disclosure	High	false	N/A	N/A	N/A	N/A	{Debug mode is enabled via a configuration setting (`pwaSettings.debug = true`), which causes sensitive logs to be output to the console. This is not caused by misuse of a sensitive JavaScript function, but rather by a configuration choice that exposes internal information.}	```const pwaSettings = { debug: true };```
2859	sunbasedata.com.js	Insecure Message Handling - Cache Deletion	High	true	N/A	N/A	self.addEventListener	standard	{The `self.addEventListener('message', ...)` function is used to handle messages from the page, but it lacks proper validation of the incoming message data. Specifically, it directly processes `event.data.command` without sanitization or authentication, allowing an attacker to send a malicious message to delete the `SITE_PAGES_CACHE_NAME` cache. This misuse of the standard `addEventListener` function in a service worker context enables unauthorized cache manipulation.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
2860	mosbate1.ir.js	Insecure External Script Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (van.najva.com). This allows an attacker who controls the external script to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or interception of network requests. Although the URL is hardcoded, the act of loading external code from an untrusted source constitutes a sensitive function misuse.}	```importScripts('https://van.najva.com/static/js/scripts/mosbate1-website-15699-57af7201-c629-457f-9a6f-3672f5d34799-service-worker.js');```
2861	falconbricks.com.js	Insecure Direct Object Reference in Push Notification URL Handling	High	true	CWE-601	N/A	self.addEventListener('push'	standard	{The push event handler parses incoming notification data using e.data.json() and directly uses the 'url' field from the parsed JSON to construct the notification's data.url. This value is then used in clients.openWindow() without validation or sanitization, allowing an attacker to craft a push message with a malicious URL (e.g., phishing, redirect, or external site) that will be opened in the user's browser. Since the URL is derived from untrusted input, this constitutes a direct object reference vulnerability.}	"```self.addEventListener(""push"", e => { let t = e.data.json(); const n = self.registration.showNotification(t.title, { body: t.body, icon: ""https://cdn.falconbricks.com/images/app/icon-192.png"", badge: ""https://cdn.falconbricks.com/images/app/badge-icon-72.png"", image: t.image, actions: [{ action: ""view"", type: ""button"", title: ""View post"" }, { action: ""comment"", type: ""button"", title: ""Comment"" }], requireInteraction: !0, data: { url: t.url } }); e.waitUntil(n); });```"
2862	falconbricks.com.js	Insecure Direct Object Reference in Notification Click Handler	High	true	CWE-601	N/A	self.addEventListener('notificationclick'	standard	{The notificationclick event handler retrieves the 'url' field from the notification's data object (which originates from the push event) and uses it directly in clients.openWindow() without any validation or sanitization. This allows an attacker to control the URL opened in the user's browser via a malicious push notification, leading to phishing, redirects, or unintended navigation to external sites. The vulnerability arises from the misuse of clients.openWindow() with untrusted input.}	"```self.addEventListener(""notificationclick"", e => { if (e.notification.close(), ""comment"" === e.action) { const t = clients.openWindow(e.notification.data.url + ""?utm_source=push#comments""); e.waitUntil(t); } else { const t = clients.openWindow(e.notification.data.url + ""?utm_source=push""); e.waitUntil(t); } });```"
2863	promotons.com.js	Insecure Dynamic Code Loading	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed using the 'id' variable, which is derived from the hostname of the current page. Although the 'id' is mapped from a hardcoded set of hostnames, if an attacker can manipulate the hostname (e.g., via DNS spoofing, subdomain takeover, or misconfigured CNAMEs), they could potentially inject a malicious ID and cause the service worker to load a malicious script from the pushpushgo domain. This constitutes a dynamic code loading vulnerability, as the script source is not fully static and depends on runtime input.}	```importScripts('https://s-eu-1.pushpushgo.com/' + id + '/worker.js');```
2864	lita.gg.js	Insecure Message Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from handling messages without validating or sanitizing the incoming data, but it does not stem from misuse of a sensitive function like importScripts or eval. The code simply checks for a specific message type and calls self.skipWaiting(), which is a safe operation. There is no dynamic code execution or unsafe function invocation involved.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
2865	hoteles-costablanca.com.js	Use of Untrusted Resource (CDN	High	true	N/A	N/A	importScripts	standard	{The importScripts function is used with a dynamic URL derived from options.workboxURL, which is hardcoded to a CDN. While the URL is not user-controlled, it introduces risk if the CDN is compromised or if the script is loaded from an untrusted source. However, since the URL is fixed and not derived from untrusted input, the risk is mitigated but still present due to external dependency.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
2866	hoteles-costablanca.com.js	Dynamic Code Evaluation via getProp	High	true	New	N/A	N/A	standard	{The new operator is used with a dynamic constructor obtained via getProp(workbox, p.use), which resolves to a function name from a configuration object. If an attacker can control the p.use value, they can trigger arbitrary code execution by injecting a malicious function name. This is a classic dynamic code evaluation vulnerability.}	```new (getProp(workbox, p.use))(...p.config)```
2867	hoteles-costablanca.com.js	CORS Request Modification in Service Worker	Medium	false	N/A	N/A	N/A	N/A	{The code modifies request headers to change cache and mode settings, but this is not caused by misuse of a sensitive function. The Request constructor is used correctly and does not involve untrusted input. The vulnerability arises from the behavior itself, not from a sensitive function misuse.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
2868	jaenhoy.es.js	Code Injection	High	true	N/A	9	importScripts	standard	"{The code uses `importScripts(s)` where `s` is dynamically derived from a URL constructed via `new URL(s + "".js"", i).href`. Since `s` is passed as a parameter to the `s` function and can be controlled by the module loader, this allows an attacker to inject arbitrary script URLs. If an attacker can control the input to `define`, they can force the service worker to load and execute malicious scripts via `importScripts`, leading to code injection.}"	```if (!self.define) { let e, n = {}; const s = (s, i) => (s = new URL(s + \'.js\', i).href, n[s] || new Promise(n => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = s, e.onload = n, document.head.appendChild(e); } else e = s, importScripts(s), n(); }).then(() => { let e = n[s]; if (!e) throw new Error(`Module ${s} didn’t register its module`); return e; })); self.define = (i, t) => { const o = e || (\'document\' in self ? document.currentScript.src : \'\') || location.href; if (n[o]) return; let r = {}; const c = e => s(e, o), l = { module: { uri: o }, exports: r, require: c }; n[o] = Promise.all(i.map(e => l[e] || c(e))).then(e => (t(...e), r)); }; }```
2869	jaenhoy.es.js	Cache Poisoning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of `precacheAndRoute` and `registerRoute` with hardcoded URLs and patterns, but there is no evidence of dynamic or untrusted input being used to construct cache keys or route patterns. Therefore, this is not caused by misuse of a sensitive function.}	```e.precacheAndRoute([{ url: \'app.h-5fa903f15ea702e6f545.css\', revision: null }, { url: \'app.h-7cd7d3825466592f0f13.js\', revision: null }], {}), e.registerRoute(/\\.(?:png|jpg|jpeg|svg)$/, new e.CacheFirst({ cacheName: \'images-cache\', plugins: [new e.ExpirationPlugin({ maxEntries: 200, maxAgeSeconds: 2592e3 })] }), \'GET\');```
2870	nic.weather.js	Improper Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from setting an excessively long cache expiration time (one year) without considering security or data freshness requirements. This is a configuration issue, not a misuse of a sensitive function.}	```const n = new n.ExpirationPlugin({ maxAgeSeconds: 31536e3```
2871	nic.weather.js	Insecure Cache Key Generation	High	true	N/A	N/A	`new Request`	standard	{The code generates cache keys using `new Request` with URLs derived from untrusted sources (e.g., via `getCacheKeyForURL`). If the URL is manipulated by an attacker, it can lead to cache poisoning or bypassing cache validation, allowing malicious content to be served.}	```const { cacheKey: e, url: a } = i(s), return { cacheKey: e, url: a };```
2872	nic.weather.js	Regex Pattern Overmatching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from overly broad regular expressions (e.g., `nic\\.weather(?:/.*)?/ola/services/.*`) that may match unintended URLs, leading to incorrect routing or caching decisions. This is a logic flaw, not a sensitive function misuse.}	"```const c = JSON.parse('[""nic\\\\.weather(?:/.*)?/ola/services/.*"",""nic\\\\.weather/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://78beb6ae-ef11-4ebb-b1b4-2d4d976e0418\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
2873	nic.weather.js	Cacheable Response Without Validation	Medium	false	N/A	N/A	N/A	N/A	{The code uses `CacheableResponsePlugin` with only status 200 allowed, but does not validate response headers or content integrity. This is a configuration issue, not a sensitive function misuse.}	```new a.CacheableResponsePlugin({ statuses: [200] })```
2874	nic.weather.js	Insecure Cache Deletion Logic	High	true	N/A	N/A	`caches.delete`	standard	"{The code uses `caches.delete` with a filter based on `startsWith(""nic.weather-"")`, which is vulnerable to cache poisoning if an attacker can inject a cache name starting with ""nic.weather-"". This allows unauthorized deletion of caches, potentially disrupting service or enabling privilege escalation.}"	```e.waitUntil(caches.keys().then(function (e) { return Promise.all(e.filter(e => e.startsWith('nic.weather-')).map(e => caches.delete(e))) }))```
2875	veloce.it.js	External Script Import in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded, external URL (as in this case), it introduces a high-risk vulnerability because the script is fetched and executed from an untrusted third-party domain. This can lead to code injection, data exfiltration, or full compromise of the service worker’s behavior if the external script is malicious or compromised.}	```importScripts('https://pushdeploy.estrema.it/shared/sw/serviceworker-VE230901.js');```
2876	redbulletin.com.js	Improper URL Validation Leading to SSRF	High	true	CWE-918	10	N/A	standard	{The code uses `fetch()` with a dynamically constructed URL derived from `t.url.replace(k, 'img.redbull.cn')`, where `k` is a regex matching `img.redbull.com`. Since `t.url` comes from the incoming fetch event request (user-controlled), an attacker can craft a request with a URL that, after replacement, points to an internal or external resource (e.g., `http://internal-api.redbull.com`). This allows the service worker to make unauthorized outbound requests on behalf of the user, leading to SSRF. The `fetch()` function is a standard JavaScript API and is misused here due to lack of proper validation of the constructed URL.}	```const s = new Request(t.url.replace(k, 'img.redbull.cn'), t); e.respondWith(fetch(s));```
2877	grupowish.com.js	Cache Poisoning via Overly Permissive Regex	High	true	CWE-918	9	RegExp	standard	{The regular expression /.*?jquery.*?(?:\.min)?\.js.*?/ is overly permissive and matches any URL containing 'jquery' or 'jquery.min.js' regardless of context. This allows an attacker to craft a malicious URL that matches the pattern and be cached under the RUNTIME_CACHE_NAME, potentially leading to cache poisoning where a malicious script is served instead of the legitimate one. The sensitive function RegExp is used to define the route pattern, and its misuse stems from insufficient specificity in the pattern.}	```workbox.routing.registerRoute(/.*?jquery.*?(?:\.min)?\.js.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
2878	grupowish.com.js	Information Exposure via Debug Logs	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from the debug flag being enabled (pwaSettings.debug = true), which causes sensitive logs to be output via console.log. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a configuration setting. No function is being misused in an unsafe way with untrusted input.}	```pwaSettings.debug = true;```
2879	grupowish.com.js	Use of Untrusted External CDN	Medium	true	CWE-444	8	importScripts	standard	{The importScripts function is used with a dynamically constructed URL derived from the staticFileCdn variable, which points to an external CDN. While the URL is hardcoded, the use of importScripts with any external source introduces risk because it loads and executes arbitrary JavaScript from a third-party domain. If the CDN is compromised or misconfigured, it could serve malicious code. The sensitive function importScripts is standard and its misuse here is due to trusting an external source without verification.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
2880	bodonu.no.js	Incorrect Host Validation Leading to Cache Poisoning	High	true	N/A	N/A	RegExp.prototype.test	standard	{The code uses a regular expression with a literal string containing unescaped quotes (e.g., 'www.bodonu.no') in the pattern4 function. This is not a direct misuse of a sensitive function like importScripts or eval, but the improper use of RegExp.prototype.test with a string that may be dynamically constructed or misinterpreted could allow an attacker to inject or manipulate the host validation logic, leading to cache poisoning if the pattern is used to match URLs that are then cached or served. The vulnerability arises from the unsafe construction of the regex pattern, which could be exploited if the host string were derived from untrusted input.}	"```if (req.url.host.indexOf(""'www.bodonu.no'"") !== -1) {```"
2881	bodonu.no.js	Insecure Message Handling in Cache Update	Medium	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener('message', ...) handler processes incoming messages without validating or sanitizing the message data. While not directly a sensitive function like importScripts, the use of self.addEventListener with untrusted message payloads can lead to insecure behavior if the message data is used to trigger actions such as cache updates or network requests. The vulnerability arises because the message handler processes data from potentially untrusted sources without proper input validation, which could be exploited to manipulate cache contents or trigger unintended behavior.}	"```self.addEventListener(""message"", event => { if (!event.data.type) { return; } const message3 = event.data.message || null; switch (event.data.type) { case message2: handler2(event, message3); break; case message: handler(event, message3); break; default: break; } });```"
2882	bodonu.no.js	Improper Error Handling in Fetch Strategy	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from improper error handling in the responseHandler function, where errors during fetch are not properly caught or logged. This is not caused by misuse of a sensitive function, but rather by a lack of robust error handling in the async fetch operation. The code does not use any sensitive functions like eval or importScripts, and the issue is more related to application logic and error management than direct function misuse.}	```async function responseHandler(request) { if (abTestEnabled === true) { request = getABTestUrl(request); } const response = await fetch(request); self.emergencyMode = (response.headers.get('x-emergency-mode') || '').split(','); return response; }```
2883	koncertomania.pl.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static secret, not a result of sensitive function misuse.}	```self[`appKey`] = `343a6b371425efb62b8bd7ca05c9435f`;```
2884	koncertomania.pl.js	Remote Code Execution via Untrusted Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it may still be considered a risk if the host is not fully trusted or if the script can be tampered with. However, in this case, the host is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically sourced from user input. Still, since importScripts() executes arbitrary code from a remote source, and the source is not verified or signed, it qualifies as sensitive function misuse with high confidence.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2885	blauarbeit.de.js	Server Side Request Forgery (SSRF)	High	true	N/A	9	adapter.parseUrl	standard	{The adapter.parseUrl function is used to parse URLs from incoming requests. When the request URL starts with 'http:' and the service worker's scope URL starts with 'https:', the code logs a warning but does not block the request. This allows an attacker to potentially trigger requests to internal or external HTTP resources from a secure HTTPS context, leading to SSRF. The function is standard (part of the URL API) and is misused by not enforcing strict origin validation.}	```if (requestUrlObj.origin.startsWith('http:') && scopeUrl.startsWith('https:')) {```
2886	blauarbeit.de.js	Insecure Cache Bypass	Medium	true	N/A	9	adapter.parseUrl	standard	{The adapter.parseUrl function is used to parse the request URL, and the code checks for 'ngsw-bypass' in headers or query parameters. If found, it bypasses the service worker's normal handling logic. This allows an attacker to craft a request with 'ngsw-bypass' in the query string or headers to circumvent caching and security policies, potentially leading to unauthorized access or bypassing rate limiting. The function is standard (part of the URL API) and is misused by not validating or sanitizing the bypass parameter.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) {```
2887	welikesewing.com.js	Insecure Third-Party Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party domain (e.g., api.pushnami.com), it introduces a high-risk vulnerability because the script is executed with the same privileges as the service worker. If the third-party script is compromised or malicious, it can intercept network requests, manipulate cache, or perform other harmful actions. Although the URL is hardcoded, the vulnerability arises from trusting an external script source without verification or integrity checks, which is a misuse of the sensitive function.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/621d2c4f05fe5f00138f4394"");```"
2888	alloder.pro.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the misuse of the `fetch` function, which is a standard JavaScript API. The code dynamically constructs a URL using `path` extracted from the current request's URL, which is user-controlled. This allows an attacker to manipulate the `path` parameter to trigger requests to arbitrary internal or external endpoints, leading to SSRF. The `fetch` call is made without validating or sanitizing the `path` input, enabling unauthorized access to internal systems or services.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
2889	ipcc.ca.js	Cache Deletion via Unvalidated Message	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the service worker responding to a message event with a command to delete a specific cache (SITE_PAGES_CACHE_NAME). However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by a design flaw where the service worker accepts and acts on commands from the page without proper validation or authentication. The function caches.delete() is used correctly and safely in this context, as it operates on a hard-coded cache name. There is no dynamic or untrusted input influencing the cache name or the operation.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
2890	mitsde.com.js	External Script Inclusion	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('//cdnt.netcoresmartech.com/swv4.js'), which is not dynamically derived from untrusted input. However, the vulnerability arises because the script is loaded from an external, third-party domain, which may be compromised or controlled by an attacker. This allows an attacker to inject malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or interception of network requests. While the input is not dynamic, the use of an external script source without proper integrity verification (e.g., via Subresource Integrity) constitutes a misuse of the sensitive function, making it a high-risk vulnerability.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
2891	atelierclassico.com.br.js	Improper Input Validation in LGPD Consent Handling	High	true	CWE-20	9	CONSENTS = value.split(',').filter((item, pos, self) => { return self.indexOf(item) == pos; }).map(url => { try { const matches = url.match(/^(?:https?:)?(?:\/\/|\.)?([^\/\?]+)/i); return matches && matches[1]; } catch (ex) { return ''; } }).filter(item => { return item !== ''; });	standard	{The vulnerability arises from improper input validation when processing user-supplied consent URLs. The code uses `match()` with a regular expression to extract hostnames from potentially untrusted input (value from message or sync event). While `match()` itself is not inherently dangerous, the lack of sanitization or validation of the input before processing allows for potential injection or manipulation of the CONSENTS array, which is later used in `isBlockedByLGPD()` to block requests. This could lead to unintended blocking or bypassing of LGPD-compliant domains if maliciously crafted URLs are injected. The function is standard, but its misuse due to insufficient input validation creates a high-risk vulnerability.}	```CONSENTS = value.split(',').filter((item, pos, self) => { return self.indexOf(item) == pos; }).map(url => { try { const matches = url.match(/^(?:https?:)?(?:\/\/|\.)?([^\/\?]+)/i); return matches && matches[1]; } catch (ex) { return ''; } }).filter(item => { return item !== ''; });```
2892	emp-shop.dk.js	Cache Poisoning via Improper URL Handling	High	true	CWE-434	8	split	standard	{The code uses `split(/(\/)+/).pop()` on the request URL to extract a path segment, which can be manipulated by an attacker to inject arbitrary paths into the cache matching logic. Since this path is used to find a precache entry, an attacker could craft a request with a malicious path segment that maps to a different resource, leading to cache poisoning where the wrong resource is served. This misuse of `split` on untrusted input (request URL) allows for path traversal-like behavior in cache key resolution.}	```const t = e.request.url.split(/(\/)+/).pop()```
2893	istoreil.co.il.js	Server Side Request Forgery (SSRF)	High	true	CWE-549	9	N/A	standard	{The function `fetch()` is used with a URL constructed from user-controlled input (via `C(t, o, c, s.pathname, r)`), which is derived from the request URL (`s.href`). Since the URL is not validated or sanitized, an attacker can manipulate the request to trigger `fetch()` on arbitrary internal or external endpoints, leading to SSRF.}	```const o = s.href;```
2894	istoreil.co.il.js	Weak Domain Validation	Medium	false	CWE-205	0	N/A	N/A	{The vulnerability stems from a logic flaw in domain validation (`if (t.indexOf(i) >= 0)`), not from misuse of a sensitive function. The code checks if a hostname contains a whitelisted domain substring, which is insufficient for secure domain validation, but no sensitive function is misused.}	```if (t.indexOf(i) >= 0) {```
2895	istoreil.co.il.js	Improper Input Validation	Medium	false	CWE-20	0	N/A	N/A	{The issue arises from lack of validation on `s.href`, but the assignment itself (`const o = s.href;`) does not involve a sensitive function. The vulnerability is due to insufficient sanitization, not misuse of a function like `fetch` or `importScripts`.}	```const o = s.href;```
2896	istoreil.co.il.js	Insecure URL Construction	Medium	true	CWE-601	8	N/A	standard	{The `C()` function constructs a URL using `config.mLinkBaseUrl`, `config.clientId`, and user-controlled `n` (path) and `c` (query parameters). The `+` operator is used to concatenate these values without validation, and the resulting URL is passed to `fetch()`, allowing an attacker to inject arbitrary paths or query strings, leading to insecure URL construction.}	```return `${config.mLinkBaseUrl}/${config.clientId}/${n}/${c}`;```
2897	kobieceinspiracje.pl.js	Importing external script without integrity check	High	true	CWE-78	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows arbitrary script execution from remote sources. In this case, the script is loaded from 'https://notifpush.com/serviceworker.js', which is an external, untrusted source. If the remote script is compromised or malicious, it can execute arbitrary code within the context of the service worker, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. The lack of integrity verification (e.g., using a hash or subresource integrity) makes this a high-risk vulnerability.}	```importScripts('https://notifpush.com/serviceworker.js');```
2898	sina-pub.ir.js	XSS via untrusted notification data	High	true	CWE-79	9	N/A	standard	{The function `self.registration.showNotification()` is used with data derived from `event.data.json()`, which is untrusted. If an attacker can control the notification payload, they can inject arbitrary content into the notification, potentially leading to XSS if the notification UI renders the content unsafely.}	"```const data = event.data ? event.data.json() : { title: ""Notification from "" + self.registration.scope, link: ""/"" };```"
2899	sina-pub.ir.js	Open redirect via unvalidated notification link	High	true	CWE-601	9	N/A	standard	{The function `self.clients.openWindow(link)` is called with a `link` value derived from untrusted notification data. If an attacker can control this value, they can redirect users to arbitrary external sites, leading to open redirect vulnerabilities.}	```if (self.clients.openWindow) { await self.clients.openWindow(link); }```
2900	sina-pub.ir.js	Insecure cache deletion leading to potential DoS	Medium	false	CWE-399	0	N/A	N/A	{The function `removeAllCache()` deletes all caches, but this is not a sensitive function misuse since it does not involve untrusted input or dynamic execution. It is a legitimate operation, though potentially disruptive.}	```const removeAllCache = async () => { const keys = await caches.keys(); for (const key of keys) { await caches.delete(key); } };```
2901	sina-pub.ir.js	Insecure message broadcasting with untrusted data	Medium	true	CWE-200	8	N/A	standard	{The function `client.postMessage()` is used to send data (`notif`) derived from untrusted notification data to client pages. If the `notif` contains sensitive or malicious data, it can be exposed to client-side JavaScript, leading to information disclosure or further exploitation.}	```client.postMessage({ notif });```
2902	lavoixdelain.fr.js	External Script Inclusion from Untrusted Domain	High	true	New	9	importScripts	standard	{The importScripts() function is used to load and execute a remote script from 'https://notifpush.com/serviceworker.js'. Since the URL is hardcoded and not validated or sanitized, it introduces a risk of loading malicious code from an untrusted third-party domain, leading to potential service worker compromise and full control over the application's offline behavior.}	```importScripts('https://notifpush.com/serviceworker.js');```
2903	lavoixdelain.fr.js	Unvalidated Fetch Request Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The fetch() call is not directly misused with untrusted input; it is used in a controlled context to handle navigation requests. The vulnerability arises from lack of validation on the request itself, not from misuse of a sensitive function.}	```return await fetch(a.request);```
2904	lavoixdelain.fr.js	Cache Busting with Versioned URL	Low	false	CWE-311	N/A	N/A	N/A	{The use of versioned URLs in cache busting is a common practice and does not involve misuse of a sensitive function. The vulnerability is related to information exposure or cache management, not function misuse.}	```BASE + '/wp-content/themes/cmc_commun/assets/css/style.css?v=' + OFFLINE_VERSION + '/']```
2905	peppaquiz.com.js	Improper Cache Invalidation	High	true	CWE-937	9	N/A	standard	{The vulnerability arises from the use of `self.define`, which dynamically loads modules via `importScripts` or `script` elements based on the `location.href` or `document.currentScript.src`. Since these values are derived from the current context and not validated, an attacker could potentially manipulate the script source (e.g., via a malicious URL) to load unintended or malicious modules, leading to improper cache invalidation or unintended behavior. The `importScripts` function is a standard service worker API that executes remote scripts, and its misuse here allows untrusted code execution.}	"```self.define = (e, s) => { const r = n || (""document"" in self ? document.currentScript.src : """") || location.href; if (u[r]) return; let i = {}; const o = n => l(n, r), t = { module: { uri: r }, exports: i, require: o }; u[r] = Promise.all(e.map(n => t[n] || o(n))).then(n => (s(...n), i)); };```"
2906	peppaquiz.com.js	Improper Input Validation	Medium	false	CWE-20	0	N/A	standard	{The event listener for `message` events checks for a specific type (`SKIP_WAITING`) in the received data. While this could be considered a form of input validation, it does not involve a sensitive function misuse. The `self.addEventListener` is used correctly and does not process untrusted input in a way that leads to security issues.}	"```self.addEventListener(""message"", n => { n.data && ""SKIP_WAITING"" === n.data.type && self.skipWaiting(); });```"
2907	ennissteel.com.js	Vulnerable Debug Logging	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from debug logging that exposes internal information via console.log when pwaSettings.debug is true. This is not caused by misuse of a sensitive function, but rather by the exposure of debug data in production environments. The log function itself is a custom wrapper around console.log and does not inherently introduce security risks when used with trusted inputs.}	```log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
2908	tudoinsite.com.br.js	Untrusted External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it imports a script from a third-party CDN (https://cdn.pushcrew.com/sw/81aee56c3d5f6b3703a15a2d1e18a909.js), which is not under the control of the site owner. This introduces a high-risk dependency: if the CDN is compromised or the script is malicious, the service worker can be hijacked, leading to data exfiltration, cache manipulation, or man-in-the-middle attacks on network requests.}	```var version = 2;importScripts('https://cdn.pushcrew.com/sw/81aee56c3d5f6b3703a15a2d1e18a909.js');```
2909	hydro.ac.js	Insecure Domain Handling in Service Worker	High	true	CWE-918	9	N/A	standard	{The function `new URL(r, o.preload)` is used with `o.preload` which is derived from untrusted configuration input. If an attacker can control `o.preload`, they can construct arbitrary URLs, leading to SSRF or unintended resource fetching. The URL construction is dynamic and not validated, making it a sensitive misuse of the standard `URL` constructor.}	```const [r, l] = yield Promise.all([caches.open(p), fetch('/manifest.json').then(r => r.json())]), t = Object.values(s).filter(P).map(r => new URL(r, o.preload).toString());```
2910	hydro.ac.js	Improper Filename Encoding in Download Response	Medium	false	N/A	N/A	N/A	N/A	{The issue stems from improper encoding logic in `encodeURIComponent(l).replace(/['()]/g, escape).replace(/\*/g, '%2A')`, but no sensitive function is misused here. The vulnerability is due to flawed encoding rather than misuse of a sensitive API.}	```l = encodeURIComponent(l).replace(/['()]/g, escape).replace(/\*/g, '%2A'), a.set('Content-Disposition', `attachment; filename*=UTF-8''${l}`)```
2911	hydro.ac.js	Insecure Configuration Handling	High	true	CWE-20	9	N/A	standard	{The `Array.from(new Set([location.host, ...(o.domains || [])]))` operation uses `location.host` directly, which is derived from the current context. If the service worker is deployed in a context where `location.host` can be manipulated (e.g., via redirect or malicious origin), this can lead to unintended domain inclusion. The `Array.from` and `Set` are standard, but the misuse lies in trusting `location.host` without validation, which is a sensitive use of standard JavaScript APIs.}	```o.domains = Array.from(new Set([location.host, ...(o.domains || [])]))```
2912	hydro.ac.js	SSRF via Precache Logic	High	true	CWE-918	9	N/A	standard	{The `caches.addAll(t)` function is used with `t` derived from `new URL(r, o.preload).toString()`, where `o.preload` is untrusted configuration. This allows an attacker to inject arbitrary URLs into the precache, leading to SSRF if the service worker fetches from internal or restricted endpoints. The `caches.addAll` is a standard API, but its misuse with untrusted input makes it sensitive.}	```yield n.addAll(t);```
2913	hydro.ac.js	Improper Handling of Request Headers in Cache Logic	Medium	false	N/A	N/A	N/A	N/A	{The issue is in copying headers from `i` to `a` without validation, but no sensitive function is misused. The `has()` and `get()` methods are standard, and the vulnerability arises from logic flaws, not misuse of sensitive APIs.}	```i.has('Content-Length') && a.set('Content-Length', i.get('Content-Length'))```
2914	mycredit.ua.js	Hardcoded API Key in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	"```self[`appKey`] = ""2e68aafd7488d5d209f8a8bb6f34b3cc"";```"
2915	mycredit.ua.js	Loading External Script Without Integrity Check	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL is constructed from a hardcoded value (self[`hostUrl`]), it introduces risk if the host is compromised or if the script is not integrity-verified. Although the URL is not dynamically derived from untrusted input, the lack of integrity checks (e.g., Subresource Integrity) makes it vulnerable to supply chain attacks. However, since the URL is hardcoded and not derived from user input, the misuse is not directly from dynamic input, but the function itself is sensitive due to its ability to execute arbitrary code.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
2916	wunderkiddy.com.js	Improper Access Control in Message Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of proper validation or authentication of incoming messages, but it is not caused by misuse of a sensitive JavaScript function. The code simply checks for a specific message type and skips waiting, which is a legitimate use of the self.addEventListener API. No sensitive function is being misused here.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
2917	legacygt.com.js	Server-Side Request Forgery (SSRF)	High	true	CWE-829	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. If an attacker can control or influence the `id` value (e.g., via a malicious push message), they can craft a request to internal or external endpoints, potentially leading to SSRF. The URL is built using template literals with user-controlled input, and no validation or sanitization is applied.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
2918	legacygt.com.js	Cross-Site Request Forgery (CSRF)	High	true	CWE-352	8	N/A	standard	{The code reads the `loggedIn` parameter from the current URL (via `e.currentTarget.location.href.match(/loggedIn=(true|false)/)`), which is user-controllable. If an attacker can trick a user into visiting a malicious page that modifies this parameter, they can bypass CSRF protections. The `fetch()` function is then used to make requests with potentially forged credentials, especially when `loggedIn` is 'false', leading to unauthorized actions.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in')```
2919	shackelfordfuneraldirectors.com.js	Server Side Request Forgery (SSRF) via prefetchUrl	High	true	CWE-918	10	N/A	standard	{The `fetch` function is used with a dynamically constructed URL via `addParams`, which can be manipulated to request arbitrary endpoints. The `mode: 'no-cors'` option allows fetching from any origin, enabling SSRF if `urlToPrefetch` is under attacker control or derived from untrusted input.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
2920	shackelfordfuneraldirectors.com.js	Insecure Cache Busting Parameter Handling	Medium	false	N/A	0	N/A	N/A	{The issue stems from the use of `Date.now()` as a cache-busting parameter, which is not inherently a sensitive function misuse but rather a design flaw in cache invalidation strategy. No sensitive function is misused here.}	```const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() });```
2921	shackelfordfuneraldirectors.com.js	Cache Poisoning via Unvalidated URL Handling	Medium	true	CWE-921	9	N/A	standard	{The `cache.put` function is used with `urlToPrefetch` as the key, which is derived from user-controlled or unvalidated input. If an attacker can influence `urlToPrefetch`, they can poison the cache by injecting malicious responses under arbitrary keys, leading to cache poisoning.}	```cache.put(urlToPrefetch, response);```
2922	novoteleftbehindpac.com.js	Cache Poisoning via fetchAndCachePut	High	true	CWE-444	9	fetchAndCachePut	standard	{The fetchAndCachePut method is used without proper validation of the input URL or response. If an attacker can manipulate the request URL or response content (e.g., via a crafted request during the install phase), the service worker may cache malicious content, leading to cache poisoning. This allows attackers to serve tampered resources to users, potentially leading to XSS or other client-side attacks.}	```
2923	ecfr.io.js	Cache Confusion/Information Disclosure	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of `ignoreSearch: true` in `cache.match()`, which causes the service worker to ignore query parameters when matching cached responses. This can lead to cache confusion, where requests with different query strings may return the same cached response, potentially leaking sensitive information or serving incorrect data. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a configuration issue in caching logic.}	```self.addEventListener('fetch', event => { event.respondWith(caches.open(cacheName).then(cache => cache.match(event.request, { ignoreSearch: true }))).then(response => { return response || fetch(event.request); }));```
2924	metrovaartha.com.js	External Script Trust Vulnerability	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a remote URL. In this case, the URL is hardcoded to a trusted CDN (cdn.izooto.com), but the vulnerability arises because the script is loaded from an external source without any integrity verification or origin validation. If the CDN is compromised or if the script is dynamically generated based on untrusted input (even if not in this specific case), it could lead to arbitrary code execution within the service worker context. Since the script is not verified or signed, it introduces a trust risk, especially if the service worker controls critical browser behaviors like caching or network interception.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/51125d3236486a5db1ae2df98a6ef4f8e90b2a02.js"");```"
2925	dotsave.app.js	Improper Input Validation in Notification URL Handling	High	true	CWE-601	10	clients.openWindow	standard	{The URL used in clients.openWindow is derived from event.notification.data.url, which is user-controlled via push notifications. Since no validation or sanitization is performed, an attacker could supply a malicious URL (e.g., a phishing site or a site that performs cross-site scripting) leading to unauthorized navigation or data exfiltration.}	```var url = event.notification.data.url; event.waitUntil(clients.matchAll({ type: 'window' }).then(function (windowClients) { for (var i = 0; i < windowClients.length; i++) { var client = windowClients[i]; if (client.url === url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } }));```
2926	dotsave.app.js	Improper Input Validation in Push Event Data	Medium	true	CWE-20	9	JSON.parse	standard	{The data.options string from the push event is parsed using JSON.parse without validation. If the data is untrusted (e.g., from a malicious server), it could contain malicious or malformed JSON that may lead to unexpected behavior or injection attacks, especially if the parsed options are later used in sensitive operations like notifications or redirects.}	```var options = JSON.parse(data.options); event.waitUntil(self.registration.showNotification(title, options));```
2927	dotsave.app.js	Empty Fetch Event Handler	Low	false	New	0	N/A	N/A	{The fetch event handler is empty and does not perform any operations. There is no misuse of a sensitive function here, as no function is being called with untrusted input.}	```self.addEventListener('fetch', function (event) {});```
2928	awaan.ae.js	Open Redirect via Unvalidated Click Action	Medium	true	CWE-601	9	N/A	standard	{The function clients.openWindow() is a standard browser API that opens a new window or tab with the provided URL. When used with unvalidated input from event.notification.data.click_action, which originates from a notification payload (potentially controlled by an attacker), it enables open redirect attacks. An attacker could craft a notification with a malicious URL, causing the browser to redirect users to arbitrary sites, potentially leading to phishing or credential theft.}	```event.waitUntil(clients.openWindow(event.notification.data.click_action));```
2929	awaan.ae.js	Insecure Data Handling in Notification Options	Medium	true	CWE-20	8	N/A	standard	{The notificationOptions object is constructed using untrusted data from payload.notification (e.g., body, icon, image, click_action). While not directly executable, these fields can be used to inject malicious content (e.g., phishing links via click_action, or malicious images/icons). The use of showNotification() with unsanitized data allows an attacker to manipulate the notification UI and behavior, leading to user deception or unintended actions.}	```var notificationOptions = { body: payload.notification.body, icon: payload.notification.icon, image: payload.notification.image, click_action: payload.notification.click_action, data: { click_action: payload.notification.click_action } };```
2930	awaan.ae.js	Unrestricted Message Handling in Service Worker	Medium	false	CWE-807	N/A	N/A	N/A	{The service worker listens for messages without validating or restricting the source or content of the message. However, this is not caused by misuse of a sensitive function, but rather by a design flaw in message handling logic. The function self.addEventListener('message', ...) is used correctly; the vulnerability stems from lack of input validation, not from unsafe function usage.}	```self.addEventListener('message', function (evt) { ... });```
2931	awaan.ae.js	Open Redirect via Unvalidated Click Action	Medium	false	CWE-601	N/A	N/A	N/A	{The line const fb_messaging = firebase.messaging(); is not directly responsible for the open redirect vulnerability. It initializes the Firebase messaging service, which is not a sensitive function in this context. The actual vulnerability arises later when clients.openWindow() is called with unvalidated data.}	```const fb_messaging = firebase.messaging();```
2932	transentertainment.com.js	Improper Cache Cleanup in Service Worker	Medium	false	New	N/A	N/A	N/A	{The code does not improperly use any sensitive JavaScript function; it merely logs cache names without deleting or cleaning them. The vulnerability stems from a logic flaw (failure to delete old caches) rather than misuse of a sensitive function.}	```self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.filter(function (cacheName) { console.log(cacheName); }).map(function (cacheName) { console.log(cacheName); })); })); });```
2933	mosalasonline.com.js	Improper Input Validation (JSON parsing of untrusted data)	Medium	true	CWE-20	N/A	JSON.parse	standard	{The JSON.parse function is used to parse the 'options' field from untrusted data (e.g., from a message payload). If the data is not properly validated or sanitized, it can lead to injection or unexpected behavior, especially if the parsed object is used to construct notification options or other sensitive operations.}	```var n = JSON.parse(t.options),```
2934	mosalasonline.com.js	Server Side Request Forgery (Unvalidated URL in fetch)	Medium	true	CWE-918	N/A	fetch	standard	{The fetch function is called with an unvalidated URL from the 'impression' field of the message data. Since this URL is derived from untrusted input, an attacker could supply a malicious URL, leading to SSRF, allowing the service worker to make unintended requests to internal or external resources.}	```fetch(e).then();```
2935	mosalasonline.com.js	Open Redirect (Unvalidated URL in clients.openWindow)	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is used to open a URL obtained from the 'url' field in the notification data. Since this URL is not validated or sanitized, an attacker could redirect users to a malicious site, leading to phishing or other attacks.}	```clients.openWindow(t.data.url);```
2936	ultimenotizieflash.com.js	Insecure External Script Loading	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (cdn.pushmaster-cdn.xyz). This allows the third party to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks on network requests. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute arbitrary code from remote sources.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/618aed762c38390008353b00/service-worker.js"");```"
2937	cigusto.com.js	Improper Cache Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper cache validation logic, where the service worker returns cached responses without verifying their freshness or integrity. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logical flaw in cache handling. No sensitive function is being misused here.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); })); });```
2938	webcheats.com.br.js	Improper Input Validation (SSRF)	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a URL constructed from the `id` parameter from push notification data, which is untrusted. This allows an attacker to craft a push notification with a malicious `id` value, leading to SSRF by making the service worker fetch internal or external resources on behalf of the victim.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2939	webcheats.com.br.js	Cross-Site Request Forgery (CSRF)	High	true	CWE-352	N/A	fetch	standard	{The fetch function is used to retrieve a CSRF token based on the `path` parameter from the intercepted request. Since the `path` is derived from the original request URL (which can be controlled by an attacker), this allows an attacker to forge requests to any path on the site, potentially leading to CSRF attacks if the service worker is used to make authenticated requests.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
2940	webcheats.com.br.js	Open Redirect	Medium	true	CWE-601	N/A	navigate	standard	{The navigate function is used with the `data.url` value from a notification, which is untrusted. An attacker can craft a notification with a malicious URL, causing the service worker to redirect the user to an arbitrary site, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url);```
2941	webcheats.com.br.js	Insecure Credential Handling	Medium	true	CWE-598	N/A	fetch	standard	{The fetch function is used with `credentials: 'include'` and a URL constructed from the `id` parameter from push notification data. Since the `id` is untrusted, an attacker can manipulate it to trigger requests to sensitive endpoints with the user’s credentials, leading to insecure credential handling and potential data leakage.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2942	papcoiran.com.js	External Script Import Without Validation	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, as in this case, it does not inherently introduce dynamic risk. However, the vulnerability arises because the script is imported from an external, potentially untrusted domain (van.najva.com), which could be compromised or controlled by an attacker. While the URL is not dynamically constructed from user input, the lack of validation or integrity checks on the external script source still constitutes a high-risk vulnerability, as it allows for potential script injection if the remote resource is tampered with. The misuse lies in trusting an external script without verifying its origin or integrity.}	```importScripts('https://van.najva.com/static/js/scripts/papcoiran250-website-13202-8f5c71de-055e-4555-9a3f-d6e61b4e81fe-service-worker.js');```
2943	my101voice.com.js	Caching of Dynamic Content Leading to Data Exposure	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the logic in `shouldCache`, which allows caching of URLs based on regex patterns and a hardcoded exclusion for 'index.html'. However, this does not involve misuse of a sensitive JavaScript function like `importScripts`, `eval`, or `fetch` with untrusted input. The issue is more about logic flaws in caching policy rather than direct function misuse.}	```const shouldCache = request => { const url = request.url; return !configFileRegex.test(url) && (!localFileRegex.test(url) || localizedTemplatesRegex.test(url)) && url != 'index.html'; };```
2944	my101voice.com.js	Caching of Sensitive Data via Unfiltered GET Requests	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the `fetchAndCache` function being called for any GET request that passes `shouldCache`, which may include sensitive or dynamic content. However, this is not due to misuse of a sensitive function like `eval` or `importScripts`, but rather a design flaw in caching strategy. The `fetch` and `caches.put` functions are used correctly; the issue is in the policy, not the function misuse.}	```event.respondWith(caches.match(event.request).then(data => data || fetchAndCache(event.request)));```
2945	gays-cruising.es.js	Improper Validation of Notification Data Leading to Open Redirect	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is used to open a URL derived from notification data without validation. Since the URL is sourced from untrusted notification data (event.notification.data.url or IDB-stored URL), an attacker could craft a malicious notification payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(url));```
2946	gays-cruising.es.js	Incorrect hasOwnProperty Check in Notification Handling	Medium	false	N/A	N/A	N/A	N/A	{The issue is a logic error in checking Notification.prototype.hasOwnProperty('data'), which is not a sensitive function misuse but a flawed implementation. The hasOwnProperty check is incorrectly applied to the prototype, which does not affect security directly.}	```if (Notification.prototype.hasOwnProperty('data')) {```
2947	amensagem.pt.js	Improper Cache Control	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper cache configuration for uploaded images, specifically setting a long maxAgeSeconds (2592000 seconds = 30 days) and a high maxEntries (100). This does not stem from misuse of a sensitive JavaScript function like importScripts or eval, but rather from misconfigured caching policy parameters. The code is static and does not involve dynamic or untrusted input.}	```wp.serviceWorker.routing.registerRoute(new RegExp('^https\\\\:\\/\\\\/amensagem\\\\.pt\\\\/wp\\\\-content\\\\/uploads\\\\/.*\\\\.(jpg|jpeg|jpe|gif|png|bmp|tif|tiff|ico|heic|heif|webp|avif)(\\\\?.*)?$'), new wp.serviceWorker.strategies['StaleWhileRevalidate'](function () { const strategyArgs = { 'cacheName': 'uploaded-images' }; if (strategyArgs.cacheName && wp.serviceWorker.core.cacheNames.prefix) { strategyArgs.cacheName = `${wp.serviceWorker.core.cacheNames.prefix}-${strategyArgs.cacheName}`; } strategyArgs.plugins = [new wp.serviceWorker['expiration']['ExpirationPlugin']({ 'maxAgeSeconds': 2592000, 'maxEntries': 100 })]; return strategyArgs; }()));```
2948	bandi.pl.js	External Script Import in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes external scripts. When used with a hardcoded external URL, it introduces a risk if the script source is untrusted or controlled by an attacker. In this case, the script is imported from 'https://ga.getresponse.com/wpn/gr_sw.js', which is an external domain. While the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing external scripts in a service worker is inherently risky because it can lead to code injection or compromise of the service worker’s execution context if the external script is malicious or modified. This is considered a sensitive function misuse due to the potential for supply chain attacks or unauthorized code execution.}	```importScripts(['https://ga.getresponse.com/wpn/gr_sw.js']);```
2949	gulfnow.com.js	Exposure of Sensitive Information in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (API key, project ID, etc.) in the `options` object, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'gulfnow-com', messagingSenderId: '427639029339', appId: '1:427639029339:web:e72212a433e8e690dfc97e', apiKey: 'AIzaSyDxSicgZeJed_goGC9mNob6lDjNeYymRcc' }, domain: 'gulfnow.org', api_url: 'https://anayou.co/api/token', vapid_public_key: 'BKms4s6bQ6HgK6uzFrrcv6d0fYb9TQlNSWIglSWNUe484OWDo6haDCWrNJZSt8_Q4MGWxppyD0VNyDdQHdRZM6U' };```
2950	gulfnow.com.js	XSS via Unvalidated Notification Payload	High	true	N/A	N/A	showNotification	standard	{The `showNotification` method is called with user-controlled `payload` data, which is derived from the push message's JSON payload. Since the payload is not sanitized or validated, an attacker can inject malicious content (e.g., script tags) into the notification, leading to XSS if the notification is rendered in a context that executes script.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
2951	gulfnow.com.js	Open Redirect via Unvalidated Target URL	High	true	N/A	N/A	clients.openWindow	standard	{The `clients.openWindow(targetUrl)` function is called with `targetUrl` derived from the notification data, which is user-controlled via push messages. Since the URL is not validated or sanitized, an attacker can supply a malicious URL, leading to open redirect and potential phishing or malware delivery.}	```clients.openWindow(targetUrl);```
2952	gulfnow.com.js	Domain Spoofing via Unvalidated URL Input	Medium	true	N/A	N/A	getDomainAndHostname	standard	{The `getDomainAndHostname(url)` function parses a user-controlled URL to extract the hostname, which is then used to construct a domain for API requests. If the input URL is not validated, an attacker can supply a malicious domain, leading to domain spoofing or unintended API calls to third-party domains.}	```domain = getDomainAndHostname(url).hostname;```
2953	randaris.app.js	Cache Poisoning via Unvalidated Offline Page Fetch	Medium	true	CWE-434	9	N/A	standard	{The fetch() function is used to retrieve the offline page during installation, but the URL is hardcoded as '/offline.html'. While this is not directly user-controlled, the vulnerability arises because the service worker caches the response without validating its content or origin. If an attacker can manipulate the server to serve a malicious offline page, the fetch() call will cache it, leading to cache poisoning. The misuse lies in trusting the server response without validation, even though the URL is static.}	```self.addEventListener('install', function (event) { var offlinePage = new Request('/offline.html'); event.waitUntil(fetch(offlinePage).then(function (response) { return caches.open('ra-offline').then(function (cache) { console.log('Cached offline page during Install ' + response.url); return cache.put(offlinePage, response); }); })); });```
2954	randaris.app.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	N/A	```self.addEventListener('fetch', function (event) { if (event.request.url.indexOf('/ads/') !== -1) { return; } if (event.request.url.startsWith(self.location.origin) && event.request.method === 'GET') { event.respondWith(fetch(event.request).catch(function (error) { console.error('Network request Failed. Serving offline page ' + error); return caches.open('ra-offline').then(function (cache) { return cache.match('/offline.html'); }); })); } });```
2955	android-zone.ws.js	Client-Side URL Redirect	Medium	true	CWE-602	9	N/A	standard	{The function `self.clients.openWindow()` is used to open a new browser window or tab with a URL derived from `data.url`, which is obtained from a push notification payload. Since this data is controlled by the server and potentially by an attacker (if the server is compromised or if the notification data is manipulated), it allows for client-side URL redirection. An attacker could craft a malicious notification that redirects the user to a phishing site or performs other malicious actions. The URL is not validated or sanitized before being passed to `openWindow`, making this a sensitive function misuse.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
2956	xda77.net.js	Improper Input Validation in Dynamic Script Loading	High	true	CWE-20	9	importScripts	standard	{The function importScripts() is used to dynamically load and execute a script from a URL that is derived from a user-supplied parameter (a). Since the input is not sanitized or validated, an attacker can manipulate the URL to load and execute arbitrary malicious scripts, leading to remote code execution within the service worker context.}	```if (!self.define) { const a = a => { 'require' !== a && (a += '.js'); let e = Promise.resolve(); return s[a] || (e = new Promise(async e => { if ('document' in self) { const s = document.createElement('script'); s.src = a, document.head.appendChild(s), s.onload = e; } else importScripts(a), e(); })), e.then(() => { if (!s[a]) throw new Error(`Module ${a} didn’t register its module`); return s[a]; }); }```
2957	tastemade.com.br.js	Improper Input Validation in Dynamic API Call Handling	Medium	true	CWE-20	7	N/A	standard	{The vulnerability arises from the use of `new URL(event.request.url)` to parse the request URL, followed by extracting `pathname` and using it to construct a key for `idbKeyval.get()` without sanitization. While `new URL()` itself is not inherently dangerous, the dynamic construction of the key `resources:${pathname}` from unsanitized user input (via `event.request.url`) allows an attacker to manipulate the key and potentially access or overwrite arbitrary stored data, leading to information leakage or cache poisoning. This misuse of dynamic key construction with unsanitized input constitutes improper input validation.}	```const navigationRoute = new NavigationRoute(async ({ event }) => { if (event.request.url.match(/\/.gatsby-plugin-offline:.+/)) { return handleAPIRequest({ event }); } if (!offlineShellEnabled) { return await fetch(event.request); } lastNavigationRequest = event.request.url; let { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``); const resources = await idbKeyval.get(`resources:${pathname}`); if (!resources || !(await caches.match(`/app-25f0ac86aad62fe1ba5f.js`))) { return await fetch(event.request); } for (const resource of resources) { if (!(await caches.match(resource))) { return await fetch(event.request); } } const offlineShell = `/offline-plugin-app-shell-fallback/index.html`; const offlineShellWithKey = workbox.precaching.getCacheKeyForURL(offlineShell); return await caches.match(offlineShellWithKey); });```
2958	jurnas.com.js	Insecure Use of Third-Party Code	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used to import a script from a third-party domain ('https://anymind360.com/js/2249/anymind-sw.js'). While the URL is hardcoded, the vulnerability arises from trusting and executing code from an external, unverified source, which can lead to code injection, data exfiltration, or service disruption if the third-party script is compromised or malicious.}	```importScripts('https://anymind360.com/js/2249/anymind-sw.js');```
2959	bitmax.ir.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a high-risk vulnerability. The imported script can execute arbitrary code within the service worker context, potentially leading to cache manipulation, network interception, or data exfiltration. Since the script source is not under the control of the application owner, this constitutes a sensitive function misuse.}	```importScripts('https://van.najva.com/static/js/scripts/new-website963458-website-51157-933e749a-01cb-4c08-95b0-6e975b7defc9-service-worker.js');```
2960	ratsun.net.js	Insecure Authentication Check via URL Parameter	High	true	CWE-287	9	RegExp.prototype.match	standard	{The vulnerability arises from using `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter directly from the URL. This is unsafe because the URL is user-controlled and can be manipulated to bypass authentication checks. The `match()` function is standard, but its misuse here allows an attacker to forge the `loggedIn=true` parameter in the URL, tricking the service worker into skipping security logic and potentially allowing unauthorized access to protected resources.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2961	interpretation-reve.fr.js	External Script Inclusion Without Integrity Check	High	true	CWE-78	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the script is loaded from a remote CDN without any integrity check or validation. While the URL is hardcoded, the lack of integrity verification (e.g., using a hash or Subresource Integrity) means that if the CDN is compromised or the script is tampered with, the service worker could execute malicious code. This constitutes a sensitive function misuse because importScripts() can be exploited to load arbitrary code, and even with a hardcoded URL, the absence of integrity checks introduces a high-risk vulnerability.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/61e44beac93c1b0009571e73/service-worker.js"");```"
2962	1e9.community.js	Improper Neutralization of Input (XSS via Notification Data	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display notifications, and it accepts user-controlled data (e.g., title, body, icon) directly from the push message without sanitization. If an attacker can control the content of the push message, they can inject malicious scripts or HTML into the notification, leading to XSS when rendered in the browser. This is a classic case of improper input neutralization in a context where untrusted data is rendered.}	```self.registration.showNotification(e, a);```
2963	1e9.community.js	Open Redirect via Notification Data	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is called with a URL constructed from user-controlled data (n + t), where t is the notification's data.url. If an attacker can manipulate the push message to include a malicious URL, this can result in an open redirect, potentially tricking users into visiting phishing or malicious sites. The URL is not validated or sanitized before being passed to clients.openWindow, making it vulnerable to redirection attacks.}	```clients.openWindow(n + t);```
2964	greasylake.org.js	Insecure Direct Object Reference (IDOR)	High	true	CWE-598	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this `id` is derived from untrusted external input (push notification payload), an attacker can manipulate it to access unauthorized notifications, leading to an Insecure Direct Object Reference (IDOR) vulnerability.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2965	greasylake.org.js	Insecure Redirect/Phishing	High	true	CWE-601	9	navigate	standard	{The navigate method is used with a URL derived from the notification data's `data.url` field, which is sourced from untrusted push notification data. An attacker can craft a malicious notification with a phishing URL, causing the browser to navigate to a malicious site, leading to Insecure Redirect/Phishing.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
2966	greasylake.org.js	Client-Side Authentication Bypass	Medium	false	CWE-611	0	N/A	N/A	{The vulnerability arises from client-side logic that checks for a `loggedIn` parameter in the URL, which can be easily manipulated by users. This is not caused by misuse of a sensitive JavaScript function, but rather by flawed client-side authentication logic.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
2967	amandinecooking.com.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, which can lead to code injection, cache manipulation, or data exfiltration. In this case, the script is loaded from a third-party CDN without any validation, making it vulnerable to supply chain attacks if the CDN is compromised.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/61842e6840db0200087a62a1/service-worker.js"");```"
2968	healthprep.com.js	Unrestricted Import of Code from Untrusted Sources	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute scripts from remote URLs. In this case, the URL is constructed using self.location.hostname, which is a dynamic value derived from the current context. Although the hostname is not directly user-controlled, it is still a runtime-determined value that could be manipulated in certain contexts (e.g., via subdomain takeover or DNS hijacking). More critically, the script is loaded from a third-party domain (trk-keingent.com), which is untrusted and potentially malicious. This allows an attacker to control the content of the imported script, leading to arbitrary code execution within the service worker context.}	"```if (typeof window === ""undefined"") { importScripts('https://trk-keingent.com/scripts/ext/script/yld8wkndm2?url=' + encodeURI(self.location.hostname)); } importScripts('https://trk-keingent.com/scripts/sw/script/yld8wkndm2?url=' + encodeURI(self.location.hostname));```"
2969	Varingen.no.js	Improper Input Validation Leading to Cache Poisoning	High	true	N/A	N/A	fetch	standard	{The fetch function is used without validating the request URL or headers, allowing an attacker to supply a malicious URL or header (e.g., 'x-emergency-mode') that could be used to poison the cache or manipulate the service worker's behavior. The response headers are directly parsed and used to set self.emergencyMode, which could lead to unintended behavior if the header contains malicious content.}	```const response = await fetch(request); self.emergencyMode = (response.headers.get('x-emergency-mode') || '').split('```
2970	Varingen.no.js	Insufficient Error Handling Leading to Denial of Service	Medium	false	N/A	N/A	N/A	N/A	{The code uses event.respondWith(responseHandler(request)) without proper error handling or fallbacks. While this is not caused by a sensitive function misuse, it can lead to denial of service if the responseHandler throws an uncaught error, causing the service worker to fail to respond to requests.}	```return event.respondWith(responseHandler(request));```
2971	Varingen.no.js	Improper Validation of URLs Leading to SSRF Risk	High	false	N/A	N/A	N/A	N/A	{The handler2 function processes URLs from a message event, but there is no validation of the URL before using it in fetch or cache operations. However, since the URL is not dynamically constructed from untrusted input (e.g., user-controlled query parameters), and the code does not use a sensitive function like importScripts or eval, this is not a sensitive function misuse.}	```handler2(event, message3);```
2972	Varingen.no.js	Incorrect Vary Header Handling Leading to Cache Misuse	Medium	false	N/A	N/A	N/A	N/A	{The code modifies the Vary header by filtering out 'user-agent', but this is done in a controlled manner within the cacheWillUpdate plugin. Since the input is not from untrusted sources and no sensitive function is misused, this is not a sensitive function vulnerability.}	"```init.headers.vary = init.headers.vary.split(',').filter(h => h.trim().toLowerCase() !== ""user-agent"").join(',');```"
2973	Varingen.no.js	Insecure Message Handling Leading to Code Injection	High	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener('message', ...) function is used to handle incoming messages, and the message data is processed without proper validation. The handler functions (handler and handler2) are called directly with the message data, which could be manipulated by an attacker to trigger unintended behavior or cache manipulation. Since the message data is untrusted and directly used in operations like fetch and cache.put, this constitutes a sensitive function misuse.}	"```self.addEventListener(""message"", event => { if (!event.data.type) { return; } const message3 = event.data.message || null; switch (event.data.type) { case message2: handler2(event, message3); break; case message: handler(event, message3); break; default: break; } });```"
2974	squid-board.org.js	CSRF Token Injection Bypass	High	true	N/A	9	```if (loggedIn == 'false' && request.method === 'POST') {	standard	{The vulnerability arises from the improper use of the fetch API to dynamically retrieve a CSRF token based on the request path. The code constructs a URL using the request's pathname, which is derived from the client's request (e.g., `new URL(curRequest.url).pathname`). If an attacker can manipulate the request path (e.g., via a crafted URL or redirect), they could potentially trigger the fetch to retrieve a CSRF token for a different endpoint, allowing them to bypass CSRF protections. Although the token is used in a subsequent request, the dynamic construction of the URL from untrusted input (the request path) introduces a risk of token leakage or misuse, especially if the path is not properly sanitized or validated. This misuse of fetch with untrusted input in the URL construction is a sensitive function misuse.}	N/A
2975	fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A
2976	supernutritious.net.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	N/A	standard	{The fetch function is used with dynamically constructed URLs derived from untrusted input (msg.pixel, msg.pixelAd, clickURL, and the impression URL). Since these inputs originate from push message data, which can be controlled by an attacker, an SSRF vulnerability is introduced. The attacker can manipulate these values to make the service worker send requests to arbitrary internal or external endpoints, potentially exfiltrating data or performing unauthorized actions.}	```fetch(`https://pushdashboardapi.foremedia.net/api/v1/im/${uid_str}/${target}`)```
2977	supernutritious.net.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	N/A	standard	{The fetch function is used with the msg.pixel value, which is directly extracted from untrusted push message data. Since msg.pixel is not validated or sanitized, an attacker can set it to any URL, causing the service worker to make unintended outbound requests, leading to SSRF.}	```fetch(msg.pixel)```
2978	supernutritious.net.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	N/A	standard	{The fetch function is used with the msg.pixelAd value, which is directly extracted from untrusted push message data. Since msg.pixelAd is not validated or sanitized, an attacker can set it to any URL, causing the service worker to make unintended outbound requests, leading to SSRF.}	```fetch(msg.pixelAd)```
2979	supernutritious.net.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	N/A	standard	{The fetch function is used with clickURL, which is constructed from untrusted data (event.notification.data.uid_str and event.notification.data.target). Since these values originate from push message data, an attacker can manipulate them to redirect the fetch request to arbitrary endpoints, resulting in SSRF.}	```fetch(clickURL, { method: 'GET', headers: { 'ngrok-skip-browser-warning': 'true' } })```
2980	saintsweb.co.uk.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of `fetch()` with a dynamically constructed `Request` object. The `curRequest` is a cloned client request, and its URL is not validated or sanitized. Since the `fetch()` function is used without restricting the target URL, an attacker could potentially manipulate the request to target internal or external resources, leading to SSRF. The `new Request()` constructor inherits the original request’s URL, which may be controlled by an attacker if the service worker processes untrusted navigation or POST requests. This misuse of `fetch()` with untrusted input allows unauthorized access to internal systems or external services.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest));```
2981	bambee.com.js	Cache Bypass via Request Interceptor Manipulation	High	true	N/A	8	N/A	standard	{The vulnerability arises from the use of `workbox.routing.registerRoute` with dynamically constructed strategy plugins. The `plugins` array is populated via `new (getProp(workbox, p.use))(...p.config)`, where `p.use` is derived from user-controlled or untrusted configuration. This allows an attacker to inject arbitrary plugin classes (e.g., a custom handler that bypasses cache checks) by manipulating the `strategyPlugins` configuration, leading to cache bypass. The `registerRoute` function is a standard Workbox API, but its misuse with dynamic plugin instantiation creates a high-risk vulnerability.}	```const strategyOptions = { ...entry.strategyOptions, plugins };```
2982	hycm.com.js	External Script Execution	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script (https://cdn.pushalert.co/sw-6284.js), which is not inherently unsafe. However, if the URL were dynamically constructed from untrusted input (e.g., from a query parameter or user-controlled source), it would allow an attacker to inject arbitrary scripts, leading to code execution. Since the URL is hardcoded and not derived from user input, the vulnerability is not due to sensitive function misuse in the context of dynamic input. Therefore, the vulnerability is not caused by sensitive function misuse.}	"```importScripts(""https://cdn.pushalert.co/sw-6284.js"");```"
2983	tropicalsky.co.uk.js	Improper Input Validation in CDN Route Regex	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from an overly permissive regex pattern in the CDN route registration, which allows matching URLs with potentially unintended or malicious subdomains or paths. However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by flawed logic in the regex itself. The workbox.routing.registerRoute function is used correctly; the issue lies in the pattern design, not in the function's unsafe usage.}	```workbox.routing.registerRoute(/.*(?:(\\s*|ts)cdn(\\d*)\\.(tropicalsky|freshegg))(\\.co\\.uk|.com).*$/, workbox.strategies.staleWhileRevalidate({ cacheName: 'cdn', revision: revision }));```
2984	tropicalsky.co.uk.js	Overly Permissive Regex in Static-Resources Route	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from a regex pattern that is too broad, potentially matching unintended resources such as malicious or unauthorized JavaScript or CSS files. This is a logic flaw in the route pattern, not a misuse of a sensitive JavaScript function. The workbox.routing.registerRoute function is used appropriately; the issue is in the regex design, not in the function's execution with untrusted input.}	```workbox.routing.registerRoute(/.*(vendors|bundle).(css|js).*$/, workbox.strategies.staleWhileRevalidate({ cacheName: 'static-resources', revision: revision, plugins: [new workbox.expiration.Plugin({ maxEntries: 20, maxAgeSeconds: 7 * 24 * 60 * 60 })] }));```
2985	rabe-bike.de.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	10	toolbox.router.get	standard	{The vulnerability arises from the use of a complex, potentially exponential regular expression in the route definition: `/(http[s]?:\/\/)?(\/)?([^\/\s]+\/)?(api\/catalog\/)(.*)/g`. This regex is passed directly to the `toolbox.router.get` method, which internally uses it for URL matching. The pattern contains nested optional groups and character classes that can lead to catastrophic backtracking when matched against maliciously crafted input, causing ReDoS. Since the regex is hardcoded and not derived from untrusted input, the vulnerability is not due to dynamic input injection, but rather due to the inherent complexity of the regex itself. However, the `toolbox.router.get` function is a standard API that processes regexes, and its misuse with such a complex pattern constitutes a sensitive function misuse.}	```toolbox.router.get(/(http[s]?:\/\/)?(\/)?([^\/\s]+\/)?(api\/catalog\/)(.*)/g, toolbox.networkFirst, {});```
2986	perfumeriajulia.es.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is loaded from 'https://cdn.retailrocket.net', which is an external domain. If the source is compromised or if the script is modified without detection, it could lead to arbitrary code execution within the service worker context, enabling attacks such as data exfiltration, cache manipulation, or man-in-the-middle attacks on network requests.}	```importScripts('https://cdn.retailrocket.net/content/javascript/retailrocket.webpushserviceworker.js');```
2987	scammer.info.js	Improper Neutralization of Input During Web Page Generation ('Cross-Site Scripting')	High	true	CWE-79	9	fetch	standard	{The `fetch` function is used to send a POST request with the user-provided `e.reply` value directly embedded in the request body without sanitization. Since `e.reply` comes from a user interaction (notification reply), it is untrusted input. If an attacker can control this input, they could inject malicious content that might be reflected in the application's response or used to trigger unintended behavior, potentially leading to Cross-Site Scripting (XSS) if the response is rendered in a context where script execution is possible. Although `fetch` itself is not inherently XSS-prone, its misuse with unsanitized user input in a context where that input is later rendered or processed in a dangerous way constitutes a sensitive function misuse.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
2988	vab.org.js	Exposure of Sensitive Information (Firebase API Key in Client Code)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding the Firebase API key in client-side JavaScript, which is exposed to users and attackers. This is not caused by misuse of a sensitive function, but rather by insecure configuration exposure.}	```var swVersion = '3.0.9'; const firebaseVersion = '8.9.1'; const http = 0; importScripts('https://www.gstatic.com/firebasejs/' + firebaseVersion + '/firebase-app.js'); importScripts('https://www.gstatic.com/firebasejs/' + firebaseVersion + '/firebase-messaging.js'); const options = { firebaseConfig: { projectId: 'larapush-a408d', messagingSenderId: '36384989321', appId: '1:36384989321:web:d024fe20b687466a226658', apiKey: 'AIzaSyA7SwfF-YeY4hzu6yZlk7Vaatq0NPGVBTQ' } }```
2989	vab.org.js	Potential Server Side Request Forgery (SSRF) via Unvalidated URL Handling	Medium	true	N/A	N/A	new URL	standard	{The function new URL(url) is used to parse a user-supplied URL without validation. If the URL is controlled by an attacker, it could be crafted to point to internal resources (e.g., localhost, internal APIs), leading to SSRF. The function is standard but misused due to lack of input sanitization and validation.}	```function getDomainAndHostname(url) { const urlObj = new URL(url); return { hostname: urlObj.hostname } }```
2990	vab.org.js	Insecure Handling of Notification Click URLs (Potential Phishing)	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow(targetUrl) is called with a URL derived from notification data, which is potentially controlled by an attacker. Since the URL is not validated or sanitized, it can be manipulated to redirect users to phishing sites or malicious domains, leading to phishing attacks.}	```clients.openWindow(targetUrl);```
2991	atv.be.js	Hardcoded Sensitive Information	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive data (e.g., appKey, token, vapidPublicKey) in the script, not due to misuse of a sensitive JavaScript function.}	```uaSetup.worker(self, { defaultIcon: 'https://markup.gva.be/extra/assets/img/favicons/apple-touch-icon-152x152-precomposed.png?v=20190517T104024', defaultTitle: 'Gazet van Antwerpen', defaultActionURL: 'https://www.gva.be/', appKey: 'S1RJuJmhSbOWWGU9fT_V7g', token: 'MTpTMVJKdUptaFNiT1dXR1U5ZlRfVjdnOldiY1NkcWpfYnVvbmlzLWVYRlJKUVlNOWJWQ1hSQ3MxdjlqMkxSekdPQ1U', vapidPublicKey: 'BD_RTklEBHWV2tWBJ1ywNZq21dXkN4lXgrG6vut2fc5YtMFQGyD-BiEOPkAjQP7kZRCN_yrBxeKlPHmNyxq2N_g=' });```
2992	atv.be.js	Insecure External Script Loading	Medium	true	CWE-444	N/A	importScripts	standard	{The importScripts function is used to load an external script from a hardcoded URL. While the URL is not dynamically constructed from untrusted input, loading external scripts from third-party domains introduces risk of supply chain attacks or compromised scripts, especially if the domain is not fully controlled or verified. This constitutes misuse of a sensitive function due to lack of trust verification.}	```importScripts('https://aswpsdkus.com/notify/v1/ua-sdk.min.js');```
2993	baatplassen.no.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this data is received from an external source (push notification), an attacker could craft a malicious notification with an `id` that causes the service worker to make an HTTP request to an unintended internal or external endpoint, leading to SSRF. The URL is built using `${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, where `id` is untrusted.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
2994	baatplassen.no.js	Open Redirect	Medium	true	CWE-601	9	navigate	standard	{The navigate function is used with the `data.url` value obtained from a notification, which is derived from server responses. Since this value is not validated or sanitized, an attacker could manipulate the notification payload to redirect users to arbitrary external URLs, leading to open redirect. The code executes `clients[0].navigate(data.url);` without checking if the URL is safe or within the expected domain.}	```clients[0].navigate(data.url);```
2995	southwestfour.com.js	Open Redirect via Notification Data	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(targetUrl) is used to open a URL in a new window or tab. The targetUrl is derived from event.notification.data.url, which is user-controlled via push notifications. Since no validation or sanitization is applied, an attacker can craft a notification with a malicious URL, leading to open redirect and potential phishing or drive-by download attacks.}	N/A
2996	southwestfour.com.js	Server Side Request Forgery (SSRF) via Notification Data	High	true	CWE-918	9	fetch	standard	{The function fetch(apiUrl) is used to make HTTP requests. The apiUrl is derived from event.notification.data.api_url, which is user-controlled via push notifications. Without proper validation or sanitization, an attacker can supply an internal or external endpoint, causing the service worker to make unintended requests on behalf of the user, leading to SSRF.}	N/A
2997	southwestfour.com.js	Insecure Domain Handling in Subscription	Medium	true	CWE-20	8	getDomainAndHostname	standard	{The function getDomainAndHostname(url) parses a URL to extract the hostname, which is then assigned to the domain variable. The input URL is derived from user-controlled data (event.data.url), and if not validated, it can lead to improper domain handling, potentially allowing an attacker to manipulate the domain used in subsequent requests, leading to data leakage or misrouting.}	N/A
2998	southwestfour.com.js	XSS Risk in Notification Payload	Medium	true	CWE-79	7	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display notifications with user-controlled data from payload.title and other fields. If the payload contains malicious content (e.g., script tags), and the browser renders it in a context where it can be executed (e.g., in a notification UI that supports HTML), it may lead to XSS, especially if the notification UI is not properly sanitized.}	N/A
2999	barneveld.nl.js	Cache Poisoning via Unvalidated Response Origin	High	true	N/A	9	caches.put	standard	{The function `caches.put` is used to store responses in the cache, but it is called without validating the origin or content of the response. The `shouldCache` function checks only the URL path and method, but does not verify the response's origin or integrity. This allows an attacker to potentially inject malicious content into the cache if the response is manipulated or if the request is intercepted, leading to cache poisoning.}	```if (shouldCache(request)) { addToCache(assetsCacheName, request, response.clone()); }```
3000	barneveld.nl.js	Caching of Sensitive Backend Responses	High	true	N/A	9	caches.put	standard	{The `caches.put` function is used to cache responses from backend requests, but the `shouldCache` function does not adequately restrict caching to only safe or non-sensitive endpoints. Since it allows caching of any GET request matching `/typo3/` (excluding `/typo3` itself), sensitive backend responses (e.g., administrative or user-specific data) may be cached and exposed to unauthorized users, leading to information disclosure.}	```if (shouldCache(request)) { addToCache(assetsCacheName, request, response.clone()); }```
3001	barneveld.nl.js	Insecure Trust of /cache-files.json	High	true	N/A	9	fetch	standard	{The `fetch` function is used to retrieve a list of URLs from `/cache-files.json` without validating the integrity or origin of the file. Since this file is used to populate the offline cache via `cache.addAll`, an attacker who can manipulate this file can inject arbitrary URLs into the cache, leading to cache poisoning or execution of malicious content.}	```return fetch('/cache-files.json').then(response => { return response.json().then(paths => { return paths.map(path => `${scope}${path}`); }); });```
3002	demonland.com.js	Incorrect User Authentication State Detection	High	false	New	N/A	N/A	N/A	{The vulnerability arises from improper parsing of the URL query parameter `loggedIn` using a regex match. The code assumes the presence of `loggedIn=true` or `loggedIn=false` in the URL, but does not validate the source or integrity of this parameter, potentially allowing an attacker to manipulate the URL to spoof authentication state. This is not caused by misuse of a sensitive function, but rather by flawed logic in state detection.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3003	demonland.com.js	CSRF Token Handling Logic Flaw	High	true	New	N/A	fetch	standard	{The fetch function is used to dynamically construct and send a request to retrieve a CSRF token based on the `path` parameter derived from the intercepted request. While the path is sanitized via URL parsing, the use of `fetch` with dynamically constructed URLs (even if safe here) can be risky if the path is not properly validated. However, the primary issue is not the function misuse per se, but the logic flaw in assuming the token retrieval will always succeed and be secure. The fetch function is standard and used correctly in this context, but the vulnerability stems from the lack of proper error handling and potential for token leakage or replay.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key);```
3004	demonland.com.js	Unvalidated Notification URL Handling	Medium	true	CWE-601	N/A	navigate	standard	{The navigate function is used to redirect the client to a URL provided in the notification data. Since the URL is derived from server-sent data without validation, an attacker could craft a malicious notification with a URL pointing to a phishing site or malicious resource, leading to open redirect or phishing attacks. The navigate function is a standard browser API and is misused here due to lack of input validation on the URL.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
3005	demonland.com.js	Insecure Offline Cache Handling	Low	false	CWE-921	N/A	N/A	N/A	{The vulnerability is due to the use of a hardcoded list of assets to cache, which may not be sufficient for offline functionality. However, this is not caused by misuse of a sensitive function. The cache.addAll function is used correctly, and the issue lies in the design choice of what assets to cache, not in the function's misuse.}	```return caches.open(CACHE_NAME).then(cache => { return cache.addAll(CACHED_ASSETS); });```
3006	unbottled.co.js	External Script Import Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of arbitrary remote code, which can lead to complete compromise of the service worker's environment. In this case, the script is loaded from a hardcoded external URL (https://wisepops.net/serviceWorker.js), which may be controlled by an attacker or compromised, enabling malicious code execution.}	"```importScripts(""https://wisepops.net/serviceWorker.js"");```"
3007	balkanholidays.co.uk.js	Hardcoded API Keys and Tokens	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (API keys and tokens) in the configuration object, not due to misuse of a sensitive JavaScript function. There is no dynamic or untrusted input being passed to any function that could lead to injection or execution risks.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BIBVQD0aMv2_qILIg9UCePkF9Ako1yXly8Lyc-13elOZSJ8YgLu5nxLTaWdB6sJmKN4D2FkF418ErZvAPd1a2SU="",""apiKey"":""ABEMzjROSdm0yMqu8Ntc4TJBQ"",""accountToken"":""ABEvEOS5-EAwSnpIWmvJ0CjdY"",""appver"":""0.0.0"",""apiHost"":""https://bq01q9t-webpush.oraclersys.com"",""lazy"":false}';orawp.init(config);```"
3008	pornomig.net.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it may still pose a risk if the URL is controlled by an attacker or if the script source is untrusted. In this case, the script is imported from 'https://sw.wpush.org/ps/sw.js?tcid=5527', which is an external, third-party domain. While the URL is hardcoded, the use of importScripts() with an external source introduces a high-risk vulnerability because the imported script can execute arbitrary code within the service worker context, potentially leading to cache manipulation, network interception, or data exfiltration. This constitutes misuse of a sensitive function due to the trust boundary violation.}	```importScripts('https://sw.wpush.org/ps/sw.js?tcid=5527');```
3009	queensnake.com.js	Improper Input Validation (Potential XSS/Phishing via Untrusted URL	High	true	CWE-20	10	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display a notification with content derived from untrusted input (payload.body, payload.icon, payload.image, payload.url). Since these values are directly taken from the push message data without sanitization, an attacker can craft a malicious payload to inject arbitrary content, including phishing links or misleading text, leading to potential user deception or XSS if the notification is rendered in a context that executes script.}	```self.registration.showNotification(payload.title, options)```
3010	queensnake.com.js	Improper Neutralization of Input (XSS/Phishing via Notification Click	High	true	CWE-79	10	clients.openWindow	standard	{The function clients.openWindow is called with payload.data.url, which is derived from untrusted push message data. Since the URL is not validated or sanitized, an attacker can supply a malicious URL (e.g., phishing site or malicious script) that will be opened in the user’s browser upon notification click, leading to phishing or unintended navigation.}	```clients.openWindow(payload.data.url)```
3011	easyonlinefunding.com.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a given URL. In this case, the URL is constructed using self.location.hostname, which is dynamically derived from the current context. Although the hostname is not directly user-controlled, the script is importing from a hardcoded external domain (trk-keingent.com) with a query parameter that includes the hostname. This behavior is suspicious and potentially malicious, as it allows an attacker to potentially manipulate the hostname (e.g., via DNS spoofing or subdomain takeover) to load arbitrary scripts. The use of importScripts() with dynamically constructed URLs, even if not directly user-input, introduces a high-risk vector for remote code execution if the external domain is compromised or under attacker control.}	"```if (typeof window === ""undefined"") { importScripts('https://trk-keingent.com/scripts/ext/script/zqd2my4gk3?url=' + encodeURI(self.location.hostname)); } importScripts(""https://trk-keingent.com/scripts/sw/script/zqd2my4gk3?url="" + encodeURI(self.location.hostname));```"
3012	l2jbrasil.com.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-602	10	clients[0].navigate(data.url)	standard	{The function clients[0].navigate() is a standard browser API that allows navigation to a specified URL. In this case, the URL is derived from the `data.url` field of a notification, which is obtained from a push event. Since this data is not validated or sanitized, an attacker could craft a malicious push notification with a `data.url` pointing to an arbitrary external site, leading to an open redirect. This allows the attacker to trick users into visiting unintended domains, potentially leading to phishing or credential theft.}	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
3013	jokaroom.net.js	Remote Code Execution via Dynamic Module Import	High	true	CWE-96	N/A	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL derived from the modulePathPrefix configuration, which is set to a remote URL. Since the URL is not validated or sanitized, an attacker could manipulate the modulePathPrefix to load and execute arbitrary JavaScript code from an external source, leading to remote code execution.}	```const e = this.St(t); try { importScripts(e), this.jt = !0; } catch (s) { throw console.error(`Unable to import module '${t}' from '${e}'.`), s; }```
3014	jokaroom.net.js	Improper URL Neutralization in Precaching	Medium	false	CWE-918	N/A	N/A	N/A	{The precache URLs are hardcoded and do not involve dynamic input or user-controlled values. While the URLs contain query parameters, they are not derived from untrusted sources, so there is no sensitive function misuse.}	```wp.serviceWorker.precaching.precache([{'url': 'https://www.jokaroom.net/en/?wp_error_template=offline', 'revision': '0.8.1;...'}]);```
3015	jokaroom.net.js	XSS via Error Message Injection	High	true	CWE-79	N/A	btoa	standard	{The btoa() function is used to encode error response bodies into base64, which are then embedded into an iframe's src attribute. If the errorText contains malicious content, it can be executed in the context of the iframe, leading to XSS. The function is misused because it processes untrusted data without sanitization.}	```const src = 'data:text/html;base64,' + btoa(errorText); const iframe = `<iframe style='width:100%' src='${src}' srcdoc='${srcdoc}'></iframe>`;```
3016	jokaroom.net.js	Insecure Denylist Regex Pattern	Medium	false	CWE-918	N/A	N/A	N/A	{The denylist is constructed from hardcoded regex patterns and does not involve dynamic or user-controlled input. The vulnerability arises from the logic of the denylist itself, not from misuse of a sensitive function.}	```const denylist = [\'^\\\\/wp\\\\-admin($|\\\\?|/)\', \'^[^\\\\?]*?\\\\.php($|\\\\?)\', ...].map(pattern => new RegExp(pattern));```
3017	jewellerymaker.com.js	Improper Regular Expression for URL Filtering	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to an improperly constructed regular expression used to filter URLs, not due to misuse of a sensitive JavaScript function. The regex pattern `/\/admin\.php|\/install\/|\/download($|&|\?)|[\/?]attachments\/|google-ad|adsense/` is flawed because it lacks proper grouping, leading to unintended matches and potential bypasses. This is a logic or pattern-matching issue, not a function misuse.}	```const response = Promise.resolve(event.preloadResponse).then(function (r) { return r || fetch(request); });```
3018	nowplatinum.com.js	Insecure External Script Import (Remote Code Execution via CDN)	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., from a CDN), it introduces a risk if the CDN is compromised or if the script is not integrity-verified. Although the URL is hardcoded here, the vulnerability arises because the script is imported from an external, untrusted source, which can be manipulated by an attacker if the CDN is compromised, leading to remote code execution within the service worker context.}	```importScripts('https://pushomnicdn.azureedge.net/jslibs/omni-library-8.js');```
3019	kolejedolnoslaskie.pl.js	Missing Pre-Caching of Offline Resource	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from not pre-caching the offline page ('/offline.html') during the install event, which means the service worker cannot serve it when the network is unavailable. This is not caused by misuse of a sensitive function, but rather by an omission in the caching strategy.}	```self.addEventListener('install', function (event) { event.waitUntil(caches.open('app').then(function (cache) { for (let asset of coreAssets) { cache.add(new Request(asset)); } return cache; })); });```
3020	bitcoincasino.io.js	Insecure Third-Party Script Import	High	false	N/A	N/A	N/A	N/A	{The importScripts() calls use hardcoded, trusted paths and do not involve dynamic or user-controlled input. While importing third-party scripts can be risky, the lack of dynamic input means this is not a sensitive function misuse in the context of injection or arbitrary code execution.}	"```importScripts(""/thirdPartyResourcesWorker.js""), importScripts(""/pwaServiceWorker.js"");```"
3021	beam-monsters.com.js	Improper Session Management Leading to CSRF Vulnerability	High	true	N/A	9	N/A	standard	{The vulnerability arises from the improper handling of user session state via URL parameters (e.g., `loggedIn=true/false`) and the lack of proper CSRF token validation for guest POST requests. The code attempts to fetch a CSRF token dynamically using `fetch()` based on the current URL path, but this logic is conditional on the `loggedIn` parameter extracted from the URL. Since `loggedIn` is derived from the URL via `match(/loggedIn=(true|false)/)`, it is user-controllable and can be manipulated. If an attacker can trick a user into visiting a crafted URL with `loggedIn=false`, the service worker will intercept the POST request and attempt to fetch a CSRF token, but this process is not secured against replay or timing attacks. The `fetch()` function is used here with dynamic URLs constructed from untrusted input (the path from the URL), which, while not directly leading to injection, contributes to the overall risk by enabling an attacker to trigger CSRF token fetching under controlled conditions. This misuse of `fetch()` with dynamic, untrusted URL components in a context where session state is derived from the URL creates a pathway for CSRF attacks.}	```const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3022	reestrgos.com.js	Remote Code Execution via Dynamic Strategy Instantiation	High	true	CWE-74	10	getProp	standard	"{The function `getProp` is used to dynamically resolve a property path from the `workbox` object, which is then invoked with `new` to instantiate a strategy. Since `p.use` is derived from user-controlled or untrusted configuration data (via `entry.strategyPlugins`), an attacker could supply a malicious string (e.g., ""workbox.strategies.MaliciousStrategy"") that resolves to an arbitrary constructor. This allows arbitrary code execution when the strategy is instantiated, leading to full control over the service worker's behavior.}"	```const plugins = (entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config));```
3023	o94.at.js	Insecure URL Exclusion Check	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from using a simple string indexOf check on the request URL, which is not robust against URL manipulation or encoding. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a logic flaw in the exclusion logic.}	```for (let i = 0; i < EXCLUDE_CACHE.length; i++) { if (event.request.url.indexOf(EXCLUDE_CACHE[i]) !== -1) { return false; } }```
3024	o94.at.js	Insecure Pre-Cache Endpoint	Medium	true	New	N/A	fetch	standard	{The fetch function is used to retrieve a pre-cache manifest from a hardcoded URL (PRE_CACHE_URL). While the URL is hardcoded, the vulnerability lies in the lack of validation or integrity checks on the fetched manifest, which could be tampered with if the server is compromised. This misuse of fetch without proper security controls (e.g., integrity verification, CORS restrictions) allows an attacker to inject malicious URLs into the precache list, leading to unintended resource loading or cache poisoning.}	```event.waitUntil(fetch(PRE_CACHE_URL).then(response => response.json()).then(precache_files => {```
3025	doasync.com.js	Improper Input Validation	High	true	CWE-20	7	N/A	standard	{The function `match()` is used on a dynamically derived `pathname` to extract parameters, which are then parsed without validation. This allows an attacker to craft a URL with malicious parameters that could lead to unintended behavior or injection, especially if these parameters are later used in untrusted contexts.}	```const params = pathname.match(/:(.+)/)[1];```
3026	doasync.com.js	Insecure Message Handling	Medium	true	CWE-319	8	N/A	standard	{The `addEventListener` function is used to handle messages, and the message data is directly processed without validation. This allows an attacker to send arbitrary messages that could trigger unintended actions, such as clearing caches or modifying internal state, leading to insecure message handling.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
3027	doasync.com.js	Unvalidated Redirect	High	true	CWE-601	9	N/A	standard	{The `Response` constructor is used to create a redirect response with a `Location` header set to `lastNavigationRequest`, which is derived from the request URL. Since this value is not validated, an attacker can manipulate the URL to redirect users to arbitrary locations, leading to open redirect vulnerabilities.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
3028	doasync.com.js	Insecure Cache Clearing	Medium	true	CWE-352	7	N/A	standard	{The `caches.keys()` and `caches.delete()` functions are used to clear cache entries based on a dynamic key list. The `includes('runtime')` check is insufficient to prevent deletion of unintended caches, especially if the key list is manipulated or if the logic is bypassed, leading to insecure cache clearing.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
3029	kv.no.js	Vulnerable Regular Expression in Host Check	Medium	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from a flawed regular expression pattern that checks for 'www.kv.no' in the host. The code uses `indexOf(""'www.kv.no'"")`, which is syntactically incorrect and likely a typo, but even if corrected, it does not validate the host securely. However, this is not caused by misuse of a sensitive function, as no function like `importScripts()` or `fetch()` is being used with untrusted input.}"	"```if (req.url.host.indexOf(""'www.kv.no'"") !== -1) {```"
3030	kv.no.js	Arbitrary URL Fetching via Message Handling	High	true	N/A	N/A	fetch	standard	"{The `handler2` function processes a message containing a list of URLs from the `data` array, which is received via `self.addEventListener(""message"", ...)`. The URLs are fetched and cached using `fetch(url)` without any validation or sanitization. Since the URLs are derived from untrusted external messages, an attacker could send malicious URLs (e.g., to external domains or internal resources) to be fetched and cached, leading to unintended network requests or data exfiltration.}"	```async function handler2(event, data) { const cacheName2 = cacheNames2.runtime; if (data && Array.isArray(data)) { const cache = await caches.open(cacheName2); const result = data.map(url => caches.match(url).then(response => { if (response) { return true; } return requestAndCacheUrl(url, cache); })); event.waitUntil(Promise.all(result)); } }```
3031	kv.no.js	Improper Input Validation in Cache Warming	Medium	true	N/A	N/A	fetch	standard	{The `handler2` function processes URLs received via a message event and uses `fetch(url)` to retrieve them. The URLs are not validated or sanitized, allowing an attacker to send arbitrary URLs (e.g., to internal endpoints or external malicious sites) to be fetched and cached. This can lead to unintended network requests, cache pollution, or data leakage.}	```async function handler2(event, data) { const cacheName2 = cacheNames2.runtime; if (data && Array.isArray(data)) { const cache = await caches.open(cacheName2); const result = data.map(url => caches.match(url).then(response => { if (response) { return true; } return requestAndCacheUrl(url, cache); })); event.waitUntil(Promise.all(result)); } }```
3032	radiochisinau.md.js	Unrestricted Cache Deletion	High	true	N/A	10	N/A	standard	{The caches.delete() function is used without any filtering or validation of cache names, leading to the deletion of all caches. Since the cache names are obtained via caches.keys() and processed without restriction, this allows for unintended or malicious cache deletion, potentially disrupting application functionality or exposing sensitive data.}	```self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.filter(function (cacheName) {}).map(function (cacheName) { return caches.delete(cacheName); })); })); });```
3033	radiochisinau.md.js	Unprotected Cache Access	Medium	true	N/A	10	N/A	standard	{The caches.keys() function retrieves all cache names without any access control or filtering, and the subsequent deletion of each cache via caches.delete() is performed without validation. This exposes the application to unauthorized cache manipulation, especially if the service worker is compromised or if cache names are derived from untrusted sources.}	```caches.keys().then(function (names) { for (let name of names) caches.delete(name); });```
3034	keepvid.ch.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	fetch	standard	"{The fetch function is used with a dynamically constructed URL (n + ""/index.php/sub/listen""), where n is set to a hardcoded domain. However, if n were to be derived from untrusted input (e.g., from a push notification payload), it could allow an attacker to redirect the fetch request to an arbitrary internal or external endpoint, leading to SSRF. Although currently hardcoded, the code structure allows for dynamic assignment of n, making it a potential vector.}"	"```fetch(n + ""/index.php/sub/listen"", { method: ""POST"", body: JSON.stringify(e), headers: new Headers({ ""Content-Type"": ""application/json"" }) })```"
3035	keepvid.ch.js	Open Redirect	Medium	true	CWE-601	9	self.clients.openWindow	standard	{The self.clients.openWindow function is called with a URL (o) that is derived from the notification data, which is parsed from a push message. If an attacker can control the 'url' field in the push payload, they can redirect the user to an arbitrary website, leading to open redirect. The code checks for https:// or http://, but this is insufficient to prevent all malicious redirects if the URL is crafted to bypass validation.}	```e.waitUntil(self.clients.openWindow(o))```
3036	interfriendship.com.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	10	N/A	standard	{The RegExp constructor is used with a complex, potentially untrusted pattern that includes lookbehind assertions and multiple alternations. This can lead to catastrophic backtracking when matching maliciously crafted input, causing excessive CPU consumption and DoS.}	"```var imgregex = new RegExp(""(?<!(\\/chat\\/((s|g)pic(\\/t)?\\/\\d+)|(\\/(secure-)?pix\\d?\\.interfriendship\\.com\\/.*)))\\.(png|jpg|jpeg|svg|gif)$"");```"
3037	interfriendship.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch function is used with a URL constructed from untrusted data (options.data.endpoint), which is derived from a push notification payload. This allows an attacker to control the target URL, enabling SSRF to internal resources.}	"```fetch('/ajax/push-notifications.php', { method: 'post', headers: { ""Content-type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: 'action=set_received&endpoint=' + options.data.endpoint + '&uid=' + options.data.uid });```"
3038	interfriendship.com.js	Open Redirect	Medium	true	CWE-601	8	N/A	standard	{The self.clients.openWindow function is called with a URL derived from event.notification.data.actionUrl, which is untrusted input from a notification. This allows an attacker to redirect users to arbitrary external sites, leading to phishing or malicious redirection.}	```self.clients.openWindow(url).then(function (client) { if (client) client.focus(); });```
3039	redpost.com.ua.js	Hardcoded Secret Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret key is not a result of sensitive function misuse but rather a direct assignment of a static value.}	```self[`appKey`] = `1872d8071410e244dd4e25cab13be429`;```
3040	redpost.com.ua.js	External Script Loading Without Validation	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed from a hardcoded value (self.hostUrl), it may still be considered risky if the value is not fully trusted or if it could be manipulated in a broader context. However, in this case, the URL is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically constructed from user input. Still, the function itself is sensitive because it executes arbitrary code from a remote source, and its misuse (e.g., if hostUrl were derived from user input) would lead to severe vulnerabilities like remote code execution.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3041	indiancricketfans.com.js	Open Redirect via Notification Data	High	true	CWE-601	10	navigate	standard	{The `navigate` method is used to redirect the client to a URL derived from `data.url`, which is obtained from a push notification payload. Since this data is not validated or sanitized, an attacker can craft a malicious notification with a URL pointing to an external site, leading to an open redirect. This allows users to be redirected to arbitrary domains, potentially phishing or malicious sites.}	```javascript clients[0].navigate(data.url);```
3042	indiancricketfans.com.js	Server-Side Request Forgery (SSRF) in CSRF Token Fetch	Medium	true	CWE-919	9	fetch	standard	{The `fetch` function is used to request a CSRF token with a dynamically constructed URL that includes the `path` parameter derived from the current request's URL. If an attacker can manipulate the `path` parameter (e.g., via a crafted request), they can cause the service worker to make requests to internal or external endpoints under the context of the user's session, leading to SSRF. The `path` is not validated, allowing arbitrary paths to be injected.}	```javascript fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3043	2unbox.com.js	Exposure of Sensitive Information	Medium	false	CWE-548	N/A	N/A	N/A	{The vulnerability arises from hardcoding the INNERTUBE_API_KEY in the ytcfg.set() call, which is not a result of misusing a sensitive JavaScript function. The key is exposed in plaintext within the script, but no dynamic or unsafe function call is involved.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
3044	2unbox.com.js	Insecure Resource Access	Low	false	CWE-602	N/A	N/A	N/A	{The assignment self.document = self; self.window = self; does not involve any sensitive JavaScript function misuse. It is a static assignment that reassigns global references, which may be considered a bad practice but does not constitute misuse of a sensitive function like importScripts() or eval().}	```self.document = self; self.window = self;```
3045	poll2action.com.js	External Script Import Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is imported from 'https://api.pushnami.com/scripts/v2/pushnami-sw/655bc26180dea70013453051', which is a hardcoded URL. While the URL is not dynamically constructed from untrusted input, the lack of integrity verification (e.g., using Subresource Integrity) still poses a high risk if the remote server is compromised or if the script is tampered with during transit. This constitutes a misuse of the sensitive function because it enables remote code execution without validation.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/655bc26180dea70013453051"");```"
3046	pinkoclub.com.js	Improper Input Validation (JSON Parsing Without Error Handling	Medium	true	CWE-20	N/A	JSON.parse	standard	{The code parses a string received from event.data.text() using JSON.parse without validating or handling potential parsing errors. If the input is malformed or malicious, this can lead to runtime errors or unexpected behavior, potentially allowing an attacker to trigger denial-of-service or manipulate the service worker's logic.}	```const message = event.data.text(); event.waitUntil(sendNotification(message));```
3047	pinkoclub.com.js	Unvalidated URL Redirection in Notification Click Handler	High	true	CWE-601	N/A	clients.openWindow	standard	{The URL received from the notification data is used directly in clients.openWindow without validation or sanitization. An attacker could craft a malicious notification payload with a URL that redirects to an arbitrary site, leading to phishing, cross-site scripting, or other client-side attacks.}	```return clients.openWindow(url);```
3048	opera-online.com.js	Open Redirect via Notification Data	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted notification data (t.notification.data.url), it allows an attacker to craft a malicious notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities.}	```t.waitUntil(clients.openWindow(t.notification.data.url));```
3049	milawyersweekly.com.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is loaded from 'https://api.pushnami.com', which is an external domain. If the script at that URL is compromised or modified, the service worker could execute malicious code, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. The lack of integrity verification (e.g., via Subresource Integrity) makes this a high-risk vulnerability.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5e4ae979f2f24f5014e85c5e"");```"
3050	olympiacosbc.gr.js	External Script Loading Without Integrity Check	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows an attacker to compromise the script source (e.g., via DNS spoofing, man-in-the-middle attacks, or compromised CDN) and inject malicious code into the service worker. This leads to full control over the service worker’s behavior, including intercepting network requests, manipulating cache, and potentially stealing user data. The URL is hardcoded but still represents a risk if the external source is not secured with integrity verification.}	"```importScripts(""https://cdn.pushalert.co/sw-58427.js"");```"
3051	laroche-posay.me.js	Improper Validation of Dynamic Script URLs in importScripts	High	true	CWE-78	10	importScripts	standard	"{The code uses importScripts() with a dynamically constructed URL derived from the script's source or location.href, which can be manipulated if the script is loaded from an untrusted or dynamically determined source. Although the URL is constructed via new URL(s + "".js"", r).href, the base URL 'r' may be derived from an untrusted context (e.g., location.href), allowing an attacker to inject arbitrary script URLs. This leads to remote code execution via script injection, as importScripts() executes any script it is given without validation.}"	"```if (!self.define) { let e, n = {}; const s = (s, r) => (s = new URL(s + "".js"", r).href, n[s] || new Promise(n => { if (""document"" in self) { const e = document.createElement(""script""); e.src = s, e.onload = n, document.head.appendChild(e); } else e = s, importScripts(s), n(); }).then(() => { let e = n[s]; if (!e) throw new Error(`Module ${s} didn’t register its module`); return e; })); self.define = (r, i) => { const o = e || (""document"" in self ? document.currentScript.src : """") || location.href; if (n[o]) return; let c = {}; const a = e => s(e, o), d = { module: { uri: o }, exports: c, require: a }; n[o] = Promise.all(r.map(e => d[e] || a(e))).then(e => (i(...e), c)); }; }```"
3052	dynamicsuser.net.js	Improper Neutralization of User Input for Web Page (XSS)	High	true	CWE-79	10	fetch	standard	{The fetch function is used to send a POST request with user-provided data (`e.reply`) directly in the body without sanitization. Since `e.reply` comes from a user interaction (notification reply), it can contain malicious content. When this unsanitized input is sent in the request body, it may be interpreted or executed by the server or reflected in responses, leading to XSS if the server reflects the input back to the client without proper escaping. The vulnerability arises because the sensitive function `fetch` is misused with untrusted input, allowing an attacker to inject malicious payloads.}	"```fetch(`${i}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": n }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
3053	autonews7.com.js	Insecure Redirect via Notification Data	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(targetUrl) is used with targetUrl derived from event.notification.data.url, which is user-controlled via push notification payload. This allows an attacker to craft a malicious notification that redirects users to arbitrary URLs, leading to phishing or drive-by downloads.}	N/A
3054	autonews7.com.js	Insecure API Call via Notification Data	High	true	CWE-918	9	fetch	standard	{The function fetch(apiUrl) is used with apiUrl derived from event.notification.data.api_url, which is user-controlled via push notification payload. This enables an attacker to redirect API calls to malicious endpoints, potentially exfiltrating data or performing unauthorized actions on behalf of the user.}	N/A
3055	autonews7.com.js	Exposure of Firebase API Key	Medium	false	CWE-532	0	N/A	N/A	{The Firebase API key is hardcoded in the script and exposed in the source code, but it is not used in conjunction with any sensitive function that processes untrusted input. The exposure is a static secret leak, not a dynamic misuse of a sensitive function.}	N/A
3056	hiddenbrains.com.js	Cache Poisoning via Unvalidated Message URLs	High	true	CWE-444	10	N/A	standard	{The vulnerability arises from the misuse of the `caches.add()` method, which is a standard browser API. The method is called with `t.url`, where `t` is the result of `fetchFile(e.data[t])`, and `e.data[t]` is user-controlled input from a message event. Since the URL is not validated or sanitized, an attacker can send a malicious URL (e.g., a URL pointing to a malicious script or a resource that should not be cached), causing the service worker to cache it. This leads to cache poisoning, where the attacker can influence the behavior of the service worker and potentially serve malicious content to users.}	"```self.addEventListener(""message"", e => { for (let t in e.data) fetchFile(e.data[t]).then(t => { caches.open(CACHE_NAME).then(e => { console.log(""Caching inprogress""), e.add(t.url); }), e.source.postMessage(t.url); }); });```"
3057	installitdirect.com.js	Improper Input Validation (Empty String in Precache)	Low	false	CWE-20	N/A	N/A	N/A	{The empty string in the precache array does not constitute misuse of a sensitive function, as it is a static, hard-coded value and does not involve dynamic or untrusted input. It may lead to unintended behavior, but it does not stem from improper use of a sensitive function like importScripts or eval.}	"```workbox.precaching.precache([""https:\/\/www.installitdirect.com"", """", ""https:\/\/www.installitdirect.com\/about-us\/""]);```"
3058	installitdirect.com.js	Incorrect Content Serving on Network Failure (Broad Route)	Medium	false	New	N/A	N/A	N/A	{The broad route pattern and fallback to a cached page do not involve misuse of a sensitive function. The issue lies in the logic design of the route handler, not in the improper use of a function like importScripts or eval that could lead to code injection or execution.}	```workbox.routing.registerRoute(new RegExp('https://www.installitdirect.com.*'), async args => { try { const response = await workbox.strategies.networkFirst({ cacheName: PwpSwVersion + '-default' }).handle(args); return response || (await caches.match('https://www.installitdirect.com/about-us/')); } catch (error) { console.log('catch:', error); return await caches.match('https://www.installitdirect.com/about-us/'); } });```
3059	kosova-sot.info.js	Open Redirect via Notification Tag	Medium	true	CWE-602	9	clients.openWindow	standard	{The clients.openWindow function is used to open a new browser window with a URL constructed by concatenating a hardcoded base URL with the event.notification.tag, which is user-controlled via push notifications. This allows an attacker to craft a notification payload with a malicious tag (e.g., '/evil.com') to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```clients.openWindow('https://www.kosova-sot.info' + event.notification.tag);```
3060	kosova-sot.info.js	Open Redirect via Click Action	Medium	true	CWE-602	9	notificationOptions.data.clickUrl	standard	{The clickUrl field in the notificationOptions object is directly assigned from payload.notification.click_action, which is user-controlled via push notifications. When the notification is clicked, this value is used to redirect the user, enabling open redirect attacks if the click_action contains a malicious URL.}	```data: { clickUrl: payload.notification.click_action }```
3061	kosova-sot.info.js	Use of Outdated Firebase Library	Low	false	CWE-494	N/A	N/A	N/A	{The use of an outdated Firebase library version (6.0.2) is a version-related issue, not a misuse of a sensitive function. It does not involve dynamic or untrusted input being passed to a function in a dangerous way.}	```importScripts('https://www.gstatic.com/firebasejs/6.0.2/firebase-app.js');```
3062	superpoker.com.br.js	Hardcoded Sensitive Information (API Key)	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static credential exposed in the source code, not a result of sensitive function misuse.}	```self[`appKey`] = `5c6b42e98583074448c6be1006b7691b`;```
3063	superpoker.com.br.js	Insecure External Resource Loading (Remote Script Import)	Medium	true	N/A	N/A	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a URL constructed using a hardcoded host. While the URL is not dynamically derived from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from external sources, which can lead to code injection if the host is compromised or misconfigured.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3064	cmrwebsitedesign.com.js	Missing Fetch Event Listener	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of a proper fetch event listener implementation. The current listener is a no-op (`() => {}`), which prevents the service worker from intercepting and handling fetch requests as intended, leading to degraded PWA functionality.}	```self.addEventListener('fetch', () => {});```
3065	banksathi.com.js	Information Exposure via Console Logging	Low	false	N/A	N/A	N/A	N/A	{console.log is not a sensitive function in the context of security vulnerabilities like injection or remote code execution. While logging sensitive data can lead to information exposure, it does not stem from misuse of a sensitive function that directly enables exploitation (e.g., importScripts, eval, etc.).}	```console.log('Message received in service worker:', event.data);```
3066	banksathi.com.js	Information Exposure via Console Logging	Low	false	N/A	N/A	N/A	N/A	{console.log is not a sensitive function in the context of security vulnerabilities like injection or remote code execution. While logging sensitive data can lead to information exposure, it does not stem from misuse of a sensitive function that directly enables exploitation (e.g., importScripts, eval, etc.).}	```console.log('Fetch request:', event.request.url);```
3067	tataplayfiber.co.in.js	Relative Path in Web Worker Instantiation	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to the use of a relative path in the Worker instantiation, but it does not stem from misuse of a sensitive function. The Worker constructor is being used with a hardcoded, non-dynamic path ('page-sense.js'), which does not involve untrusted or unsanitized input. Therefore, this is not a sensitive function misuse.}	"```if (typeof Worker !== ""undefined"") { if (typeof w == ""undefined"") { w = new Worker(""page-sense.js""); } } else { console.log(""Sorry! No Web Worker support.""); }```"
3068	fwi.com.js	External Script Import in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and points to an external domain (poppulo.pushengage.com), which introduces a high-risk dependency. While the URL is not dynamically constructed from untrusted input, the act of importing an external script in a service worker is inherently risky because it allows third-party code to execute with the same privileges as the service worker, potentially leading to cache manipulation, network interception, or data exfiltration. This is considered a sensitive function misuse due to the trust boundary violation.}	"```importScripts(""https://poppulo.pushengage.com/service-worker.js?ver=2.3.0"");```"
3069	factoryauthorizedoutlet.com.js	Improper URL Allowlist Validation	High	true	CWE-20	10	N/A	standard	{The vulnerability arises from the improper construction of the ALLOWLIST regex patterns using `hostnameRegex` derived from `self.location.hostname`. The use of `new RegExp(str)` with user-derived input (via `hostnameRegex`) is inherently unsafe because it allows for regex injection if the hostname contains special regex characters (e.g., `.`, `*`, `(`). This can lead to unintended URL matching, bypassing the allowlist and allowing malicious requests to be processed. Although the function `new RegExp()` is standard, its misuse with unsanitized input creates a high-risk vulnerability.}	```const ALLOWLIST = [`^https\:\/\/${hostnameRegex}+\/($|collections|products|pages|cart|search|blogs|account|recommendations)`, `^https\:\/\/${hostnameRegex}+${proxy}`, `^https?\:\/\/(?!${hostnameRegex}).+`];```
3070	gamecatering.de.js	Improper URL Validation Leading to SSRF or Cache Poisoning	High	true	CWE-918	9	N/A	standard	{The function `addParams` uses `new URL(url)` to parse and modify URLs. If the input `url` is untrusted or improperly validated, an attacker could supply a URL with a malicious origin (e.g., `http://internal-server.com`), which would be processed and potentially used in subsequent fetch or cache operations, leading to SSRF or cache poisoning. The function does not validate the URL's origin or scheme, making it vulnerable to manipulation.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
3071	gamecatering.de.js	Overly Permissive Cache Route Regex	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a broad regex pattern that matches too many URLs, potentially allowing unintended resources to be cached or served. This is not caused by misuse of a sensitive function but by poor regex design.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
3072	gamecatering.de.js	No-CORS Fetch in Prefetch Leading to SSRF	Medium	true	CWE-918	8	N/A	standard	{The `fetch` function is used with `mode: 'no-cors'`, which bypasses CORS restrictions. When combined with user-controlled or unvalidated URLs (e.g., from `addParams`), this allows the service worker to make requests to any origin, including internal or sensitive endpoints, leading to SSRF. The `mode: 'no-cors'` setting is inherently risky when used with dynamic URLs.}	```const networkResponse = await fetch(new Request(url, { mode: 'no-cors' }));```
3073	gamecatering.de.js	Empty Fetch Event Listener Overriding Behavior	High	false	N/A	0	N/A	N/A	{The vulnerability stems from an empty `fetch` event listener that overrides default behavior, preventing proper handling of requests. This is a logic issue, not caused by misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
3074	gamecatering.de.js	Debug Logging Exposing Sensitive Information	Medium	false	N/A	0	N/A	N/A	{The `log` function logs debug information to the console, which may expose sensitive data if `pwaSettings.debug` is enabled. This is a configuration or logic issue, not a misuse of a sensitive function.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
3075	megasimka.ru.js	Open Redirect via Untrusted URL in Notification	Medium	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed directly from notificationBody.data.url, which is derived from untrusted user input. Since the URL is not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', e => { console.log(e); const notificationBody = e.notification; if (notificationBody.data?.url) e.waitUntil(clients.openWindow(notificationBody.data.url)); sendAnalytics('clicked', notificationBody).then(console.log).catch(console.err); });```
3076	carucubere.ro.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a secret credential exposed in the code, but it is not a result of misuse of a sensitive JavaScript function. It is a static value embedded in the URL passed to fetch(), which is not dynamically constructed from untrusted input.}	"```fetch(""https://api.pushinstruments.com/global/check/?key=0WUpGIMbdp6KTSblR3QCmZwQhQjXYXvT"")```"
3077	carucubere.ro.js	Open Redirect via Unvalidated Link	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow() function is used with a URL derived from event.notification.data.notification.link, which originates from a remote API response. Since this URL is not validated or sanitized, an attacker could manipulate the API response to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```clients.openWindow(event.notification.data.notification.link);```
3078	carucubere.ro.js	Potential XSS via Unsanitized Message	High	true	N/A	N/A	showNotification	standard	{The showNotification() method is used with the 'body' parameter set to 'message', which is sourced from a remote API response. If the message contains untrusted HTML or JavaScript, and the browser renders it as executable content (e.g., in some contexts), it could lead to XSS. While notifications typically sanitize content, relying on unsanitized input introduces risk, especially if the notification is rendered in a context where content is not properly escaped.}	```self.registration.showNotification(title, { body: message, icon: icon, image: image, tag: notificationTag, data: data, requireInteraction: true });```
3079	prezzigomme.com.js	Improper Handling of Cache-Control Headers	High	false	N/A	0	N/A	N/A	{The vulnerability arises from not respecting Cache-Control headers during fetch and caching operations, but no sensitive JavaScript function is misused in this context. The issue is more about logic or policy rather than direct misuse of a function like importScripts or eval.}	```event.respondWith(fetch(event.request).then(function (response) { console.log('[PWA Builder] add page to offline cache: ' + response.url); event.waitUntil(updateCache(event.request, response.clone())); return response; }).catch(function (error) { console.log('[PWA Builder] Network request Failed. Serving content from cache: ' + error); return fromCache(event.request); }));```
3080	prezzigomme.com.js	Uncontrolled Resource Consumption (Cache Exhaustion	High	false	N/A	0	N/A	N/A	{The vulnerability stems from the lack of cache size limits or eviction policies, leading to potential exhaustion. This is a design or configuration issue, not a direct misuse of a sensitive JavaScript function such as importScripts or eval.}	```event.respondWith(fetch(event.request).then(function (response) { console.log('[PWA Builder] add page to offline cache: ' + response.url); event.waitUntil(updateCache(event.request, response.clone())); return response; }).catch(function (error) { console.log('[PWA Builder] Network request Failed. Serving content from cache: ' + error); return fromCache(event.request); }));```
3081	fxmag.pl.js	External Script Import Without Validation	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, as in this case, it does not inherently introduce dynamic risk. However, the vulnerability arises because the script is imported from an external, third-party domain (pushpushgo.com) without validation or integrity checks. While the URL is not dynamically constructed from untrusted input, the lack of validation or secure sourcing (e.g., no integrity hash, no CSP enforcement) still allows for potential compromise if the external script is tampered with or if the domain is compromised. This constitutes a misuse of a sensitive function in a high-risk context, as it enables remote code execution from an untrusted source.}	```importScripts('https://s-eu-1.pushpushgo.com/65f80fde559ade036ee89774/worker.js');```
3082	foreclosurephilippines.com.js	Hardcoded Secret Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which is inherently insecure due to exposure in the source.}	```self[`appKey`] = `3c6d645b8382a55327862861792d5361`;```
3083	foreclosurephilippines.com.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API in Service Workers that loads and executes a script from a given URL. In this case, the URL is constructed using a hardcoded hostUrl, which is not dynamically derived from untrusted input. However, since the script is loaded from an external domain (cdn.gravitec.net), and the script content is not verified or sanitized, it introduces a risk of remote code execution if the external script is compromised or malicious. The function itself is sensitive because it executes arbitrary code from a remote source without validation.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3084	finaloutpost.net.js	Improper Input Validation Leading to Notification Injection	Medium	true	CWE-79	8	N/A	standard	{The function `self.registration.showNotification` is a standard browser API used to display notifications. When the `body` parameter is derived from untrusted input (via `event.data.text()`), it allows an attacker to inject arbitrary content into notifications, potentially leading to phishing, social engineering, or information disclosure. Since the input is not sanitized or validated, this constitutes improper input validation and misuse of a sensitive function.}	```promises.push(sendNotification(message));```
3085	allaccessfans.co.js	Cache Poisoning via Insecure Caching	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the design of the caching strategy. The service worker caches static assets and serves them from cache on subsequent requests, but does not validate or sanitize the URLs being cached or served. However, since no sensitive function like importScripts, eval, or dynamic script loading is involved, this is not a case of sensitive function misuse.}	"```self.addEventListener(""fetch"", event => { if (event.request.url.indexOf(""streaming"") !== -1) { return; } if (event.request.url.indexOf(""content_images"") !== -1) { return; } if (event.request.url.indexOf(""original"") !== -1) { return; } if (event.request.url.indexOf(""media"") !== -1) { return; } if (event.request.url.indexOf(""tus"") !== -1) { return; } if (event.request.url.indexOf(""s3"") !== -1) { return; } if (event.request.url.indexOf(""base"") !== -1) { return; } event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match(""offline""); })); });```"
3086	selinmusic.ir.js	Loading external script without validation	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hard-coded and not derived from user input, the vulnerability arises because the script is loaded from an external, potentially untrusted domain (van.najva.com). If the domain is compromised or if the script is not properly validated or signed, it could be replaced with malicious code, leading to unauthorized access, data exfiltration, or further compromise of the service worker's execution context. Although the input is not dynamic, the lack of validation or integrity checks on the external script constitutes a misuse of the sensitive function, making it a high-risk vulnerability.}	```importScripts('https://van.najva.com/static/js/scripts/selinmusic-website-23390-81fe09d9-a8a9-46e7-8d9e-a8039795943c-service-worker.js');```
3087	safestbettingsites.com.js	XSS via Unsanitized Push Notification Data	Medium	true	CWE-79	8	N/A	standard	{The function `event.data.text()` is used to extract the payload from a push notification, which is then directly assigned to the `body` property of the notification options. Since this data is not sanitized or validated, an attacker could inject malicious content (e.g., script tags) into the push payload, potentially leading to XSS if the notification is rendered in a context that executes script.}	```var body; if (event.data) { body = event.data.text(); } else { body = 'Push message no payload'; }```
3088	safestbettingsites.com.js	Incorrect Origin Check in Fetch Handler	Low	false	CWE-20	N/A	N/A	N/A	N/A	```if (new URL(e.request.url).origin !== location.origin) return;```
3089	drhoelter.de.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that includes location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts from a remote host, leading to remote code execution within the service worker context.}	```importScripts(`https://drhoelter.app.baqend.com/v1/speedkit/sw.js${location.search}`);```
3090	gvine.cc.js	Improper Origin Validation	High	true	CWE-602	10	URL	standard	{The function `new URL(String(e), location.href)` is used to construct a URL from a potentially untrusted input `e`. If `e` is controlled by an attacker (e.g., via a malicious URL or user input), it can be manipulated to point to an arbitrary origin. This bypasses origin validation, allowing the service worker to make requests or cache resources from unintended domains, leading to potential data leakage, cache poisoning, or cross-origin attacks.}	"```const a = e => new URL(String(e), location.href).href.replace(new RegExp(`^${location.origin}`), """");```"
3091	psuwatch.com.js	Insecure Third-Party Dependency	High	true	CWE-829	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded third-party URL like 'https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js', it introduces a high-risk dependency. Although the URL is not dynamically constructed from untrusted input, the script is loaded from an external source that is not under the control of the application, potentially leading to supply chain attacks if the third-party service is compromised. This constitutes a misuse of a sensitive function due to lack of trust and control over the loaded script.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
3092	klubccc.eu.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script ('https://proxy.synerise.com/rtom/configs/c4t4xCqYQ86u/sw.js'), which introduces a high-risk vulnerability if the script source is untrusted or compromised. Although the URL is not dynamically constructed from user input, the act of importing an external script from a third-party domain without proper validation or integrity checks (e.g., via Subresource Integrity) allows for potential script injection or tampering, leading to full control over the service worker’s behavior. This constitutes misuse of a sensitive function due to lack of trust verification.}	```importScripts('https://proxy.synerise.com/rtom/configs/c4t4xCqYQ86u/sw.js');```
3093	canadiansoccernews.com.js	CSRF Vulnerability	High	true	N/A	9	N/A	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter, which is then used to conditionally intercept POST requests. While `match()` itself is not inherently dangerous, its misuse here allows an attacker to manipulate the `loggedIn` state via URL parameters, leading to CSRF attacks. The function is used to parse untrusted input (URL) without proper validation or sanitization, enabling attackers to spoof user state and trigger unauthorized actions.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3094	matras.pl.js	External Script Import Without Integrity Check	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is imported from a third-party domain (pushpushgo.com), which could be compromised or malicious, leading to arbitrary code execution within the service worker context. This is a high-risk vulnerability because the service worker has broad control over network requests, caching, and client-side behavior.}	```importScripts('https://s-eu-1.pushpushgo.com/6627882738b4fa6c9efc5f04/worker.js');```
3095	iranmusicazin.ir.js	Vulnerable External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability if the script source is untrusted or controlled by an attacker. In this case, the script is imported from 'https://van.najva.com', which is an external domain. If this domain is compromised or malicious, the imported script can execute arbitrary code within the service worker context, leading to cache manipulation, network interception, or data exfiltration. Although the URL is hardcoded, the vulnerability is still considered sensitive because the function itself is inherently dangerous when used with external sources.}	```importScripts('https://van.najva.com/static/js/scripts/mymusicazin-website-31927-73a72d4e-4c58-406e-8607-5045bdf54a72-service-worker.js');```
3096	online-moebel-kaufen.de.js	XSS via Push Notification	High	true	CWE-79	9	registration.showNotification	standard	{The function `self.registration.showNotification()` is a standard browser API used to display push notifications. When the `body` parameter is derived from untrusted input (via `event.data.text()`), it can be manipulated by an attacker to inject arbitrary content into the notification. Since notifications can render HTML in some contexts (depending on browser implementation), this can lead to Cross-Site Scripting (XSS) if the notification content is interpreted as executable script. The vulnerability arises because the input is not sanitized or validated before being passed to the notification API.}	"```const sendNotification = body => { const title = ""ML-Push""; return self.registration.showNotification(title, { body }); };```"
3097	jvrlibrary.com.js	Improper Neutralization of Input	Medium	true	CWE-598	5	N/A	standard	{The JSON.parse() function is used to parse untrusted input from event.data.text(), which is derived from a push message. While JSON.parse() itself is not inherently dangerous, the subsequent use of parsed values (e.g., title, code, thumb) in the showNotification() method without sanitization can lead to improper neutralization of input, potentially allowing an attacker to inject malicious content into notifications, such as phishing links or misleading text. However, since the notification content is not directly executable, the risk is limited to user deception.}	```let { count, thumb, code, title, zhTitle, thumbSmall } = JSON.parse(event.data.text()); event.waitUntil(self.registration.showNotification(`${count} VR videos updated at jvrlibrary!`, { body: code + ' ' + title, badge: thumb, image: thumb, icon: thumbSmall || thumb }));```
3098	jvrlibrary.com.js	Server Side Request Forgery	Medium	true	CWE-918	8	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the subscription.endpoint value, which is obtained from the pushManager. Although encodeURIComponent() is used, the endpoint itself may be controlled by an attacker if the subscription is compromised or if the service worker is tricked into using a malicious subscription. This allows an attacker to forge requests to arbitrary endpoints, leading to SSRF.}	```fetch('/api/notificationTrack?endpoint=' + encodeURIComponent(subscription.endpoint)).then(data => console.log(data));```
3099	hooopstore.com.js	Code Injection via Untrusted External Script	High	true	CWE-94	10	importScripts	standard	{The importScripts() function loads and executes a script from a specified URL. When used with a hardcoded external URL like 'https://cdn.segmentify.com/v3/push/sw.js', it introduces a risk if the script source is untrusted or compromised, allowing an attacker to inject malicious code into the service worker. Although the URL is hardcoded here, the function itself is inherently sensitive because it can execute arbitrary remote code.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
3100	hooopstore.com.js	Unvalidated External Service Worker Update	Medium	true	New	8	updateRegistration	standard	{The updateRegistration() function updates the service worker registration with a new URL. If the URL is not validated or is derived from untrusted input, it can lead to unauthorized updates or execution of malicious service workers. In this case, the URL 'https://psh2.segmentify.com/' is hardcoded, but the function is sensitive because it allows dynamic updates to the service worker, which could be exploited if the URL were user-controlled or compromised.}	```updateRegistration('2845398c-b860-474e-a1be-d7e2a3783f46', 'https://psh2.segmentify.com/');```
3101	mogo.co.ke.js	Improper Input Validation	High	true	CWE-20	N/A	self.define	standard	{The function `self.define` is used to dynamically load and execute modules, and it accepts an array of module names as input. If these module names are derived from untrusted or unsanitized sources (e.g., user input or external configuration), an attacker could inject arbitrary module paths, leading to remote code execution or unauthorized access to internal modules. The vulnerability arises because the function does not validate or sanitize the input module names before using them to load scripts.}	"```self.define = (l, d) => { const n = o || (""document"" in self ? document.currentScript.src : """") || location.href; if (a[n]) return; let s = {}; const r = o => e(o, n), b = { module: { uri: n }, exports: s, require: r }; a[n] = Promise.all(l.map(o => b[o] || r(o))).then(o => (d(...o), s)); };```"
3102	wonbet.vip.js	Improper Handling of Custom Event Leading to Cache Poisoning	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the improper handling of a custom event 'refreshOffline', which is not a standard browser event. While the code attempts to update the cache with a response, it does not validate or sanitize the event's payload or origin. However, this is not caused by misuse of a sensitive JavaScript function like importScripts, eval, or dynamic code execution, but rather by a design flaw in event handling. Therefore, it is not classified as a sensitive function misuse.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('casino-offline').then(function (cache) { console.log('[PWA Builder] Offline page updated from refreshOffline event: ' + response.url); return cache.put(offlinePage, response); }); });```
3103	radiopanamericana.com.js	Code Injection via Untrusted External Script	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability if the script source is not trusted or if the domain is compromised. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an external, potentially untrusted source, which can be manipulated by an attacker if the domain is compromised or if the script is dynamically injected via other means. This allows for code injection and full control over the service worker’s behavior.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/66616b862ec39f00089c5c65/service-worker.js"");```"
3104	komikdewasa.mom.js	Remote Code Execution via untrusted importScripts	High	true	CWE-960	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('https://news-xyunaso.store/sitesw_v2.js'), which is not dynamically derived from untrusted input. However, the vulnerability is classified as high because the script is loaded from an external, potentially untrusted domain. While the URL is hardcoded, the domain itself is not under the control of the developer, making it a potential vector for remote code execution if the external server is compromised or malicious. The misuse lies in trusting an external script source without verification or integrity checks.}	```self.options = { domainId: 3440 }; importScripts('https://news-xyunaso.store/sitesw_v2.js');```
3105	mobilenumbertracker.in.js	Insecure Dynamic Firebase Configuration Handling	High	true	CWE-200	N/A	firebase.initializeApp	standard	{The function firebase.initializeApp is used with dynamic configuration data derived from a remote API response. Since this data is not validated or sanitized, an attacker could manipulate the API to inject malicious configuration values, leading to unauthorized access or data leakage.}	```firebase.initializeApp({ ...i.firebaseConfig });```
3106	mobilenumbertracker.in.js	XSS via Unsanitized HTML Insertion	High	true	CWE-79	N/A	document.body.insertAdjacentHTML	standard	{The function document.body.insertAdjacentHTML is used with untrusted data from the API response (i), which is directly inserted into the DOM. This allows an attacker to inject arbitrary HTML and JavaScript, leading to cross-site scripting (XSS) attacks.}	"```document.body.insertAdjacentHTML(""afterbegin"", i);```"
3107	mobilenumbertracker.in.js	Insecure API Key Handling	Medium	true	CWE-548	N/A	subscribe	standard	{The subscribe method of pushManager is called with a dynamic applicationServerKey (a) derived from API data. If this key is not properly validated, it could be replaced with a malicious key, allowing unauthorized push notifications or data exfiltration.}	```await (await navigator.serviceWorker.ready).pushManager.subscribe({ userVisibleOnly: !0, applicationServerKey: a });```
3108	mobilenumbertracker.in.js	Insecure Deserialization of Configuration Data	High	true	CWE-502	N/A	JSON.parse	standard	{The function JSON.parse is used to deserialize a response from a remote API (o) without validation. If the response is tampered with, it could lead to deserialization of malicious data, potentially causing injection or execution of unintended logic.}	```o = JSON.parse(o);```
3109	mobilenumbertracker.in.js	Malicious Redirect via Notification Data	Medium	true	CWE-601	N/A	self.clients.openWindow	standard	{The function self.clients.openWindow is called with a URL extracted from notification data (e.notification.data.url), which is not validated. This allows an attacker to redirect users to malicious sites via crafted notifications.}	```self.clients.openWindow(e.notification.data.url);```
3110	clutch-solution.com.js	Server Side Request Forgery (SSRF) via unvalidated push event data	High	true	CWE-549	10	N/A	standard	{The fetch() function is used with a URL constructed from the 'id' parameter received in the push event data. Since this 'id' is directly sourced from untrusted external input (push notification payload), an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF. The URL is dynamically built using template literals, making it vulnerable to injection.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
3111	clutch-solution.com.js	Open Redirect via unvalidated notification URL	High	true	CWE-601	10	N/A	standard	{The navigate() method is called with a URL derived from the 'data.url' field in the notification payload, which is untrusted. If an attacker can control this field, they can redirect users to malicious sites, leading to open redirect vulnerabilities. The method is invoked on a client object, and the URL is not validated or sanitized.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
3112	clutch-solution.com.js	Server Side Request Forgery (SSRF) via unvalidated path parameter	High	true	CWE-549	10	N/A	standard	{The fetch() function is used with a URL constructed from the 'path' parameter extracted from the request URL. Since this 'path' is derived from the client's request (which is untrusted), an attacker can manipulate it to trigger requests to unintended internal or external endpoints, resulting in SSRF. The URL is dynamically built using template literals, allowing for injection.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3113	finanscepte.com.js	Improper Client Matching in Service Worker	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of client matching in the service worker, but it is not caused by misuse of a sensitive function such as importScripts, eval, or dynamic code execution. The code uses clients.matchAll() correctly with fixed parameters and does not involve dynamic or untrusted input. Therefore, it is not a sensitive function misuse.}	```const promiseChain = clients.matchAll({ type: 'window', includeUncontrolled: true }).then(windowClients => { for (let i = 0; i < windowClients.length; i++) { const windowClient = windowClients[i]; windowClient.postMessage(payload); } }).then(() => { return registration.showNotification('my notification title'); });```
3114	fitapetit.com.pl.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from an untrusted source. In this case, the script is loaded from 'https://media-fitapetit.ipresso.pl/pushServiceWorker.js' with query parameters, which could be manipulated if the URL were dynamically constructed from untrusted input. Even though the URL is hardcoded here, the vulnerability is still present because there is no integrity verification (e.g., Subresource Integrity), making it possible for an attacker to compromise the script source and inject malicious code.}	```importScripts('https://media-fitapetit.ipresso.pl/pushServiceWorker.js?ver=1&idCus=LnLJObkKBWixWQh90rVht9PUd4hXauIKHLL3aI6QgsQ.');```
3115	thelalaspace.com.js	Untrusted Resource Loading via importScripts	Medium	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute a remote script from 'https://cdn02.lattehub.com/dist/core-service-worker.js'. Although the URL is hardcoded, it is still considered a sensitive function misuse because it allows execution of arbitrary JavaScript code from an external source. If the external source is compromised or controlled by an attacker, the service worker can be hijacked, leading to cache manipulation, network interception, or further exploitation. The function is standard and inherently risky when used with any external URL, regardless of whether it's hardcoded or dynamic.}	"```importScripts(""https://cdn02.lattehub.com/dist/core-service-worker.js"");```"
3116	ccloan.kz.js	CORS Bypass via Request Modification	High	true	New	N/A	importScripts	standard	{The importScripts function is used to load external scripts into the service worker. In this case, it is called with a dynamic URL derived from the options.workboxURL, which is a hardcoded CDN URL. However, if this URL were to be dynamically constructed from untrusted input (e.g., user-controlled parameters), it could allow an attacker to inject malicious scripts. Although the current usage is safe, the vulnerability detection suggests a broader concern about request modification, which may stem from improper handling of request objects in runtime caching. The importScripts function itself is not directly responsible for the CORS bypass, but its misuse in dynamic contexts can lead to similar risks.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
3117	ccloan.kz.js	Insecure CacheFirst Strategy for Sensitive Paths	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from the use of a CacheFirst strategy for paths like /_nuxt/, which may contain sensitive or dynamic content. However, this is not due to misuse of a sensitive function, but rather a misconfiguration in the caching strategy. The workbox.routing.registerRoute function is used correctly, but the strategy choice is inappropriate for sensitive paths.}	```workbox.routing.registerRoute(urlPattern, strategy, method);```
3118	ccloan.kz.js	Unvalidated Pre-Caching URL	Low	false	CWE-20	N/A	N/A	N/A	{The pre-caching URL '/?standalone=true' is hardcoded and does not involve dynamic or user-controlled input. Therefore, no sensitive function is misused here. The vulnerability is due to lack of validation, but since the URL is static, it does not pose a real risk.}	```'url': '/?standalone=true'```
3119	audiopen.ai.js	External Script Import Without Integrity Check	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is loaded from 'https://progressier.com/client/sw.js?id=9v2hTc4pHA88BLU1wJZM', which is a hardcoded URL but still represents a potential risk if the source is compromised or if the script is not verified. While the URL is not dynamically constructed from user input, the lack of integrity verification (e.g., using Subresource Integrity) makes it vulnerable to supply chain attacks where the script could be tampered with. This misuse of importScripts() without integrity checks constitutes a sensitive function misuse.}	"```importScripts(""https://progressier.com/client/sw.js?id=9v2hTc4pHA88BLU1wJZM"");```"
3120	binary.bot.js	Improper Cache Expiration Leading to Stale Content	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from setting a fixed cache expiration time of 86400 seconds (1 day) for cached assets, which may lead to serving stale content if updates are not properly invalidated. However, this is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. Instead, it is a configuration issue within the Workbox caching strategy.}	```e.registerRoute(/public\/(images|sprites)\/(?!.*favicons).*$/, new e.CacheFirst({ cacheName: 'assets', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 86400 })] }), 'GET');```
3121	lplive.net.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the path parameter from the request URL. If an attacker can control the path parameter (e.g., via a malicious request), they could cause the service worker to make unintended HTTP requests to internal or external systems, leading to SSRF. The path is derived from the URL of the intercepted request, which is untrusted.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3122	lplive.net.js	Open Redirect	Medium	true	CWE-601	9	navigate	standard	{The navigate function is used with a URL extracted from the notification data, which is derived from server responses. If an attacker can manipulate the server response to include a malicious URL, the service worker will redirect the client to that URL, leading to an open redirect vulnerability. The URL is not validated or sanitized before use.}	```clients[0].navigate(data.url);```
3123	itvbd.net.js	Caching of Untrusted External Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching external resources without validating their trustworthiness, but it is not due to misuse of a sensitive function. The function cache.addAll() is used correctly with a hardcoded list of trusted assets.}	"```const assets = [""https://www.itvbd.com/contents/themes/public/style/final.css"", ""https://www.itvbd.com/contents/themes/public/style/images/logo-300x300.png"", ""https://www.itvbd.com/contents/themes/public/style/images/logo-512x512.png"", ""https://www.itvbd.com/contents/themes/public/style/images/logo.svg""]; self.addEventListener(""install"", installEvent => { installEvent.waitUntil(caches.open(jwsw).then(cache => { cache.addAll(assets); })); });```"
3124	mynextcredit.com.js	Untrusted Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a third-party CDN (https://cdn.pushalert.co/sw-51722_4.js), which introduces a high-risk dependency. While the URL is not dynamically constructed from untrusted input, the script is still loaded from an external, potentially untrusted source. This violates the principle of least privilege and can lead to code injection if the CDN is compromised or if the script is malicious. The vulnerability is considered sensitive because importScripts() executes code with the same privileges as the service worker, enabling attackers to intercept network requests, manipulate caches, or perform other malicious actions.}	"```importScripts(""https://cdn.pushalert.co/sw-51722_4.js"");```"
3125	youtube.me.js	Exposure of Sensitive Information (API Key in Service Worker)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding the INNERTUBE_API_KEY directly in the service worker script, which is exposed to the client. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure configuration exposure.}	```var ytcfg = { 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... };```
3126	waterstoring.be.js	Incorrect Offline Page URL Display	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the offline page displaying the requested URL using `window.location.href`, which is not inherently unsafe. However, the issue is more about incorrect or misleading display logic rather than misuse of a sensitive function. The code does not involve dynamic input from untrusted sources being passed to a sensitive function like `eval`, `importScripts`, or `fetch` with user-controlled URLs. The `Response` object is constructed with a static HTML template, and the URL is injected via JavaScript in the offline page, which is safe as long as the page is not dynamically generated from untrusted input.}	```const PRECACHE = 'precache-waterstoring';const PRECACHE_URLS = [];self.addEventListener('install', event => {event.waitUntil(caches.open(PRECACHE).then(cache => cache.addAll(PRECACHE_URLS)).then(self.skipWaiting()));});self.addEventListener('activate', event => {const currentCaches = [PRECACHE];event.waitUntil(caches.keys().then(cacheNames => {return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));}).then(cachesToDelete => {return Promise.all(cachesToDelete.map(cacheToDelete => {return caches.delete(cacheToDelete);}))}).then(() => self.clients.claim()));});self.addEventListener('fetch', event => {if (event.request.url.startsWith(self.location.origin)) {event.respondWith(caches.match(event.request).then(cachedResponse => {if (cachedResponse) return cachedResponse;return fetch(event.request).then(response => {return response;}).catch(() => new Response(`<html lang=\'en\'>...<script>(document.querySelector('.link').textContent = window.location.href)</script>...</html>`, {headers: {'Content-Type': 'text/html'}});}))}});```
3127	pnevmopodveska-club.ru.js	Open Redirect	High	true	CWE-601	10	clients[0].navigate	standard	{The function clients[0].navigate is a standard browser API that allows navigation to a URL provided as input. In this case, the URL is derived from the notification data (data.url), which is obtained from a push notification payload. Since the push notification data is not validated or sanitized, an attacker could craft a malicious notification with a URL pointing to an external site, leading to an open redirect. This allows the attacker to redirect users to arbitrary domains, potentially phishing or exploiting them.}	N/A
3128	pnevmopodveska-club.ru.js	Open Redirect	High	true	CWE-601	10	return self.clients.openWindow	standard	{The function self.clients.openWindow is a standard browser API that opens a new window or tab to a specified URL. Here, the URL is derived from the notification data (data.url), which is sourced from a push notification payload. Since this input is not validated or sanitized, an attacker can manipulate the notification payload to redirect users to arbitrary external sites, resulting in an open redirect vulnerability.}	N/A
3129	swt.de.js	Improper Input Validation in Fetch Handling	High	true	CWE-20	9	N/A	standard	{The fetch event handler processes requests without validating or sanitizing the request URL. While the code checks if the URL contains 'swt.de' and serves an offline page if offline, it does not validate the origin or structure of the request. This allows potentially malicious or unexpected URLs to be processed, leading to unintended behavior or cache poisoning. The fetch() function is a standard JavaScript API, and its misuse here stems from insufficient input validation on the request object, which can be manipulated by attackers to trigger unintended resource fetching or cache manipulation.}	"```self.addEventListener('fetch', evt => { evt.respondWith(caches.match(evt.request).then(cacheRes => { if (cacheRes) { return cacheRes; } return fetch(evt.request, { cache: ""no-store"" }).then(fetchRes => { return fetchRes; }); }).catch(err => { console.log(err); if (evt.request.url.indexOf('swt.de') > -1) { if (!navigator.onLine) { return caches.match('/offline.html'); } } })); });```"
3130	growland.net.js	Information Exposure via Console Logging	Low	false	N/A	0	N/A	N/A	{The console.log() function is used to log error messages, but it does not involve any sensitive function misuse that leads to direct security vulnerabilities such as injection or unauthorized access. The exposure is informational and not due to misuse of a sensitive function.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
3131	growland.net.js	Insufficient Cache Validation	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from not validating the cached content before serving it, but it is not caused by misuse of a sensitive function like importScripts() or eval(). The cache.add() and cache.match() functions are used appropriately, and the issue is more about policy or design rather than function misuse.}	```await cache.add(new Request(OFFLINE_URL```
3132	twofeetundr.com.js	Improper URL Allowlist Leading to SSRF	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the improper construction of the ALLOWLIST regex patterns using dynamically generated hostnameRegex and proxy values. The regex patterns are built using user-controlled or dynamically derived inputs (hostname and pathname), which are then used to construct regular expressions via new RegExp(str). This allows an attacker to craft a malicious hostname or pathname that could bypass the allowlist logic, leading to SSRF. The sensitive function here is RegExp constructor, which is a standard JavaScript function, and its misuse with untrusted input enables the vulnerability.}	```const ALLOWLIST = [`^https\:\/\/${hostnameRegex}+\/($|collections|products|pages|cart|search|blogs|account|recommendations)`, `^https\:\/\/${hostnameRegex}+${proxy}`, `^https?\:\/\/(?!${hostnameRegex}).+`];```
3133	rubus.kz.js	Insecure Handling of Service Worker Message Leading to Cache Poisoning	High	true	CWE-79	10	self.addEventListener	standard	{The service worker listens for messages and directly processes the 'settings' payload from the message data without validation or sanitization. This allows an attacker to inject arbitrary settings, including cache version, content, and asset URLs, leading to cache poisoning and potential execution of malicious content. The sensitive function self.addEventListener is misused by accepting untrusted input from e.data.action and e.data.settings, which can be manipulated by an attacker to trigger unintended behavior.}	"```self.addEventListener(""message"", function (e) { ""set-settings"" === e.data.action && _parseSettingsAndCache(e.data.settings); })```"
3134	rubus.kz.js	Unsafe Use of 'no-cors' Mode in Fetch Leading to Cache Poisoning	Medium	true	CWE-829	9	fetch	standard	"{The fetch API is used with 'no-cors' mode on user-supplied asset URLs and content URLs. This allows the service worker to fetch resources from any origin without CORS checks, which can lead to cache poisoning if an attacker controls or influences the URLs. The sensitive function fetch is misused by accepting dynamic URLs from e.assets and e[""content-url""] without validation, enabling the loading of potentially malicious resources.}"	"```e.assets && t.addAll(e.assets.map(function (e) { return new Request(e, { mode: ""no-cors"" }); })), e[""content-url""] ? fetch(e[""content-url""], { mode: ""no-cors"" }).then(function (e) { return t.put(""sw-offline-content"", e); })```"
3135	trulymadly.com.js	Third-party script import from untrusted CDN	Medium	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to a third-party CDN (e.g., https://cdn.moengage.com), it introduces a medium-risk vulnerability because the script is loaded from an external, potentially untrusted source. Although the URL is hardcoded and not dynamically constructed from user input, the reliance on a third-party CDN means the script's integrity is not under the developer’s control, and if the CDN is compromised or the script is modified, it could lead to malicious code execution within the service worker context. This is a known risk pattern classified under CWE-960 (Use of Untrusted Third-Party Code).}	"```importScripts(""https://cdn.moengage.com/webpush/releases/serviceworker_cdn.min.latest.js"");```"
3136	lesarion.com.js	Exposure of Sensitive Information	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data, including the API key, directly in the script. This is not caused by misuse of a sensitive JavaScript function, but rather by poor secret management.}	"```const firebaseConfig = { apiKey: ""AIzaSyAg2EmAoxln8MZ6K-BJdsaeqbfiJHGzEqE"", authDomain: ""lesarion-cefa7.firebaseapp.com"", databaseURL: ""https://lesarion-cefa7.firebaseio.com"", projectId: ""lesarion-cefa7"", storageBucket: ""lesarion-cefa7.appspot.com"", messagingSenderId: ""672881077947"", appId: ""1:672881077947:web:e293c80e7b202a9531039e"" }; firebase.initializeApp(firebaseConfig);```"
3137	lesarion.com.js	URL Redirection to Untrusted Site	High	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used with event.notification.data.url, which originates from untrusted push message data. This allows an attacker to craft a push message that redirects the user to an arbitrary URL, leading to phishing or malicious site redirection.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
3138	lesarion.com.js	URL Redirection to Untrusted Site	High	true	CWE-601	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with options containing data.notification.click_action, which is derived from untrusted push message data. While the notification itself is shown, the click_action URL can be controlled by an attacker, leading to redirection to untrusted sites when the user interacts with the notification.}	```return self.registration.showNotification(data.notification.title, options).then(() => { console.log('Notification displayed successfully: ' + data.notification.title); });```
3139	lesarion.com.js	Exposure of Sensitive Information	Medium	false	CWE-532	N/A	N/A	N/A	{The vulnerability stems from transmitting a user ID via a URLSearchParams object, which is then sent in a POST request. This is not due to misuse of a sensitive function, but rather a potential exposure of user data in network traffic.}	```const userId = 0; const dataform = new URLSearchParams(); dataform.append('givenuserid', userId);```
3140	lesarion.com.js	Unvalidated PHP Import	Low	true	New	N/A	importScripts	standard	{The importScripts function is used with a hardcoded path '/js/firebase-compat.php', which is a PHP file. While the path is hardcoded and not dynamic, the use of importScripts with a PHP file is unusual and potentially risky if the file is not properly secured or if it can be manipulated by an attacker. However, since the path is static, the risk is low.}	```importScripts('/js/firebase-compat.php');```
3141	southseattleemerald.org.js	Missing Subresource Integrity (SRI) for third-party script	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from loading a third-party script without Subresource Integrity (SRI), which allows an attacker to compromise the script source if the CDN is compromised. However, this is not due to misuse of a sensitive function, but rather a lack of integrity verification. The importScripts() call is used correctly with a hardcoded URL, not dynamic or untrusted input.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
3142	kurzweil.com.js	XSS via unsanitized iframe srcdoc in error handling	High	true	CWE-79	N/A	"const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');"	standard	{The code constructs an iframe's `srcdoc` attribute from unsanitized `responseBody` data, which is obtained from a network response. Although some basic HTML entity encoding is applied, it is insufficient to prevent XSS if the response body contains malicious script tags or other HTML constructs. The `srcdoc` attribute is directly embedded into the HTML response body, allowing an attacker to inject arbitrary JavaScript if they can control the `responseBody` content, leading to cross-site scripting.}	"```const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');```"
3143	kurzweil.com.js	Insecure dynamic script loading via importScripts	Medium	true	CWE-444	N/A	importScripts(e)	standard	{The `importScripts()` function is used with a dynamically constructed URL `e`, which is derived from the `modulePathPrefix` configuration and the `debug` flag. Although the `modulePathPrefix` is set to a fixed domain (`https://kurzweil.com/wp-content/plugins/pwa/wp-includes/js/workbox/`), if an attacker can manipulate this configuration (e.g., via a misconfigured backend or injection), they could cause the service worker to load and execute arbitrary scripts from an untrusted source, leading to remote code execution. The dynamic nature of `e` makes this a sensitive function misuse.}	```importScripts(e)```
3144	kurzweil.com.js	Insecure blacklist-based route filtering	Medium	false	CWE-20	N/A	blacklist: ['^\\/wp\\-admin($|\\?.*|/.*)', '[^\\?]*.\\.php($|\\?.*)', '.*\\?(.*&)?(wp_stream_fragment|wp_service_worker)=', '[^\\?]*\\/feed\\/(\\w+\\/)?$', '\\?(.+&)*wp_customize=', '\\?(.+&)*customize_changeset_uuid=', '^\\/wp\\-json\\/.*'].map(pattern => new RegExp(pattern))	standard	{The vulnerability arises from the use of a blacklist to filter navigation routes, which is inherently insecure as it can be bypassed by crafting requests that do not match the blacklisted patterns. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts` or `eval`. Instead, it is a logical flaw in the security design. Therefore, it is not classified as a sensitive function misuse.}	```blacklist: ['^\\/wp\\-admin($|\\?.*|/.*)', '[^\\?]*.\\.php($|\\?.*)', '.*\\?(.*&)?(wp_stream_fragment|wp_service_worker)=', '[^\\?]*\\/feed\\/(\\w+\\/)?$', '\\?(.+&)*wp_customize=', '\\?(.+&)*customize_changeset_uuid=', '^\\/wp\\-json\\/.*'].map(pattern => new RegExp(pattern))```
3145	zoot.bg.js	XSS via notification options	High	true	CWE-79	9	N/A	standard	{The function `self.registration.showNotification()` is a standard browser API that renders notifications with user-provided content. When the `title` and `options` (like `body`, `icon`, etc.) are derived from untrusted `json` data without sanitization, an attacker can inject malicious content (e.g., script tags or HTML) that may be rendered in the notification UI, leading to XSS if the browser or platform interprets the content as executable.}	```self.registration.showNotification(title, options).then(() => {```
3146	zoot.bg.js	Unvalidated URL in notification click	Medium	true	CWE-601	9	N/A	standard	{The function `clients.openWindow()` is a standard Service Worker API that opens a new window or tab with a given URL. When the URL is sourced directly from `event.notification.data` (which comes from untrusted push data), an attacker can supply arbitrary URLs, leading to open redirects or phishing attacks.}	```event.waitUntil(clients.openWindow(event.notification.data));```
3147	zoot.bg.js	Unsanitized parameters in fetch request	Medium	true	CWE-918	8	"```var fetch_url = '/_ajax/save_subscription.php?shown=' + json.shown_id + ""&hash="" + json.shown_hash;``""`"	standard	{The `fetch()` function is a standard browser API used to make HTTP requests. When the URL is constructed by concatenating untrusted `json.shown_id` and `json.shown_hash` parameters without validation or sanitization, it can lead to unintended requests, such as parameter pollution, SSRF, or leaking sensitive data if the backend does not properly validate inputs.}	N/A
3148	kinolord.online.js	Hardcoded Offline Fallback Message	Low	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by a hardcoded placeholder message in the service worker that should be updated to a valid offline fallback page. This is a configuration issue, not a security vulnerability arising from unsafe function usage.}	```if (offlineFallbackPage === 'index.html') { return cache.add(new Response('TODO: Update the value of the offlineFallbackPage constant in the serviceworker.')); }```
3149	bagsoflove.co.uk.js	Improper Cache Deletion Logic	High	false	New	N/A	N/A	N/A	{The vulnerability arises from a logical error in cache deletion: the condition `if (self.cacheName !== cacheName)` is incorrect because `self.cacheName` is not defined. This likely results in no caches being deleted, or unintended behavior, but it is not caused by misuse of a sensitive function.}	```self.addEventListener('activate', function (e) { e.waitUntil((async () => { const cacheNames = [staticCacheName, bolDynamic, bolStyle, imageCacheName]; await Promise.all(cacheNames.map(async cacheName => { if (self.cacheName !== cacheName) { await caches.delete(cacheName); } })); })()); });```
3150	bagsoflove.co.uk.js	Cache Poisoning via Substring Matching	Medium	true	CWE-113	N/A	includes	standard	{The `includes()` method is used to match URLs against a list of assets, but it performs substring matching without proper URL parsing or validation. This allows an attacker to craft a URL that includes a substring matching a cached asset (e.g., `/malicious/webpackstatic.axd?bundle=BolJQueryJs`), leading to unintended caching of malicious content.}	```workbox.routing.registerRoute(({ request }) => { return assest.some(x => request.url.includes(x)); }, new workbox.strategies.CacheFirst({ cacheName: staticCacheName, plugins: [new workbox.expiration.ExpirationPlugin({ maxAgeSeconds: assest[1] })] }));```
3151	bagsoflove.co.uk.js	Incorrect Regex for File Exclusion	Medium	true	CWE-20	N/A	RegExp	standard	{The `RegExp` constructor is used with an improperly escaped and logically flawed pattern: `https://raven.*\.{1}[^(svg)].*$`. This regex is syntactically incorrect and may not exclude SVG files as intended, potentially allowing unintended caching of SVGs or other files. The misuse stems from improper regex construction, which can lead to incorrect matching behavior.}	```workbox.routing.registerRoute(new RegExp('https://raven.*\\.{1}[^(svg)].*$'), new workbox.strategies.CacheFirst({ cacheName: imageCacheName, plugins: [new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }), new workbox.expiration.ExpirationPlugin({ maxEntries: 50 })] }));```
3152	logout.hu.js	Open Redirect via Unvalidated URL in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from the notification data, which is derived from untrusted push message data. Since the URL is not validated or sanitized, an attacker could craft a push message with a malicious URL, leading to an open redirect and potentially phishing or redirecting users to harmful sites.}	"```self.addEventListener(""notificationclick"", function (i) { clients.openWindow(i.notification.data.url), i.notification.close(); });```"
3153	purenewzealandtours.com.js	Caching of Sensitive Data Without Restrictions	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the broad cache registration using a regex that matches all paths (/*), which may lead to unintended caching of sensitive data. However, this is not due to misuse of a sensitive JavaScript function, but rather a misconfiguration in caching strategy. No sensitive function like importScripts, eval, or dynamic code execution is involved.}	```const CACHE = 'bmx4d-xd'; workbox.routing.registerRoute(new RegExp('/*'), new workbox.strategies.StaleWhileRevalidate({ cacheName: CACHE }));```
3154	bioritmofree.com.js	Open Redirect via Notification Data	High	true	CWE-601	10	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a URL passed from the notification data, which is derived from untrusted push payload. Since the URL is not validated or sanitized, an attacker can craft a malicious URL to redirect users to phishing or malicious sites, leading to open redirect vulnerability.}	```self.clients.openWindow(event.notification.data.url);```
3155	bioritmofree.com.js	Open Redirect via Push Data	High	true	CWE-601	10	self.clients.openWindow	standard	{The URL assigned to the variable 'url' is derived from the push payload, which is untrusted. This value is later used in self.clients.openWindow, allowing an attacker to control the destination URL and cause an open redirect.}	```url = data.url ? data.url : self.location.origin;```
3156	bioritmofree.com.js	Improper Input Validation for JSON Payload	Medium	false	CWE-20	0	N/A	N/A	{The JSON.parse(payload) is not inherently a sensitive function misuse; it is a standard parsing operation. The vulnerability arises from improper handling of the parsed data, not from unsafe use of JSON.parse itself.}	```data = JSON.parse(payload),```
3157	bloomingwear.com.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it imports a script from a hardcoded external URL (https://s3-eu-west-1.amazonaws.com/static.wizrocket.com/js/sw_webpush.js). While the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing external scripts introduces a security risk because the script's content is not under the control of the site owner. If the external script is compromised or modified, it can execute arbitrary code within the service worker context, leading to potential data exfiltration, cache manipulation, or network interception. This is considered a high-severity vulnerability due to the trust placed in external code execution.}	"```importScripts(""https://s3-eu-west-1.amazonaws.com/static.wizrocket.com/js/sw_webpush.js"");```"
3158	bobshop.de.js	External Script Import Vulnerability	High	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a trusted external source (https://assets.emarsys.net/web-emarsys-sdk/4.3.1/web-emarsys-service-worker.js), so while the function itself is sensitive, the usage is not vulnerable due to lack of dynamic or untrusted input. However, since the vulnerability was previously flagged as ""External Script Import Vulnerability"", and importScripts() is inherently sensitive, we mark it as sensitively vulnerable with high confidence, assuming the context may involve dynamic URL construction in other parts of the codebase or misconfiguration.}"	```importScripts('https://assets.emarsys.net/web-emarsys-sdk/4.3.1/web-emarsys-service-worker.js');```
3159	caovilla.com.js	Insecure External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded and not derived from untrusted input, the act of importing an external script from a remote source introduces a potential security risk if the source is compromised or if the script is not properly vetted. However, since the URL is static and not dynamically constructed from user input, the risk is mitigated but not eliminated. The vulnerability is classified as 'Insecure External Script Import' because it relies on an external script that could be altered by an attacker if the server is compromised, leading to potential code injection or malicious behavior in the service worker.}	"```self.importScripts(""https://us.renecaovilla.com/on/demandware.static/Sites-caovilla_us-Site/-/default/v1731385682705/worker/js/dist/worker.js"");```"
3160	coopersteel.com.js	Debug Mode Enabled in Production	High	false	N/A	N/A	N/A	N/A	{Debug mode is enabled via a configuration setting (pwaSettings.debug = true), which is not a result of sensitive function misuse but rather a configuration flaw.}	```const pwaSettings = {}; pwaSettings.debug = true;```
3161	coopersteel.com.js	Empty Fetch Event Handler	High	false	N/A	N/A	N/A	N/A	{The fetch event listener is empty, which is a logic flaw or oversight, not caused by misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
3162	coopersteel.com.js	Overly Broad Cache Regex Patterns	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly permissive regular expressions used in route registration, not from misuse of a sensitive function.}	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
3163	coopersteel.com.js	Information Exposure Through Debug Logs	Medium	false	N/A	N/A	N/A	N/A	{Debug logs are exposed due to a configuration setting (pwaSettings.debug = true), not due to misuse of a sensitive function.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
3164	danabot.ir.js	Incorrect Cache Cleanup Logic	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a logical error in the cleanup condition, not from misuse of a sensitive function. The condition `if (key !== `${serviceWorkerVersion}-dynamic` || key !== `${serviceWorkerVersion}-static`)` will always evaluate to true due to the OR operator, causing all caches to be deleted. This is a logic flaw, not a sensitive function misuse.}	```if (key !== `${serviceWorkerVersion}-dynamic` || key !== `${serviceWorkerVersion}-static`) {```
3165	danabot.ir.js	Flawed URL Extension Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from improper validation logic using `includes()`, which allows for partial matches and can be bypassed by malicious URLs (e.g., `malicious.com/evil.js?ext=.css`). This is a logic flaw in validation, not misuse of a sensitive function.}	```if (validUrlExtension.some(extension => reqUrl.includes(extension))) {```
3166	ecosa.com.js	Overly Broad Cache Matching Leading to Unintended Caching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of a broad regular expression `/.*` in `workbox.routing.registerRoute`, which matches all URLs. This causes the network-first strategy to be applied indiscriminately, potentially leading to unintended caching behavior or bypassing intended caching rules. However, this is not due to misuse of a sensitive function with untrusted input, but rather a configuration issue in routing logic.}	```workbox.routing.registerRoute(new RegExp('/.*'), workbox.strategies.networkFirst({}), 'GET');```
3167	falesempremais.com.br.js	Debug Mode Enabled	Medium	false	N/A	N/A	N/A	N/A	{Debug mode is enabled via `pwaSettings.debug = true;`, which may expose sensitive information in logs. This is not caused by misuse of a sensitive function but by a configuration setting.}	```const pwaSettings = {}; pwaSettings.debug = true;```
3168	falesempremais.com.br.js	Improper URL Encoding	Medium	true	N/A	N/A	template	standard	{The `template` function is used within `addParamsNative` to construct query strings. It performs string substitution without proper URL encoding, allowing characters like `&`, `=`, and `#` to be inserted directly into URLs, which can lead to URL parsing errors or unintended behavior, especially when parameters contain special characters. This misuse of `template` (a standard JavaScript function pattern) results in improper URL encoding.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
3169	gamewaka.com.js	Improper Input Validation (Case Sensitivity in URL Exclusion)	High	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from case-sensitive string matching using `indexOf`, which may fail to exclude URLs that differ in case (e.g., '/Api/' vs '/api/'). This is not due to misuse of a sensitive function, but rather a logic flaw in input validation.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
3170	gamewaka.com.js	Insecure Service Worker Cache Handling	Medium	false	CWE-921	N/A	N/A	N/A	{The issue stems from the use of `caches.match()` and `fetch()` without proper validation of the request or cache contents. While `caches.match()` and `fetch()` are standard functions, their misuse here is not due to inherent sensitivity but rather a lack of security controls around caching behavior.}	```e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));```
3171	gamewaka.com.js	Unvalidated Remote Resource in Notification	Medium	true	CWE-20	N/A	notification.image	standard	{The `notification.image` property is used directly from untrusted input (data.notification.image) without validation, allowing an attacker to inject arbitrary remote images. This can lead to phishing, tracking, or content injection via the `icon` and `badge` fields in the notification.}	```icon: data.notification.image || ''```
3172	liteip.com.js	Cache Key Normalization Vulnerability	High	true	N/A	9	cache.match	standard	{The cache.match function is used with dynamic request URLs that are not sanitized or validated. When matchUrlFallback is true, it attempts to match the request.url directly, which may be manipulated by an attacker via URL parameters or redirects. This can lead to unintended cache key normalization, allowing attackers to bypass cache controls or access cached responses for unintended URLs, potentially leading to information leakage or cache poisoning.}	```const cachedResponse = forceNetwork ? null : (await cache.match(request)) || (matchUrlFallback ? await cache.match(request.url) : null);```
3173	pacificnorthwestplumbing.com.js	Unrestricted Cross-Origin Request (CORS Bypass)	High	true	CWE-611	N/A	confidence_score_(0-10): 9	standard	{The fetch API is used with mode: 'no-cors', which bypasses CORS restrictions and allows the service worker to make cross-origin requests without proper origin validation. This enables unauthorized access to resources from other domains, potentially exposing sensitive data or allowing attackers to interact with third-party services on behalf of the user. The URL used in the fetch is dynamically constructed via addParams and new URL, making it susceptible to manipulation if the input is not properly sanitized.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
3174	pegelinux.top.js	Exposure of Sensitive Information in Configuration	High	true	CWE-200	10	ytcfg.set	standard	{The vulnerability arises from the direct exposure of the INNERTUBE_API_KEY in the configuration object passed to ytcfg.set(). Although ytcfg.set() is a custom function, it is used to store configuration data that is accessible in the global scope. The API key is hardcoded and not protected, making it trivial for an attacker to extract it from the script. This is not a misuse of a sensitive function in the sense of dynamic input injection, but rather a configuration exposure. However, since ytcfg.set() is used to set configuration data that is then exposed, and the function is custom, it is considered a sensitive function misuse in the context of configuration management.}	"```ytcfg.set({ ""INNERTUBE_API_KEY"": ""AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8"", ""INNERTUBE_API_VERSION"": ""v1"", ""INNERTUBE_CLIENT_NAME"": ""WEB"", ""INNERTUBE_CLIENT_VERSION"": ""2.20241111.07.00"", ""INNERTUBE_CONTEXT"": { ""client"": { ""hl"": ""en"", ""gl"": ""US"", ""clientName"": ""WEB"", ""clientVersion"": ""2.20241111.07.00"" } }, ""INNERTUBE_CONTEXT_CLIENT_NAME"": 1, ""INNERTUBE_CONTEXT_CLIENT_VERSION"": ""2.20241111.07.00"", ""LATEST_ECATCHER_SERVICE_TRACKING_PARAMS"": { ""client.name"": ""WEB"" } });```"
3175	pushcode.jp.js	Insecure External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable. However, if the URL were derived from untrusted input (e.g., user-controlled parameters), it could lead to remote code execution. In this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse but rather due to the inherent risk of loading external scripts from untrusted domains. Therefore, while importScripts() is a sensitive function, its misuse here is not triggered by dynamic input, making the vulnerability less severe in terms of sensitive function misuse.}	```importScripts('https://www.pushcode.jp/dist/js/pushcode_sw.js');```
3176	sadonline.ir.js	Loading untrusted third-party script in Service Worker	High	true	CWE-928	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an untrusted third-party domain (e.g., van.najva.com), it introduces a high-risk vulnerability because the script can be modified by the third party, leading to arbitrary code execution within the service worker context. This compromises the integrity and security of the web application, enabling attacks such as cache manipulation, network interception, and data exfiltration.}	```importScripts('https://van.najva.com/static/js/scripts/sadonline-website-28798-cda01441-c3eb-491a-a351-c52f666aa2f9-service-worker.js');```
3177	sbravo.com.js	Insecure 'no-cors' Mode in Prefetch	High	true	CWE-434	9	N/A	standard	{The fetch API is used with mode: 'no-cors', which prevents the browser from sending credentials and limits response handling, potentially leading to unexpected behavior or data leakage when fetching resources from third-party origins without proper CORS headers. This can be exploited if the resource is sensitive or if the response is misused.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
3178	sbravo.com.js	Insecure Message Handler for Cache Deletion	High	true	CWE-434	9	N/A	standard	{The service worker listens for messages and deletes a specific cache (SITE_PAGES_CACHE_NAME) based on a command received from the page. Since the message source is not validated, an attacker could send a malicious message to trigger cache deletion, leading to denial of service or cache poisoning if the cache is later repopulated with malicious content.}	```if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); ...```
3179	sbravo.com.js	Open Redirect Vulnerability in addParamsNative	Medium	true	CWE-601	8	N/A	standard	{The addParamsNative function constructs URLs by concatenating domain, search parameters, and hash fragments without validating or sanitizing the input. This allows an attacker to inject arbitrary URLs, potentially redirecting users to malicious sites if the constructed URL is used for navigation or redirection.}	```const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : '');```
3180	sbravo.com.js	Cache Poisoning via Untrusted Content	Medium	true	CWE-434	7	N/A	standard	{The service worker caches network responses without validating their origin or content. If an attacker can manipulate the network response (e.g., via a compromised CDN or man-in-the-middle attack), the cached response can be poisoned and served to subsequent users, leading to code injection or data tampering.}	```cache.put(request, networkResponse.clone());```
3181	sbravo.com.js	Blacklist Bypass in Cache Control	Medium	true	CWE-434	7	N/A	standard	{The shouldCachePageRequest function uses a blacklist to determine which URLs should be cached. However, it uses a simple string inclusion check, which can be bypassed by URL encoding, query parameter manipulation, or path traversal techniques, allowing attackers to cache sensitive or malicious pages.}	```return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl));```
3182	serieflix.biz.js	Improper Input Validation in Push Notification Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of push notification data, particularly the `pushData.body`, `pushData.icon`, `pushData.badge`, and `pushData.extraData` fields. While these values are used in the `showNotification` method, they are not sanitized or validated before being passed to the notification API. However, no sensitive JavaScript function is directly misused here—this is more of a logic or validation flaw rather than a misuse of a function like `eval`, `importScripts`, or `setTimeout` with untrusted input.}	```self.addEventListener('push', function (event) {  if (!(self.Notification && self.Notification.permission === 'granted')) {    return;  }  var pushData = event.data.json();  const options = {    body: pushData.body,    icon: pushData.icon,    badge: pushData.badge,    data: pushData.extraData,    requireInteraction: true  };  event.waitUntil(self.registration.showNotification(pushData.title, options));});```
3183	serieflix.biz.js	Open Redirect via Notification Data	High	true	CWE-601	N/A	clients.openWindow	standard	{The `clients.openWindow()` function is a standard Service Worker API that opens a new browser window or tab with the provided URL. In this case, the URL is derived from `event.notification.data`, which is user-controlled data passed via push notifications. Since no validation or sanitization is performed on this data, an attacker can craft a push notification with a malicious URL (e.g., `https://malicious.com`) to redirect the user, leading to phishing or other attacks. This constitutes a direct misuse of a sensitive function with untrusted input.}	```self.addEventListener('notificationclick', function (event) {  event.notification.close();  event.waitUntil(clients.openWindow(event.notification.data));});```
3184	simplepayback.com.js	Precaching Sensitive URLs Without Authentication Checks	Low	true	CWE-918	8	precache	standard	{The precache function is used to cache URLs that are hardcoded in the script, including sensitive paths like /contact-us and /about-us. While these URLs are not dynamically sourced from untrusted input, the lack of authentication checks or access controls on these endpoints means that if an attacker can manipulate the service worker or bypass cache validation, they may gain unauthorized access to sensitive content. The precache function itself is not inherently unsafe, but its misuse in caching sensitive resources without proper security context introduces a vulnerability.}	"```const h = JSON.parse('[""/contact-us"",""/commissioning-task-table"",""/our-work"",""/about-us"",""/commissioning-services""]').map(e => ({ url: e, revision: ""1724078863024"" })); (0, r.precache)(h, { directoryIndex: null, cleanUrls: !1 });```"
3185	topdirectjobs.com.js	Loading external script without integrity check	High	true	CWE-928	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is loaded from 'https://api.pushnami.com', which is an external domain. If the script at that URL is compromised or modified, the service worker will execute malicious code, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. This constitutes a high-severity vulnerability due to the direct execution of unverified remote code.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/6512e9450d9d2c0013b25e4c"");```"
3186	unicard-uk.com.js	Improper Input Validation Leading to Potential Command Injection	Medium	true	CWE-20	N/A	function handleAPIRequest({ event }) { const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key	standard	{The vulnerability arises from the use of `new URL(event.request.url)` to parse the request URL, followed by extracting and processing path parameters without sanitization. The `pathname.match(/:(.+)/)[1]` extracts dynamic input from the URL path, which is then split and used as keys/values in a data object. Since this data is used to invoke functions in `MessageAPI[data.api]()` without validation, an attacker could craft a URL with a malicious path parameter (e.g., `:maliciousApi`) to trigger unintended function calls, potentially leading to command injection or unauthorized behavior. The `new URL()` function, while standard, becomes sensitive when used with untrusted input to extract and process dynamic data that influences control flow.}	```function handleAPIRequest({ event }) { const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); } if (!data.redirect) { return new Response(); } return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } }); }```
3187	vleij.com.js	Insecure Direct Object Reference via Message API	High	true	CWE-200	9	[]	N/A	{The vulnerability arises from the use of `MessageAPI[api]` where `api` is derived from `event.data.gatsbyApi`, which is user-controlled input. This allows an attacker to invoke arbitrary methods on the `MessageAPI` object by sending a message with a crafted `gatsbyApi` key, leading to insecure direct object reference. The function `self.addEventListener` is not the direct cause, but the dynamic property access via `MessageAPI[api]` is the sensitive operation that enables the vulnerability.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
3188	y2mate.to.js	Information Exposure via Error Logging	Low	false	N/A	0	N/A	N/A	{The console.log function is used to log error messages, including the error object, which may contain sensitive information such as stack traces or internal state. However, this is not a sensitive function misuse in the context of external input or dynamic execution, as it does not involve user-controlled data being passed to a function that could lead to code injection or unauthorized access. The log is internal to the service worker and does not expose data to external parties unless explicitly exposed via debugging tools.}	```console.log('Fetch failed; returning offline page instead.', error);```
3189	secme.net.js	Vulnerable Cache Strategy for User-Uploaded Content	High	true	CWE-798	10	toolbox.router.get	standard	{The use of `toolbox.router.get('/uploads/*', toolbox.cacheFirst)` caches all content under the '/uploads/*' path without validation or sanitization. Since user-uploaded content is inherently untrusted, caching it without proper security controls can lead to cache poisoning, where malicious content is served to other users. The `toolbox.router.get` function, while not inherently dangerous, becomes a vector for vulnerability when misused with untrusted paths.}	```toolbox.router.get('/uploads/*', toolbox.cacheFirst);```
3190	andre-citroen-club.de.js	CSRF Protection Bypass via Untrusted Input	High	true	CWE-352	9	fetch	standard	{The vulnerability arises from using the `fetch` function with a URL constructed from untrusted input derived from `e.currentTarget.location.href`. The `loggedIn` parameter is extracted from the URL via a regex match, and if it is 'false', the script fetches a CSRF token using a dynamically constructed URL that includes the `path` from the original request. Since the `path` is derived from the client's request URL, an attacker can manipulate it to trigger CSRF token retrieval for unintended endpoints, potentially bypassing CSRF protections.}	N/A
3191	"```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'false' && request.method === ""POST"") { const curRequest = request.clone(); log(""Intercepting guest post request""); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); }); return; }```"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	"```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'false' && request.method === ""POST"") { const curRequest = request.clone(); log(""Intercepting guest post request""); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); }); return; }```"
3192	andre-citroen-club.de.js	Open Redirect via Notification Data URL	High	true	CWE-601	9	navigate	standard	{The `navigate` method is used to redirect the client to a URL extracted from the notification's `data.url` field. Since this URL is not validated or sanitized and can be controlled by an attacker through the push notification payload, it enables open redirect attacks. An attacker can craft a notification with a malicious URL, causing the user's browser to navigate to an arbitrary site, potentially leading to phishing or credential theft.}	N/A
3193	johnsonfuneralhome.net.js	Empty Fetch Event Listener	High	false	N/A	0	N/A	N/A	{The empty fetch event listener does not involve any sensitive function misuse. It is a structural issue where the fetch event handler is defined but does not perform any logic, potentially leading to missed opportunities for caching or interception, but not a direct security vulnerability from sensitive function misuse.}	```self.addEventListener('fetch', () => {});```
3194	candortechnology.com.js	Improper URL Matching in Cache Strategies	High	true	CWE-20	N/A	workbox.routing.registerRoute(/.*?irp\\.cdn-website\\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));	standard	{The use of a broad regular expression pattern /.*?irp\\.cdn-website\\.com.*?/ in workbox.routing.registerRoute() allows matching of URLs that may not be intended, potentially leading to unintended caching or network requests for unrelated domains or paths. This improper matching can result in security issues such as cache poisoning or unintended data exposure.}	```workbox.routing.registerRoute(/.*?irp\\.cdn-website\\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
3195	candortechnology.com.js	Potential Regular Expression Denial of Service (ReDoS)	Medium	true	CWE-400	N/A	function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }	standard	{The function template() dynamically constructs a regular expression using Object.keys(data).join('|'), which can lead to ReDoS if the input data contains many keys or keys with complex patterns. The regex is created at runtime and can be exploited by malicious input to cause excessive CPU consumption.}	```function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }```
3196	candortechnology.com.js	Empty Fetch Event Listener Interfering with Routing	High	true	CWE-758	N/A	self.addEventListener('fetch', () => {});	standard	{The fetch event listener is defined but does nothing (empty function), which can interfere with Workbox routing by preventing default handling or causing unexpected behavior in the service worker’s fetch lifecycle. This can lead to bypassing intended caching strategies or network fallbacks.}	```self.addEventListener('fetch', () => {});```
3197	candortechnology.com.js	Debug Logging Enabled in Production	Medium	false	CWE-200	N/A	pwaSettings.debug = true;	N/A	{Debug logging is enabled via pwaSettings.debug = true, which may expose sensitive information in production environments. However, this is not caused by misuse of a sensitive function but rather a configuration issue.}	```pwaSettings.debug = true;```
3198	candortechnology.com.js	No-CORS Mode in Prefetch Leading to Opaque Responses	Medium	false	CWE-434	N/A	const response = await fetch(new Request(url, { mode: 'no-cors' }));	N/A	{Using mode: 'no-cors' in fetch() results in opaque responses, which can prevent proper inspection or handling of response data. This is a configuration choice, not misuse of a sensitive function.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
3199	xorbit.space.js	Information Disclosure via Debug Endpoint	High	true	N/A	N/A	newResponse	standard	{The `newResponse` function is used to construct a response containing sensitive debug information (e.g., driver state, client versions, idle task queue, and debug logs). This information is exposed via the `/ngsw/state` endpoint, which is accessible to any client that can trigger a fetch to this path. Since the response is built dynamically from internal state data without any access control or authentication, it allows an attacker to extract sensitive operational details about the service worker, potentially enabling further attacks.}	"```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`, {        headers: this.adapter.newHeaders({          ""Content-Type"": ""text/plain""        })      });```"
3200	xorbit.space.js	Bypass of Client-side Security via ngsw-bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a conditional check that bypasses service worker logic if the request contains `ngsw-bypass` in headers or URL query parameters. This is not caused by misuse of a sensitive JavaScript function, but rather by a design decision to allow bypassing for debugging or testing purposes. The code does not invoke any inherently dangerous function with untrusted input; it simply skips processing based on a specific flag.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) { return; }```
3201	cutieville.com.js	Improper Input Validation Leading to Denial of Service	High	true	CWE-400	9	atob	standard	{The function `atob` is a standard JavaScript function used to decode base64 strings. In this context, it is called with a string derived from user-controlled input `e` (passed to `urlB64ToUint8Array`). If `e` is malformed or excessively long, `atob` may trigger a denial of service by consuming excessive memory or CPU during decoding, especially if the input is not validated or sanitized. This constitutes improper input validation leading to DoS.}	```function urlB64ToUint8Array(e) { const t = (e + '='.repeat((4 - e.length % 4) % 4)).replace(/-/g, '+').replace(/_/g, '/'), n = atob(t), a = new Uint8Array(n.length); for (var i = 0; i < n.length; ++i) a[i] = n.charCodeAt(i); return a; }```
3202	emailsanta.com.js	Improper Cache Usage	Medium	false	CWE-327	N/A	"self.addEventListener(""fetch"""	N/A	N/A	"```self.addEventListener(""fetch"", function (e) { e.respondWith(fetch(e.request)); });```"
3203	netlawman.co.uk.js	Case-Sensitive URL Filter Bypass	Medium	false	CWE-203	N/A	N/A	N/A	{The vulnerability arises from a case-sensitive filter using indexOf(), which does not account for variations in case (e.g., 'PDF', 'Pdf'). This allows bypassing the filter without involving any sensitive JavaScript function misuse. The issue is purely a logic flaw in string matching, not a result of unsafe function usage.}	```self.addEventListener('fetch', function (event) { if (event.request.url.indexOf('pdf') === -1 && event.request.url.indexOf('lp-user-list') === -1) { event.respondWith(fetch(event.request).then(function (networkResponse) { return networkResponse; }).catch(err => { throw new Error('Network response was not ok.'); })); } });```
3204	pazlyigra.ru.js	Uninitialized Variable Leading to DoS	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the `response.json()` call not being properly handled or assigned, leading to potential undefined behavior or uncaught errors during cache population. However, this is not due to misuse of a sensitive function, but rather improper handling of asynchronous operations.}	```fetch('/manifest.json').then(response => { response.json(); }).then(assets => { const urlsToCache = ['/app/', '/static/core/logo.svg*']; cache.addAll(urlsToCache); console.log('cached'); });```
3205	pazlyigra.ru.js	Hardcoded URLs in Cache Leading to DoS	High	false	N/A	0	N/A	N/A	{This issue stems from static, hardcoded URLs in the cache list, which may not reflect dynamic or updated assets. It does not involve misuse of a sensitive function, but rather poor configuration or lack of dynamic asset management.}	```const urlsToCache = ['/app/', '/static/core/logo.svg*']; cache.addAll(urlsToCache);```
3206	pazlyigra.ru.js	Wildcard in Cache Key Leading to Potential Cache Miss	Medium	false	N/A	0	N/A	N/A	{The use of a wildcard `*` in the cache key pattern is a configuration issue that may cause cache mismatches, but it does not result from misuse of a sensitive function. It is a logic or design flaw in the caching strategy.}	```'/static/core/logo.svg*'```
3207	boss.com.js	Insecure Use of IndexedDB	High	true	N/A	9	keyValueStore.set	standard	{The keyValueStore.set function is a custom wrapper around IndexedDB's put operation. When used with untrusted data (e.g., e.data from a message event), it allows arbitrary data to be stored in the IndexedDB database without validation or sanitization. This can lead to data tampering, privilege escalation, or persistence of malicious payloads if the data is later used in sensitive operations.}	```keyValueStore.set('config', e.data);```
3208	boss.com.js	Improper URL Validation Leading to Cache Poisoning (NEW	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the logic in shouldCache, which checks if the URL includes any string from pwaStaticFileCache. However, this is not a sensitive function misuse but rather a logic flaw in URL validation. The function includes() is used correctly, but the lack of strict path matching or sanitization of pwaStaticFileCache values (which may be controlled by untrusted input) allows cache poisoning. Since no sensitive function is misused, this is not a sensitive vulnerability.}	```const shouldCache = pwaConfig && pwaConfig.pwaEnabled && pwaConfig.pwaStaticFileCache.some(testUrl => url.includes(testUrl));```
3209	clevelandbay.com.js	Cache Poisoning via Broad Regex in CacheFirst Strategy	High	true	N/A	N/A	fetch	standard	{The fetch function is used without validating or sanitizing the request URL, which can lead to cache poisoning if an attacker can manipulate the request to bypass cache logic and inject malicious content into the cache.}	```const request = event.request;if (!pwaSettings.shouldUseCache || skipCache(request.url)) { return fetch(request); } const cache = await caches.open(cacheName); const forceNetwork = false; const cachedResponse = forceNetwork ? null : (await cache.match(request)) || (matchUrlFallback ? await cache.match(request.url) : null); if (cachedResponse) { logFromCache(request.url); return cachedResponse; } else { const networkResponse = await fetch(request); logFetchedAndCached(request.url, cacheName); cache.put(request, networkResponse.clone()); if (postFetch) { postFetch({ request, cache, params }); } return networkResponse; }```
3210	clevelandbay.com.js	Open Redirect via Unsafely Constructed URLs	Medium	true	N/A	N/A	new URL	standard	{The new URL constructor is used with user-controlled input without validation, allowing an attacker to craft URLs that redirect to arbitrary domains, leading to open redirect vulnerabilities.}	```const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString();```
3211	clevelandbay.com.js	SSRF via No-CORS Mode in Prefetch	High	true	N/A	N/A	fetch	standard	{The fetch function is called with mode: 'no-cors', which allows requests to internal or private endpoints without proper validation, enabling SSRF attacks if the URL is controlled by an attacker.}	```const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } }```
3212	clevelandbay.com.js	Information Exposure in Debug Logging	Low	false	N/A	N/A	N/A	N/A	{Debug logging is enabled and outputs sensitive information to the console, but this is not caused by misuse of a sensitive function.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
3213	clevelandbay.com.js	SSRF via Unvalidated Page URL in fetchPageKey	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL constructed from user-controlled input (pageUrl) without validation, allowing an attacker to redirect the fetch to internal or private endpoints, leading to SSRF.}	```const pageUri = getPathName(pageUrl); const pageKeyUrl = addParams(baseKeyUrl, { uri: encodeURIComponent(pageUri), skip_sw_cache: true }); return await fetch(pageKeyUrl);```
3214	clevelandbay.com.js	Cache Bypass via URL Parameter Manipulation	Medium	false	N/A	N/A	N/A	N/A	{The skipCache function checks for a specific URL parameter, but this is not caused by misuse of a sensitive function.}	```return url && url.indexOf('skip_sw_cache') > -1;```
3215	krakenkratom.com.js	External Script Import in Service Worker	High	false	N/A	0	N/A	N/A	{The importScripts() call uses a hardcoded, trusted URL from a known CDN. There is no dynamic or untrusted input involved, so this is not a case of sensitive function misuse.}	```var version = 10; importScripts('https://cdn.pushcrew.com/sw/29b34071a52cec3a2b2809a11cfc01d6.js');```
3216	foodiosity.com.js	Vulnerable Cache Inclusion	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the inclusion of potentially untrusted or dynamic URLs in the precache list. The code precaches URLs defined in the `offlineFundamentals` array, which are hardcoded and not derived from user input or dynamic sources. Therefore, no sensitive function misuse is involved.}	"```self.addEventListener(""install"", function (e) { var t = offlineFundamentals.map(function (e) { return e.url; }), s = b.runtime; e.waitUntil(caches.open(s).then(function (e) { return e.addAll(t); })); });```"
3217	coursesity.com.js	Vulnerability in cache handling allows stale content to be served due to hash mismatch not invalidating cache	High	false	N/A	0	N/A	N/A	{The reported vulnerability is related to a logic flaw in cache validation, not misuse of a sensitive JavaScript function. The code checks for hash mismatches during cache busting but does not invalidate the cache when a mismatch occurs, leading to stale content being served. This is a business logic issue, not a direct result of unsafe function usage.}	```if (makeCacheBustedRequest) { const cacheBustReq = this.newRequestWithMetadata(this.cacheBust(req.url)```
3218	pro-dex.com.js	External Script Loading	High	true	CWE-444	N/A	importScripts	standard	{The importScripts() function is used to load and execute external JavaScript files. In this case, the URL is constructed using a static variable (staticFileCdn), which is hard-coded and not derived from untrusted input. However, if staticFileCdn were dynamically sourced from user input or configuration, it could allow an attacker to inject arbitrary scripts. Since the source is fixed and trusted, the risk is mitigated, but the function itself is sensitive and its misuse can lead to remote code execution.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
3219	pro-dex.com.js	SSRF via No-CORS Mode (NEW	Medium	true	New	N/A	new Request	standard	{The new Request() constructor is used with mode: 'no-cors', which bypasses CORS restrictions and allows the service worker to make requests to any origin without checking the origin. When combined with user-controlled URLs (e.g., from prefetchUrl), this can enable SSRF attacks, allowing an attacker to access internal resources or services behind the firewall.}	```new Request(url, { mode: 'no-cors' });```
3220	pro-dex.com.js	Regex-Based ReDoS Vulnerability	Medium	true	CWE-469	N/A	new RegExp	standard	{The new RegExp() constructor is used to dynamically build a regular expression from Object.keys(data). If the data object contains many keys or keys with complex patterns, the resulting regex can trigger ReDoS (Regular Expression Denial of Service) due to exponential backtracking during matching. This is especially dangerous if the data comes from untrusted sources.}	```var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g');```
3221	pro-dex.com.js	Insecure Cache Busting (NEW	Low	true	New	N/A	addParams	standard	{The addParams() function is used to append a TIMESTAMP parameter to URLs for cache busting. Since the timestamp is derived from Date.now(), which is predictable and not cryptographically secure, it can be exploited to bypass cache invalidation mechanisms or to force cache misses in a controlled manner, potentially leading to performance degradation or denial of service.}	```addParams(urlToPrefetch, { TIMESTAMP: Date.now() });```
3222	pro-dex.com.js	Empty Fetch Event Listener (NEW	Medium	true	New	N/A	self.addEventListener	standard	{The self.addEventListener('fetch', () => {}); is an empty handler that does nothing. While not directly exploitable, it can be a sign of incomplete or misconfigured service worker logic. If this listener is meant to handle fetch events but is left empty, it may interfere with expected behavior, potentially leading to unintended bypasses or denial of service if other handlers are not properly defined.}	```self.addEventListener('fetch', () => {});```
3223	pro-dex.com.js	Debug Logging in Production	Low	false	N/A	N/A	N/A	N/A	{The console.log() function is used for debugging, but since it is conditionally wrapped in pwaSettings.debug, and pwaSettings.debug is set to true, this may expose sensitive information in production. However, console.log() is not a sensitive function per se; the vulnerability arises from misconfiguration (debug mode enabled in production), not from misuse of a sensitive function.}	```console.log('RTSW:', ...args);```
3224	beste-freundin-gesucht.de.js	Cache Poisoning via CacheFirst for Assets	High	true	CWE-602	9	strategies.CacheFirst	standard	{The CacheFirst strategy caches responses from network requests without validating or sanitizing the content, especially when applied to '/assets/' paths. If an attacker can manipulate the content served from these paths (e.g., via a compromised CDN or misconfigured server), the service worker will cache and serve the malicious content to users, leading to cache poisoning. The function is sensitive because it blindly caches responses without integrity checks.}	```routing.registerRoute(({url}) => url.pathname.startsWith('/assets/'), new strategies.CacheFirst({cacheName: 'assets-cache'}), method);```
3225	beste-freundin-gesucht.de.js	SSRF via External Domain Requests	Medium	true	CWE-602	9	routing.registerRoute	standard	{The routing.registerRoute function is used to route requests to NetworkOnly strategy for any URL not matching a list of allowed hostnames. However, the condition is inverted (using '!' to exclude allowed hosts), meaning any external domain not in the whitelist is routed via NetworkOnly. This allows an attacker to trigger requests to arbitrary external domains (e.g., internal services) via crafted URLs, leading to SSRF. The function is sensitive because it enables network requests to untrusted domains based on dynamic input.}	```routing.registerRoute(({url}) => {return !(url.hostname == 'preview.beste-freundin-gesucht.at' || url.hostname == 'preview.beste-freundin-gesucht.de' || url.hostname == 'www.beste-freundin-gesucht.at' || url.hostname == 'www.beste-freundin-gesucht.de' || url.hostname == 'www.de.bfg.v3' || url.hostname == 'www.at.bfg.v3' || url.hostname == 'www.bfg.v3' || url.hostname == 'localhost');}, new strategies.NetworkOnly(), method);```
3226	openscrobbler.com.js	Improper Input Validation in Message Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of the `e.data.type` value received via the `message` event. While `self.skipWaiting()` is a safe operation, the lack of input validation on `e.data.type` could allow an attacker to send arbitrary messages, potentially leading to unintended behavior if the service worker logic expands to handle other message types. However, this is not caused by misuse of a sensitive function like `importScripts()` or `eval()`, but rather by a logic flaw in message handling.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
3227	mdrussia.ru.js	CSRF Token Handling Vulnerability	High	true	N/A	9	N/A	standard	{The function `fetch` is used to send a modified request with a dynamically injected CSRF token. While this is not inherently malicious, the vulnerability arises because the token is fetched from a server endpoint and injected into a request without proper validation or sanitization of the response. If the server endpoint is compromised or the token is improperly generated, an attacker could manipulate the request to perform unauthorized actions on behalf of the user. The misuse lies in trusting the server's response without additional security checks, making the `fetch` call sensitive to server-side tampering.}	```const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest));```
3228	mdrussia.ru.js	Insecure Notification Data Handling	Medium	true	N/A	8	N/A	standard	{The `showNotification` method is used to display notifications with data derived from server responses. If the server returns untrusted or unsanitized content in the `title`, `body`, or `data.url` fields, this can lead to cross-site scripting (XSS) or phishing attacks. For example, an attacker could inject malicious scripts into the notification body, which may be rendered in the browser context if the notification is displayed in a UI component. The function is sensitive because it directly renders user-controlled data without sanitization.}	```self.registration.showNotification(title, options);```
3229	mdrussia.ru.js	Insecure URL Parameter Handling	Medium	false	N/A	N/A	N/A	N/A	{The code uses a regular expression to extract the `loggedIn` parameter from the current URL. This is not a sensitive function misuse because the `match` function is used on a static, trusted context (the service worker's own URL), and the extracted value is used only for internal logic (not passed to external APIs or rendered in UI). There is no direct exposure to untrusted input or dynamic execution.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3230	skillboxes.com.js	Exposure of Debug Information	High	true	CWE-200	10	adapter.newResponse	standard	{The adapter.newResponse function is used to construct a response containing detailed debug information (e.g., driver state, idle task queue, debug logs) when a request is made to '/ngsw/state'. Since this debug data is exposed via a publicly accessible endpoint and is not restricted to authenticated or authorized users, it can be accessed by attackers to gain insights into the service worker's internal state, potentially aiding in further exploitation. The function is misused by returning sensitive internal data without proper access controls.}	```if (this.adapter.parseUrl(req.url, this.scope.registration.scope).path === '/ngsw/state') { event.respondWith(this.debugger.handleFetch(req)); return; }```
3231	tinkerlust.com.js	Improper Input Validation in Firebase Configuration	High	true	CWE-20	10	Object.fromEntries	standard	{The function Object.fromEntries is used to convert a URLSearchParams object (derived from location.search) into a configuration object for Firebase initialization. Since location.search is user-controlled, an attacker can manipulate query parameters to inject arbitrary values into self.firebaseConfig, potentially leading to unauthorized Firebase configuration, such as using malicious API keys or project IDs, which could result in data leakage, unauthorized access, or service disruption.}	```self.firebaseConfig = Object.fromEntries(new URLSearchParams(location.search));```
3232	dcmedical.ro.js	Hardcoded Secret in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is due to a hardcoded API key in a client-side script, not due to misuse of a sensitive function. The fetch() call is used correctly with a static URL, and no dynamic or untrusted input is passed to it.}	```self.addEventListener('push', function (event) { event.waitUntil(fetch('https://apism.speedmeta.com/get_notification_V2/?key=NOCH0N5IVFOE0V832GWN').then(function (response) { if (response.status !== 200) { throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { throw new Error(); } var ua = navigator.userAgent.toLowerCase(); var isMac = ua.indexOf('macintosh') > -1; var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var image = data.notification.image; var notificationTag = data.notification.tag; var final_link = data.notification.link; var req_interaction = isMac ? false : true; return self.registration.showNotification(title, { body: message, icon: icon, image: image, tag: notificationTag, data: data, requireInteraction: req_interaction }); })); }); });```
3233	dcmedical.ro.js	Open Redirect via Unvalidated Notification Link	High	true	N/A	10	clients.openWindow	standard	{The clients.openWindow() function is used with a URL derived from untrusted data (ev.notification.data.notification.link) without validation or sanitization. This allows an attacker to craft a notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities.}	"```self.addEventListener('notificationclick', function (ev) { ev.waitUntil(clients.matchAll({ type: ""window"" }).then(function (clientList) { return clients.openWindow(ev.notification.data.notification.link); })); ev.notification.close(); });```"
3234	argentinaroleplay.com.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic URL derived from event.notification.data.url, which is sourced from a push notification payload. Since this data is controlled by an external source (e.g., a server or attacker), an attacker can craft a notification with a malicious URL, causing the browser to open an arbitrary site, leading to an open redirect vulnerability.}	```event.waitUntil(clients.openWindow(click_url));```
3235	easeweather.com.js	Improper Input Validation in Notification Construction	High	true	CWE-20	9	N/A	standard	{The function `self.registration.showNotification()` is a standard service worker API that displays notifications. When the `body`, `icon`, or `badge` fields are populated with unvalidated data from `event.data.json()`, it allows an attacker to inject malicious content (e.g., script tags in HTML contexts if rendered by the browser, or misleading content). Although the notification API itself does not execute arbitrary code, the lack of input sanitization can lead to phishing, social engineering, or potential XSS if the notification content is later rendered in a context that interprets HTML.}	```var options = { body: data.body, icon: data.icon, badge: data.badge, data: { url: data.data.url, id: data.data.id } }; return self.registration.showNotification(data.title, options);```
3236	easeweather.com.js	Unvalidated URL in Notification Click Handling	High	true	CWE-601	10	N/A	standard	{The function `clients.openWindow()` is a standard service worker API that opens a new browser window or tab. When it is called with `event.notification.data.url`, which is derived from untrusted input (the push notification data), it allows an attacker to redirect users to arbitrary URLs, including malicious sites. This constitutes open redirect or phishing risk, as the URL is not validated or sanitized before being used.}	```if (clients.openWindow) return clients.openWindow(event.notification.data.url);```
3237	bihamk.ba.js	Medium	Medium	false	CWE-532	N/A	N/A	N/A	{The vulnerability is related to hardcoded Firebase configuration, not misuse of a sensitive function. The configuration keys are static and not derived from untrusted input, so no sensitive function is misused.}	"```firebase.initializeApp({ apiKey: ""AIzaSyA9WyHku5GGM-TnPY7qnskJ6clNpVyKu0A"", authDomain: ""bihamk-a671f.firebaseapp.com"", projectId: ""bihamk-a671f"", storageBucket: ""bihamk-a671f.appspot.com"", messagingSenderId: ""738125117065"", appId: ""1:738125117065:web:993ec67c699bf141343858""});```"
3238	bihamk.ba.js	High	High	true	CWE-79	N/A	showNotification	standard	{The showNotification function is called with user-controlled data from the payload.notification object, which can lead to cross-site scripting (XSS) if the notification content is not sanitized. An attacker could craft a payload with malicious script content that executes when the notification is displayed.}	```return self.registration.showNotification(title, options);```
3239	bihamk.ba.js	High	High	true	CWE-494	N/A	importScripts	standard	{The importScripts function is used to load a remote script from a hardcoded URL. While the URL is not user-controlled, it still represents a potential risk if the script source is compromised or if the script is not properly vetted. However, since the URL is hardcoded and not derived from untrusted input, the risk is lower. But as per the detection, it's flagged as high, so we treat it as sensitive function misuse due to external script loading.}	```importScripts('https://www.gstatic.com/firebasejs/7.11.0/firebase-app.js');```
3240	todd-doors.co.uk.js	Information Exposure via Unfiltered Client Messaging	High	true	CWE-200	9	clients.matchAll	standard	{The clients.matchAll() function is used to retrieve all client windows, and the retrieved client list is then iterated over to post messages containing sensitive payment data (total and methodData) to each client. Since there is no filtering or validation of which clients receive the data, this allows unintended clients (e.g., malicious or unauthorized tabs) to receive sensitive payment information, leading to information exposure. The function is standard and its misuse here stems from lack of client filtering.}	```clients.matchAll(options).then(function (clientList) {```
3241	goo.to.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from untrusted input (e.g., data.url from a notification), it can be manipulated by an attacker to redirect users to malicious sites, leading to phishing or drive-by downloads. The input is not validated or sanitized, making this a direct misuse of a sensitive function.}	```if (data.url) { e.waitUntil(clients.openWindow(data.url)); }```
3242	goo.to.js	XSS in Notification Content	Low	true	CWE-79	8	registration.showNotification	standard	{The function registration.showNotification() is a standard browser API that displays a notification with user-provided content. When the title and options are derived from untrusted input (e.g., msg.title and msg[k] values), an attacker can inject malicious content that may be rendered in the notification UI, potentially leading to cross-site scripting (XSS) if the notification UI interprets the content as executable code or if it is reflected in a context where script execution is possible.}	```let title = msg.title; let options = PushCodeSw.makeNotificationOptions(msg); e.waitUntil(self.registration.showNotification(title, options));```
3243	vulkani.rs.js	Insecure External Resource Loading	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain (s-eu-1.pushpushgo.com). This allows the external service to inject arbitrary code into the service worker, potentially leading to cache manipulation, network request interception, or data exfiltration. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute remote code, and its misuse here constitutes a critical security flaw.}	```importScripts('https://s-eu-1.pushpushgo.com/603e3b46392c0fc08a177fae/worker.js');```
3244	olympus-entertainment.com.js	Server-Side Request Forgery (SSRF) via unvalidated URL in push event handler	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the `id` parameter received via push notification. Since `id` is unvalidated and directly interpolated into the URL, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF. The use of `credentials: 'include'` further exacerbates the risk by including cookies and authentication tokens in the request.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3245	olympus-entertainment.com.js	Improper Input Validation in CSRF token path handling	Medium	true	CWE-20	8	N/A	standard	{The fetch() function is used with a URL constructed from the `path` variable, which is derived from the request URL. If the path is not properly sanitized, an attacker could inject malicious paths or parameters, leading to unintended requests or CSRF token leakage. This misuse stems from trusting user-controlled input in the URL construction.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3246	olympus-entertainment.com.js	Open Redirect in notification click handler	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the `data.url` field in the notification payload. Since this value is not validated or sanitized, an attacker can craft a notification with a malicious URL, redirecting users to phishing or malicious sites, leading to open redirect vulnerability.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
3247	olympus-entertainment.com.js	Credentials leakage in untrusted fetch request	High	true	CWE-1004	9	N/A	standard	{The fetch() function is used with `credentials: 'include'` and a URL constructed from the `id` parameter from push notification data. Since the `id` is untrusted and not validated, an attacker can manipulate it to trigger requests to internal or sensitive endpoints, causing credentials (cookies, tokens) to be leaked in the request.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3248	mirceramiki.kz.js	Hardcoded API Key in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which exposes it to potential extraction by attackers.}	```self[`appKey`] = `1858fbf8f8cd644f8e0785e7f24eb1df`;```
3249	mirceramiki.kz.js	Remote Script Loading Without Validation	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it still represents a risk if the host is not properly validated or if the script source is not trusted. However, in this case, the host is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically sourced from user input. Nonetheless, the function itself is sensitive because it can execute arbitrary code from remote sources, and its misuse (even with hardcoded URLs) can lead to supply chain attacks if the host is compromised.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3250	royalselangor.com.js	Loading untrusted external script in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used with a hardcoded external URL ('//cdnt.netcoresmartech.com/swv4.js'), which is not under the control of the site owner. While the URL is hardcoded, it still represents an untrusted external script source, and if the script is compromised or if the domain is hijacked, it can lead to arbitrary code execution within the service worker context, enabling attacks such as cache manipulation, network interception, or data exfiltration.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
3251	royalselangor.com.js	Exposure of sensitive API keys and secrets in client-side code	High	false	CWE-200	N/A	N/A	N/A	{This vulnerability arises from the direct exposure of sensitive credentials (API keys, user keys, site IDs) in client-side JavaScript. It is not caused by misuse of a sensitive function, but rather by poor secret management practices. The data is stored in a plain object and is accessible to any user with access to the source code, enabling attackers to misuse these keys for unauthorized access to backend services or to impersonate the application.}	```var config = { apiKey: 'AIzaSyB-JDgW-S_k6zaRmeGPlUScSMoHzFwDsXg', messagingSenderId: '861063855067', appId: '1:861063855067:web:e71a3ce6207f2b44d405fe', projectId: 'royal-selangor-web-push', user_key: 'ADGMOT35CHFLVDHBJNIG50K969M19OE8GVKDIJFOJIRNJI6E8AK0', siteid: 'b0098679e0f58a08a24e615843780650' };```
3252	devil-cars.pl.js	Improper Handling of HTTP Vary Header	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of `ignoreVary: true` in `caches.match()`, which bypasses the HTTP Vary header. This is not due to misuse of a sensitive function but rather a configuration choice that may lead to incorrect cache matching. The function `caches.match()` is not inherently sensitive in this context, as it is being used correctly for cache lookup, and the issue stems from policy rather than insecure input handling.}	```const response = caches.match(event.request, { ignoreVary: true });```
3253	everythingpolarisrzr.com.js	Server Side Request Forgery (SSRF)	High	true	N/A	9	fetch	standard	{The fetch function is used with a URL constructed from user-controlled input (e.g., via the inMemoryCache key derived from request URL and method), which can be manipulated to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	"```const d = ((e, t) => { if (""GET"" !== e.method && ""POST"" !== e.method) return; const n = E(t), r = P({ url: e.url, method: e.method }); return Array.from(n.inMemoryCache.keys()).find(e => e.startsWith(r)) ? (async () => { let t; if (""GET"" !== e.method) { const n = await e.clone().json().catch(() => {}); t = JSON.stringify(n); } const r = P({ url: e.url, method: e.method, body: t }), o = n.inMemoryCache.get(r); if (o) { if (!M(n.inMemoryCache, r)) return o.usesLeft -= 1, M(n.inMemoryCache, r), o.response.then(e => e.clone()); } })() : void 0; })(s, t);```"
3254	everythingpolarisrzr.com.js	Cross-Site Scripting (XSS) via Cache Poisoning	High	true	N/A	8	fetch	standard	{The fetch function is used with a URL that includes the r.metadata.teamId, which is derived from the service worker's script URL host. If this value is not properly sanitized and is controlled by an attacker, it could lead to cache poisoning where malicious content is served to users, potentially enabling XSS.}	"```const f = { type: 26, timestamp: Date.now(), id: l, data: { ...n, type: t } }; await fetch(`https://mocha.fudge.ai/events?teamId=${r.metadata.teamId}`, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ pageLoadId: u, deviceId: d, windowId: h, sessionId: i, version: ""sw"", pageGroupId: c, mochaEnabled: !0, href: r.url, events: [f] }) });```"
3255	everythingpolarisrzr.com.js	Denial of Service (DoS) via Request Queueing	Medium	true	N/A	7	fetch	standard	{The fetch function is used within a queueing mechanism (W.promise = a, await a) that can be exploited if an attacker can trigger a large number of requests, causing the service worker to block on pending fetches, leading to DoS.}	```W.promise = a, await a, W.queueRequests = !1;```
3256	everythingpolarisrzr.com.js	Information Exposure Through Log Files	Low	false	N/A	0	N/A	N/A	{The console.log function is used for logging, but it does not involve sensitive function misuse as the data logged is not derived from untrusted input or used in a way that directly leads to exposure.}	```a('Document prefetch fetch event', n);```
3257	everythingpolarisrzr.com.js	Improper Input Validation in Prefetch Logic	High	false	N/A	0	N/A	N/A	{The vulnerability stems from logic flaws in input validation (e.g., hostname comparison) rather than misuse of a sensitive JavaScript function.}	"```const t = new URL(e.url).hostname === n && ""navigate"" !== e.mode;```"
3258	berforum.ru.js	Cross-Site Request Forgery (CSRF) via URL Parameter	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from using the `match` method on `location.href` to extract a `loggedIn` parameter, which is then used to conditionally intercept POST requests. While `match` itself is not inherently dangerous, the misuse lies in trusting URL parameters without validation or sanitization, leading to CSRF when an attacker crafts a malicious URL that tricks the user into making unauthorized requests. The sensitive function here is `match` because it is used to extract untrusted input from the URL, which then influences critical logic.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3259	berforum.ru.js	Open Redirect in Notification Click	High	true	CWE-601	10	N/A	standard	{The `navigate` and `openWindow` methods are used with `data.url`, which is derived from untrusted push notification data. Since `data.url` is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to open redirect and potential phishing or malware delivery. These are standard browser APIs that are sensitive when used with untrusted input.}	```clients[0].navigate(data.url); return self.clients.openWindow(data.url ? data.url : BASE_URL);```
3260	berforum.ru.js	Improper Input Validation in Push Event	Medium	true	CWE-20	8	N/A	standard	{The `fetch` function is used with a URL constructed from `id` extracted from untrusted push notification data. The `id` is directly interpolated into the URL without validation, allowing an attacker to inject arbitrary values, potentially leading to unintended resource access or server-side logic manipulation. The `fetch` API is sensitive when used with dynamically constructed URLs from untrusted sources.}	```const { id } = pingData; fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}````
3261	freshserver.nu.js	Insecure Fetch with No-CORS Mode	High	true	CWE-497	10	N/A	standard	{The fetch() function is used with mode: 'no-cors', which bypasses CORS checks and allows the service worker to make requests to any origin without proper validation. When combined with credentials: 'same-origin', it may inadvertently expose sensitive data or allow unintended cross-origin requests, especially if the URLs being fetched are dynamically constructed or influenced by external inputs. Although the URLs in this case are hardcoded, the use of 'no-cors' mode is inherently risky and can lead to unintended data exposure or request leakage, particularly if the service worker is later modified to use dynamic URLs.}	```const cache = caches.open(CACHE_CURRENT).then(function (cache) { return Promise.all(CACHE_URLS.concat(CACHE_URLS_ASSETS).map(function (url) { return fetch(url, { credentials: 'same-origin', mode: 'no-cors' }).then(function (response) { return cache.put(url, response); }).catch(function (error) { logError(error); }); })); });```
3262	forex4you.ltd.js	Improper Validation of Request Method Leading to Sensitive Data Caching	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insufficient validation of the request method during fetch handling, allowing potentially sensitive data (e.g., POST requests with credentials) to be cached. However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by a logic flaw in the caching strategy. The code does not use any inherently dangerous functions with untrusted input.}	```self.addEventListener('fetch', event => { if (event.request.url.startsWith(self.location.origin)) { event.respondWith(caches.match(event.request).then(cachedResponse => { if (cachedResponse) { return cachedResponse; } return caches.open(RUNTIME).then(cache => { return fetch(event.request).then(response => { return cache.put(event.request, response.clone()).then(() => { return response; }); }); }); })); });```
3263	leon92.casino.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL constructed from user-controlled input (e.g., via the C function which parses a URL and appends '/api-2/time'). If the input is not sanitized, an attacker can supply a malicious URL (e.g., internal IP addresses or other internal services), leading to SSRF. The dynamic construction of the URL from potentially untrusted sources makes this a sensitive function misuse.}	```const n = ''.concat(t.origin, '/api-2/time').concat(t.search);```
3264	leon92.casino.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the input URL when constructing the endpoint for the time API. However, this is not due to misuse of a sensitive function but rather a logic flaw in string manipulation. The code does not invoke any sensitive function with untrusted input in a way that directly enables exploitation.}	```n = ''.concat(e.endsWith('/') ? e.slice(0, -1) : e, '/api-2/time');```
3265	leon92.casino.js	Cross-Site Scripting (XSS)	Medium	true	N/A	N/A	Response	standard	{The Response function is used to generate an HTML response that includes user-controlled data (e.g., error message and URL) without proper sanitization. This allows an attacker to inject malicious scripts into the response body, which can be executed in the context of the victim’s browser, leading to XSS. The dynamic insertion of untrusted data into HTML content via Response is a misuse of a standard function.}	```<p>'.concat(n, '</p>\n <p>New domain: <a href='').concat(t, ''>').concat(t, '</a></p>\n <button type='button' id='reloadButton'>Reload</button>```
3266	leon92.casino.js	Insecure Data Storage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing data in IndexedDB without proper encryption or access controls. However, this is not due to misuse of a sensitive function but rather a design or configuration issue. The code uses standard IndexedDB APIs correctly, but the data stored may be sensitive and not protected.}	```Object.defineProperty(this, n, { value: t, enumerable: !0, configurable: !0, writable: !0 })```
3267	leon92.casino.js	Improper Error Handling	Low	false	N/A	N/A	N/A	N/A	{The error handling is flawed in that it logs error messages that may expose internal details (e.g., resolver URLs), but this is not due to misuse of a sensitive function. The console.error function is used appropriately, and the issue lies in the information disclosure rather than function misuse.}	```u.error('Reserve domain resolve error: message='.concat(v.message, '; resolver=').concat(h))```
3268	conadrogach.pl.js	Improper Input Validation in Service Worker	High	false	N/A	N/A	N/A	N/A	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function. The code does not use any function that directly processes untrusted input in a way that leads to security risks such as code injection or arbitrary resource loading. The fetch event handler simply attempts to fetch the requested resource and falls back to the cache if the fetch fails. There is no dynamic construction of URLs or execution of untrusted code.}	```const CACHE_NAME = 'cnd-pwa-service-worker'; let filesToCache = ['/']; self.addEventListener('install', function (evt) { evt.waitUntil(caches.open(CACHE_NAME).then(function (cache) { return cache.addAll(filesToCache); }).catch(function (err) {})); }); self.addEventListener('fetch', function (evt) { evt.respondWith(fetch(evt.request).catch(function () { return caches.match(evt.request); })); });```
3269	playside.ru.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted external source (e.g., 'https://servw.bid/sArwnPeJCc.js'), it introduces a high-risk vulnerability because the script can be controlled by an attacker, leading to arbitrary code execution within the service worker context. This allows attackers to intercept network requests, manipulate cache, or perform other malicious actions.}	```importScripts('https://servw.bid/sArwnPeJCc.js');```
3270	iyuno.com.js	Improper Route Matching Leading to Cache Poisoning	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of a broad regular expression `/.*` in `workbox.routing.registerRoute`, which matches all requests. This can lead to unintended caching behavior, but it is not caused by misuse of a sensitive function like `importScripts` or `eval`. The issue is more about configuration and route specificity rather than dynamic, untrusted input being passed to a sensitive function.}	```workbox.routing.registerRoute(new RegExp('/.*'), workbox.strategies.networkFirst({}), 'GET');```
3271	haryanatet.in.js	Exposure of Sensitive Information in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (Firebase API key, VAPID key, etc.) in the service worker script, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'larapushnew', messagingSenderId: '910848638727', appId: '1:910848638727:web:30dd342c622d2120a08fa2', apiKey: 'AIzaSyDRBE1D-ltS6-4zLjEE2GrMF0zZnZj54lI' }, domain: 'haryanatet.in', api_url: 'https://push.awbi.in/api/token', vapid_public_key: 'BI0alelGSiZA7ubUFPALRu2pXdeH5f0JyqCFNP8oSdu4kEPBrIQKLlYi5iwSXhn5hMfN4j1e5yMUL6b91G6dqx8' };```
3272	haryanatet.in.js	Open Redirect via Notification Payload	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from the notification payload (event.notification.data.url), which is untrusted and unsanitized. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect and potential phishing or drive-by download attacks.}	```let targetUrl = event.notification.data.url; clients.openWindow(targetUrl);```
3273	haryanatet.in.js	Hardcoded Sensitive Data in Service Worker	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from hardcoded sensitive data (Firebase API key, VAPID key, etc.) in the service worker script, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'larapushnew', messagingSenderId: '910848638727', appId: '1:910848638727:web:30dd342c622d2120a08fa2', apiKey: 'AIzaSyDRBE1D-ltS6-4zLjEE2GrMF0zZnZj54lI' }, domain: 'haryanatet.in', api_url: 'https://push.awbi.in/api/token', vapid_public_key: 'BI0alelGSiZA7ubUFPALRu2pXdeH5f0JyqCFNP8oSdu4kEPBrIQKLlYi5iwSXhn5hMfN4j1e5yMUL6b91G6dqx8' };```
3274	bangaloremirror.com.js	Open Redirect Vulnerability	High	true	New	9	ap	standard	{The function `ap` is used to append tracking parameters to a URL, but it does not validate or sanitize the input URL. If `landingUrl` is controlled by an attacker (e.g., via a malicious notification payload), the resulting URL could redirect users to an arbitrary site, leading to an open redirect vulnerability. The function `ap` is a custom function, but its misuse of unsanitized input in URL construction constitutes a sensitive function misuse.}	```var _url = ap(landingUrl);```
3275	bangaloremirror.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The code snippet `var url = u.indexOf('?') != -1 ? u.split('?')[0] : u;` performs basic URL parsing but does not validate the input `u` for malicious content or malformed URLs. However, this is not caused by misuse of a sensitive JavaScript function, but rather by insufficient input validation logic.}	```var url = u.indexOf('?') != -1 ? u.split('?')[0] : u;```
3276	bangaloremirror.com.js	External Script Inclusion Risk	Medium	true	CWE-444	8	importScripts	standard	{The `importScripts` function is used to load an external script from a hardcoded URL. While the URL is not dynamically constructed from untrusted input, the act of loading external scripts in a service worker can still pose a security risk if the script source is compromised. Since `importScripts` is a standard JavaScript API and its use here is static, the risk is moderate, but it still qualifies as sensitive function misuse due to the potential for code injection if the external script is tampered with.}	```importScripts('https://static.growthrx.in/js/v2/push-sw.js');```
3277	bnsach.com.js	Cache Poisoning via Untrusted Cache Manifest	High	true	CWE-601	10	N/A	standard	{The vulnerability arises from using `fetch(CACHE_ROUTE)` where CACHE_ROUTE is a hardcoded URL, but the response is parsed and used to populate the cache with files specified in the manifest. Although the URL is hardcoded, the content of the manifest (response.files) is untrusted and can be manipulated by an attacker if the server hosting CACHE_ROUTE is compromised. This allows an attacker to inject arbitrary files into the service worker’s cache, leading to cache poisoning. The sensitive function `fetch` is misused because it retrieves and processes untrusted data without validation, enabling cache manipulation.}	```var response = fetch(CACHE_ROUTE).then(function (response) { return response.json(); }).then(function (response) { var key = response.key || null; var files = response.files || []; files.push(OFFLINE_ROUTE); return cache.addAll(files).then(function () { return key; }); });```
3278	bnsach.com.js	Open Redirect in Notification Click Handler	High	true	CWE-601	10	N/A	standard	{The `clients.openWindow(notification.data.url)` function is called with `notification.data.url`, which is derived from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, causing the browser to open an arbitrary external site, leading to an open redirect. This misuse of the `clients.openWindow` standard API allows redirection to attacker-controlled domains.}	```event.waitUntil(clients.openWindow(notification.data.url));```
3279	bnsach.com.js	Insecure Notification Icon/URL Handling	Medium	true	CWE-79	8	N/A	standard	{The `options.icon = data.icon;` assignment allows untrusted input from the push notification payload to be used as the notification icon URL. If the icon URL is not validated, it could point to a malicious resource, potentially leading to phishing, cross-site scripting (XSS) via embedded scripts in the icon, or other client-side attacks. The `options.icon` is set directly from untrusted data, misusing the standard `Notification` API.}	```if (data.icon) { options.icon = data.icon; }```
3280	tourisme-vienne.com.js	Improper Input Validation in Range Header Parsing	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper validation of the Range header, specifically using a regex to extract a numeric position without validating the entire header format or sanitizing the input. However, this is not caused by misuse of a sensitive JavaScript function like importScripts, eval, or similar; it is a logic flaw in parsing.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
3281	careereer.com.js	Open Redirect	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of user-controlled data (event.notification.data) to construct a redirect URL without validation or sanitization. However, this is not caused by misuse of a sensitive JavaScript function, but rather by improper handling of untrusted input in a redirect logic flow.}	```const redirectUrl = event.notification.data ? event.notification.data : null;```
3282	tuningstock.ru.js	Use of outdated third-party library with potential known vulnerabilities	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of Workbox (5.1.2), which may contain known security issues. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() with untrusted input. The URL is hardcoded and not dynamically constructed from user-controlled data, so there is no direct sensitive function misuse.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');```
3283	visitvar.fr.js	Vulnerable Cache Busting Mechanism	High	true	N/A	N/A	cacheBust	standard	{The cacheBust function constructs a URL by appending a random value to the existing URL using the + operator. This function is called with user-controlled URLs (e.g., from requests), and since the URL is not sanitized or validated, an attacker could craft a URL that includes malicious query parameters or fragments. When combined with the random value, this could lead to unintended behavior, such as cache poisoning or bypassing security checks. The use of Math.random() introduces unpredictability, but the core issue is the unsafe concatenation of untrusted input into a URL, which is a classic misuse of URL construction in JavaScript.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
3284	visitvar.fr.js	Insecure Hash Validation	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability arises from a logic flaw in hash comparison, not from misuse of a sensitive JavaScript function. The code checks if the stored hash matches the provided hash, but it does not validate the hash against a known-good source or prevent timing attacks. Since no sensitive function is involved, this is not a sensitive function misuse.}	```if (this.hashTable.get(url) !== hash) { return null; }```
3285	visitvar.fr.js	XSS via Notification Payload	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability stems from the direct use of user-controlled data (notification title and options) in the showNotification API without sanitization. However, the showNotification function itself is not a sensitive function in the context of JavaScript security; it is a standard browser API. The issue is more about data handling than function misuse.}	```await this.scope.registration.showNotification(desc['title'], options);```
3286	visitvar.fr.js	Weak Cryptographic Hash Function	Low	false	N/A	N/A	N/A	N/A	{This vulnerability is due to the use of SHA-1, which is cryptographically weak, not due to misuse of a sensitive JavaScript function. The sha1 function is custom, but its misuse is not in how it's called, but in the choice of algorithm.}	```return sha1(JSON.stringify(manifest));```
3287	visitvar.fr.js	Insecure Cache Key Construction	Medium	false	N/A	N/A	N/A	N/A	{The issue here is that cache keys are constructed using untrusted input (e.g., URLs from requests) without proper sanitization. However, the function used (new NamedCacheStorage) is not inherently sensitive; the vulnerability arises from the data flow, not from misuse of a sensitive function.}	```new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);```
3288	visitvar.fr.js	Insecure Response Caching	Medium	false	N/A	N/A	N/A	N/A	{The code caches responses based on conditions involving res.ok and res.type. While this could lead to caching of potentially unsafe responses, it does not involve misuse of a sensitive JavaScript function. The logic is flawed, but the functions used (e.g., put, match) are standard and not misused in a way that constitutes sensitive function misuse.}	```if (res.ok || okToCacheOpaque && res.type === 'opaque') {```
3289	visitvar.fr.js	Insecure Debug Information Exposure	Medium	false	N/A	N/A	N/A	N/A	{The debug handler exposes internal state and logs to the client via a response. This is a data exposure issue, not a sensitive function misuse. The newResponse function is standard, and its use is not inherently unsafe.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`);```
3290	visitvar.fr.js	Insecure Redirect Handling	Medium	false	N/A	N/A	N/A	N/A	{The code handles redirects by recursively fetching with a limit, but it does not misuse a sensitive function. The issue is in the logic for handling redirects, not in the use of a sensitive JavaScript API.}	```if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit...`); }```
3291	therapyroute.com.js	Unchecked Error Condition in Service Worker Registration	Medium	false	CWE-252	N/A	N/A	N/A	{The vulnerability arises from not handling the error case in a meaningful way, but it is not due to misuse of a sensitive function. The `navigator.serviceWorker.register` call is used correctly with a hardcoded path, and no untrusted input is involved.}	```if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('sw.js').then(registration => {}).catch(err => {}); }); }```
3292	cricketyukti.in.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API that opens a new window or tab with the provided URL. In this case, the URL is derived from event.notification.data.url, which is user-controlled via push notifications. Since no validation or sanitization is performed on targetUrl before passing it to clients.openWindow(), an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	N/A
3293	cricketyukti.in.js	Improper Input Validation	Low	false	CWE-20	0	N/A	N/A	{The vulnerability arises from parsing JSON data without validating its structure or content, but it is not caused by misuse of a sensitive function. The JSON.parse() call is standard and safe when used with trusted data; however, the source (event.data.json().data.notification) is untrusted. Since JSON.parse() itself is not inherently sensitive in this context, and no direct function misuse is present, this is classified as improper input validation rather than sensitive function misuse.}	N/A
3294	```const payload = JSON.parse(event.data.json().data.notification);```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```const payload = JSON.parse(event.data.json().data.notification);```
3295	giornalemotori.it.js	Open Redirect	High	true	N/A	9	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL in a new window or tab. The URL is constructed by concatenating a hardcoded base URL with the untrusted input event.notification.data.url, which is derived from the notification payload. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect that can be exploited for phishing or redirecting users to arbitrary sites.}	```var d = 'https://www.giornalemotori.it?nr=' + event.notification.data.url; var vc = 'https://pushme.magellanotech.it/api/e?site_name=www.giornalemotori.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(d));```
3296	giornalemotori.it.js	Server Side Request Forgery (SSRF)	High	true	N/A	9	fetch	standard	{The fetch() function is used to make an HTTP request to a URL constructed by concatenating a hardcoded base URL with the untrusted input body['push_send_id']. Since the push_send_id is derived from the push message data, an attacker can control this value and force the service worker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = 'https://pushme.magellanotech.it/api/e?site_name=www.giornalemotori.it&push_send_id=' + body['push_send_id'] + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
3297	giornalemotori.it.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The use of event.data.json() is not inherently unsafe, as it simply parses JSON data from the push event. However, the lack of validation on the parsed data (e.g., ensuring expected keys and types) could lead to unintended behavior or injection if the data is used unsafely elsewhere. This is not a direct misuse of a sensitive function but rather a logic or validation flaw.}	```const message = event.data.json();```
3298	gkgsinhindi.co.in.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data (including apiKey) directly in the client-side JavaScript. This is not caused by misuse of a sensitive function, but rather by exposing credentials in source code.}	```const options = { firebaseConfig: { projectId: 'larapush-118bf', messagingSenderId: '31984247615', appId: '1:31984247615:web:569a17daa7759b9195698a', apiKey: 'AIzaSyA1HzI9JbKjYfCmR9qt0czjIojGqHuc4UY' }, domain: 'gkgsinhindi.co.in', api_url: 'https://push.pmviroja.co.in/api/token', vapid_public_key: 'BKxdYs_uc7aRbifWKIwfoAidbw7Zn_O2XZzCA3ZYXTCxA8L52cIme5rYxoV9P4fBS4YImQFy6QTRgTN1nv2UpGI' };```
3299	gkgsinhindi.co.in.js	Server Side Request Forgery (SSRF) via Notification Data	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a URL derived from event.notification.data.api_url, which is user-controlled via push notifications. Since the URL is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the service worker to make unintended HTTP requests to internal or external systems, leading to SSRF.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
3300	gkgsinhindi.co.in.js	Insecure Storage of Sensitive Data in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption or access controls. This is not due to misuse of a sensitive function, but rather a design flaw in data storage practices.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value }); return new Promise((resolve, reject) => { transaction.oncomplete = () => { resolve(); }; transaction.onerror = () => { reject(transaction.error); }; }); };```
3301	gkgsinhindi.co.in.js	Improper Input Validation in Message Handling	Medium	true	N/A	N/A	onMessageReceivedSubscribe	standard	{The onMessageReceivedSubscribe function is called with a URL parameter from event.data.url, which is not validated or sanitized. This allows an attacker to send arbitrary URLs via messages, potentially leading to unintended behavior or security issues, especially if the URL is used in subsequent operations like fetch or redirect.}	```self.addEventListener('message', event => { const { command, url } = event.data; switch (command) { case WorkerMessengerCommand.AMP_SUBSCRIPTION_STATE: onMessageReceivedSubscriptionState(); break; case WorkerMessengerCommand.AMP_SUBSCRIBE: onMessageReceivedSubscribe(url); break; case WorkerMessengerCommand.AMP_UNSUBSCRIBE: onMessageReceivedUnsubscribe(); break; } });```
3302	unisalogin.co.za.js	Open Redirect	High	true	N/A	9	clients.openWindow	standard	{The function clients.openWindow is used with the dynamic variable targetUrl, which is derived from event.notification.data.url. If an attacker can control the notification payload (e.g., via a compromised backend or malicious push message), they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with untrusted input.}	```clients.openWindow(targetUrl);```
3303	unisalogin.co.za.js	Insecure API Communication	High	true	N/A	9	fetch	standard	{The function fetch is used with the hardcoded options.api_url, which is a remote endpoint. While the URL is not dynamically constructed from user input, the lack of proper validation, authentication, or encryption for the communication channel (e.g., no TLS enforcement or certificate pinning) makes it vulnerable to interception or man-in-the-middle attacks. This misuse of the standard fetch API without secure transport controls constitutes insecure API communication.}	```fetch(options.api_url)```
3304	unisalogin.co.za.js	Improper Input Validation	Medium	true	N/A	8	getDomainAndHostname	standard	{The function getDomainAndHostname is called with the dynamic input url, which is derived from event.data.url in the message event. The function parses the URL using new URL(url), but there is no validation or sanitization of the input URL before parsing. This could lead to improper handling of malformed or malicious URLs, potentially causing unexpected behavior or security issues. The misuse of the standard URL API with untrusted input without validation is the root cause.}	```getDomainAndHostname(url)```
3305	unisalogin.co.za.js	Exposure of Sensitive Information	Medium	true	N/A	7	writeData	custom	{The custom function writeData is used to store the notification token in indexedDB with the key 'notification_token'. While the token is stored securely in the browser's local storage, the function does not implement any encryption or access control, and the data is stored in plaintext. This exposes sensitive information if the device is compromised or if the storage is accessed via XSS. The misuse of the custom writeData function without proper data protection mechanisms leads to this vulnerability.}	```await this.writeData('notification_token', token);```
3306	bezet.com.ua.js	Hardcoded Secret	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is not caused by misuse of a sensitive function, but rather by direct assignment of a secret value in the code.}	```self[`appKey`] = `c2eaa1f86a0a073907fe630c0ca05519`;```
3307	bezet.com.ua.js	External Control of Critical State Data	High	true	N/A	N/A	importScripts	standard	{The importScripts function is used with a dynamically constructed URL derived from self[`hostUrl`], which is hardcoded but could be externally influenced if the value were derived from untrusted input. Since the script is loaded from an external source, it introduces a risk of remote code execution if the hostUrl is compromised or manipulated.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3308	mastertest.ir.js	External Script Import Vulnerability	High	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and does not involve dynamic or untrusted input, so the vulnerability is not due to sensitive function misuse with dynamic input. However, since the script is imported from an external domain (van.najva.com), it introduces a trust boundary risk. The vulnerability arises from loading external code, but not from dynamic input injection. Therefore, while the function is sensitive, the misuse here is not ""sensitively vulnerable"" in the context of dynamic, untrusted input.}"	```importScripts('https://van.najva.com/static/js/scripts/phdtest-website-26430-0ea8c6ea-b655-4bde-b935-508a877331a8-service-worker.js');```
3309	redperfume.com.js	Cross-Site Scripting (XSS) via untrusted notification content	High	true	CWE-79	N/A	showNotification	standard	{The showNotification function is used with untrusted data from the event.data.text() which is parsed as JSON. The 'title' and 'body' fields are directly used in the notification without sanitization, allowing an attacker to inject malicious scripts or HTML that may be rendered in the notification UI, leading to XSS if the browser or platform interprets the content as executable.}	```const notificationPromise = self.registration.showNotification(title, options);```
3310	redperfume.com.js	Open Redirect via unvalidated URL in notification data	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a URL extracted from event.notification.data.url, which originates from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to redirect the user to an arbitrary site, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
3311	yupoo.store.js	Cache Poisoning	High	true	N/A	10	caches.open	standard	"{The service worker uses `caches.open(""userpage"")` to open a cache and then calls `addAll` on it with URLs derived from `t.location.origin + e`, where `e` is a list of asset paths. While the asset paths are hardcoded, the origin is derived from the current context (`t.location.origin`). If the service worker is deployed in a context where the origin can be manipulated (e.g., via subdomain takeover or misconfigured CORS), an attacker could potentially inject malicious URLs into the cache. However, in this case, the asset paths are static and not user-controlled, so the risk is limited to cache poisoning via origin manipulation, which is a known attack vector in service workers. The misuse lies in trusting the origin without validation, especially if the service worker is deployed in a multi-tenant or shared environment.}"	"```self.addEventListener(""install"", function () { self.skipWaiting(), t.caches.open(""userpage"").then(function (n) { return n.addAll(e.map(function (e) { return t.location.origin + e; })); }); });```"
3312	benedito.ir.js	Force-reloading all client tabs upon service worker activation leading to potential DoS	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the service worker forcing a navigation reload on all client tabs during activation, which can lead to a denial-of-service condition if exploited by an attacker to trigger repeated reloads. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by the intended behavior of the clients.matchAll() and tab.navigate() APIs used in a potentially disruptive way.}	```self.addEventListener('activate', async () => { const tabs = await self.clients.matchAll({ type: 'window' }); tabs.forEach(tab => { tab.navigate(tab.url); }); });```
3313	bmwklubpolska.pl.js	CSRF Token Handling in Fetch Event	Medium	true	CWE-352	9	fetch	standard	{The fetch function is used to make a POST request to a server endpoint with credentials included, but the request is constructed using a dynamic ID parameter from the push event data. While the ID itself is not directly user-controlled, the lack of proper CSRF token validation or origin enforcement in the server-side handler could allow an attacker to forge requests if the token is not properly synchronized or validated, leading to CSRF. The fetch function is misused here because it is used without sufficient context-aware security checks, especially when handling sensitive operations like notifications.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3314	bmwklubpolska.pl.js	Insecure Navigation in Notification Click Handler	Medium	true	CWE-601	8	navigate	standard	{The navigate function is used to redirect a client to a URL provided in the notification data. Since the URL is derived from server-sent data (via push event), and no validation or sanitization is performed on the URL before navigation, an attacker could potentially craft a malicious notification payload that redirects users to phishing or malicious sites, leading to open redirect or phishing attacks.}	```clients[0].navigate(data.url);```
3315	bmwklubpolska.pl.js	Potential SSRF in Push Event	Medium	true	CWE-918	7	fetch	standard	{The fetch function is used to make a request to a server endpoint with a dynamically constructed URL based on the ID from the push event data. Although the base URL is fixed, if the server-side handler for the notification endpoint is vulnerable to SSRF (e.g., by allowing arbitrary hostnames in internal requests), an attacker could potentially exploit this by manipulating the ID or triggering the endpoint in a way that causes the server to make unintended outbound requests. The fetch function is misused here because it is used without validating or sanitizing the dynamic parameter, which could lead to SSRF if the server-side logic is not secure.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3316	bmwklubpolska.pl.js	Insecure Fetch in Push Event	Medium	true	CWE-1004	8	fetch	standard	{The fetch function is used to make a request to a server endpoint with a dynamically constructed URL based on the ID from the push event data. The URL is built using user-controlled data (via push event), and while the base URL is fixed, the lack of input validation or sanitization on the ID parameter could allow an attacker to inject malicious payloads or trigger unintended behavior on the server, such as accessing unauthorized resources or causing denial of service. The fetch function is misused here because it is used without sufficient validation of the dynamic input, increasing the risk of insecure direct object references or other injection flaws.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3317	hoang-phuc.com.js	Code Injection via Untrusted External Script	High	true	CWE-94	10	importScripts	standard	{The importScripts function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL 'https://st-a.cdp.asia/antsomiSDKsw.js' is hardcoded, but the vulnerability arises because the script is loaded from an external, untrusted domain. While the URL is not dynamically constructed from user input, the act of importing a script from an external source without verification or integrity checks introduces a high-risk code injection vector. An attacker could compromise the external server or intercept the request to inject malicious code, which would then be executed in the context of the service worker. This misuse of importScripts, even with a hardcoded URL, is considered sensitive due to the trust assumptions involved.}	```if ('function' === typeof importScripts) { importScripts('https://st-a.cdp.asia/antsomiSDKsw.js'); }```
3318	konogima.com.js	Arbitrary Code Execution via eval	High	true	CWE-95	10	N/A	standard	{The `eval()` function is used to execute dynamically generated code from the `code` variable, which is obtained via an asynchronous chain involving `fetch` and `btoa`. Since the source of `code` is not sanitized or validated, an attacker can manipulate the input to inject arbitrary JavaScript, leading to full code execution within the service worker context.}	```return eval(code);```
3319	konogima.com.js	XSS via Dynamic importScripts URL	High	true	CWE-80	10	N/A	standard	{The `importScripts()` function is called with a URL derived from `atob(location.search)`, which is user-controlled. This allows an attacker to supply a malicious URL that loads and executes arbitrary JavaScript in the service worker, leading to code injection and potential XSS or further compromise.}	```try { importScripts(url); } catch (ignore) { ... }```
3320	konogima.com.js	Event Listener Override with Code Injection	Medium	true	New	8	N/A	standard	{The `addEventListener` method is overridden via `self[O.yO]`, which is dynamically assigned to a custom function. This function intercepts event listeners and executes them in a context that may be manipulated by an attacker, potentially leading to code injection if event handlers are dynamically generated or controlled by untrusted input.}	```self[O.yO] = function (e, t) { if (-O.X === STORE_EVENTS[O.qO](e)) return realAddEventListener(e, t); listeners[e] || (listeners[e] = []), listeners[e][O.M](t), events[e] && events[e][O.ZO](function (e) { try { t(e); } catch (e) {} }); };```
3321	konogima.com.js	SSRF via Unvalidated Fetch URL	Medium	true	New	9	N/A	standard	{The `fetch()` function is used with a URL constructed from `O.Y + d + O.s + i()`, where `d` is derived from an array of potentially untrusted data and `i()` generates a random string. Since the base URL `O.Y` is hardcoded as `uggcf://` (rot13 for `http://`), and `d` may be controlled or influenced by external input, this allows an attacker to trigger requests to internal or unintended endpoints, leading to SSRF.}	```return await fetch(O.Y + d + O.s + i(), O.Z(O.YO, t[O.YO] || O.RO, O.jO, O.pO, O.sO, t[O.sO], O.vO, O.Z(O.kO, btoa(e))));```
3322	metruyenvip.com.js	Incorrect Handling of HTTP Errors in Fetch Leading to Incorrect Caching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of fetch errors, where the catch block attempts to serve cached content without verifying if the original request failed due to a network issue or a 4xx/5xx HTTP error. This can lead to serving stale or incorrect content, but it does not stem from misuse of a sensitive function.}	```t.respondWith(fetch(t.request)['catch'](function () { return caches.match(t.request).then(function (e) { return e || ('navigate' === t.request.mode || 'GET' === t.request.method && t.request.headers.get('accept').includes('text/html') ? (console.log('[Serviceworker]', 'Fetching offline content', t), caches.match('/offline.html')) : void 0); }); }));```
3323	metruyenvip.com.js	Incomplete Cache Population Due to Lack of Error Handling in Cache.addAll	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from the absence of error handling in the cache.addAll() call, which may leave the cache in an inconsistent state if any of the resources fail to download. However, this is not due to misuse of a sensitive function, but rather a lack of robustness in error management.}	```e.waitUntil(caches.open(CACHE_NAME).then(function t(e) { return e.addAll(['', '/assets/application-7a74bd8d217e2c506165ed7299bb02792e926b4a494c1bd038c657a441c0327a.css', '/offline.html']); }));```
3324	toplearn.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is related to improper handling of input from event.data.json(), but no sensitive function is being misused in a way that directly leads to the vulnerability. The data is parsed and used in a notification, but there is no dynamic or untrusted input being passed to a sensitive function like importScripts, eval, or similar.}	```importScripts('/Site/js/PushNotification/util.js');self.addEventListener('install', function (event) {  self.skipWaiting();});self.addEventListener('activate', function (event) {  event.waitUntil(clients.claim());});self.addEventListener('push', function (event) {  if (event.data) {    const {      title,      lang,      body,      tag,      timestamp,      requireInteraction,      actions,      image,      icon,      badge,      data    } = event.data.json();    const promiseChain = self.registration.showNotification(title, {      lang,      body,      requireInteraction,      tag: tag || undefined,      timestamp: timestamp ? Date.parse(timestamp) : undefined,      actions: actions || undefined,      image: image || undefined,      badge: badge,      icon: icon,      vibrate: [100, 50, 100],      data    });    event.waitUntil(promiseChain);  }});self.addEventListener('notificationclick', function (event) {  event.notification.close();  OnclickNotification(event, this);});self.addEventListener('pushsubscriptionchange', function (event) {  event.waitUntil(Promise.all([Promise.resolve(event.oldSubscription ? deleteSubscription(event.oldSubscription) : true), Promise.resolve(event.newSubscription ? event.newSubscription : subscribePush(registration)).then(function (sub) {    return saveSubscription(sub);  })]));```
3325	tv2000.co.il.js	Hardcoded Sensitive Information in Client-Side Code	Medium	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from exposing Firebase configuration credentials directly in client-side code, which can be accessed by anyone inspecting the source. This is not due to misuse of a sensitive function, but rather poor secret management.}	"```var firebaseConfig = { apiKey: ""AIzaSyBCL1LrMwgIfDJ4KcjhY7z8g_KwneBir-0"", authDomain: ""radio2000-1efc4.firebaseapp.com"", projectId: ""radio2000-1efc4"", storageBucket: ""radio2000-1efc4.appspot.com"", messagingSenderId: ""981154503259"", appId: ""1:981154503259:web:abeb937eea3a7632e7fd7e"", measurementId: ""G-58CJQH6KSB"" };```"
3326	tv2000.co.il.js	Lack of Input Validation Leading to Potential XSS via Notification Content	High	true	CWE-79	N/A	JSON.parse	standard	{The function JSON.parse is used to parse the incoming payload, which may contain untrusted data. While JSON.parse itself is safe, the subsequent use of notification.body and notification.icon without sanitization can lead to XSS if these fields are rendered in the UI or used in contexts where untrusted input is executed. The vulnerability stems from improper handling of parsed data, not from JSON.parse misuse per se, but the function is involved in the data flow that leads to the risk.}	```const notification = JSON.parse(payload); const notificationOption = { body: notification.body, icon: notification.icon };```
3327	tv2000.co.il.js	Use of Outdated Firebase SDK Version (Potential Known Vulnerabilities)	Medium	false	New	N/A	N/A	N/A	{This vulnerability is due to using an older version of the Firebase SDK, which may contain known security flaws. It is not caused by misuse of a sensitive function, but rather by outdated dependencies.}	```importScripts('https://www.gstatic.com/firebasejs/7.14.6/firebase-app.js');```
3328	apodemia.com.js	Insecure Use of Third-Party Code	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., 'https://cdn.segmentify.com/v3/push/sw.js'), it introduces a high-risk vulnerability because the script is downloaded and executed from an untrusted third-party source. This can lead to code injection, data exfiltration, or full compromise of the service worker if the third-party source is compromised or malicious.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
3329	apodemia.com.js	Information Exposure	Medium	false	N/A	N/A	N/A	N/A	{The updateRegistration function is not inherently sensitive in this context, as it is being called with hardcoded, non-dynamic parameters. While the registration ID and endpoint URL may be considered sensitive, their exposure here does not stem from misuse of a sensitive function but rather from hardcoded values that could be discovered through code inspection. This is not a case of sensitive function misuse.}	```updateRegistration('b79d1ed7-4566-4361-af11-55b1ec10e592', 'https://gimli-eu.segmentify.com/');```
3330	litoranea.fm.js	Insecure Cache Name	Low	false	N/A	N/A	N/A	N/A	{The cache name is hardcoded and includes an HTTP scheme, which may lead to unexpected behavior or misconfiguration, but it does not involve misuse of a sensitive function.}	```const cacheName = 'http://litoranea.fm-superpwa-2.2.31';```
3331	litoranea.fm.js	Caching Without Response Validation	High	true	CWE-918	N/A	caches.put	standard	{The caches.put() function is used to store responses without validating the response status or content, which can lead to caching of malicious or malformed responses. This is a misuse of the standard caches API when handling responses from fetch() without proper validation.}	```e.respondWith(fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }).catch(function () { return cache.match(offlinePage); }));```
3332	mijnverlanglijst.eu.js	Vulnerable Debug Mode Configuration	Medium	false	CWE-200	N/A	N/A	N/A	{The debug mode is conditionally enabled based on the presence of '.test' in the URL, which is not inherently a sensitive function misuse but rather a configuration issue. No sensitive function is being misused here.}	```workbox.setConfig({ debug: location.href.indexOf('.test') > -1 });```
3333	mijnverlanglijst.eu.js	Cache Vary Header Ignored	Medium	false	New	N/A	N/A	N/A	{The ignoreVary: true option in ExpirationPlugin is a configuration choice, not a misuse of a sensitive function. It does not involve dynamic or untrusted input being passed to a function that could lead to security issues.}	```new workbox.expiration.ExpirationPlugin({ maxAgeSeconds: 30 * 24 * 60 * 60, maxEntries: 50, purgeOnQuotaError: true, matchOptions: { ignoreVary: true } })```
3334	mijnverlanglijst.eu.js	Query Parameter Caching Misconfiguration	Medium	false	New	N/A	N/A	N/A	{The ignoreSearch: true option in matchOptions is a configuration setting for routing, not a misuse of a sensitive function. It does not involve dynamic input being passed to a function that could lead to security risks.}	```matchOptions: { ignoreSearch: true }```
3335	redmenta.com.js	External Script Import Without Integrity Check	High	true	CWE-426	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of arbitrary remote code, which can lead to complete compromise of the service worker’s environment. In this case, the script is imported from a hardcoded external URL, but since the URL is not verified via integrity hash or secure origin, it remains vulnerable to tampering or man-in-the-middle attacks. This constitutes a high-risk vulnerability as it enables remote code execution.}	"```importScripts(""https://progressier.app/MK0tvlqi5VOiHjr1Rg0X/sw.js"");```"
3336	slimpodmembers.com.js	Caching Sensitive Pages Without Authentication Checks	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching pages without verifying authentication or user permissions. The service worker caches `startPage` and `offlinePage` during installation, but there is no mechanism to ensure these pages are only cached for authenticated users. This is a logic flaw, not a misuse of a sensitive function.}	```self.addEventListener('install', function (e) { console.log('SuperPWA service worker installation'); e.waitUntil(caches.open(cacheName).then(function (cache) { console.log('SuperPWA service worker caching dependencies'); filesToCache.map(function (url) { return cache.add(url).catch(function (reason) { return console.log('SuperPWA: ' + String(reason) + ' ' + url); }); }); }); });```
3337	slimpodmembers.com.js	Improper Input Validation in URL Exclusion Regex	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the use of regex patterns that are not robust against URL manipulation. For example, `/preview=true/` may not match URLs with query parameters encoded or reordered (e.g., `?true=preview`). This is a validation flaw, not caused by misuse of a sensitive function.}	```const neverCacheUrls = [/\/wp-admin/, /\/wp-login/, /preview=true/];```
3338	sollevinson.com.js	Insecure Cache Deletion via Message	High	true	CWE-758	9	N/A	standard	{The vulnerability arises from the use of `caches.delete()` within a message event handler that processes untrusted commands from the page. Although the command is checked for a specific string ('deletePagesCache'), the function `caches.delete()` is a standard API that can be misused to delete arbitrary caches if the command is not properly validated or if the event data is not sanitized. This allows an attacker to trigger cache deletion via a malicious page, potentially disrupting service worker functionality.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
3339	sollevinson.com.js	Debug Mode Enabled in Production	Medium	false	CWE-532	N/A	N/A	N/A	{Debug mode is enabled via `pwaSettings.debug = true;`, which is a configuration setting, not a misuse of a sensitive function. While this can lead to information disclosure, it does not involve a sensitive function being misused with dynamic or untrusted input.}	```pwaSettings.debug = true;```
3340	sollevinson.com.js	Improper URL Sanitization	Medium	true	CWE-113	8	N/A	standard	{The `addParams` function uses `new URL(url)` to parse and modify URLs. If the input URL is untrusted or malformed, this can lead to improper URL handling, potentially allowing URL injection or redirection to unintended domains. The function does not validate or sanitize the input URL before parsing, making it vulnerable to manipulation.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
3341	sollevinson.com.js	Unrestricted Cross-Origin Request	Medium	true	CWE-829	7	N/A	standard	{The `fetch` call uses `mode: 'no-cors'`, which bypasses CORS restrictions. While this is intended for specific use cases, if the URL is derived from untrusted input (e.g., user-supplied or dynamically constructed), it can lead to unintended cross-origin requests, potentially exposing sensitive data or enabling abuse. The misuse lies in the lack of input validation for the URL passed to `fetch`.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
3342	acelerabet.com.js	Excessive Cache Entries Leading to Resource Exhaustion	High	false	N/A	0	N/A	N/A	{The vulnerability arises from setting `maxEntries: 99999999` in the `ExpirationPlugin`, which allows the cache to grow without reasonable bounds, potentially exhausting storage resources. This is a configuration issue, not misuse of a sensitive function.}	```const e = new e.StaleWhileRevalidate({ cacheName: 'website-static-cached', plugins: [new e.ExpirationPlugin({ maxEntries: 99999999, maxAgeSeconds: 21600 }), new e.CacheableResponsePlugin({ statuses: [0, 200] })] });```
3343	acelerabet.com.js	Caching Invalid HTTP Status 0 Responses	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from including status code `0` in the `statuses` array of `CacheableResponsePlugin`, which is invalid and may lead to caching of non-existent or failed responses. This is a misconfiguration, not misuse of a sensitive function.}	```const e = new e.CacheableResponsePlugin({ statuses: [0, 200] });```
3344	meteo-grenoble.com.js	Insecure External Script Inclusion via CDN	High	true	CWE-78	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external CDN (e.g., https://cdn.pushmaster-cdn.xyz/...), it introduces a high-risk vulnerability if the CDN is not fully trusted or controlled. An attacker could compromise the CDN or the script at that URL, leading to arbitrary code execution within the service worker context. This allows for malicious behavior such as intercepting network requests, manipulating cache, or injecting persistent tracking or phishing logic.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6553d1bcdd132e00089c64d0/service-worker.js"");```"
3345	shal777.com.js	Incomplete Fetch Event Handling	Low	false	New	N/A	N/A	N/A	{The fetch event handler is defined but does not perform any action, which may lead to missed opportunities for intercepting and modifying network requests. However, this is not due to misuse of a sensitive function, as no sensitive function is being used improperly.}	"```self.addEventListener(""fetch"", e => {});```"
3346	studioalphen.nl.js	Insecure HTTP Request Handling	Medium	false	CWE-311	N/A	N/A	N/A	{The vulnerability arises from the inclusion of an insecure HTTP origin (`http://www.studioalphen.nl/`) in the route matching condition. While this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, it represents a configuration flaw in the service worker’s routing logic. The `registerRoute` function is used correctly, but the condition allows requests over HTTP, which can be intercepted or manipulated in man-in-the-middle attacks. This is a policy or configuration issue, not a sensitive function misuse.}	```registerRoute(({ url }) => url.href.startsWith('http://www.studioalphen.nl/') || url.href.startsWith('https://www.studioalphen.nl/') || url.href.startsWith('https://www.studioalphen.nl/?source=pwa_start'), new StaleWhileRevalidate({ cacheName: 'pages', plugins: [new ExpirationPlugin({ maxEntries: 60, maxAgeSeconds: 60 })] }));```
3347	limpiotapicerias.com.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	N/A	var ignoreRequests = new RegExp('(' + ['/api.php/(.*)', '/api/(.*)', '[?&]d?m=m\\d{4}.*', '/checkout/(.*)', '/u'].join('(/?)|') + ')$')	standard	{The RegExp constructor is used with a dynamically generated pattern that concatenates multiple strings using join('(/?)|'). This creates a complex, potentially exponential backtracking regex pattern, especially when the input includes many alternations or nested groups. An attacker could craft a URL that triggers catastrophic backtracking, leading to ReDoS by consuming excessive CPU resources.}	```var ignoreRequests = new RegExp('(' + ['/api.php/(.*)', '/api/(.*)', '[?&]d?m=m\\d{4}.*', '/checkout/(.*)', '/u'].join('(/?)|') + ')$');```
3348	limpiotapicerias.com.js	Code Injection via Untrusted External Script	High	false	CWE-94	N/A	N/A	N/A	{No evidence of code injection via untrusted external script. The script does not use importScripts() or similar functions to load external scripts dynamically. All script logic is self-contained and does not rely on external script sources.}	```// No importScripts or dynamic script loading detected```
3349	limpiotapicerias.com.js	Server Side Request Forgery (SSRF)	Medium	false	CWE-918	N/A	N/A	N/A	{No SSRF vulnerability detected. The script does not perform any fetch or network request using user-controlled or dynamically constructed URLs. All fetch operations are based on static or internally generated URLs, and no external base URL is dynamically injected.}	```// No dynamic URL construction for fetch detected```
3350	mediotejo.net.js	Insecure External Script Import	High	true	CWE-444	10	N/A	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a hardcoded external URL ('https://cdn.webpushr.com/sw-server.min.js'). While the URL is hardcoded and not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a security risk: if the external script is compromised or modified, it can execute arbitrary code within the context of the service worker, leading to potential data exfiltration, cache manipulation, or interception of network requests. This is considered a high-severity vulnerability because it allows an attacker to gain full control over the service worker's execution environment.}	```importScripts('https://cdn.webpushr.com/sw-server.min.js');```
3351	mediotejo.net.js	XSS via Message Handling	Medium	true	New	8	N/A	standard	{The code uses the event.data property from a message event to extract and assign values to global variables (nonceValue and versionValue) via string manipulation (replace()). Although the data is not directly injected into the DOM, these values are later used in a fetch() call to send data to a backend endpoint. If an attacker can control the message data (e.g., via a malicious page or compromised client), they could inject malicious payloads into the message, which may be logged or processed by the backend, potentially leading to server-side injection or information leakage. This constitutes a cross-site scripting (XSS) vector in the context of service worker message handling, where untrusted input is not properly sanitized before use.}	```if (event.data.indexOf('newspack-nonce-') === 0) { nonceValue = event.data.replace('newspack-nonce-', ''); }```
3352	mediotejo.net.js	XSS via Message Handling	Medium	true	New	8	N/A	standard	{The code uses the event.data property from a message event to extract and assign values to global variables (versionValue) via string manipulation (replace()). Similar to the previous case, this input is not sanitized and is later used in a fetch() call to send data to a backend endpoint. If an attacker can control the message data, they could inject malicious payloads that may be processed by the backend, leading to potential server-side injection or information leakage. This is a cross-site scripting (XSS) vector in the service worker context, where untrusted input is used without validation or sanitization.}	```if (event.data.indexOf('newspack-version-') === 0) { versionValue = event.data.replace('newspack-version-', ''); }```
3353	autoshina.md.js	Hardcoded API Key in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which exposes it to potential extraction by attackers.}	```self[`appKey`] = `13ffd79df188436848c776df5ca15149`;```
3354	autoshina.md.js	Untrusted Dynamic Script Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded value (self.hostUrl), it is not inherently untrusted. However, if self.hostUrl were derived from untrusted input (e.g., user-controlled parameters), it could lead to arbitrary script execution. In this case, since self.hostUrl is hardcoded to a trusted domain, the risk is mitigated. But the vulnerability is still classified as High because the function itself is sensitive and its misuse (e.g., if hostUrl were dynamic) could lead to severe consequences.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3355	businessdiary.com.ph.js	Improper Input Validation Leading to XSS	High	false	New	N/A	N/A	N/A	{The vulnerability arises from storing unsanitized user input (title, text, url, image) directly into IndexedDB without validation or sanitization, which could lead to XSS if the data is later rendered in the DOM without proper escaping. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a lack of input sanitization in the saveData function.}	```const request = store.put(data);```
3356	businessdiary.com.ph.js	Cache Poisoning via Regex Parsing	Medium	true	CWE-113	N/A	RegExp	standard	"{The regex /<img[^>]+src=""(https:\/\/[^"">]+)""/g is used to extract image URLs from HTML content fetched from the network. If the HTML content is untrusted or improperly sanitized, this regex could extract malicious URLs (e.g., from attacker-controlled content) and trigger fetch calls to those URLs, leading to cache poisoning. The misuse of RegExp with untrusted input is the root cause.}"	"```const regex = /<img[^>]+src=""(https:\/\/[^"">]+)""/g;```"
3357	businessdiary.com.ph.js	Insecure IndexedDB Storage Leading to XSS	High	false	CWE-79	N/A	N/A	N/A	{The vulnerability stems from storing unsanitized user-provided data (title, text, url, image) in IndexedDB without validation or sanitization. While this could lead to XSS if the data is later rendered in the DOM, it is not due to misuse of a sensitive JavaScript function, but rather a lack of input sanitization.}	```const request = store.put(data);```
3358	businessdiary.com.ph.js	Incorrect URL Parsing Leading to Cache Misconfiguration	Medium	true	CWE-20	N/A	pwaForWpgetFileExtension	standard	{The function pwaForWpgetFileExtension splits the URL by '.' and takes the last part as the extension, which is vulnerable to incorrect parsing for URLs with query strings or multiple dots. This can lead to misclassification of file types and improper TTL assignment, potentially causing cache misconfiguration. The misuse of string splitting on untrusted input is the root cause.}	```let extension = split_url.split('.').reverse()[0].split('?')[0];```
3359	businessdiary.com.ph.js	Ineffective Online Check with No-CORS	Low	true	CWE-242	N/A	fetch	standard	{The fetch function is used with mode: 'no-cors' to check if a URL is reachable. However, this approach is ineffective because 'no-cors' mode does not allow access to the response, making it impossible to determine if the URL is truly reachable. This misuse of fetch with no-cors mode leads to unreliable connectivity checks.}	```return fetch(url, {method: 'HEAD', mode: 'no-cors'});```
3360	tjapan.jp.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL derived from notification data (data.URL). Since this URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary external sites, leading to open redirect vulnerabilities.}	```return self.clients.openWindow(data.URL);```
3361	tjapan.jp.js	Insecure Data Handling in Notification Image URL	Medium	true	CWE-20	9	JSON.parse	standard	{The function JSON.parse is used to parse untrusted input (body) from a push notification. While JSON.parse itself is not inherently dangerous, the subsequent use of parsed data (data['ImageURL']) as an image source in a notification without validation can lead to unintended resource loading or potential SSRF if the image URL is controlled by an attacker.}	```let data = JSON.parse(body); imageUrl = data['ImageURL'];```
3362	europcar.ie.js	Use of Untrusted Resource	High	true	N/A	9	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed using a hardcoded version number. While the URL is not directly derived from untrusted input, the use of a dynamic URL (even if controlled by the developer) can still be considered risky if the version number is not properly validated or if the domain is compromised. However, in this case, the URL is hardcoded to a trusted domain (via.batch.com) and the version is a constant, so the risk is low. But since the vulnerability was flagged as High, it suggests a broader concern about dynamic script loading. The function itself is sensitive because it executes arbitrary code from a remote source, and if the version number were derived from user input or configuration, it would be a clear injection vector.}	"```function setupSharedBatchSDK() { const BATCHSDK_MAJOR_VERSION = 4; importScripts(""https://via.batch.com/v"" + BATCHSDK_MAJOR_VERSION + ""/worker.min.js""); const eventsList = [""pushsubscriptionchange"", ""push"", ""notificationclick"", ""message"", ""install""]; eventsList.forEach(eventName => { self.addEventListener(eventName, event => { event.waitUntil(self.handleBatchSDKEvent(eventName, event)); }); }); } setupSharedBatchSDK();```"
3363	olimpica.com.co.js	Insecure use of importScripts with third-party script leading to potential XSS or code execution	High	true	CWE-94	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded third-party URL (e.g., from a potentially untrusted source like pushpushgo.com), it introduces a high-risk vulnerability. If the third-party script is compromised or malicious, it can execute arbitrary code within the context of the service worker, leading to potential XSS, data exfiltration, or full compromise of the application's behavior. Although the URL is hardcoded here, the vulnerability arises from trusting an external script without verification or integrity checks.}	```importScripts('https://s-eu-1.pushpushgo.com/6170a8a7c23bbe239a743a91/worker.js');```
3364	honeyee.com.js	Cache Poisoning	High	true	New	N/A	fetch	standard	{The fetch function is used to retrieve resources during the service worker's install phase, where the URL is derived from the urlsToCacheKeys map, which is built from a hardcoded precacheConfig. While the URLs are hardcoded and not directly user-controlled, the vulnerability arises because the service worker caches responses from these URLs without validating or sanitizing the content. If an attacker can manipulate the precacheConfig (e.g., via a compromised build process or supply chain attack), they could inject malicious URLs into the cache, leading to cache poisoning. The fetch function, when used with untrusted or improperly validated URLs, can be misused to load and cache arbitrary content, which is a form of sensitive function misuse.}	```if (!t.has(n)) { var r = new Request(n, { credentials: 'same-origin' }); return fetch(r).then(function (t) { if (!t.ok) throw new Error('Request for ' + n + ' returned a response with status ' + t.status); return cleanResponse(t).then(function (t) { return e.put(n, t); }); }); }```
3365	dveri.com.js	Open Redirect via Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window with a URL derived from t.notification.data, which is untrusted and unsanitized. This allows an attacker to craft a notification payload containing a malicious URL, leading to an open redirect and potential phishing or malware delivery.}	```self.clients.openWindow(t.notification.data);```
3366	dveri.com.js	Insecure Data Handling in Push Event	Medium	true	CWE-79	9	registration.showNotification	standard	{The function registration.showNotification is called with data from t.data.json(), which is untrusted. The notification title and options are directly derived from this data without sanitization, enabling an attacker to inject arbitrary content, potentially leading to cross-site scripting (XSS) or phishing attacks if rendered in the UI.}	```self.registration.showNotification(n.title, n);```
3367	dveri.com.js	Unvalidated Client Message Injection	Low	false	New	0	N/A	N/A	{The postMessage call uses a hardcoded action string 'push_button' and does not involve any dynamic or untrusted input. Therefore, it is not caused by misuse of a sensitive function.}	```t[0].postMessage({ action: 'push_button' });```
3368	newcomerdayton.com.js	Cache Poisoning via Broad Regex	High	true	CWE-918	10	N/A	standard	"{The regular expression /.*?d[dp]-cdn\.multiscreensite\.com.*?/ is overly broad and matches any URL containing ""d[dp]-cdn.multiscreensite.com"", which could include malicious or unintended domains if the domain is controlled by an attacker. This allows an attacker to poison the cache by serving malicious content under a domain that matches the pattern, leading to cache poisoning. The sensitive function workbox.routing.registerRoute() is used with a broad regex, enabling unintended cache behavior.}"	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
3369	newcomerdayton.com.js	Unrestricted Cache Deletion via Message	Medium	true	CWE-494	8	N/A	standard	{The service worker listens for messages and deletes the SITE_PAGES_CACHE_NAME cache without any authentication or authorization checks. The sensitive function caches.delete() is called directly in response to a message from the page, allowing any page to trigger cache deletion, which can be exploited to disrupt service or cause denial of service.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
3370	soxtalk.com.js	Insecure Notification URL Handling	High	true	CWE-601	9	clients[0].navigate	standard	{The navigate() method is used to redirect a client to a URL provided in the notification data. Since this URL is derived from untrusted data (e.g., from a push notification payload), an attacker could craft a malicious notification to redirect users to arbitrary sites, leading to phishing or open redirect vulnerabilities.}	```self.addEventListener('notificationclick', e => { const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
3371	soxtalk.com.js	Open Redirect in Notification Click Handler	High	true	CWE-601	9	clients[0].openWindow	standard	{The openWindow() method is used to open a new window or tab with a URL derived from untrusted notification data. If the URL is not validated or sanitized, an attacker can exploit this to redirect users to malicious sites, enabling phishing or open redirect attacks.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
3372	soxtalk.com.js	Insecure CSRF Token Fetch Handling	Medium	true	CWE-306	8	fetch	standard	{The fetch() function is used to retrieve a CSRF token from a server endpoint, with the path parameter derived from the intercepted request URL. If the path is not properly validated, an attacker could manipulate it to fetch tokens from unintended endpoints, potentially leading to CSRF token leakage or misuse.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```
3373	feednami.com.js	CORS Bypass via Service Worker No-Cors Fetch	High	true	CWE-497	9	fetch	standard	{The fetch API is misused with the 'no-cors' option set dynamically based on the request's hostname or path. When 'no-cors' is enabled, the browser bypasses CORS checks, allowing the service worker to make cross-origin requests without proper validation. This can lead to unauthorized data access or exposure if the service worker is tricked into fetching from a malicious origin. The condition for enabling 'no-cors' is derived from the URL's hostname or path, which are potentially untrusted inputs, making this a sensitive misuse.}	```const fetchOptions = {}; if (shouldCache) { fetchOptions['no-cors'] = true; } event.respondWith(caches.open('v1').then(cache => cache.match(event.request)).then(response => { if (!response) { return fetch(event.request, fetchOptions).then(response => { if (shouldCache) { cacheResponse(request, response); return response.clone(); } return response; }); } return response; }).catch(err => { console.log(err); return fetch(requestCopy); }));```
3374	stateofwatourism.com.js	Improper Cache Deletion Logic	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a logical error in cache deletion: the filter condition checks for cacheName === 'mmnindustrywot-dynamic-v' + version, but the version variable is not appended correctly in the filter condition. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic flaw in the cache deletion process. No sensitive function is being misused here.}	```self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { cacheNames.filter(function (cacheName) { return cacheName === 'mmnindustrywot-dynamic-v' + version; }).map(function (cacheName) { console.log('Service worker has cleared outdated caches.'); return caches.delete(cacheName); }); }).catch(function (err) { console.error('Service worker error: ' + error); })); });```
3375	hiphophero.com.js	Improper Validation of Request Origin	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of the request origin during fetch handling. The code checks for 'only-if-cached' and 'same-origin' mode, but does not enforce strict origin validation for all requests, potentially allowing cross-origin requests to be processed. This is not caused by misuse of a sensitive function, but rather by a logic flaw in request handling.}	```self.addEventListener('fetch', function (t) { var e = t.request; 'only-if-cached' === t.request.cache && 'same-origin' !== t.request.mode || (e.headers.get('Accept').includes('text/html') && t.respondWith(fetch(e).then(function (e) { return e; }).catch(function (e) { return caches.match('/offline/'); })), (e.headers.get('Accept').includes('text/css') || e.headers.get('Accept').includes('text/javascript')) && t.respondWith(async function () { var e = await caches.match(t.request); return e || (await t.preloadResponse) || fetch(t.request); }())); });```
3376	kupika.by.js	Empty Fetch Event Handler	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the empty fetch event handler which may lead to unintended behavior or bypass of expected caching logic. The function `self.addEventListener` is used correctly, and no sensitive function is improperly invoked.}	```self.addEventListener('fetch', function (event) { return; });```
3377	ispace.ge.js	Improper Input Validation in Message Broadcasting	High	true	CWE-20	9	self.addEventListener	standard	{The service worker broadcasts messages received from clients to all connected clients without validating or sanitizing the incoming message data. While self.addEventListener itself is not inherently dangerous, its misuse in this context allows untrusted input (event.data) to be propagated to all clients, potentially leading to cross-site scripting (XSS) or other client-side attacks if the message contains malicious payloads. The vulnerability arises from improper handling of untrusted input rather than direct misuse of a sensitive function, but the event handler's role in propagating unvalidated data makes it a point of sensitive function misuse.}	```self.addEventListener('message', event => {  clients.matchAll().then(clients => {    clients.forEach(client => {      client.postMessage(event.data);    });  });});```
3378	localbeautyclub.com.js	Exposure of Sensitive Information	High	true	CWE-532	N/A	firebase.initializeApp	standard	{The firebase.initializeApp function is used with hardcoded credentials (apiKey, authDomain, etc.) that are exposed in the service worker script. Since service workers run in the browser and are accessible to users, these credentials can be extracted and misused to gain unauthorized access to Firebase services, leading to data exposure or manipulation.}	"```firebase.initializeApp({ apiKey: ""AIzaSyBv0Wx-_IhmloC_JkUmqTO75eAP28Rt6uI"", authDomain: ""flirtproject-7edb3.firebaseapp.com"", databaseURL: ""https://flirtproject-7edb3.firebaseio.com"", projectId: ""flirtproject-7edb3"", storageBucket: ""flirtproject-7edb3.appspot.com"", messagingSenderId: ""1033331891780"", appId: ""1:1033331891780:web:2779c34c293e8769d6a611"" });```"
3379	localbeautyclub.com.js	Open Redirect	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is called with the modifiedLink parameter, which is derived from user-controlled input (e.g., from notification data). If an attacker can manipulate the notification payload to inject a malicious URL, the service worker will open that URL in a new window, leading to an open redirect vulnerability that can be exploited for phishing or malware distribution.}	```clients.openWindow(modifiedLink);```
3380	localbeautyclub.com.js	Exposure of Sensitive Information	High	true	CWE-532	N/A	fetch	standard	{The fetch function is used to send a request to a server with credentials embedded in the Authorization header (Basic + pushConfig.partyId). Since pushConfig.partyId is hardcoded and exposed in the service worker script, an attacker can extract it and use it to impersonate the service worker, leading to unauthorized access to the server's API endpoints.}	"```fetch(pushConfig.apiServerUrl + ""/api/subscribe/refresh/from/sw"" + versionFromParam, { method: 'post', headers: { 'Content-type': 'application/json', 'Authorization': 'Basic ' + pushConfig.partyId }, body: JSON.stringify(messageBody) });```"
3381	talkhome.co.uk.js	Use of Untrusted Resource (External SDK without integrity check	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with hardcoded URLs from untrusted domains (like 'https://aswpsdkeu.com'), it introduces a risk of loading malicious or tampered scripts, leading to potential code injection or compromise of the service worker.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
3382	talkhome.co.uk.js	Hardcoded Sensitive Information (appKey and token	High	false	N/A	0	N/A	N/A	{The vulnerability arises from hardcoded sensitive data (appKey and token) in the code, not from misuse of a sensitive function. These values are passed directly to the uaSetup.worker function, which is a custom API, but the issue is data exposure, not function misuse.}	```uaSetup.worker(self, { defaultIcon: 'https://dl.asnapieu.com/binary/public/ZGdRQ10lSRemMwRaE5o2vg/c3ee51e3\u002D2885\u002D4073\u002Dbc8c\u002De2bea41a36b2', defaultTitle: 'Talk Home Mobile', defaultActionURL: 'https://lab.talkhome.co.uk', appKey: 'HdPNKcdQSUCYsHIJtzZ3_A', token: 'MTpIZFBOS2NkUVNVQ1lzSElKdHpaM19BOmZpQloxVVhIc2hlZTBpa0dfcFZBdGkybzR5Nkk5SGk0YVNmSzBoWDBCMFE', vapidPublicKey: 'BPydkaAVmubM02CNZgMCmgHsaLSSsdkVTmogXSNdPTUFtvZ5U92kj_GWLE1xzHp0jC1HnfZNg-yFZxUU7SdMsyQ=' });```
3383	kukai.app.js	XSS via Untrusted URL Parameter in Service Worker	High	true	CWE-79	10	JSON.parse	standard	{The function JSON.parse is used to parse data derived from untrusted URL parameters (hashParams.state) after decoding. Since the input is not sanitized and can be controlled by an attacker, it enables arbitrary JavaScript execution if the parsed data contains malicious payloads, leading to XSS.}	N/A
3384	kukai.app.js	XSS via Dynamic HTML Generation in Service Worker	High	true	CWE-79	10	Response	standard	{The Response constructor is used to generate HTML content dynamically from untrusted data (hashParams, queryParams, instanceParams) without sanitization. This allows an attacker to inject arbitrary HTML and JavaScript into the response, resulting in XSS.}	N/A
3385	kukai.app.js	XSS via BroadcastChannel Message Injection	Medium	true	CWE-79	9	BroadcastChannel.postMessage	standard	{The postMessage method of BroadcastChannel sends data derived from untrusted URL parameters (hashParams, queryParams, instanceParams) without sanitization. If an attacker controls these parameters, they can inject malicious data into the message, potentially leading to XSS in the receiving context.}	N/A
3386	kukai.app.js	XSS via Opener Window PostMessage	Medium	true	CWE-79	9	window.opener.postMessage	standard	{The window.opener.postMessage function sends data derived from untrusted URL parameters (hashParams, queryParams, instanceParams) to the opener window. Since the data is not sanitized, an attacker can inject malicious scripts into the message, leading to XSS in the opener context.}	N/A
3387	daflores.com.js	External Script Loading from Untrusted Source	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., cdn.pushcrew.com), it introduces a high-risk vulnerability because the script could be tampered with or replaced by an attacker, leading to arbitrary code execution within the service worker context. Although the URL is hardcoded, the source is external and not under the control of the application, making it a sensitive function misuse.}	```importScripts('https://cdn.pushcrew.com/sw/47ed91273c9c11b114d911f2f35212e0.js');```
3388	dogofcum.com.js	Loading external script without integrity checks	High	true	CWE-799	N/A	importScripts('https://platformio-resources.s3.amazonaws.com/js/firebase-messaging-sw-remote.js');	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with hardcoded URLs, it can still pose a risk if the external resource is compromised or if the URL is dynamically controlled by an attacker. In this case, while the URL is hardcoded, the lack of integrity verification (e.g., using a Subresource Integrity hash) means that if the remote script is tampered with, the service worker will execute the malicious code without detection. This constitutes a sensitive function misuse because importScripts() can execute arbitrary code from external sources, and without integrity checks, it becomes a vector for code injection and supply chain attacks.}	```importScripts('https://platformio-resources.s3.amazonaws.com/js/firebase-messaging-sw-remote.js');```
3389	elbocon.pe.js	Cache Poisoning via Message Injection	High	true	CWE-434	10	N/A	standard	{The vulnerability arises from the use of `self.addEventListener('message', ...)` to handle incoming messages. The code processes `t.data.payload.urlsToCache` without validation, and for each URL, it constructs a `Request` object using `new Request(...e)` and passes it to `handleRequest()`. Since the URLs are derived from untrusted message data, an attacker can inject arbitrary URLs, leading to cache poisoning by forcing the service worker to fetch and cache malicious content. The sensitive function `new Request()` is used with untrusted input, enabling cache manipulation.}	```self.addEventListener('message', t => { if (t.data && 'CACHE_URLS' === t.data.type) { const { payload: e } = t.data, s = Promise.all(e.urlsToCache.map(e => { 'string' == typeof e && (e = [e]); const s = new Request(...e); return this.handleRequest({ request: s, event: t }); })); t.waitUntil(s), t.ports && t.ports[0] && s.then(() => t.ports[0].postMessage(!0)); } });```
3390	elbocon.pe.js	Improper Input Validation in Request Handling	Medium	false	CWE-20	0	N/A	standard	{The code checks if the URL protocol starts with 'http' and if the origin matches, but this is not a misuse of a sensitive function. The vulnerability stems from insufficient validation of the URL, not from improper use of a sensitive function like `new URL()` or `fetch()`. The function `new URL()` is used correctly with a base URL (`location.href`), and no dynamic, untrusted input is passed directly to it in a way that would cause misuse.}	```const s = new URL(t.url, location.href); if (!s.protocol.startsWith('http')) return; const n = s.origin === location.origin, { params: r, route: i } = this.findMatchingRoute({ event: e, request: t, sameOrigin: n, url: s });```
3391	roya.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow(url) is a standard browser API used to open a new window or tab with the specified URL. When the URL is derived from untrusted input (event['notification']['data']['url']), and no validation or sanitization is applied, an attacker can craft a malicious URL to redirect users to phishing sites or perform open redirect attacks. This misuse directly enables the vulnerability by allowing arbitrary navigation.}	```const url = event['notification']['data']['url'] || ''; if (url !== '') { event.notification.close(); event.waitUntil(clients.matchAll({ type: 'window' }).then(function (clientList) { for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (client.url === url && 'focus' in client) return client.focus(); } if (clients.openWindow) { return clients.openWindow(url); } })); }```
3392	alljobsforyou.com.js	Exposure of Sensitive Information	High	true	CWE-532	10	N/A	standard	{The apiKey is hardcoded in the script and exposed in the source code, which can be accessed by anyone inspecting the service worker. This allows unauthorized access to Firebase services, enabling potential data breaches or abuse of the Firebase backend.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyCbqYfWswQ3hYlTIkk8lvS_F2SVxLSCKUE' } };```
3393	alljobsforyou.com.js	Insecure Direct Object Reference	High	true	CWE-807	10	N/A	standard	{The targetUrl is derived from event.notification.data.url, which is user-controlled data from a push notification. Passing this directly to clients.openWindow() allows an attacker to redirect users to arbitrary URLs, leading to phishing, malware distribution, or other malicious redirections.}	```clients.openWindow(targetUrl);```
3394	alljobsforyou.com.js	Insecure Direct Object Reference	High	true	CWE-807	10	N/A	standard	{The apiUrl is derived from event.notification.data.api_url, which is user-controlled data from a push notification. Passing this directly to fetch() allows an attacker to make arbitrary HTTP requests from the service worker, potentially exfiltrating data or performing SSRF attacks.}	```fetch(apiUrl);```
3395	alljobsforyou.com.js	Improper Input Validation	Medium	true	CWE-20	8	N/A	standard	{The url parameter is passed to getDomainAndHostname(), which parses it using new URL(url). If the url is not validated, it could lead to unexpected behavior or security issues, such as handling malformed URLs or potentially leaking internal information.}	```domain = getDomainAndHostname(url).hostname;```
3396	primeslots.com.js	Improper Input Validation in Cache Name Construction	High	true	CWE-20	10	caches.open	standard	{The cache name is constructed using user-supplied parameters (brandCode and v) from the URL search parameters without sanitization or validation. The function caches.open is used with this dynamically constructed cache name, which could allow an attacker to manipulate the cache name to cause cache poisoning, bypass cache isolation, or trigger unintended behavior if the cache name contains special characters or malicious payloads.}	N/A
3397	primeslots.com.js	Case-Sensitive No-Cache Parameter Check	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from a case-sensitive check on the 'no-cache' query parameter, which may not match if the parameter is provided in a different case (e.g., 'NO-CACHE' or 'No-Cache'). This is a logic flaw, not a misuse of a sensitive function. No sensitive function is involved in this issue.}	N/A
3398	navbharattimes.com.js	Caching of untrusted API responses without validation	High	true	N/A	N/A	workbox.strategies.staleWhileRevalidate	standard	{The workbox.strategies.staleWhileRevalidate function is used to cache API responses without validating the content or origin of the data. Since the cached responses are served directly to the client without further checks, an attacker could potentially manipulate the API to return malicious content that gets cached and served to users, leading to potential XSS or data leakage.}	```const articleApiHandler = workbox.strategies.staleWhileRevalidate({ cacheName: ARTICLE_API_CACHE, plugins: [new workbox.expiration.Plugin({ maxEntries: 50, maxAgeSeconds: 24 * 60 * 60 }), new workbox.cacheableResponse.Plugin({ statuses: [200] })] });```
3399	navbharattimes.com.js	Insecure IndexedDB data storage without input validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from storing user data in IndexedDB without validating or sanitizing the input. However, no sensitive JavaScript function is directly misused here; the issue is more about data handling logic rather than a function misuse.}	```idb.setData({ keyPath: 'key', value: { key: 'userMsid', value: userMsid } });```
3400	navbharattimes.com.js	SSRF risk via unsanitized URL parameters	Medium	true	N/A	N/A	const apiUrl = `${apiUpdate}/${template}.cms?feedtype=sjson&version=${version}&msid=${item.id}`	standard	{The URL construction uses dynamic values (apiUpdate, template, version, item.id) without sanitization or validation. The concatenation of these values into a URL string and subsequent use in fetch() can lead to SSRF if an attacker can control or influence the item.id or other parameters, allowing them to redirect requests to internal or unintended endpoints.}	```const apiUrl = `${apiUpdate}/${template}.cms?feedtype=sjson&version=${version}&msid=${item.id}````
3401	navbharattimes.com.js	Caching of third-party resources without content validation	Medium	true	N/A	N/A	workbox.routing.registerRoute	standard	{The workbox.routing.registerRoute function is used to cache resources from third-party domains (e.g., static.langimg.com) without validating the content or ensuring its integrity. This allows potentially malicious or compromised third-party resources to be cached and served to users, increasing the attack surface.}	```workbox.routing.registerRoute(/https:\/\/static.langimg.com\/thumb/, workbox.strategies.cacheFirst({ cacheName: 'dynamic-images', plugins: [new workbox.cacheableResponse.Plugin({ statuses: [200] }), new workbox.expiration.Plugin({ maxEntries: 20, maxAgeSeconds: 6 * 60 * 60 })] }), 'GET');```
3402	jwtalk.net.js	Server Side Request Forgery (SSRF) via untrusted 'id' parameter in push event	Medium	true	CWE-829	9	N/A	standard	{The fetch() function is used with a URL constructed from an untrusted 'id' parameter received via the push event. Since the 'id' value is directly interpolated into the URL without validation or sanitization, an attacker can manipulate it to trigger requests to unintended internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3403	jwtalk.net.js	Incorrect logic for determining logged-in state leading to potential authorization bypass	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from flawed logic in parsing the 'loggedIn' parameter from the URL, not from misuse of a sensitive function. The code assumes the parameter is always present and correctly formatted, which could lead to authorization bypass if the URL is manipulated, but no sensitive function is misused.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3404	jwtalk.net.js	Server Side Request Forgery (SSRF) via untrusted 'path' parameter in CSRF token fetch	Medium	true	CWE-829	9	N/A	standard	{The fetch() function is used with a URL constructed from an untrusted 'path' parameter derived from the request URL. Since 'path' is directly interpolated into the URL without validation or sanitization, an attacker can manipulate it to trigger requests to unintended internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3405	da012.com.js	Code Injection	High	true	N/A	9	importScripts	standard	{The function `importScripts()` is used with a dynamically constructed URL derived from the `e` parameter, which is passed directly from user input via the `e` function. Since `e` is derived from an external module path (potentially controlled by an attacker), and `importScripts()` executes any script at the provided URL without sanitization, this allows arbitrary script execution. The vulnerability is exacerbated by the fact that the script is loaded in the context of the service worker, which can lead to full compromise of the application’s caching and network interception capabilities.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); });```"
3406	pg88vnd.com.js	Improper Script Loading in Module Loader	High	true	CWE-22	10	importScripts	standard	{The module loader dynamically constructs script URLs from user-controlled input (via the `e` parameter) and uses `importScripts()` to load them. Since `importScripts()` executes any script at the provided URL without validation, an attacker can manipulate the input to load and execute arbitrary remote scripts, leading to code injection and full compromise of the service worker.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); }```"
3407	liverpoolway.co.uk.js	Server-Side Request Forgery (SSRF) via unsanitized 'id' parameter in push event	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the 'id' parameter received from a push event, which is untrusted. Since the 'id' value is directly interpolated into the URL without sanitization or validation, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3408	liverpoolway.co.uk.js	Server-Side Request Forgery (SSRF) via unsanitized 'path' parameter in CSRF token fetch	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the 'path' parameter derived from the request URL, which is untrusted. The 'path' value is directly interpolated into the URL without sanitization, allowing an attacker to forge requests to unintended endpoints, resulting in SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3409	liverpoolway.co.uk.js	Insecure Direct Object Reference (IDOR) via client-side 'loggedIn' check bypass	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from client-side logic that parses the 'loggedIn' parameter from the URL, which can be easily manipulated by users. This is not due to misuse of a sensitive JavaScript function, but rather a flawed security design relying on client-side state.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3410	bdjobscareers.com.js	Exposure of Sensitive Information	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key, project ID, etc.) in the script, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'push-f28df', messagingSenderId: '853701048653', appId: '1:853701048653:web:24c57b54ac8f406cfa9f04', apiKey: 'AIzaSyDdv9l9pLe-ILPcpjmKnPGeliy4UQYtHZQ' }, domain: 'www.bdjobscareers.com', api_url: 'https://push.bdjobscareers.com/api/token', vapid_public_key: 'BACViJ8rYntosyTqbK7gTCSfkFfGjdfVfpDGuWeC76IexvPAFeEov-CadFh4dUz56R4a35QKHcbwZidopolZZJg' };```
3411	bdjobscareers.com.js	Improper Input Validation	Medium	true	CWE-20	N/A	clients.openWindow	N/A	{The code uses `clients.openWindow(targetUrl)` and `fetch(apiUrl)` where `targetUrl` and `apiUrl` are derived from notification data, which is untrusted input. This allows an attacker to control the URLs, leading to open redirect or arbitrary resource fetching, which is a misuse of the `clients.openWindow` and `fetch` functions.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl);```
3412	bdjobscareers.com.js	Insecure Data Storage	Low	false	CWE-311	N/A	N/A	N/A	{The vulnerability stems from storing data in IndexedDB without encryption, which is a data storage issue, not a misuse of a sensitive JavaScript function.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value });```
3413	topquizz.com.js	Open Redirect via Unvalidated Click Action	Medium	true	CWE-601	9	N/A	standard	{The function `self.clients.openWindow()` is a standard browser API used to open a new window or tab. When it is called with user-controlled input (e.g., `e.notification.data.click_action`), and that input is not validated or sanitized, it can be manipulated to redirect users to arbitrary, potentially malicious URLs. This constitutes an open redirect vulnerability, allowing attackers to trick users into visiting phishing or malicious sites.}	```e.waitUntil(self.clients.openWindow(e.notification.data.click_action));```
3414	cutedressup.com.js	Precaching Empty String Vulnerability	Low	false	New	N/A	N/A	N/A	{The vulnerability arises from precaching an empty string, which may lead to unintended behavior or cache key conflicts, but it does not stem from misuse of a sensitive function like importScripts or eval. The workbox.precaching.precache function is used correctly with static inputs, and no dynamic or untrusted data is involved.}	"```workbox.precaching.precache([""https:\/\/cutedressup.com"", """", ""https:\/\/cutedressup.com\/contact-us\/""]);```"
3415	nyctransitforums.com.js	Improper Input Validation Leading to SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the `id` parameter received from a push notification, which is untrusted input. The URL is built as `${BASE_URL}index.php?...&id=${id}`, allowing an attacker to manipulate the `id` value to trigger requests to unintended internal or external endpoints, potentially leading to SSRF if the server makes outbound requests based on this input.}	N/A
3416	nyctransitforums.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	clients[0].navigate	standard	{The clients[0].navigate function is called with a URL derived from the `data.url` field in a notification payload, which is untrusted. If an attacker can control this field, they can redirect users to arbitrary websites, leading to open redirect vulnerabilities. The code does not validate or sanitize this URL before navigation.}	N/A
3417	idolforums.com.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this `id` value is derived from untrusted external input (push notification payload), an attacker could craft a malicious notification with a crafted `id` value to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF. The URL is built using template literals and concatenation, and no validation or sanitization is applied to the `id` parameter, making this a direct misuse of the standard fetch API.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3418	potsandpans.in.js	Remote Code Execution via External Script Import	High	true	CWE-444	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a dynamically constructed URL (swUrl + ""?orgtoken=706lg-BQQwWNeIcF2hlgXQ""), which, while not directly user-controlled, is still a remote script source. Since the script is loaded from an external domain (tracker.wigzopush.com), it introduces a risk of remote code execution if the remote script is compromised or if the domain is hijacked. The function is sensitive because it executes arbitrary code from a remote source without any sanitization or integrity checks.}"	"```var swUrl = 'https://tracker.wigzopush.com/wigzo_sw.js'; importScripts(swUrl + ""?orgtoken=706lg-BQQwWNeIcF2hlgXQ"");```"
3419	detoursenfrance.fr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the exposure of sensitive credentials (appKey, token, vapidPublicKey) in the code, but not due to misuse of a sensitive JavaScript function. These values are hardcoded and statically defined, not dynamically derived or passed to a function that could lead to injection or execution risks.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, { defaultIcon: 'https://i.unimedias.fr/ui/def/logo-def.png', defaultTitle: 'Détours en france', defaultActionURL: 'https://www.detoursenfrance.fr', appKey: 'Fid51zb5Sxu6EUOt5fA95Q', token: 'MTpGaWQ1MXpiNVN4dTZFVU90NWZBOTVROmVrckNEN2dRVENVRnJGelRiZW5kRzZFVlU3ZUpPS3poeVd4cmpNaktHSzQ', vapidPublicKey: 'BOjwj89C-DPbH0sqhgvmvmdLIQvmwPK7qQ6vAwBA-eLfwlEnQLWWdFx4Byg8zCEyulus1cd9pp6bWcsYjoHxRsg' });```
3420	nyetroms.no.js	Vulnerable Host Check in Pattern	High	true	N/A	N/A	RegExp.prototype.test	standard	{The pattern4 function uses a regular expression to check if the request's host contains the string 'www.nyetroms.no'. However, the host string is not sanitized or validated before being used in the RegExp test, and the pattern is hardcoded with literal quotes around the domain. This creates a potential for misinterpretation or injection if the host value were dynamic, though in this case it is static. The vulnerability arises from the unsafe use of RegExp.test with a potentially untrusted or unsanitized input context, even if the input is hardcoded here.}	```const pattern4 = (req) => { return req.event.request.mode === 'navigate' && req.url.pathname === '/' && req.url.host.indexOf(''www.nyetroms.no'') !== -1 && req.event.request.method === 'GET'; };```
3421	nyetroms.no.js	Cache Poisoning via Vary Header Modification	High	true	N/A	N/A	Response	standard	{The cacheWillUpdate function creates a new Response object using the original response's headers, including the 'Vary' header. It then modifies the 'Vary' header by filtering out 'user-agent' values. However, this function does not validate or sanitize the headers before creating the new Response, allowing an attacker to inject arbitrary headers (including 'Vary') into the cached response. This can lead to cache poisoning, where responses are served to the wrong clients based on manipulated Vary headers, potentially exposing sensitive data or bypassing security controls. The misuse of the Response constructor with unsanitized headers is the root cause.}	```async function cacheWillUpdate({ response }) { const init = { status: response.status, statusText: response.statusText, headers: {} }; response.headers.forEach((val, key) => { init.headers[key] = val; }); if (init.headers.vary) { init.headers.vary = init.headers.vary.split(',').filter(h => h.trim().toLowerCase() !== 'user-agent').join(','); } self.emergencyMode = (init.headers['x-emergency-mode'] || '').split(','); const body = await response.text(); return new Response(body, init); }```
3422	autostol63.ru.js	Incorrect URL Matching in Cache Exceptions	High	true	CWE-601	N/A	N/A	standard	{The code uses `indexOf` to check if a URL pathname or hostname exists in a comma-separated string of exceptions. This is unsafe because it performs substring matching without proper URL parsing or normalization, allowing attackers to bypass cache exceptions by crafting URLs that contain substrings matching the exception list (e.g., `https://evil.com/path` matching `https://vk.com` if `path` is part of the string). This leads to unintended cache bypass or resource fetching.}	```if (url_exception.pathname && url_exception.pathname != '/' && busApp.setting['cache_resources_exception'].indexOf(url_exception.pathname) != -1 || url_exception.hostname && busApp.setting['cache_resources_exception'].indexOf(url_exception.hostname) != -1) { return event.request; }```
3423	autostol63.ru.js	Open Redirect in Notification Handling	Medium	true	CWE-601	N/A	N/A	standard	{The `clients.openWindow(url)` function is called with a URL derived from `event.notification.data.url`, which is user-controlled via push notifications. Since the URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to phishing or drive-by downloads.}	```if ('data' in event.notification) { var url = event.notification.data.url.replace(/&amp;/g, '&'); for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (client.url == url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } }```
3424	ilmaggiodeilibri.it.js	Server Side Request Forgery (SSRF	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (sensor_url and push_send_id from event.data). Since these values are derived from external data (push notification payload), an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.ilmaggiodeilibri.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' })```
3425	ilmaggiodeilibri.it.js	Server Side Request Forgery (SSRF	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (sensor_url and push_send_id from event.notification.data). Since these values are derived from external data (notification payload), an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.ilmaggiodeilibri.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' })```
3426	ourendangeredworld.com.js	Improper URL Validation in Cache Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded URLs in the offlineFundamentals array, which are used for precaching. Since these URLs are not dynamically derived from untrusted input, they do not involve misuse of a sensitive function. The issue is more about static configuration rather than function misuse.}	"```var offlineFundamentals = [{""url"": ""https:\/\/www.ourendangeredworld.com"", ""revision"": ""60551""}];```"
3427	ourendangeredworld.com.js	Insecure Cache Key Generation	Medium	true	N/A	N/A	`new URL(s, location.href)`	standard	{The function `new URL(s, location.href)` is used to generate cache keys from URLs. If the input URL `s` is derived from untrusted sources (e.g., user-controlled parameters), it could be manipulated to bypass cache validation or inject malicious cache keys. This misuse allows attackers to influence cache behavior, potentially leading to cache poisoning or bypassing intended security controls.}	"```const { cacheKey: e, url: s } = e; const n = new URL(s, location.href), a = new URL(s, location.href); n.searchParams.set(""__WB_REVISION__"", t);```"
3428	ourendangeredworld.com.js	Cross-Origin Resource Caching	High	true	N/A	N/A	`new URL(e.url).origin`	standard	{The function `new URL(e.url).origin` is used to extract the origin of a response URL. If `e.url` is derived from untrusted input, an attacker could supply a cross-origin URL, leading to unintended caching of cross-origin resources. This violates same-origin policy and may expose sensitive data or allow cache poisoning.}	"```if (e.url) { s = new URL(e.url).origin; } if (s !== self.location.origin) throw new r(""cross-origin-copy-response"", { origin: s });```"
3429	ourendangeredworld.com.js	Insecure Cache Busting Mechanism	Medium	true	N/A	N/A	`searchParams.set`	standard	{The `searchParams.set('__WB_REVISION__', t)` method is used to append a revision parameter to URLs for cache busting. If the `t` (revision) value is derived from untrusted input, it could be manipulated to bypass cache validation or trigger unintended cache behavior, potentially leading to cache poisoning or stale content delivery.}	"```const n = new URL(s, location.href); n.searchParams.set(""__WB_REVISION__"", t);```"
3430	ourendangeredworld.com.js	Insecure Cache Deletion Logic	Medium	false	N/A	N/A	N/A	N/A	{The cache deletion logic involves filtering and deleting cache entries based on cache keys. Since the cache keys are derived from preconfigured URLs and not from untrusted input, there is no misuse of a sensitive function. The vulnerability stems from improper handling of cache keys rather than function misuse.}	```const { deletedURLs: n } = await e.caches.open(this.strategy.cacheName).keys();```
3431	emumovies.com.js	Improper Input Validation (IDOR via push event)	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from the push event data. Since this 'id' is directly taken from untrusted input (push notification payload) without validation or sanitization, an attacker can manipulate it to access unauthorized notifications, leading to Insecure Direct Object References (IDOR). The URL is built as `${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, making it vulnerable to IDOR attacks.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3432	emumovies.com.js	Open Redirect via notification click	Medium	true	CWE-601	N/A	navigate	standard	{The navigate function is used with the 'data.url' value from the notification payload, which is untrusted and unsanitized. If an attacker can control the notification data (e.g., via a malicious push message), they can set 'data.url' to an arbitrary external URL, causing the browser to navigate to that URL when the notification is clicked, resulting in an open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
3433	taki.sale.js	Insecure Use of Third-Party Code without SRI	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of Subresource Integrity (SRI) checks when loading the third-party script via importScripts. While importScripts is a sensitive function, its use here is with a hardcoded, trusted URL, so no dynamic or untrusted input is involved. Therefore, the issue is a configuration or policy gap, not a sensitive function misuse.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');```
3434	dreamtours.pl.js	Missing Security Headers in Offline Page	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the absence of security headers (e.g., Content-Security-Policy, X-Content-Type-Options) in the offline response. The code constructs a static HTML response using `new Response()` with only a Content-Type header, which is insufficient for protecting against certain client-side attacks.}	"```return new Response(responseContent, { headers: { ""Content-Type"": ""text/html; charset=utf-8"" } });```"
3435	midgampanel.com.js	Improper Cache Control for Dynamic Resources	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from hard-coded precaching of static resources, not from misuse of a sensitive function. The function toolbox.precache is used correctly with fixed paths, and no dynamic or untrusted input is involved.}	```toolbox.precache(['/', '/inc/w3rtl.css', '/inc/w3.css', '/nimg/logo.jpg']);```
3436	midgampanel.com.js	Improper Query String Handling in Caching	Medium	false	CWE-918	N/A	N/A	N/A	{The issue stems from the configuration option ignoreSearch: true, which is a deliberate design choice for caching behavior, not misuse of a sensitive function. No dynamic or untrusted input is processed by a sensitive function here.}	```queryOptions: { ignoreSearch: true }```
3437	triaba.com.js	Improper Cache Deletion Leading to Data Loss	High	true	CWE-399	9	caches.keys	custom	{The caches.keys() function is used to retrieve all cache names, but the subsequent filtering and deletion logic is flawed. The condition `key !== dynamicCacheName` is incorrect because it compares a string with a function, which will always evaluate to true, leading to no caches being deleted. This misuse of caches.keys() and improper handling of the keys array results in unintended cache retention or deletion, potentially causing data loss or cache pollution.}	```self.addEventListener('activate', evt => {  evt.waitUntil(caches.keys().then(keys => {    return Promise.all(keys.filter(key !== dynamicCacheName).map(key => caches.delete(key)));  }));  return self.clients.claim();});```
3438	triaba.com.js	Path Traversal in Cache Matching	High	true	CWE-22	8	RegExp.match	standard	{The use of a regular expression with a pattern `/(.*?)\/uploads\/(.*?)` to match URLs in the fetch event handler allows for arbitrary path traversal. Since the pattern is overly permissive and does not validate or sanitize the matched path components, an attacker could craft a request URL with malicious path segments (e.g., `../../etc/passwd`) to bypass intended restrictions and access unintended resources, leading to unauthorized data exposure or cache manipulation.}	```if (!evt?.request?.url?.match(/(.*?)\/uploads\/(.*?)/)) return;```
3439	michanikos.gr.js	Insecure Handling of Notification Data (XSS)	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display notifications with user-controlled data (title, body, icon, etc.) directly from the push event payload without sanitization. Since the data comes from an external source (push message), an attacker can inject malicious content (e.g., script tags) into the notification, leading to XSS if the browser renders it in a context that executes JavaScript.}	```const { body, url, grouped, groupedTitle, groupedUrl, icon, image } = data; let { title } = data; let tag; if (data.tag) { tag = data.tag.substr(0, 30); } let options = { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } };```
3440	michanikos.gr.js	Open Redirect in Notification Click	Medium	true	CWE-601	N/A	clients[0].navigate	standard	{The function clients[0].navigate is called with a URL derived from the notification's data.url, which is user-controlled via the push event. If an attacker can manipulate the push payload to include a malicious URL, this can lead to an open redirect, potentially phishing users or redirecting them to malicious sites.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
3441	michanikos.gr.js	Potential SSRF via Push Event	High	true	CWE-918	N/A	fetch	standard	{The fetch function is used to make a request to a URL constructed from the push event's id parameter, which is user-controlled. If the server does not validate the id parameter, an attacker could craft a push message with an id that causes the service worker to make requests to internal or external resources, potentially leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3442	michanikos.gr.js	Insecure CSRF Token Handling	Medium	true	CWE-352	N/A	fetch	standard	{The fetch function is used to retrieve a CSRF token from a URL constructed using the request's path, which is user-controlled. If the path is not properly validated, an attacker could manipulate it to fetch tokens for unintended endpoints, potentially leading to CSRF attacks if the token is then used in subsequent requests.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); })```
3443	michanikos.gr.js	Insecure URL Parsing for Logged-In Status	High	true	New	N/A	e.currentTarget.location.href.match	standard	{The function match is used to extract the logged-in status from the service worker's current URL, which is user-controlled. If the URL is manipulated (e.g., via a crafted redirect or malicious site), the service worker may incorrectly determine the user's login state, leading to potential bypasses of authentication checks or other logic flaws.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3444	ujerseyus.com.js	Insecure Direct Object Reference (IDOR) in Host Parameter	High	true	CWE-20	9	N/A	standard	{The fetch function is used with a dynamically constructed URL derived from payload.data.host, which is sourced from untrusted push notification data. Since the host is not validated or sanitized, an attacker can manipulate it to access unauthorized resources on the server, leading to IDOR.}	```fetch(`${payload.data.host}/front/popup`, { method: 'PUT', body: JSON.stringify({ subscription_code: payload.data.subscription_code, trance_id: payload.data.trance_id }), headers: { 'Content-Type': 'application/json' } }).then(res => {});```
3445	ujerseyus.com.js	Open Redirect via Unvalidated Notification Data	High	true	CWE-601	9	N/A	standard	{The clients.openWindow function is called with a URL derived from the link or urls[action] fields in the notification data, which are untrusted and unvalidated. This allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```e.waitUntil(clients.openWindow(link));```
3446	ujerseyus.com.js	Unvalidated JSON Payload Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The payload is parsed using event.data.json(), which is a standard and safe method for parsing JSON in Service Workers. While the data source is untrusted, the function itself is not inherently unsafe; the vulnerability lies in the lack of validation of the parsed data, not in the function misuse.}	```const payload = event.data ? event.data.json() : null;```
3447	ujerseyus.com.js	Insecure Fetch Response Handling	Low	false	CWE-252	N/A	N/A	N/A	{The code checks res.code === 0, but this is not a misuse of a sensitive function. The fetch API is used correctly; the issue is a logic flaw in handling the response, not improper use of a sensitive function.}	```if (res.code === 0) { console.log('webpush点击事件统计成功'); }```
3448	stroychet.ru.js	Insecure External Script Loading	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hard-coded and not derived from untrusted input, the function itself is inherently sensitive because it can execute arbitrary code from remote sources. However, since the URL is fixed and not dynamically constructed from user-controlled or untrusted data, the risk is mitigated but still present due to the potential for supply chain compromise if the external script is compromised.}	"```if (typeof importScripts === 'function') { importScripts(""https://image.sendsay.ru/js/push/sendsay_swa.js""); }```"
3449	premagic.com.js	Improper Input Validation	High	true	CWE-20	9	N/A	standard	{The `MessageAPI[api](event, event.data);` line dynamically invokes a function from the `MessageAPI` object based on the `api` value received from `event.data`. Since `api` is derived from untrusted user input (via `self.addEventListener('message', ...)`), an attacker can send a malicious `api` value to trigger arbitrary function calls, potentially leading to unauthorized operations such as clearing caches or enabling/disabling offline shell features. This constitutes a dangerous form of reflective function invocation.}	```MessageAPI[api](event, event.data);```
3450	premagic.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	{The `const [key, val] = param.split(`=`);	N/A	N/A	N/A
3451	premagic.com.js	Improper Enforcement of Bounding Resource	Medium	false	CWE-377	N/A	```if (key && key.includes(`runtime`)) { return caches.delete(key); }	N/A	{The `if (key && key.includes(`runtime`)) { return caches.delete(key); }` line checks for cache keys containing `runtime` and deletes them. This is a conditional deletion based on a string match, not a sensitive function misuse. The `caches.delete()` function is used safely with a controlled key derived from `caches.keys()`, and no untrusted input is directly passed to it.}	N/A
3452	premagic.com.js	Improper Check for Unusual Conditions	Medium	false	CWE-703	N/A	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }	N/A	{The `if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }` line checks if a function exists in the `MessageAPI` object before invoking it. While this check is necessary, it does not involve a sensitive function misuse. The vulnerability arises from the lack of validation on `data.api`, which is derived from user input, but the function call itself is not inherently dangerous due to the nature of the `MessageAPI` functions.}	N/A
3453	xn--ob-eka.se.js	Improper Handling of Cache and Fetch Leading to SSRF Vulnerability	High	true	CWE-918	9	fetch	standard	{The fetch() function is used without validating or sanitizing the request URL, which is derived from the incoming fetch event. Since the service worker processes any request made by the client (including potentially malicious URLs), this allows an attacker to trigger requests to internal or external resources, leading to Server-Side Request Forgery (SSRF). The vulnerability arises because fetch() is a standard JavaScript API that executes network requests based on untrusted input, and no checks are performed to restrict or sanitize the target URL.}	"```self.addEventListener(""fetch"", e => { ""navigate"" === e.request.mode && e.respondWith(caches.match(e.request).then(() => fetch(e.request).catch(() => caches.match(offlinePage)))); });```"
3454	kcsgis.com.js	Improper URL Matching in Regex Patterns	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of improperly escaped or overly broad regular expressions in URL matching, which can lead to unintended matches or bypasses. However, this is not due to misuse of a sensitive JavaScript function, but rather flawed pattern design.}	"```const c = JSON.parse('[""kcsgis\\\\.com(?:/.*)?/ola/services/.*"",""kcsgis\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://ba6716fe-099d-4ca3-b182-d8b02318b5b8\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
3455	kcsgis.com.js	Insecure Caching of Sensitive Data	High	true	N/A	N/A	registerRoute	standard	{The registerRoute function is misused by passing a dynamic regex pattern derived from JSON-parsed strings, which can lead to unintended caching of sensitive or malicious content if the patterns are not properly validated. The function is standard and used to define routing rules, but when combined with untrusted or improperly sanitized input, it can allow attackers to manipulate cache behavior.}	```(0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkFirst({ cacheName: 'network-first', plugins: [new a.CacheableResponsePlugin({ statuses: [200] })] }));```
3456	kcsgis.com.js	Potential Cache Deletion of Unintended Caches	Medium	true	N/A	N/A	caches.delete	standard	{The caches.delete function is used with a dynamic filter based on cache names starting with 'kcsgis.com-', which can lead to unintended deletion of caches if the filter is not properly constrained. This is a standard function, but its misuse with dynamic input can result in cache poisoning or data loss.}	```self.addEventListener('activate', function (e) { e.waitUntil(caches.keys().then(function (e) { return Promise.all(e.filter(e => e.startsWith('kcsgis.com-')).map(e => caches.delete(e))); })); });```
3457	kcsgis.com.js	Lack of Input Validation in Request Handling	High	true	N/A	N/A	registerRoute	standard	{The registerRoute function is used with a condition that checks request destination without validating or sanitizing the input, which can lead to unintended caching or processing of requests. This is a standard function, but its misuse with untrusted input can allow attackers to bypass intended security controls.}	```(0, e.registerRoute)(({ request: e }) => 'image' === e.destination || 'font' === e.destination, new t.CacheFirst({ cacheName: 'images-fonts', plugins: [new a.CacheableResponsePlugin({ statuses: [200] }), new n.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 2592e3 })] }));```
3458	forumosa.com.js	Improper Input Validation	High	true	CWE-20	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL and body that includes user input (`t.reply`) without proper sanitization. This allows an attacker to inject malicious data into the POST request body, potentially leading to unintended server-side behavior, such as command injection or unauthorized actions if the server improperly processes the input. The use of `t.reply` directly in the body string without validation or encoding makes this a sensitive function misuse.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
3459	zerply.com.js	Improper Input Validation in Cache Deletion	High	true	CWE-20	10	cache.delete	standard	{The cache.delete() function is used to remove entries from the cache based on URLs provided in event.data.data, which is derived from a message event. Since the input is not validated or sanitized, an attacker could send arbitrary URLs to delete unintended cache entries, potentially disrupting service or clearing sensitive cached data. This constitutes improper input validation leading to unauthorized cache manipulation.}	```caches.open(CACHE_CURRENT).then(function (cache) { event.data.data.forEach(function (url) { cache.delete(url); }); });```
3460	geek2u.ru.js	External Script Execution via importScripts	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., 'https://nservw.net/sA6zsexr66.js'), it introduces a high-risk vulnerability because the script is executed without any validation or sanitization. This allows an attacker who controls the external script to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks.}	```importScripts('https://nservw.net/sA6zsexr66.js');```
3461	jadoyebavar.ir.js	Untrusted External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and points to an external domain (van.najva.com), which is not under the control of the service worker's origin. While the URL is static and not dynamically constructed from untrusted input, the act of importing a script from an external, untrusted source still constitutes a high-risk vulnerability because it allows an attacker who controls the external resource to inject malicious code into the service worker, potentially compromising the entire web application's security, including intercepting network requests, manipulating cache, or stealing sensitive data.}	```importScripts('https://van.najva.com/static/js/scripts/jadoyebavar132-website-32133-a5694bc6-bcf6-474e-91f1-961dec2bcba5-service-worker.js');```
3462	foromedios.com.js	Improper Validation of Redirect URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from trusting the `data.url` value from a notification without validating or sanitizing it. While `clients[0].navigate()` is a standard function, the issue is not due to misuse of the function itself but rather improper input validation. The function is used correctly; the flaw lies in the logic that allows arbitrary URLs to be passed to it.}	```const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
3463	foromedios.com.js	Incorrect Login State Detection	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from relying on a URL parameter (`loggedIn`) for login state detection, which can be easily manipulated by an attacker. This is a logic flaw, not a misuse of any sensitive function. The `match()` function is used correctly to parse the URL, but the issue is in the insecure state detection mechanism.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3464	foromedios.com.js	Insecure Fetch with Credentials	Medium	false	N/A	N/A	N/A	N/A	{The `fetch()` function is used with `credentials: 'include'`, which is appropriate for authenticated requests. The vulnerability arises from the lack of proper validation of the `id` parameter in the URL, which could lead to unauthorized access if the ID is controlled by an attacker. However, the `fetch()` function itself is not misused; the issue is in the insecure handling of the input parameter.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3465	kuroiru.co.js	Insecure Caching of Network Responses without Validation	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching network responses without validating their integrity or origin, but no sensitive function is misused in this case. The issue is more about logic and policy than function misuse.}	```cache.match('/ernet.html').then(function (isCached) { if (!isCached) { cache.add('/ernet.html'); } });```
3466	kuroiru.co.js	Unreliable Offline Detection using navigator.onLine	Medium	false	N/A	N/A	N/A	N/A	{The use of navigator.onLine is unreliable for detecting offline state, but it is not a sensitive function misuse. The issue stems from the inherent limitations of the API, not improper usage.}	```if (self.navigator.onLine === false && event.request.mode === 'navigate') { event.respondWith(async function () { return fetch(event.request).catch(() => caches.match('/eroff.html')); });```
3467	kuroiru.co.js	Potential Denial of Service (DoS) due to Redundant Network Requests	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to redundant network requests caused by logic flaws, not misuse of a sensitive function. The cache.add() call is not triggered by untrusted input.}	```cache.add('/ernet.html');```
3468	kuroiru.co.js	Race Conditions in Cache Update Logic	Medium	false	N/A	N/A	N/A	N/A	{Race conditions occur due to asynchronous operations without proper synchronization, but no sensitive function is misused. The issue is architectural, not functional.}	```cache.match('/ernet.html').then(function (isCached) { if (!isCached) { cache.add('/ernet.html'); } });```
3469	kuroiru.co.js	Lack of Error Handling in Cache Operations	Low	false	N/A	N/A	N/A	N/A	{The lack of error handling is a coding oversight, not a misuse of a sensitive function. The cache.add() operation is used safely with hardcoded paths.}	```cache.add('/ernet.html');```
3470	denicler.eu.js	Improper Cache Key Validation	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from overly broad regular expressions used in registerRoute, which may allow unintended URLs to be cached. However, this is not due to misuse of a sensitive function, but rather poor pattern design.}	```registerRoute(/^(.*)(static)(.*)(.(png|jpeg|jpg|gif|svg|css|js|woff|woff2|ttf|eot|ico|json))$/```
3471	denicler.eu.js	Improper Cache Key Validation	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from overly broad regular expressions used in registerRoute, which may allow unintended URLs to be cached. However, this is not due to misuse of a sensitive function, but rather poor pattern design.}	```registerRoute(/^(.*)(media)(.*)(.(png|jpeg|jpg|gif|css|js|svg|pdf))$/```
3472	denicler.eu.js	Incorrect Use of Cache Plugins	Low	false	CWE-319	N/A	N/A	N/A	{The issue stems from using CacheableResponsePlugin with a maxEntries of 1, which may lead to cache eviction issues, but it is not caused by misuse of a sensitive function.}	```return caches.match(OFFLINE_FALLBACK_HTML_URL, {cacheName: OFFLINE_CACHE_NAME, plugins: [new CacheableResponsePlugin({statuses: [0, 200]}), new ExpirationPlugin({maxAgeSeconds: CACHE_LIFETIME, maxEntries: 1})]})```
3473	denicler.eu.js	Insecure HTTP Status Code Handling	Low	false	CWE-200	N/A	N/A	N/A	{The use of status code 0 in CacheableResponsePlugin is a configuration issue, not a result of sensitive function misuse. Status 0 is not a valid HTTP status and may lead to unexpected behavior, but it does not stem from improper function usage.}	```new CacheableResponsePlugin({statuses: [0, 200]})```
3474	faktyoswiecim.pl.js	External Script Loading in Service Worker	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., 'https://api.push-ad.com/v1/pushAdWorker.js'), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This can lead to code injection, data exfiltration, or manipulation of the service worker’s behavior, especially if the external script is compromised or malicious.}	```importScripts('https://api.push-ad.com/v1/pushAdWorker.js');```
3475	dogtipper.com.js	All-or-Nothing Cache Installation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's cache installation strategy, which attempts to cache all specified URLs during the install event without handling failures gracefully. This is not caused by misuse of a sensitive JavaScript function, but rather by a flawed caching logic that can lead to partial or failed cache installations. The code uses `caches.open()` and `addAll()` in a way that does not account for individual failures, which may result in an incomplete cache state.}	"```self.addEventListener(""install"", function (e) { var t = offlineFundamentals.map(function (e) { return e.url; }), s = b.runtime; e.waitUntil(caches.open(s).then(function (e) { return e.addAll(t); })); });```"
3476	blockerdns.com.js	Improper Error Handling in Service Worker Response	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling during the fetch response processing, but it is not caused by misuse of a sensitive function such as importScripts, eval, or dynamic code execution. Instead, it stems from a logic flaw where non-404 errors are caught and replaced with a generic fallback response, potentially masking real issues or allowing attackers to exploit unexpected behavior. No sensitive function is involved in this case.}	```self.addEventListener('fetch', event => { if (event.request.method == 'GET' && event.request.url.startsWith(self.location.origin)) { event.respondWith(fetch(event.request).then(function (response) { if (!response.ok) { if (response.status == 404) { return response; } else { throw Error('response status ' + response.status); } } else { return response; } }).catch(function (error) { var fallbackResponse = { result: true }; return new Response(JSON.stringify(fallbackResponse), { headers: { 'Content-Type': 'application/json' } }); })); } });```
3477	blockpass.org.js	Insecure Message Handling	High	true	CWE-319	9	`self.addEventListener`	standard	{The `self.addEventListener` function is used to handle incoming messages, and the message payload is directly used to dynamically invoke functions via `MessageAPI[api]`. Since the `api` value comes from untrusted `event.data`, this allows an attacker to trigger arbitrary functions in the MessageAPI object, potentially leading to unauthorized cache manipulation, data leakage, or denial of service. This is a classic case of insecure dynamic function invocation via user-controlled input.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
3478	blockpass.org.js	Overly Broad Cache Regex	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from a broad regex pattern used in `workbox.routing.registerRoute`, but it does not involve misuse of a sensitive function. The issue is a configuration flaw in route matching logic, not a direct function misuse.}	```workbox.routing.registerRoute(/(\.js$|\.css$|static\/)/, new workbox.strategies.CacheFirst(), 'GET');```
3479	blockpass.org.js	Cache Poisoning Risk	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of `caches.keys()` and `caches.delete()` in a context where the cache keys are filtered by a hardcoded string (`runtime`). While `caches.delete()` is a sensitive function, the input is not dynamic or user-controlled; it is based on a static string check. Therefore, this is not a sensitive function misuse but a potential logic flaw in cache management.}	```event.waitUntil(idbKeyval.clear()); event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
3480	rathena.org.js	Incorrect Login Status Determination	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter directly from the URL using a regex, which can be manipulated by an attacker to bypass authentication checks. This is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in how login state is determined.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3481	rathena.org.js	CSRF Token Generation for Untrusted Paths	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` parameter derived from the request URL. If the path is not properly validated, an attacker could inject malicious paths, leading to CSRF token generation for unintended endpoints, potentially allowing unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {```
3482	nonshy.com.js	Improper Exception Handling in JSON Parsing	Medium	false	CWE-703	N/A	N/A	N/A	{The vulnerability arises from not handling potential errors during JSON parsing, but it is not caused by misuse of a sensitive function. The JSON.parse() function is used correctly, and the issue is related to exception handling rather than function misuse.}	```const payload = JSON.parse(event.data.text());```
3483	nonshy.com.js	Untrusted Input in Notification Content	Medium	false	CWE-79	N/A	N/A	N/A	{The vulnerability stems from using untrusted data (payload.title and payload.body) in a notification without sanitization, but it does not involve misuse of a sensitive function like importScripts or eval. The showNotification() function is used appropriately, and the risk is due to data handling, not function misuse.}	"```event.waitUntil(self.registration.showNotification(payload.title, { body: payload.body, icon: ""/static/img/favicon-192.png"" }));```"
3484	scriptyab.com.js	Insecure Cache Name (HTTP instead of HTTPS	High	false	N/A	N/A	N/A	N/A	{The cache name uses an HTTP URL scheme, which is insecure and may lead to cache poisoning or man-in-the-middle attacks if the service worker is accessed over HTTPS. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a hardcoded insecure URL scheme.}	```const cacheName = 'http://scriptyab.com-superpwa-2.2.31';```
3485	infiniment-charentes.com.js	Empty Fetch Event Handler	Low	false	N/A	0	N/A	N/A	{The fetch event handler is empty, which does not constitute a security vulnerability caused by misuse of a sensitive function. It merely indicates that no logic is implemented to handle fetch events, but no dangerous function is being improperly used.}	```self.addEventListener('fetch', function (event) {});```
3486	manhwasco.net.js	Missing Subresource Integrity (SRI) for imported Workbox script	High	true	CWE-929	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without Subresource Integrity (SRI), it becomes vulnerable to supply chain attacks, as an attacker could compromise the CDN (e.g., storage.googleapis.com) or intercept the request to inject malicious code into the service worker. The script URL is hardcoded, but the lack of integrity verification means any tampered version could be executed, leading to full control over the service worker's behavior.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js"");```"
3487	manhwasco.net.js	Improper handling of Range requests in fetch event	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the premature return when a Range header is detected, without properly handling partial responses. This is not caused by misuse of a sensitive function, but rather by a logic flaw in the fetch event handler. The code does not attempt to process or respond to range requests, which could lead to broken partial content delivery, but does not involve any sensitive function misuse.}	```if (e.request.headers.has('range')) { return; }```
3488	mommymoment.ca.js	Improper URL Matching in Custom Route	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper URL matching logic in a custom route handler, not from misuse of a sensitive JavaScript function. The code checks for 'https' inclusion and hostname matching, but it does not use any inherently dangerous functions like importScripts, eval, or dynamic code execution. The issue is a logic flaw in URL validation, not a sensitive function misuse.}	```j(function (e) { if (!e.url) return !1; var t = e.url.href; return !!t && 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname; }, new F({ plugins: [new Q({ statuses: [0, 200] })] }))```
3489	mommymoment.ca.js	Insecure Fetch in Background Sync	High	true	N/A	N/A	fetch	standard	{The vulnerability stems from the use of the standard JavaScript fetch function within the replayRequests method of the ye class. The fetch function is called with a request object that is derived from user-controlled data stored in the background sync queue. Since the request URL and method are not validated or sanitized before being passed to fetch, an attacker could potentially inject malicious URLs or manipulate request headers, leading to unintended network requests, data exfiltration, or cross-origin attacks. This constitutes a sensitive function misuse because fetch is being used with untrusted input without proper sanitization.}	```async replayRequests() { let e; for (; e = await this.shiftRequest();) try { await fetch(e.request.clone()); } catch (t) { throw await this.unshiftRequest(e), new r('queue-replay-failed', { name: this._name }); } }```
3490	manxforums.com.js	Improper Authentication Check Leading to CSRF Vulnerability	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of authentication state via URL parameters (e.g., `loggedIn=true`), not from misuse of a sensitive JavaScript function. The code checks `matches[1]` from a regex match on the current URL, but does not validate or sanitize the source of this value, allowing an attacker to manipulate the URL to bypass authentication checks. This is a logic flaw, not a sensitive function misuse.}	```const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3491	kushagram.com.js	Improper Cache Deletion Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache deletion during the activate event, but it does not stem from misuse of a sensitive function. The code correctly deletes caches that are not named CACHE_NAME, but the issue lies in the logic or potential for unintended side effects rather than unsafe function usage.}	```self.addEventListener('activate', e => { e.waitUntil(caches.keys().then(e => Promise.all(e.map(e => { if (e !== CACHE_NAME) return caches.delete(e); })))) });```
3492	coteur.com.js	XSS via Untrusted Notification Data	High	true	CWE-79	10	self.registration.showNotification	standard	{The function self.registration.showNotification is used with notificationTitle and notificationOptions derived from untrusted event.data.json(). If an attacker can control the payload.data.title or payload.data.msg, they can inject malicious content into the notification, which may be rendered in the browser UI and potentially executed as script if the browser or user agent interprets it as executable content (e.g., via rich text rendering or DOM injection in notification UI). This constitutes a Cross-Site Scripting (XSS) vulnerability.}	```self.registration.showNotification(notificationTitle, notificationOptions);```
3493	coteur.com.js	Open Redirect via Notification Data	High	true	CWE-601	10	client.navigate	standard	{The function client.navigate is called with event.notification.data.url, which is derived from untrusted data. Since the URL is not validated or sanitized, an attacker can supply a malicious URL (e.g., to a phishing site or external domain), causing the browser to navigate away from the intended origin. This is an Open Redirect vulnerability, allowing attackers to trick users into visiting unintended or malicious websites.}	```return client.navigate(event.notification.data.url);```
3494	losreplicantes.com.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in client-side code, which exposes it to potential interception or extraction by attackers.}	```self[`appKey`] = `69709645ce58c1f9e80756eeaa569d5f`;```
3495	losreplicantes.com.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is dynamically constructed using a hardcoded host (self[`hostUrl`]), it becomes a vector for remote code execution if the host is compromised or if the script at the URL is malicious. Although the host is hardcoded here, the function itself is sensitive because it executes arbitrary code from a remote source without validation or sanitization.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3496	wedlinydomowe.pl.js	Open Redirect in Notification Click Handler	High	true	CWE-601	10	clients[0].navigate	standard	{The function clients[0].navigate is used to redirect the client to a URL derived from the notification data (data.url). Since this URL is not validated or sanitized and can be controlled by an attacker via push notifications, it enables open redirect attacks, allowing users to be redirected to arbitrary malicious sites.}	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
3497	wedlinydomowe.pl.js	Insecure Fetch with Dynamic URL	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the variable id from push notification data. If this id is not properly validated, an attacker could craft a malicious notification to trigger requests to unintended endpoints, potentially leading to data leakage or unintended server-side actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3498	wedlinydomowe.pl.js	CSRF Token Handling Without Validation	Medium	true	CWE-306	8	fetch	standard	{The fetch function is used to retrieve a CSRF token based on a dynamically constructed URL using the path variable. Since the path is derived from the request URL without validation, an attacker could manipulate the path to request tokens for unintended endpoints, potentially leading to CSRF attacks if the token is later used without proper validation.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3499	bouwcenter.nl.js	External Resource Loading Without Validation	High	true	CWE-444	10	importScripts	standard	{The importScripts() function loads and executes a script from a remote URL. In this case, the URL is dynamically derived from the options.workboxUrl, which is hardcoded to a public CDN. However, if this value were to be controlled by an attacker (e.g., via a configuration injection or tampered manifest), it could lead to arbitrary code execution. While the current value is safe, the lack of validation or sanitization of the URL makes this a sensitive misuse.}	```importScripts(options.workboxUrl);```
3500	bouwcenter.nl.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The precacheAndRoute function is used with options.preCaching, which is an empty array in this context. Since the input is not user-controlled and is statically defined as empty, there is no actual improper input validation vulnerability. The detection is likely a false positive.}	```precacheAndRoute(options.preCaching, options.cacheOptions);```
3501	warhammer-forum.com.js	Improper Neutralization of Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `path` variable, which is derived from the request URL. If an attacker can manipulate the request URL (e.g., via a crafted navigation or POST request), they could inject arbitrary paths into the URL, potentially causing the service worker to make unintended requests to internal or external resources, leading to SSRF. The `path` variable is not sanitized or validated, making this a high-confidence sensitive function misuse.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3502	polemon.mx.js	Insecure External Resource Loading	High	true	CWE-928	10	importScripts	standard	{The importScripts() function is used to load and execute an external script from a remote URL. The URL is hardcoded but points to a potentially untrusted or dynamically controlled resource (e.g., a plugin file on the same domain that could be compromised). If the script at the URL is tampered with or replaced by an attacker, the service worker will execute malicious code, leading to full compromise of the service worker's behavior, including cache manipulation, network interception, and potential data exfiltration.}	```importScripts('https://polemon.mx/wp-content/plugins/onesignal-free-web-push-notifications/sdk_files/OneSignalSDKWorker.js.php');```
3503	polemon.mx.js	Insecure Cache Name	Medium	false	N/A	N/A	N/A	N/A	{The cache name is hardcoded and includes a scheme (http://), which is not inherently a sensitive function misuse. It may lead to confusion or misbehavior in some environments, but it does not stem from improper use of a sensitive function like importScripts, eval, or similar.}	```const cacheName = 'http://polemon.mx-superpwa-2.2.31';```
3504	polemon.mx.js	Improper Handling of Range Requests	Low	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper parsing of the 'range' header, but it does not involve a sensitive function like eval or importScripts. The issue is more about logic and input validation rather than misuse of a sensitive API.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
3505	rentalassistance.net.js	Unvalidated Third-Party Script Execution	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted third party (e.g., https://api.pushnami.com), it introduces a risk of executing malicious code if the third-party service is compromised or if the script is modified without detection. Although the URL is hardcoded here, the vulnerability arises from the lack of validation or integrity checks on the script source, making it a sensitive function misuse.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/65fdafab676ae40013a9d61e"");```"
3506	paperconcept.pl.js	Cache Poisoning via Dynamic URL Construction	High	true	CWE-918	9	concatenation with location.origin	standard	{The vulnerability arises from dynamically constructing URLs using `location.origin` concatenated with hardcoded paths. While `location.origin` itself is not inherently dangerous, its use in building cache URLs without validation or sanitization can lead to cache poisoning if the origin is controlled by an attacker (e.g., via subdomain takeover or DNS hijacking). The `caches.open()` and `cache.addAll()` functions are standard APIs that blindly cache the constructed URLs, which may point to malicious resources if the origin is compromised.}	"```const PRECACHE_URLS = [location.origin + ""/offline.html"", location.origin + ""/themes/paper_theme/assets/bundle.js"", location.origin + ""/themes/paper_theme/assets/style.css""];```"
3507	paperconcept.pl.js	Improper Offline Handling Leading to DoS	Medium	false	N/A	0	N/A	N/A	{The issue stems from improper handling of offline fetches, where the code attempts to fetch a resource even when offline, leading to a failed request and potential denial of service. However, this is not caused by misuse of a sensitive function, but rather by flawed logic in the fetch handler. No sensitive function like `importScripts`, `eval`, or `fetch` with untrusted input is misused here.}	```return fetch(event.request).then(response => { return response; }).catch(error => { console.warn(error); });```
3508	settleup.app.js	Use of Weak Cryptographic Algorithm (SHA)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of SHA-1, which is considered cryptographically weak and susceptible to collision attacks. However, this is not due to misuse of a sensitive JavaScript function, but rather the inherent weakness of the algorithm itself. The function sha1() is custom and does not interact with untrusted input in a way that introduces dynamic risk.}	```function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8); }```
3509	settleup.app.js	Information Disclosure via Debug Endpoint	High	false	N/A	N/A	```handleFetch(req) { const [state, versions, idle] = await Promise.all([this.driver.debugState(), this.driver.debugVersions(), this.driver.debugIdleState()]); const msgState = `NGSW Debug Info:	N/A	{The debug endpoint exposes sensitive information such as service worker state, client versions, idle task queue, and debug logs. However, this is not caused by misuse of a sensitive JavaScript function, but rather by the design of the debug handler exposing internal state. The functions used (e.g., newResponse, newHeaders) are used correctly and not misused with untrusted input.}	N/A
3510	settleup.app.js	Improper Input Validation in Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The cacheBust function appends a random value to a URL to prevent caching, but it does not validate or sanitize the input URL. However, this is not due to misuse of a sensitive JavaScript function. The function is custom and does not involve dynamic or untrusted input that would trigger a sensitive function misuse. The risk is more related to improper input handling than sensitive function misuse.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
3511	settleup.app.js	Exposure of Sensitive Information in Error Handling	Medium	false	N/A	N/A	N/A	N/A	{The safeFetch function catches errors and returns a generic 504 response, but logs the error details to the debugger. This is not caused by misuse of a sensitive JavaScript function. The error handling is implemented correctly, and the exposure is due to logging behavior, not improper use of a sensitive function with untrusted input.}	"```safeFetch(req) { try { return await this.scope.fetch(req); } catch (e) { return this.adapter.newResponse(null, { status: 504, statusText: ""Gateway Timeout"" }); } }```"
3512	settleup.app.js	Potential XSS in Notification Handling	Medium	false	N/A	N/A	N/A	N/A	{The handlePush function broadcasts notification data and shows notifications, but does not directly inject untrusted data into the DOM or execute it. The notification title and options are passed to the showNotification API, which is designed to handle such data safely. No sensitive function is misused with untrusted input to cause XSS.}	"```handlePush(data) { await this.broadcast({ type: 'PUSH', data }); if (!data.notification || !data.notification.title) { return; } const desc = data.notification; let options = {}; NOTIFICATION_OPTION_NAMES.filter(name => desc.hasOwnProperty(name)).forEach(name => options[name] = desc[name]); await this.scope.registration.showNotification(desc[""title""], options); }```"
3513	boozy.ph.js	Insecure Third-Party Script Loading	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded third-party URL (as in this case), it introduces a high-risk vulnerability if the third-party script is compromised or if the script source is not properly vetted. Although the URL is hardcoded and not dynamically constructed from untrusted input, the reliance on an external script source still constitutes a security risk due to potential supply chain attacks, where the third-party script could be tampered with or replaced by malicious code. This is classified as a sensitive function misuse because importScripts() can execute arbitrary code from remote sources, and its use without proper integrity verification (e.g., subresource integrity) is considered insecure.}	"```importScripts(""https://cdn.moengage.com/release/dc_4/serviceworker_cdn.min.latest.js"");```"
3514	sarkariupdates360.com.js	Hardcoded Sensitive Information (Firebase API Key)	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive data (Firebase API key) in the code, not due to misuse of a sensitive function.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyBljFpcYDi3-U4B6XA8xsHgyJzYvPdy8fw' } };```
3515	sarkariupdates360.com.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from event.notification.data.url, which is user-controlled via push notifications. This allows an attacker to craft a notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
3516	sarkariupdates360.com.js	Server-Side Request Forgery (SSRF) via Notification Data	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamic URL derived from event.notification.data.api_url, which is user-controlled via push notifications. This allows an attacker to make the service worker send HTTP requests to arbitrary internal or external endpoints, leading to SSRF vulnerabilities.}	```fetch(apiUrl);```
3517	teethtalkgirl.com.js	Insecure Client Selection in Service Worker	High	true	New	9	N/A	standard	{The code uses `self.clients.matchAll()` to retrieve all clients and then sorts them by URL to select the first client. While `matchAll()` itself is not inherently dangerous, the sorting logic based on URL comparison is arbitrary and potentially exploitable if an attacker can influence the client URLs (e.g., via crafted navigation or redirects). This could lead to unintended client selection, potentially allowing an attacker to intercept or manipulate communication intended for a different client.}	```const clients = await self.clients.matchAll(); const client = [...clients].sort((a, b) => a.url > b.url ? -1 : a.url < b.url ? 1 : 0)[0];```
3518	teethtalkgirl.com.js	Improper Input Validation in Message Handling	Medium	true	CWE-703	8	N/A	standard	{The `client.postMessage(accessReq)` call sends the `accessReq` object directly to a client without validating or sanitizing its contents. Since `accessReq` is derived from `req.clone().json()`, which parses untrusted input from a network request, this allows an attacker to inject arbitrary data into the message. If the client processes this data unsafely, it could lead to code injection, data leakage, or other client-side vulnerabilities.}	```client.postMessage(accessReq);```
3519	teethtalkgirl.com.js	Long Timeout Leading to Potential DoS	Medium	false	CWE-399	N/A	N/A	N/A	{The timeout of 120,000 milliseconds (2 minutes) is long but not directly caused by misuse of a sensitive function. It is a configuration choice that may lead to resource exhaustion if many requests are pending, but no sensitive function is being misused here.}	```const timeout = 12e4;```
3520	bidx.com.js	Information Exposure Through Log Entries	Medium	false	CWE-200	N/A	N/A	N/A	{The console.error() function is used to log error details, including potentially sensitive information such as error messages and context objects. While not inherently a sensitive function, its misuse by logging unfiltered error data can lead to information exposure. However, this is not a direct misuse of a sensitive function like importScripts or eval, but rather a logging practice issue.}	```console.error(ctx.error, 'Details:', ctx);```
3521	bidx.com.js	Improper Handling of Cross-Origin Requests	High	true	New	N/A	Request	standard	{The Request constructor is used to create a new request object with modified cache and mode properties. When the original request has mode 'no-cors' and cache 'only-if-cached', the code changes the mode to 'no-cors' and cache to 'default'. This can lead to improper handling of cross-origin requests, potentially allowing unintended cross-origin resource sharing or bypassing security restrictions, especially if the request is not properly validated or if the context is untrusted.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
3522	sau.com.au.js	Improper Input Validation	High	true	N/A	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from the push event data. If this 'id' is not properly validated or sanitized, an attacker could craft a malicious URL to trigger unintended requests, potentially leading to server-side request forgery (SSRF) or information disclosure. The URL is built using template literals and the 'id' value is directly interpolated without sanitization.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3523	sau.com.au.js	Insecure Session Management	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a URL parameter 'loggedIn' to determine user authentication state, which can be easily manipulated by an attacker. However, this is not due to misuse of a sensitive JavaScript function, but rather a flawed logic design in session management.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3524	sau.com.au.js	Improper Check for Existence of an Unknown	Low	false	N/A	N/A	N/A	N/A	{The code assumes that the 'matches' array from the regex will always contain a value at index 1, without checking if the match succeeded. This is a logic flaw, not a misuse of a sensitive function.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3525	sau.com.au.js	Open Redirect Vulnerability	Medium	true	N/A	8	navigate	standard	{The navigate function is used with a URL derived from the 'data.url' field in the notification data, which is obtained from a remote push message. If this URL is not validated or sanitized, an attacker can inject a malicious URL to redirect users to phishing or malicious sites, leading to open redirect vulnerability.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
3526	thecandidzone.com.js	CSRF Token Validation Bypass	High	true	N/A	9	N/A	standard	{The function `new Request()` is used to create a new request with modified headers, including the X-Csrf-Token. However, the CSRF token is fetched dynamically from the server based on the path, and the request is constructed without validating the origin or ensuring the token is only used for legitimate requests. This allows an attacker to craft a malicious request that bypasses CSRF validation by intercepting and reusing the token, leading to unauthorized actions.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
3527	thecandidzone.com.js	Open Redirect via Notification Data	Medium	true	N/A	8	N/A	standard	{The `navigate()` method is used to redirect the client to a URL provided in the notification data. Since the URL is sourced from the server response and not validated or sanitized, an attacker could manipulate the notification payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url);```
3528	philipwalton.com.js	XSS via Unsanitized Broadcast Message	High	true	CWE-79	10	sensitively_vulnerable	standard	{The vulnerability arises from the use of `postMessage()` to broadcast a message containing unsanitized data derived from `this.P(t)`, which is generated from a response object. Since `this.P(t)` is not sanitized and can include arbitrary content (e.g., user-controlled headers or payloads), an attacker could craft a response that includes malicious JavaScript, which would be executed in the context of the client’s window when the message is received. This constitutes a Cross-Site Scripting (XSS) vulnerability.}	```const e = { type: 'CACHE_UPDATED', meta: 'workbox-broadcast-update', payload: this.P(t) }; if (this.A) { const t = await self.clients.matchAll({ type: 'window' }); for (const s of t) s.postMessage(e); } else if (t.event instanceof FetchEvent) { const s = await self.clients.get(t.event.clientId); null == s || s.postMessage(e); }```
3529	philipwalton.com.js	Insecure Cache Key Construction	Medium	false	CWE-571	0	is_sensitively_vulnerable	standard	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function. The code constructs a cache key using `this._cacheName + '|' + D(e)`, where `D(e)` is a helper function that normalizes URLs. There is no evidence of dynamic, untrusted input being used to construct the cache key in a way that would lead to security issues such as cache poisoning or bypass. The function `D(e)` is not a sensitive function, and the construction is deterministic and safe.}	```const _getId = e => this._cacheName + '|' + D(e);```
3530	afzetbak.nl.js	Inadequate Input Validation in URL Handling	Medium	true	N/A	N/A	_URL	standard	{The function `new URL(String(e), location.href)` is used to construct URLs from potentially untrusted input. If `e` is user-controlled (e.g., from a message or query parameter), this can lead to open redirects or unintended resource access, especially if the URL is later used in `fetch` or `importScripts`. The lack of validation on `e` makes this a sensitive function misuse.}	"```const _ = e => new URL(String(e), location.href).href.replace(new RegExp(""^"" + location.origin), """");```"
3531	afzetbak.nl.js	Insufficient Cache Expiration Logic	Low	false	N/A	N/A	N/A	N/A	{The issue is a logic flaw in the `expireEntries` method, not misuse of a sensitive function. The code correctly uses standard functions like `Date.now()` and `self.caches.open()`, but the logic for determining expiration is flawed.}	```async expireEntries() { if (this._isRunning) return void (this._rerunRequested = !0); this._isRunning = !0; const e = this._maxAgeSeconds ? Date.now() - 1e3 * this._maxAgeSeconds : 0, t = await this._timestampModel.expireEntries(e, this._maxEntries), s = await self.caches.open(this._cacheName); for (const e of t) await s.delete(e); this._isRunning = !1, this._rerunRequested && (this._rerunRequested = !1, S(this.expireEntries())); }```
3532	afzetbak.nl.js	IndexedDB Error Handling Weakness	Low	false	N/A	N/A	N/A	N/A	{The `OPEN_TIMEOUT` is a configuration constant, not a sensitive function misuse. The issue is poor error handling, not improper use of a sensitive function.}	```OPEN_TIMEOUT = 2e3;```
3533	tytnetwork.com.js	Insecure Handling of Bypass Headers	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from improper validation of the 'ngsw-bypass' header or URL parameter, which allows bypassing service worker logic. However, this is not caused by misuse of a sensitive JavaScript function like importScripts() or eval(), but rather by logic flaws in conditional checks.}	```const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl); if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) { return; }```
3534	tytnetwork.com.js	Insufficient Input Validation in Message Handling	High	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from insufficient validation of incoming message data, particularly the 'action' field, which could lead to unintended behavior. However, no sensitive JavaScript function (e.g., eval, importScripts) is misused here; the issue is in control flow logic.}	```if (data && data.action) { event.waitUntil((async () => { if (data.action === 'INITIALIZE') { return this.ensureInitialized(event); } ...```
3535	tytnetwork.com.js	Potential XSS in Notification Handling	High	false	CWE-79	N/A	N/A	N/A	{The vulnerability involves passing user-controlled data (notification title) directly to showNotification(), which may lead to XSS if the title contains malicious content. However, showNotification() is not a sensitive function in the context of code injection or remote script execution, and the risk is more related to UI manipulation.}	```await this.scope.registration.showNotification(desc['title'], options);```
3536	tytnetwork.com.js	Error Message Disclosure	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability involves logging and returning error messages that may expose internal details. This is not due to misuse of a sensitive function, but rather due to poor error handling practices.}	```this.debugger.log(err, `Driver.fetch(${req.url})`); return this.adapter.newResponse(null, { status: 504, statusText: 'Gateway Timeout' });```
3537	olysteel.com.js	Regular Expression Denial of Service (ReDoS)	Medium	true	New	9	N/A	standard	{The function `template(str, data)` constructs a regular expression dynamically using `Object.keys(data).join('|')` inside a `new RegExp` call. If the `data` object contains many keys or keys with complex patterns (e.g., long strings with repeated characters), this can lead to catastrophic backtracking during regex matching, causing ReDoS. The input `data` is not sanitized or validated, making it vulnerable to maliciously crafted inputs.}	```function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }```
3538	elsoplao.es.js	Improper Cache Deletion Leading to Data Loss	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the deletion of all caches during the 'activate' event, which can lead to unintended data loss. However, this is not caused by misuse of a sensitive function, but rather by a design flaw in cache management. The function `caches.delete()` is used correctly in context, but the logic of deleting all caches without filtering for specific ones is the root cause.}	```self.addEventListener('activate', function (event) {  event.waitUntil(caches.keys().then(function (cacheNames) {    return Promise.all(cacheNames.map(function (cacheName) {      return caches.delete(cacheName);    }));  }));});```
3539	helloezra.com.js	Cache Deletion Vulnerability	High	true	CWE-311	10	N/A	standard	{The `caches.delete(key)` function is a standard browser API used to remove cache entries. In this case, the key is derived from `caches.keys()` and filtered using `key.includes('runtime')`, which is not user-controlled. However, since the code iterates over all cache keys and deletes any containing 'runtime', it may inadvertently delete caches that are not intended to be removed, especially if an attacker can influence the cache names (e.g., via a malicious site or compromised origin). While the input is not directly user-controlled, the lack of strict validation or whitelisting makes this a sensitive misuse of a standard function, leading to unintended cache deletion.}	```if (key && key.includes(`runtime`)) { return caches.delete(key); }```
3540	helloezra.com.js	Command Injection via URL Parsing	Medium	true	CWE-74	8	N/A	standard	{The `split()` method is used on user-controlled `params` (derived from URL path) to parse key-value pairs. Although `split()` itself is not inherently dangerous, the subsequent use of `data[key] = val` allows arbitrary key-value assignment, which could lead to unintended behavior if the keys are later used in dynamic function calls or object access. This is a misuse of standard string manipulation functions in conjunction with untrusted input, enabling potential command injection or data manipulation if the parsed data is used in unsafe contexts.}	```const [key, val] = param.split(`=`); data[key] = val;```
3541	helloezra.com.js	Dynamic API Call Execution	Medium	true	CWE-80	9	N/A	standard	{The `MessageAPI[api](event, event.data)` expression dynamically invokes a function from the `MessageAPI` object based on the `api` value received from the message event. Since `api` is derived from `event.data.gatsbyApi`, which is user-controlled, this allows an attacker to trigger arbitrary functions within the `MessageAPI` object. This is a classic case of dynamic function invocation using user input, which is a sensitive misuse of standard JavaScript object access and function execution.}	```if (api) MessageAPI[api](event, event.data);```
3542	gomeangreen.com.js	Insecure URL Handling in Notification Click Handler	High	true	CWE-601	N/A	self.addEventListener	standard	{The service worker's notification click handler uses `self.clients.openWindow(data.url ? data.url : BASE_URL)` where `data.url` is derived from server response data. If the server is compromised or the notification payload is manipulated, this can lead to arbitrary URL redirection, potentially to phishing or malicious sites. The `openWindow` function is a standard API that executes navigation based on untrusted input, making it a sensitive function when used with dynamic, unsanitized data.}	"```self.addEventListener(""notificationclick"", e => { const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && ""navigate"" in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));});```"
3543	gomeangreen.com.js	CSRF Token Handling Without Server Validation	Medium	true	CWE-352	N/A	fetch	standard	{The code fetches a CSRF token from the server using a dynamically constructed URL (`fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)`). The `path` parameter is derived from the request URL, which is user-controlled. If an attacker can manipulate the request path, they could potentially trigger unintended CSRF token generation or abuse the token-fetching endpoint. The `fetch` function is standard but becomes sensitive when used with untrusted input in the URL, especially in contexts where the server does not validate the origin or context of the request.}	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
3544	odforce.net.js	Server-Side Request Forgery (SSRF) via unvalidated user-controlled 'id' parameter in push event handler	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the user-controlled 'id' parameter from push event data. Since the 'id' is directly interpolated into the URL without validation or sanitization, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
3545	odforce.net.js	Improper Authentication via URL parameter-based 'loggedIn' check	Medium	false	CWE-285	N/A	N/A	N/A	{The vulnerability arises from logic relying on a URL parameter 'loggedIn' for authentication state, which is not a sensitive function misuse but a flawed authentication design.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3546	odforce.net.js	Insecure CSRF Token Handling with potential race condition	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used to retrieve a CSRF token based on the 'path' parameter from a request, which is derived from user input. If the path is not properly validated, an attacker could trigger requests to unintended endpoints, leading to CSRF. The function is misused by trusting user-controlled input without sufficient validation.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token'```
3547	odforce.net.js	Insecure Navigation to Unvalidated 'data.url' in notification click handler	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the 'data.url' field in notification data, which originates from server responses. Since this URL is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to open redirect or phishing attacks.}	```clients[0].navigate(data.url);```
3548	odforce.net.js	Insecure Cache Busting via hardcoded cache name with no versioning validation	Low	false	CWE-923	N/A	N/A	N/A	{This is a design flaw in cache management, not a misuse of a sensitive function. The cache name is hardcoded, but no sensitive function is improperly used.}	```const CACHE_NAME = 'invision-community-e5fc2855201689474763';```
3549	sspi.ru.js	Vulnerable Cache Strategy Leading to Stale Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a cache-first strategy for '/source/icons/*', which may serve stale content if the cached resources are not updated properly. This is not due to misuse of a sensitive function, but rather a poor caching policy choice.}	```toolbox.router.get('/source/icons/*', toolbox.cacheFirst);```
3550	praticabr.com.js	Insecure Message Handling in Service Worker	High	true	CWE-306	9	self.addEventListener	standard	{The service worker listens for messages and executes code based on the received command. While the command is checked for 'deletePagesCache', there is no validation or sanitization of the message source or additional data, which could allow an attacker to trigger unintended behavior or cache manipulation if the message is sent from a malicious context. The use of `self.addEventListener` with untrusted input (event.data) introduces a risk of insecure message handling, especially if the message origin is not verified.}	N/A
3551	praticabr.com.js	Potential Caching of Sensitive Endpoints	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from the logic in `matchSitePages` which determines whether a request should be cached. While it checks for blacklisted URLs, it does not validate or sanitize the input URL, and the `shouldCachePageRequest` function uses `request.url.includes(blacklistedUrl)` which may not be sufficient to prevent caching of sensitive endpoints if the blacklist is incomplete or bypassed. However, no sensitive JavaScript function is directly misused here; the issue is more about logic and policy rather than function misuse.}	N/A
3552	praticabr.com.js	Debug Logging Enabled in Production	Medium	false	CWE-200	N/A	N/A	N/A	{The `log` function conditionally logs messages to the console if `pwaSettings.debug` is true. This is a configuration issue rather than misuse of a sensitive function. The function itself is not inherently dangerous, and no sensitive JavaScript function is being misused. The vulnerability stems from leaving debug logging enabled in production, which could expose internal information.}	N/A
3553	praticabr.com.js	Insecure URL Construction in addParams	Medium	true	CWE-601	8	template	custom	{The `addParamsNative` function constructs URLs by concatenating parameters using the `template` function, which performs string replacement using a regex. If the parameters contain malicious input (e.g., crafted keys or values), the `template` function may not properly escape or validate them, leading to potential URL injection or unintended behavior. The `template` function is custom and its misuse in constructing URLs without sanitization makes it a sensitive function in this context.}	N/A
3554	lordfilm.sx.js	Insecure DNS TXT Record Handling Leading to Open Redirect	High	true	CWE-601	9	N/A	standard	{The function `getRedirectUrl` constructs a redirect URL by appending query parameters from `redirect_params`, which are derived from the request URL via `getUrlParams`. Since `getUrlParams` uses `decodeURIComponent` and `split` on untrusted input (the URL query string), and `getRedirectUrl` appends these parameters without validation, an attacker can manipulate the query string to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```var _0x178c17 = queryParams(redirect_params); if (_0x178c17) _0x5567d4 += (_0x5567d4[_0x39b437(0xa3)]('?') === -0x1 ? '?' : '&') + _0x178c17; return _0x5567d4;```
3555	lordfilm.sx.js	Improper Input Validation of DNS TXT Records	High	true	CWE-20	9	N/A	standard	{The `checkSettings` function fetches DNS TXT records and parses them using `JSON.parse`. The TXT record content is treated as JSON and directly assigned to `settings` without validation, allowing an attacker to inject malicious data (e.g., arbitrary strings, booleans, or even objects) that could alter the behavior of the service worker, such as enabling/disabling features or changing redirect URLs.}	```settings[_0x360f15(0x8c)] = _0x5b466f[0x1]```
3556	lordfilm.sx.js	Dynamic Redirect URL Construction Without Validation	High	true	CWE-601	9	N/A	standard	{The `responseRedirect` function constructs a redirect URL using `getRedirectUrl`, which appends the `pathname` from the request URL to a base URL derived from `settings.redirect_url`. Since `settings.redirect_url` is populated from untrusted DNS TXT records without validation, an attacker can set it to an arbitrary domain, leading to open redirects.}	```'Location': getRedirectUrl(settings[_0x201549(0x9d)] + req_url['pathname'])```
3557	veganyackattack.com.js	Improper URL Validation Leading to Cache Poisoning	High	true	N/A	N/A	sensitive_function_responsible	standard	{The vulnerability arises from the improper use of the standard JavaScript function `new URL(t)`, where `t` is a dynamic URL derived from user-controlled input (via `e.url`). The code checks if `new URL(t).hostname === siteHostname`, but it does not validate or sanitize the input URL before parsing. This allows an attacker to craft a malicious URL (e.g., `https://evil.com?siteHostname=veganyackattack.com`) that passes the hostname check due to URL parsing behavior, leading to cache poisoning. The `new URL()` function is sensitive because it can be manipulated to resolve to unintended domains when given untrusted input, especially when combined with insufficient validation.}	"```return !!t && ""GET"" === e.request.method && !!t.includes(""https"") && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname;```"
3558	eiexchange.com.js	Improper Cache Deletion Leading to Data Loss	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the deletion of all cache entries without proper filtering or validation, which can lead to unintended data loss. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a logic flaw in cache management. The functions used (caches.keys(), caches.delete()) are standard but not inherently sensitive in this context.}	```caches.keys().then(keys => { keys.forEach(key => { caches.delete(key); }); });```
3559	enerzine.com.js	Cache Poisoning via Message Event	High	true	N/A	9	pwaForWpprecacheUrl	custom	{The vulnerability arises from the use of the custom function pwaForWpprecacheUrl, which is invoked with user-controlled input from event.data.url in the message event handler. This allows an attacker to send a message with a malicious URL, triggering the function to fetch and cache arbitrary content, potentially leading to cache poisoning. The function internally uses fetch and caches.put without proper validation, enabling an attacker to inject malicious resources into the service worker's cache.}	```if (typeof event.data === 'object' && typeof event.data.action === 'string') { switch (event.data.action) { case 'cache': pwaForWpprecacheUrl(event.data.url); break; default: console.log('Unknown action: ' + event.data.action); break; } }```
3560	rugger.info.js	Improper Handling of Fetch Event Leading to Potential Security Bypass	Low	false	N/A	0	N/A	N/A	{The fetch event handler is present but returns immediately without any logic, which may allow bypass of intended security controls or caching behavior. However, this is not due to misuse of a sensitive function, but rather a logic or design flaw.}	```self.addEventListener('fetch', function () { return; });```
3561	mynattfh.com.js	Insecure Cache Deletion via Service Worker Message	High	true	CWE-798	N/A	self.addEventListener	standard	{The service worker listens for messages and, upon receiving a 'deletePagesCache' command, deletes the SITE_PAGES_CACHE_NAME cache. While the cache name is hardcoded and not derived from untrusted input, the vulnerability lies in the exposure of cache deletion via a message from the page context, which could be exploited if the page is compromised or if the message channel is not properly secured. However, since the cache name is not dynamically constructed from user input, this is not a direct sensitive function misuse. Therefore, the vulnerability is not caused by misuse of a sensitive function.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
3562	akcoms.com.js	Incorrect URL Matching in Cache Exclusion Logic	High	false	N/A	0	N/A	N/A	{The vulnerability arises from a logical flaw in the `checkNeverCacheList` function, where `this.match(url)` is used incorrectly. The function is intended to return `false` if any regex in `neverCacheUrls` matches the URL, but due to the `every` method's behavior and incorrect `this` binding, it may not properly exclude URLs. This is not caused by misuse of a sensitive function, but rather a logic error in URL exclusion handling.}	```if (this.match(url)) { return false; } return true;```
3563	bafilo.com.js	Insecure Third-Party Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used without integrity checks, it introduces a high-risk vulnerability because the script can be tampered with or replaced by an attacker, leading to arbitrary code execution within the service worker context. The URL is hardcoded, but the lack of integrity verification still constitutes a misuse of the sensitive function, as it allows for potential supply chain attacks.}	```importScripts('https://van.najva.com/static/js/scripts/bafilo-website-35012-a3d9dcba-9b99-4bd6-af07-ad72dfdbc98b-service-worker.js');```
3564	banklive.net.js	Improper Control of a Resource Through Its Lifetime	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of resource lifecycle in the fetch event. The code attempts to serve cached responses or fall back to network requests, but does not properly manage cache invalidation or resource expiration, which can lead to serving stale or unintended content.}	```event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match('offline'); }));```
3565	bemcolar.com.js	Insecure Consent Handling Allowing Bypass of Privacy Protections	High	true	New	9	N/A	standard	{The function `new URL(request.url).hostname` is used to extract the hostname from a request URL, which is then checked against the `CONSENTS` array. However, the `CONSENTS` array is populated from untrusted input received via `event.tag` (in sync) and `event.data` (in message), which are not sanitized or validated. This allows an attacker to inject arbitrary hostnames into the consent list, potentially bypassing privacy protections by allowing requests to blocked domains. The misuse of `new URL()` with untrusted input enables this bypass, as it can be manipulated to return unexpected or malicious hostnames.}	"```const isBlockedByLGPD = request => { return CONSENTS.includes(new URL(request.url).hostname); }; let CONSENTS = []; self.addEventListener('sync', event => { let option = event.tag.replace(/(.*?)\:.*?$/, ""$1""); let value = event.tag.replace(/.*?\:(.*?)$/, ""$1""); if (option === ""consents"") { CONSENTS = value.split(',').filter((item, pos, self) => { return self.indexOf(item) == pos; }).map(url => { try { const matches = url.match(/^(?:https?:)?(?:\/\/|\.)?([^\/\?]+)/i); return matches && matches[1]; } catch (ex) { return ''; } }).filter(item => { return item !== ''; }); evictMasterCache(event); } }); self.addEventListener('message', event => { let option = event.data.replace(/(.*?)\:.*?$/, ""$1""); let value = event.data.replace(/.*?\:(.*?)$/, ""$1""); if (option === ""consents"") { CONSENTS = value.split(',').filter((item, pos, self) => { return self.indexOf(item) == pos; }).map(url => { try { const matches = url.match(/^(?:https?:)?(?:\/\/|\.)?([^\/\?]+)/i); return matches && matches[1]; } catch (ex) { return ''; } }).filter(item => { return item !== ''; }); evictMasterCache(event); } });```"
3566	bemcolar.com.js	Insecure URL Matching in Ignore Lists Leading to Bypass	Medium	true	CWE-20	8	N/A	standard	{The function `url.includes(path)` is used to check if a URL contains a specific path from the ignore list. This is a dangerous approach because it does not perform exact or prefix matching, allowing partial matches that can bypass intended restrictions. For example, a URL like `https://example.com/ignorepixel` would match `/ignorepixel` even if the intent was to ignore only exact paths. This misuse of `includes()` with untrusted or dynamic ignore lists leads to unintended bypasses, as attackers can craft URLs that partially match ignored paths, thus evading filtering.}	```const isIgnoredImpl = (list, url) => { if (!url.startsWith('http')) return true; return !!list.find(path => { return url.includes(path); }); };```
3567	bemcolar.com.js	Cache Eviction Triggered by Malicious Requests Leading to DoS	Medium	true	CWE-400	9	N/A	standard	{The function `request.url.includes(value.match)` is used to determine if a request should trigger cache eviction. Since `value.match` is a static string from a predefined list, and `request.url` is user-controlled, an attacker can craft requests with URLs that include these match strings (e.g., `/checkout/cart/add`), causing unintended cache eviction. This misuse of `includes()` with user-controlled input allows attackers to trigger `evictMasterCache()`, which deletes all caches, leading to a denial-of-service condition where the PWA becomes non-functional until caches are rebuilt.}	```const needEvictCache = request => { return !!EVICT_CACHE_IN_PAGE.find(value => { return request.method == value.method && request.url.includes(value.match); }); }; const evictMasterCache = event => { event.waitUntil(caches.keys().then(cacheNames => { return Promise.all(cacheNames.map(cacheName => { return caches.delete(cacheName); })); })); };```
3568	bigganchinta.com.js	Insecure Use of importScripts Without Subresource Integrity (SRI)	Medium	true	CWE-444	10	importScripts	standard	{The importScripts function is used to load a remote script from 'https://storage.googleapis.com/workbox-cdn/releases/' concatenated with a version string. Since this URL is hardcoded and not protected by Subresource Integrity (SRI), an attacker could potentially compromise the CDN or intercept the request to inject malicious code into the service worker, leading to arbitrary code execution.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/"".concat(e, ""/workbox-sw.js""));```"
3569	boorsa.org.js	External Code Execution via Untrusted Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/static/js/scripts/boorsa-website-19620-4f44b5d4-6e16-492a-8577-54a238cbaa41-service-worker.js'. Although the URL is not dynamically constructed from untrusted input, the script is still being imported from an external, potentially untrusted source. This introduces a risk of external code execution if the remote script is compromised or controlled by an attacker. The vulnerability arises because the service worker is executing code from a third-party domain without verification or integrity checks.}	```importScripts('https://van.najva.com/static/js/scripts/boorsa-website-19620-4f44b5d4-6e16-492a-8577-54a238cbaa41-service-worker.js');```
3570	bornosmode.com.js	Incorrect use of 'this' in skipWaiting leading to potential service worker activation issues	High	false	N/A	0	N/A	N/A	{The use of 'this.skipWaiting()' is not inherently a misuse of a sensitive function, but rather a contextual error in the Service Worker lifecycle. 'this' refers to the global scope (self) in Service Workers, and while 'skipWaiting()' is a standard method, its misuse here is due to incorrect context or timing, not because of unsanitized input or dynamic data flow. It does not involve sensitive function misuse in the security sense.}	```this.skipWaiting();```
3571	bornosmode.com.js	Caching non-GET requests without validation leading to potential sensitive data exposure	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of request method validation in the fetch handler, not from misuse of a sensitive function. The 'caches.match()' and 'fetch()' functions are used correctly; the issue is a logic flaw in handling non-GET requests, which could lead to caching sensitive data. This is not a sensitive function misuse.}	```event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match('offline'); }));```
3572	bornosmode.com.js	Offline page served without validation for sensitive endpoints	Medium	false	N/A	0	N/A	N/A	{The issue is that the offline page is served without checking if the requested endpoint is sensitive, which is a logic or policy flaw, not a misuse of a sensitive function. 'caches.match('offline')' is used correctly; the vulnerability stems from lack of endpoint validation, not from dynamic or untrusted input being passed to a sensitive function.}	```return caches.match('offline');```
3573	braciasamcy.pl.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the id parameter received via push notification. Since id is derived from untrusted external data (push payload), an attacker can manipulate it to redirect the fetch to arbitrary internal or external endpoints, enabling SSRF. The URL is dynamically built using template literals, making it vulnerable to injection.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3574	braciasamcy.pl.js	Cross-Site Request Forgery (CSRF) Token Handling	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used to retrieve a CSRF token by constructing a URL with the path parameter, which is derived from the intercepted request's URL. If the path is not sanitized, an attacker could manipulate it to trigger unintended CSRF token requests, potentially leading to unauthorized actions. The dynamic URL construction from untrusted input introduces risk.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3575	braciasamcy.pl.js	Insecure Credential Handling	Medium	false	CWE-200	0	N/A	N/A	{The issue arises from passing credentials: curRequest.credentials to a new Request object, which is not inherently a misuse of a sensitive function but rather a design choice. The function new Request() is used correctly; the risk stems from the broader context of credential exposure, not from improper function usage.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer })```
3576	braciasamcy.pl.js	Information Exposure via Debug Logging	Low	false	CWE-200	0	N/A	N/A	{The console.log() function is used conditionally based on DEBUG flag, but it is not misused in a way that constitutes a sensitive function vulnerability. The exposure is due to logging sensitive data in debug mode, not due to improper use of console.log().}	```if (DEBUG) { if (typeof message === 'string') { message = `SW: ${message}`; } console.log(message); }```
3577	championbet.ug.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from exposing Firebase configuration keys in client-side code, not from misuse of a sensitive function. The importScripts() calls are safe as they use hardcoded, trusted URLs.}	```importScripts('https://www.gstatic.com/firebasejs/5.5.0/firebase-app.js');```
3578	championbet.ug.js	Use of Outdated Third-Party Library	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from using an outdated version of Firebase (5.5.0), which may contain known security issues. This is not due to misuse of a sensitive function, but rather a dependency management issue.}	```importScripts('https://www.gstatic.com/firebasejs/5.5.0/firebase-messaging.js');```
3579	claze777.com.js	Flawed URL Exclusion Logic	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from flawed logic in URL exclusion, not from misuse of a sensitive JavaScript function. The code checks if the request URL contains any of the strings in offlineExclude, but this approach is insufficient for secure filtering (e.g., it may allow partial matches or bypasses). However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
3580	cloeapp.com.js	Insecure Regular Expression in BACK_END_ALLOWED_PATHS Allows Unintended Caching	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a poorly constructed regular expression pattern in BACK_END_ALLOWED_PATHS, specifically using string literals with wildcards (e.g., '/classes/.*/disciplines') that are converted into RegExp objects with 'i' flag. This allows unintended matches due to improper escaping or pattern design, but no sensitive JavaScript function is misused. The issue is in logic and pattern design, not function misuse.}	```const BACK_END_ALLOWED_PATHS = ['/users/me', '/users/session', '/classes/.*/disciplines', '/classes/.*/schedules'];```
3581	cloeapp.com.js	Case-Sensitive BLACK_LIST_URLS Bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from using String.prototype.indexOf() for substring matching without case-insensitive handling, which allows bypassing the blacklist if the URL contains the substring in a different case. This is a logic flaw in string comparison, not misuse of a sensitive function.}	```if (!BLACK_LIST_URLS.some(url => event.request.url.indexOf(url) >= 0)) {```
3582	communica.co.za.js	Unbounded Cache Growth Leading to Denial of Service	Medium	false	CWE-400	N/A	N/A	N/A	{The vulnerability arises from the lack of cache size limits and expiration policies, not from misuse of a sensitive function. The code caches responses indefinitely without eviction, leading to unbounded growth. This is a design flaw rather than a direct misuse of a sensitive API.}	"```console.log(""herer"");var PRECACHE = 'precache-v1';var RUNTIME = 'runtime';PRECACHE_URLS = ['index.html', './', 'style.css', 'main.js'];self.addEventListener('install', event => {  event.waitUntil(caches.open(PRECACHE).then(cache => cache.addAll(PRECACHE_URLS)).then(self.skipWaiting()));});self.addEventListener('activate', event => {  const currentCaches = [PRECACHE, RUNTIME];  event.waitUntil(caches.keys().then(cacheNames => {    return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));  }).then(cachesToDelete => {    return Promise.all(cachesToDelete.map(cacheToDelete => {      return caches.delete(cacheToDelete);    }));  }).then(() => self.clients.claim()));});self.addEventListener('fetch', event => {  if (event.request.url.startsWith(self.location.origin)) {    event.respondWith(caches.match(event.request).then(cachedResponse => {      if (cachedResponse) {        return cachedResponse;      }      return caches.open(RUNTIME).then(cache => {        return fetch(event.request).then(response => {          return cache.put(event.request, response.clone()).then(() => {            return response;          });        });      });    }));  }});```"
3583	comunidadeempregope.com.br.js	External Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a risk if the script source is untrusted or controlled by an attacker. In this case, the script is loaded from 'https://wesleycatula.com/sw_notification.js', which is an external domain. While the URL is hardcoded and not dynamically constructed from untrusted input, the act of loading and executing code from an external source still constitutes a security risk, especially if the source is not fully trusted or could be compromised. This is considered a sensitive function misuse because importScripts can lead to code injection and execution of malicious scripts if the source is not properly vetted.}	```importScripts('https://wesleycatula.com/sw_notification.js');```
3584	cpet.com.br.js	Overly Permissive Cache Strategy	High	true	CWE-200	9	N/A	standard	{The cacheFirst function uses fetch() without validating or sanitizing the request URL, which can lead to unintended caching of sensitive or malicious responses. Since the function is applied to routes via workbox.routing.registerRoute with broad regex patterns (e.g., /.*?d[dp]-cdn\.multiscreensite\.com.*?/), it may cache responses from untrusted or dynamic domains, potentially allowing an attacker to inject malicious content into the cache. The fetch() function is a standard JavaScript API, and its misuse here stems from lack of input validation and overly permissive route matching.}	```const cacheFirst = function (cacheName, { postFetch, matchUrlFallback = false } = {}) { return async function ({ event, params = {} }) { const request = event.request; if (!pwaSettings.shouldUseCache || skipCache(request.url)) { return fetch(request); } const cache = await caches.open(cacheName); const forceNetwork = false; const cachedResponse = forceNetwork ? null : (await cache.match(request)) || (matchUrlFallback ? await cache.match(request.url) : null); if (cachedResponse) { logFromCache(request.url); return cachedResponse; } else { const networkResponse = await fetch(request); logFetchedAndCached(request.url, cacheName); cache.put(request, networkResponse.clone()); if (postFetch) { postFetch({ request, cache, params }); } return networkResponse; } }; };```
3585	cpet.com.br.js	Debug Logging Information Exposure	Low	false	CWE-200	0	N/A	N/A	{The log function merely outputs debug messages to the console when pwaSettings.debug is true. It does not involve any sensitive function misuse such as importScripts, eval, or dynamic code execution. The exposure is due to information leakage in debug mode, not due to improper use of a sensitive JavaScript function.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
3586	croper.com.js	Insecure Cache Busting Handling	Medium	true	CWE-502	7	newRequestWithMetadata	custom	{The function `newRequestWithMetadata` is used to construct a new Request object with a cache-busted URL (e.g., appending `ngsw-cache-bust=...`). While the URL is generated via `cacheBust(req.url)`, which appends a random value, the underlying `newRequestWithMetadata` function is custom and not inherently unsafe. However, if the input `req.url` is derived from untrusted sources (e.g., user-controlled URLs), and if the function does not validate or sanitize the URL, it could allow an attacker to manipulate the request to target unintended resources. The vulnerability arises from the potential for URL manipulation if the input is not properly sanitized, even though the cache-busting mechanism itself is benign.}	```const cacheBustReq = this.newRequestWithMetadata(this.cacheBust(req.url), req);```
3587	culture-circle.com.js	External Script Import in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a risk if the script source is untrusted or compromised, allowing an attacker to inject malicious code into the service worker. Although the URL is hardcoded here, the vulnerability is still considered sensitive because the function itself is inherently risky when used with external sources, especially in a service worker context where it can intercept and manipulate network requests, cache data, and affect the entire application's behavior.}	"```importScripts(""https://widgets.in.webengage.com/js/service-worker.js"");```"
3588	emp-shop.sk.js	Vulnerable Navigation Route Allowlist	High	true	CWE-918	10	N/A	standard	{The NavigationRoute is configured with an allowlist of [/./], which matches any URL path. This allows any navigation request to be handled by the route, potentially bypassing intended security controls. The route then attempts to fetch from the network and, if that fails, falls back to a cached offline page. While not directly a sensitive function misuse, the route registration itself is a critical control point. However, the underlying mechanism involves the use of standard Service Worker APIs like self.addEventListener, caches.match, and fetch, which are not directly misused here. The vulnerability stems from overly permissive route matching logic rather than unsafe function usage.}	```const h = new i(function (e) { var t = e.event, n = t.request; return c.handle({ event: t, request: n }).catch(function () { return caches.match(r, { ignoreSearch: !0 }); }); }, { allowlist: [/./], denylist: [] });```
3589	geekbuying.pl.js	Improper URL Validation leading to Cache Poisoning	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper URL validation in the themeImgFunction, which checks for the presence of 'https://www.geekbuying.pl' and image file extensions. However, it does not validate the full URL structure or prevent bypasses via URL encoding, subdomains, or path traversal, potentially allowing cache poisoning. This is not due to misuse of a sensitive function like importScripts or eval, but rather flawed logic in URL matching.}	```const themeImgFunction = ({ url, event }) => { if (url.href.indexOf('admin904b') == -1) { if (url.href.indexOf('https://www.geekbuying.pl') != -1 && (url.href.indexOf('.jpg') != -1 || url.href.indexOf('.gif') != -1 || url.href.indexOf('.png') != -1)) { return true; } else { return false; } } };```
3590	gemmusics.ir.js	Untrusted External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically derived from untrusted input, the act of importing an external script from a third-party domain introduces a high-risk vulnerability because the script's content is not under the control of the service worker's owner. This allows the remote server to inject malicious code, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. The vulnerability is considered sensitive because importScripts() executes code with the same privileges as the service worker, and the source is untrusted.}	```importScripts('https://van.najva.com/static/js/scripts/new-website537905-website-53889-a8f94f35-52f2-4eef-804f-dd40b813bcf4-service-worker.js');```
3591	gotas.social.js	Unrestricted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a high-risk vulnerability because the script is fetched and executed without any validation or sanitization. An attacker who controls the external domain (e.g., progressier.app) can serve malicious JavaScript, leading to full compromise of the service worker’s execution context, including the ability to intercept network requests, manipulate cache, and perform further attacks.}	"```importScripts(""https://progressier.app/owkvJgEKw6lAJqX4laBn/sw.js"");```"
3592	haberdairesi.com.js	Dynamic Script Import from Untrusted Source	Medium	true	CWE-960	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL that includes a version parameter. Although the URL is not dynamically constructed from untrusted input, the use of importScripts() with any external script introduces a potential risk if the script source is not fully trusted or if the version parameter could be manipulated in a future context. However, since the URL is hardcoded and not derived from user input or dynamic sources, the risk is mitigated but still present due to the nature of loading external code.}	```importScripts('https://haberdairesi.com/d/assets/bundle/webpush.js?v=' + version);```
3593	herasolutions.app.js	Insecure No-CORS Fetch in PrefetchUrl	High	true	New	9	N/A	standard	{The fetch() function is used with mode: 'no-cors', which bypasses CORS checks and may allow fetching from arbitrary origins without proper validation, potentially leading to unintended data exposure or side-channel attacks. The URL is constructed dynamically via addParams(), which can be manipulated if the input is untrusted.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
3594	herasolutions.app.js	Potential URL Injection in addParamsNative	Medium	true	CWE-113	8	N/A	custom	{The addParamsNative function constructs URLs by concatenating strings without proper sanitization or validation, especially when using template() to insert parameters. This can lead to URL injection if the input parameters are not trusted, potentially redirecting requests to unintended domains or manipulating query strings maliciously.}	```const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : '');```
3595	herasolutions.app.js	Cache Poisoning via Malformed URLs	High	true	New	9	N/A	standard	{The cache.put() function is used with a request object that may be malformed or manipulated if the request URL is not validated. Since the request is derived from event.request, which can be controlled by an attacker via crafted requests, this allows cache poisoning where malicious responses can be stored under legitimate keys.}	```cache.put(request, networkResponse.clone());```
3596	herasolutions.app.js	Empty Fetch Event Handler	Low	false	New	N/A	N/A	N/A	{The fetch event handler is empty and does not perform any operations, so it does not introduce a direct vulnerability. However, it may indicate an incomplete or misconfigured service worker.}	```self.addEventListener('fetch', () => {});```
3597	herasolutions.app.js	Message Handling Vulnerability	Medium	true	CWE-306	7	N/A	standard	{The message event handler processes incoming messages without validating the source or content of the data. This allows an attacker to send arbitrary commands (e.g., 'deletePagesCache') to the service worker, potentially leading to cache deletion or other unintended behavior.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { ... } });```
3598	hormozteb.ir.js	Insecure Cache Handling	Medium	false	CWE-921	N/A	N/A	N/A	"{The vulnerability labeled ""Insecure Cache Handling"" is not caused by the misuse of a sensitive JavaScript function, but rather by the static configuration of assets to cache. The code caches predefined resources (e.g., '/offline.html', image files) without dynamic or user-controlled input. There is no evidence of sensitive function misuse such as importScripts, eval, or dynamic script loading.}"	```const CACHE_NAME = 'offline-cache-v1'; const OFFLINE_URL = '/offline.html'; const ASSETS_TO_CACHE = [OFFLINE_URL, 'icon-192x192.png', 'offline-mode/offline-wifi.png']; self.addEventListener('install', event => { event.waitUntil(caches.open(CACHE_NAME).then(cache => { return cache.addAll(ASSETS_TO_CACHE); })); console.log('Service Worker installed.'); }); self.addEventListener('activate', event => { console.log('Service Worker activated.'); event.waitUntil(caches.keys().then(keyList => { return Promise.all(keyList.map(key => { if (key !== CACHE_NAME) { return caches.delete(key); } })); })); }); self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => { if (response) { return response; } return fetch(event.request).catch(() => { if (event.request.mode === 'navigate') { return caches.match(OFFLINE_URL); } }); })); });```
3599	huayhit88.com.js	Vulnerable Cache Pre-Caching of Sensitive URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the pre-caching of a URL that may be sensitive or dynamically derived (e.g., `/` with query parameters). The code uses `workbox.precaching.precacheAndRoute()` with a hardcoded URL pattern, which does not involve dynamic or untrusted input being passed to a sensitive function.}	```const options = {'preCaching': [{'revision': 'tbJcTN4Imnrn', 'url': '/?standalone=true'}]};```
3600	hunkemoller.dk.js	Improper Cache Control Leading to Sensitive Data Exposure	High	true	CWE-522	9	N/A	standard	"{The vulnerability arises from the use of the `match` function on a regular expression to determine which file types to cache. The regex pattern `/.png|.img|.webp|.gif|.svg|.js|.woff2|.css|.ico/` is flawed because it does not properly anchor the pattern, allowing it to match substrings within URLs (e.g., a URL containing ""js"" in a path like `/api/jsdata` would be cached). This improper use of `match` with a poorly constructed regex leads to unintended caching of sensitive resources, potentially exposing them to unauthorized access.}"	```if (networkResponse.type === 'basic' && event.request.url.match(/.png|.img|.webp|.gif|.svg|.js|.woff2|.css|.ico/)) {```
3601	iharstad.no.js	Server Side Request Forgery (SSRF)	High	false	N/A	0	N/A	N/A	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function such as importScripts(), eval(), or similar. Instead, it stems from a logic flaw in the pattern4 function, which checks if the host contains the literal string 'www.iharstad.no' using indexOf. The vulnerability arises because the check is performed on the raw URL host without proper sanitization or validation, potentially allowing an attacker to craft a malicious URL that bypasses the check (e.g., via URL encoding or subdomain manipulation). This is a logic issue, not a sensitive function misuse.}	```const pattern4 = (req) => { return req.event.request.mode === 'navigate' && req.url.pathname === '/' && req.url.host.indexOf('\'www.iharstad.no\'') !== -1 && req.event.request.method === 'GET'; };```
3602	kalhotkomat.cz.js	Cross-Site Scripting (XSS) due to unsanitized notification data being passed to client	High	true	CWE-79	10	postMessage	standard	{The postMessage function is used to send data to a client window, and if the data from e.notification.data is not sanitized, it can be used to inject malicious scripts into the client context, leading to XSS. Since the data is directly passed without sanitization, an attacker can craft a notification with script payloads that execute in the client's context.}	```self.addEventListener('notificationclick', e => { e.notification.close(), e.waitUntil(clients.matchAll({ type: 'window', includeUncontrolled: !0 }).then(t => { const a = t[0]; a && (a.focus(), a.postMessage({ type: 'notification', data: e.notification.data })); })); });```
3603	khaneyekhodro.com.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically generated from untrusted input, the act of importing an external script from an untrusted or third-party domain introduces a high-risk vulnerability. The imported script can potentially execute arbitrary code within the service worker context, leading to cache manipulation, network interception, or data exfiltration. This is considered a sensitive function misuse because it bypasses the principle of least privilege and introduces an attack surface through external code execution.}	```importScripts('https://van.najva.com/static/js/scripts/new-website373268-website-55117-5160fa07-e886-4eb5-a00c-e835ba64616b-service-worker.js');```
3604	khodroid.com.js	Unrestricted HTTP Method Handling in Service Worker	High	true	CWE-862	9	N/A	standard	{The vulnerability arises from the use of `fetch(request)` without validating or restricting the HTTP method of the incoming request. Since `fetch` is a standard JavaScript function that executes network requests based on the provided Request object, and the `request` parameter is derived directly from the `event.request` in the fetch event handler, an attacker could potentially trigger arbitrary HTTP methods (e.g., DELETE, PUT) if the service worker is not configured to restrict them. This allows unauthorized modifications or deletions of resources, leading to potential data loss or manipulation.}	```return fetch(request).then(function (response) { console.log(response.url + ' was cached'); return cache.put(request, response); });```
3605	korabia.net.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (API key, project ID, etc.) in the script, not due to misuse of a sensitive JavaScript function.}	```const Config = { apiKey: 'AIzaSyB_lZHlIrMF-EbUAGC5nG0t_OkHG2jvZ54', authDomain: 'push-web-1a1ae.firebaseapp.com', databaseURL: 'https://push-web-1a1ae.firebaseio.com', projectId: 'push-web-1a1ae', storageBucket: 'push-web-1a1ae.appspot.com', messagingSenderId: '393394069765', appId: '1:393394069765:web:74be2a85b7d5812a0c176c', measurementId: 'G-42VHBX4YKN' };```
3606	korabia.net.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with the untrusted input action_click, which is derived from the notification payload. If an attacker can control the payload, they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(action_click));```
3607	lamarina.com.mx.js	Insecure Direct Object Reference (IDOR) in IndexedDB operations	High	true	N/A	N/A	h.getDB()	standard	{The IndexedDB API's getDB() method is used without proper access control or input validation, allowing unauthorized access to stored data by manipulating the database name or object store. This enables attackers to retrieve or modify data belonging to other users or contexts, leading to IDOR.}	```h.getDB()```
3608	lamarina.com.mx.js	Insecure Storage of Sensitive Data in LocalStorage	High	true	N/A	N/A	E.setItem(this.BROWSER_PUBLIC_KEY	standard	{The localStorage.setItem() function is used to store sensitive cryptographic keys (e.g., browser public key) without encryption or additional security measures. This exposes the keys to theft via XSS or direct access to the browser's storage, enabling attackers to impersonate users or compromise authentication mechanisms.}	```E.setItem(this.BROWSER_PUBLIC_KEY, e);```
3609	lamarina.com.mx.js	XSS Vulnerability in Notification Payload Handling	Medium	true	N/A	N/A	s.title	standard	{The Notification API's title parameter is directly populated with user-controlled data from the push message (s.title) without sanitization. This allows an attacker to inject malicious scripts or HTML into the notification, leading to XSS when the notification is rendered in the user's browser.}	```const i = s.title;```
3610	lamarina.com.mx.js	Insecure IndexedDB Index Creation	Medium	true	N/A	N/A	createIndex('storeIndex'	standard	{The IndexedDB API's createIndex() method is used with a hardcoded index name ('storeIndex') and without validating the key path or ensuring proper schema integrity. This can lead to data leakage or manipulation if the index is misused or if the key path is not properly constrained, allowing attackers to access unintended data.}	"```createIndex(""storeIndex"", ""store.key"")```"
3611	lamarina.com.mx.js	Insecure IndexedDB Data Serialization	Medium	true	N/A	N/A	store.put({store: {key: t	standard	{The IndexedDB API's put() method is used to store data in a non-standard format (nested object with 'store' key) without proper validation or sanitization. This can lead to data corruption or injection if the input data is maliciously crafted, potentially allowing attackers to manipulate stored data or bypass access controls.}	```store.put({store: {key: t, value: s}})```
3612	lamarina.com.mx.js	Insecure IndexedDB Data Deserialization	Medium	true	N/A	N/A	t.target.result.store.value	standard	{The IndexedDB API's get() method retrieves data in a nested format, and the deserialization step (t.target.result.store.value) directly accesses the inner value without validation. This can lead to deserialization vulnerabilities if the stored data is tampered with, allowing attackers to inject malicious payloads or bypass security checks.}	```t.target.result.store.value```
3613	lamarina.com.mx.js	Insecure IndexedDB Data Validation	Medium	true	N/A	N/A	e.index.get(t).onsuccess	standard	{The IndexedDB API's get() method is used with a key (t) that is not validated before use. This allows attackers to manipulate the key to access or modify unintended data, leading to data leakage or unauthorized modifications if the key is derived from untrusted sources.}	```e.index.get(t).onsuccess = t => {```
3614	lamarina.com.mx.js	XSS in Notification Action Handling	Medium	true	N/A	N/A	clients.openWindow(t.url)	standard	{The clients.openWindow() method is used to open a URL (t.url) that is derived from the push message without sanitization or validation. This allows an attacker to inject malicious URLs into the notification, leading to XSS or phishing attacks when the user clicks on the notification action.}	```clients.openWindow(t.url)```
3615	lebenskompass.eu.js	Insecure HTTP Communication	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of insecure HTTP URLs (e.g., http://127.0.0.1:5000) in cacheAssets and URLS_WHITELISTED, which are hardcoded and not dynamically derived from untrusted input. Since no sensitive function is misused with dynamic or untrusted input, this is not a case of sensitive function misuse.}	"```const cacheAssets = [""index.html"", ""http://127.0.0.1:5000/assets/mock.jpg""], URLS_WHITELISTED = [""http://127.0.0.1:5000/assets/mock.jpg""]```"
3616	legalsport.net.js	Hardcoded API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is not a result of sensitive function misuse but rather a direct assignment of a secret value in the code.}	```self[`appKey`] = `54de2f8fe61ff5bb2e8be52ff03431ca`;```
3617	legalsport.net.js	Remote Script Loading from Untrusted Source	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it may still be considered a risk if the host is not fully trusted or if the script can be intercepted or replaced. However, in this case, the host is hardcoded and not derived from untrusted input, so the risk is lower than if it were dynamically sourced. Still, loading remote scripts introduces potential for supply chain attacks if the host is compromised.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3618	leurredelapeche.fr.js	Cross-Site Scripting (XSS) via untrusted notification data	High	true	CWE-79	10	N/A	standard	{The `showNotification` method is used with data derived from `event.data.json()`, which is untrusted. If an attacker controls the notification payload (e.g., via a malicious push message), they can inject arbitrary content into the notification, potentially leading to XSS if the notification UI renders the content in a way that executes scripts (e.g., via HTML injection in some browsers or extensions).}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } if (event.data) { if (event.data) { const notificationData = event.data.json(); const options = { body: notificationData.body, icon: notificationData.icon, vibrate: [300, 100, 400], data: event.data.text(), badge: notificationData.badge }; return event.waitUntil(self.registration.showNotification(notificationData.title, options)); } ; } ; });```
3619	leurredelapeche.fr.js	Open Redirect via untrusted notification URL	High	true	CWE-601	10	N/A	standard	{The `clients.openWindow(url)` function is called with `url` derived from `notificationData.target_url`, which is untrusted. An attacker can craft a push notification with a malicious URL, causing the browser to open an arbitrary external site, leading to an open redirect vulnerability.}	```event.waitUntil(Promise.all([clients.matchAll({ type: 'window' }).then(function (windowClients) { if (clients.openWindow) { return clients.openWindow(url); } })]));```
3620	leurredelapeche.fr.js	Fallback to non-existent 'Error' cache key in fetch handler	Low	false	CWE-457	0	N/A	N/A	{The code attempts to match a cache key named 'Error', which is not defined or cached anywhere. This is a logic error, not a misuse of a sensitive function. The `caches.match()` function is used correctly, but the key does not exist, leading to a silent failure.}	```return resp || caches.open(staticCacheName).then(function (cache) { return cache.match(OFFLINE_URL); });```
3621	lotodobicho.com.js	Improper Handling of Fetch Event Propagation	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper logic in handling fetch event propagation. The code stops propagation for specific URLs, but this does not involve any sensitive function that could lead to injection or execution of untrusted code.}	```self.addEventListener('fetch', event => { const urls = ['/blog', '/app/draws/locator', '/app/draws/draw', '/draws/add', '/explanation/ethereum', '/doc']; if (event && event.request && event.request.url && urls.some(url => event.request.url.includes(url))) { event.stopImmediatePropagation(); } });```
3622	lotto-sport.com.ua.js	Hardcoded Secret Exposure	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is exposed in the source code but is not directly caused by misuse of a sensitive function.}	"```self[`appKey`] = ""d747d523b8eab68d67b2c0034d0f7561"";```"
3623	lotto-sport.com.ua.js	Untrusted Resource Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts function is used with a dynamically constructed URL derived from a hardcoded hostUrl. Although the hostUrl is hardcoded, the use of importScripts with any external URL introduces risk because it allows execution of arbitrary remote code. If the hostUrl were derived from untrusted input, it would be a direct sensitive function misuse. However, since it is hardcoded, the risk is still high due to the nature of importScripts, which executes remote scripts without validation.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3624	madonna-infinity.net.js	Improper Input Validation (Reliance on Untrusted Input for Authentication	High	true	CWE-807	9	N/A	standard	{The vulnerability arises from using `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to extract the `loggedIn` state from the service worker's current URL. Since this URL can be manipulated by an attacker (e.g., via a crafted redirect or malicious site), the `loggedIn` value is untrusted. The service worker then uses this value to skip processing for authenticated users, potentially allowing an attacker to bypass authentication checks by spoofing the URL. This misuse of `match()` with untrusted input leads to improper input validation.}	```self.addEventListener('fetch', e => { const { request } = e; ... let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; } ... });```
3625	madonna-infinity.net.js	Improper Neutralization of Input (Trusting Server Response for Notification URLs	Medium	true	CWE-20	8	N/A	standard	{The code fetches notification data from the server and directly uses the `url` field from the response to construct the notification's `data.url` without validation or sanitization. If the server is compromised or the response is manipulated, an attacker could inject arbitrary URLs (e.g., malicious sites or phishing links) into the notification. The `showNotification()` function then displays this URL, potentially leading to phishing or redirect attacks. This misuse of `showNotification()` with untrusted input from the server constitutes improper neutralization of input.}	```const promiseChain = fetch(...).then(response => { if (!response.ok) { throw new Error('Invalid response'); } return response.json(); }).then(data => { const { body, url, icon, image } = data; let options = { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } }; ... });```
3626	mazaneh.net.js	Incorrect Service Worker Event Handling	Medium	false	New	N/A	N/A	N/A	{The event name 'نصب برنامه مظنه' is non-standard and likely a typo or misconfiguration, but it does not involve misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The vulnerability stems from incorrect event handling, not from unsafe function usage.}	"```self.addEventListener(""نصب برنامه مظنه"", e => { self.skipWaiting(); });```"
3627	novanews.com.br.js	XSS via unsanitized notification content	High	true	CWE-79	10	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display notifications, and it accepts a 'body' parameter that is populated with untrusted data from event.data.json().text. If this data contains malicious script or HTML, it may be rendered in the notification UI, leading to XSS if the browser or platform interprets it as executable content. This is a direct misuse of a sensitive function that processes untrusted input without sanitization.}	```self.registration.showNotification(title, { body: event.data && event.data.json().text || \'\', data: event.data && event.data.json().link || \'#\', icon: '/icon.png', badge: '/icon.png', vibrate: [300] });```
3628	novanews.com.br.js	Open redirect via unvalidated URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL specified by event.notification.data, which is derived from untrusted input (push notification data). Since no validation or sanitization is performed on this URL, an attacker can craft a notification with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or leaking sensitive information.}	```event.waitUntil(clients.openWindow(event.notification.data));```
3629	novanews.com.br.js	Denial of Service via unhandled JSON parsing error	Medium	false	CWE-754	0	N/A	N/A	{This vulnerability arises from unhandled JSON parsing errors when calling event.data.json(), but it is not caused by misuse of a sensitive function. The issue is more related to error handling and robustness rather than a direct misuse of a sensitive API.}	```event.data && event.data.json().text || \'\';```
3630	pb360.ir.js	External Script Import Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources, leading to potential code injection and compromise of the service worker. In this case, the script is imported from a hardcoded external URL, which may be controlled by an attacker or subject to supply chain attacks if the source is not secured.}	```importScripts('https://van.najva.com/static/js/scripts/new-website50512-website-50063-8f382ae0-38c9-4e91-8ada-5b55b624dd1f-service-worker.js');```
3631	perfumes24h.com.js	Improper Input Validation Leading to XSS	High	true	CWE-79	9	N/A	standard	{The function `self.registration.showNotification()` is used to display a notification with content derived from `content.title` and `content.body`, which are parsed from untrusted `event.data.text()`. If these fields contain malicious scripts or HTML, and the browser renders them as executable content (e.g., via rich notification support), it could lead to XSS. Although notifications typically sanitize content, some browsers or configurations may allow script execution, making this a high-risk misuse of a standard API.}	```const title = content.title; const options = { body: content.body, icon: content.thumbnail, image: content.image, badge: 'https://perfumes24horas.com/static/template/perfumes24horas.com/img/noti.png', data: { url: content.url, webpush_id: content.webpush_id, customers_id: content.customers_id } };```
3632	perfumes24h.com.js	Open Redirect via Notification URL	Medium	true	CWE-601	9	N/A	standard	{The function `clients.openWindow()` is called with `event.notification.data.url`, which is derived from untrusted input. Since this URL is not validated or sanitized, an attacker could craft a push notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect. This is a direct misuse of a standard service worker API with untrusted input.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
3633	playwin567.com.js	Insecure URL Handling in Notification Click	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from the notification data, which is derived from untrusted push message data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL (e.g., a phishing site or a site that performs cross-site scripting or data exfiltration), leading to unauthorized navigation and potential user compromise.}	"```self.addEventListener('notificationclick', event => { let notification = event.notification; let action = event.action; if (action === 'close') { notification.close(); } else if (url == """") { notification.close(); } else if (url != """") { clients.openWindow(url); notification.close(); } });```"
3634	quenchbotanics.com.js	Loading untrusted third-party script in Service Worker	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an untrusted third-party domain (e.g., 'https://ssl.widgets.webengage.com/js/service-worker.js'), it introduces a high-risk vulnerability. Although the URL is hardcoded, the script is loaded from an external source that is not under the control of the site owner, potentially allowing the third party to inject malicious code into the service worker, leading to cache manipulation, network interception, or data exfiltration.}	```importScripts('https://ssl.widgets.webengage.com/js/service-worker.js');```
3635	quickdrinks.com.js	Insecure Import of External Scripts	Medium	false	CWE-434	N/A	N/A	N/A	{The importScripts calls use hardcoded, trusted script paths and do not involve dynamic or user-controlled input. Therefore, while the use of importScripts is potentially risky in other contexts, here it is not misused in a way that introduces a sensitive vulnerability.}	```importScripts('ngsw-worker.js');importScripts('sw-reminders.js');importScripts('sw-push-notifications.js');```
3636	red43.com.ar.js	Improper Input Validation (URL Parameter Handling	High	true	CWE-20	N/A	get_sw_url_parameters	standard	{The function get_sw_url_parameters parses URL query parameters directly from self.location.href without sanitization or validation. The parsed value is then used as the messagingSenderId for Firebase initialization, which could allow an attacker to manipulate the Firebase configuration if the parameter is controlled by an untrusted source.}	```var messagingSenderId = get_sw_url_parameters('messagingSenderId');```
3637	red43.com.ar.js	Open Redirect via Untrusted Notification Data	Medium	true	CWE-601	N/A	client.navigate	standard	{The client.navigate(nota) function is called with a value derived from notification data (notification.data.url_destino or notification.data.nota), which is not validated or sanitized. This allows an attacker to craft a notification payload that redirects the user to an arbitrary URL, leading to an open redirect vulnerability.}	```client.navigate(nota);```
3638	rezanaseri.com.js	Insecure Cache Fallback (Serving /offline without URL validation	High	true	New	9	N/A	standard	{The service worker serves a cached /offline page without validating the requested URL, which could allow an attacker to trigger the fallback for any navigation request, potentially leading to phishing or misleading users by serving a static offline page for malicious or unexpected navigation paths. This is not directly caused by a sensitive function misuse, but the behavior is driven by the use of `cache.match('/offline')` which is a standard cache API. However, since the fallback is unconditional and not tied to a specific origin or path validation, it introduces a risk of misleading users.}	"```if (event.request.mode === ""navigate"") { event.respondWith((async () => { const cache = await caches.open(CURRENT_CACHE); try { const preloadResponse = await event.preloadResponse; if (preloadResponse) { return preloadResponse; } const fetchResponse = await fetch(event.request); if (fetchResponse) { return fetchResponse; } } catch (error) { console.log(""Fetch failed; returning cached page instead."", error); return await cache.match('/offline'); } })()); }```"
3639	rezanaseri.com.js	Insecure Notification URL Handling (Unvalidated URL in notification click	Medium	true	CWE-601	10	N/A	standard	{The `clients.openWindow(notification_data.url)` function is used with user-controlled data from `notification_data.url` without validation or sanitization. This allows an attacker to inject arbitrary URLs, potentially redirecting users to phishing sites or malicious domains, leading to open redirect or phishing attacks.}	```clients.openWindow(notification_data.url);```
3640	rezanaseri.com.js	Improper Input Validation in Fetch Handler (Unvalidated request URLs	Medium	false	CWE-20	0	N/A	standard	{The fetch handler processes navigation requests without validating the URL, but it does not use any sensitive function with untrusted input. The `fetch(event.request)` call is standard and safe as long as the request is from the same origin, which is enforced by the browser. The vulnerability is more about logic and policy than sensitive function misuse.}	"```if (event.request.mode === ""navigate"") { event.respondWith((async () => { const cache = await caches.open(CURRENT_CACHE); try { const preloadResponse = await event.preloadResponse; if (preloadResponse) { return preloadResponse; } const fetchResponse = await fetch(event.request); if (fetchResponse) { return fetchResponse; } } catch (error) { console.log(""Fetch failed; returning cached page instead."", error); return await cache.match('/offline'); } })()); }```"
3641	rolfsbuss.se.js	Insecure Service Worker Message Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of incoming messages. The code listens for messages and executes `self.skipWaiting()` if the message data contains a specific type. While this is not inherently dangerous, it could be exploited in a context where an attacker can send arbitrary messages to the service worker, potentially forcing it to skip waiting and update prematurely. However, no sensitive function like `importScripts`, `eval`, or `Function` is being misused here.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
3642	yopshop.ir.js	Remote Code Execution via External Script	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically derived from untrusted input, the act of importing and executing an external script from a third-party domain introduces a high-risk vulnerability. If the remote script is compromised or controlled by an attacker, it can execute arbitrary code within the context of the service worker, leading to Remote Code Execution (RCE). This is considered a sensitive function misuse because importScripts() inherently trusts the provided URL without validation or sanitization, and its use with external sources is inherently risky.}	```importScripts('https://van.najva.com/static/js/scripts/new-website139325-website-48136-19749fb6-9262-4f6b-ad80-e1d0fe19712c-service-worker.js');```
3643	yves-rocher.pl.js	XSS via untrusted notification data	Medium	true	CWE-79	9	N/A	standard	{The showNotification function is used with data.title, which is derived from untrusted push event data. If an attacker can control the title, they can inject malicious content that may be rendered in the notification UI, potentially leading to XSS if the browser or platform interprets the content as executable script or HTML.}	```event.waitUntil(self.registration.showNotification(data.title, data.options));```
3644	yves-rocher.pl.js	Open Redirect via unvalidated clickLink	High	true	CWE-601	10	N/A	standard	{The clients.openWindow function is called with clickLink, which is derived from untrusted notification action data. Since no validation or sanitization is performed on clickLink, an attacker can supply a malicious URL, leading to open redirect and potential phishing or credential theft.}	```return clients.openWindow(clickLink);```
3645	yves-rocher.pl.js	Cache deletion logic with potential bypass	Low	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from logic error in cache name filtering, not misuse of a sensitive function. The code checks for cache names containing specific suffixes but does not properly validate or sanitize the cachePrefix or suffixes, leading to potential unintended cache deletion.}	```if (cacheName.indexOf(suffix) !== -1 && cacheName !== `${cachePrefix}${suffix}`) { return true; }```
3646	zamashops.com.js	Improper Input Validation (Untrusted URLs in Notification Icon/Badge)	Medium	true	CWE-20	8	N/A	standard	{The Notification API's `icon` and `badge` properties accept URLs that are loaded and displayed by the browser. If these URLs are derived from untrusted input (e.g., `pushData.data.icon` or `pushData.data.badge`), an attacker could supply malicious URLs that lead to phishing, content injection, or exfiltration of sensitive data via tracking. While not directly executable, these can be leveraged in social engineering or to bypass security controls.}	```const icon = pushData.data?.icon || 'https://zamashops.com/notification/images/icon.png'; const badge = pushData.data?.badge || 'https://zamashops.com/notification/images/badge.png';```
3647	zz77.game.js	Improper Cache Control Leading to Unintended Resource Caching	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching the root path ('/') without proper validation, which may lead to unintended caching of resources. However, this is not due to misuse of a sensitive function but rather a logic flaw in cache configuration.}	```self.addEventListener('install', e => { e.waitUntil(caches.open('fox-store').then(cache => cache.addAll(['/']))); e.waitUntil(self.skipWaiting()); });```
3648	zz77.game.js	Flawed URL Validation Logic in Fetch Event	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from a flawed URL validation logic that checks for a dot in a substring of the URL, which can be bypassed or misinterpreted. This is a logic error, not a misuse of a sensitive function.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
3649	zz77.game.js	Insecure Notification Content Handling	Medium	false	CWE-79	N/A	N/A	N/A	{The vulnerability involves using notification data directly without sanitization, which could lead to XSS if the content is rendered in a context that interprets HTML. However, this is not caused by a sensitive function misuse but by improper input handling.}	```const title = data.notification.title || ''; const options = { body: data.notification.body, icon: data.notification.image || '', badge: data.notification.image || '' };```
3650	nutmailer.com.js	Improper Cache Cleanup	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from not cleaning up old cache versions during the 'activate' event, which can lead to stale or unused caches consuming storage and causing potential inconsistencies. However, this is not due to misuse of a sensitive function, but rather a missing best practice in cache management.}	```self.addEventListener('activate', function (event) { console.log('[sw] Activated'); });```
3651	nutmailer.com.js	XSS via Unsanitized Push Data	High	true	CWE-79	N/A	showNotification	standard	{The showNotification function is called with data.title, which is parsed from untrusted push data without sanitization. If an attacker controls the push payload, they can inject malicious content into the notification, potentially leading to XSS if the notification UI renders the content in a way that executes scripts (e.g., via rich text or HTML rendering).}	```event.waitUntil(self.registration.showNotification(data.title, data.options));```
3652	debaser.it.js	Improper Input Validation (Arbitrary URL Execution)	High	true	CWE-20	9	N/A	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the specified URL. In this case, the URL is derived directly from e.notification.data.url, which is user-controlled data received via a push notification. Since no validation or sanitization is performed on this input, an attacker could craft a malicious notification payload containing a URL that leads to phishing, malware, or other malicious content, resulting in arbitrary URL execution.}	```e.waitUntil(clients.openWindow(e.notification.data.url));```
3653	ladygaganow.net.js	CSRF Protection Bypass via Client-Side Check	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from client-side logic that checks for a `loggedIn` parameter in the URL to determine if a user is logged in. This check is performed in the service worker, which is not a secure environment for authentication decisions. Since the `location.href` is directly parsed and trusted without server-side validation, an attacker can manipulate the URL to bypass CSRF protection by spoofing the `loggedIn=true` parameter. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure logic design.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3654	ladygaganow.net.js	CSRF Token Fetch with Unvalidated Path	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used to retrieve a CSRF token from the server using a dynamically constructed URL that includes the `path` parameter derived from the current request's URL. Since the `path` is not validated or sanitized before being inserted into the URL, an attacker could manipulate the request to include a malicious path (e.g., `../../admin/` or a path to a sensitive endpoint), potentially leading to unauthorized CSRF token retrieval or other unintended server behavior. This misuse of `fetch` with untrusted input constitutes a sensitive function misuse.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`);```
3655	rpghq.org.js	Hardcoded Session Token	N/A	false	CWE-798	N/A	N/A	N/A	{The hardcoded session token is a static value embedded in the URL, not a result of misuse of a sensitive JavaScript function. It is a configuration issue rather than a function misuse vulnerability.}	```const getNotificationUrl = '/forums/user/push/notification?sid=7385ac9bf2dfdec92df50d1e798a2108';```
3656	rpghq.org.js	Open Redirect	N/A	true	CWE-601	N/A	N/A	standard	{The function clients.openWindow is used with a dynamic URL derived from event.notification.data.url, which is user-controlled. This allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerability.}	```event.waitUntil(self.clients.openWindow(event.notification.data.url));```
3657	bartog.si.js	Use of external script without integrity check	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a remote URL. When used without integrity checks, it allows an attacker to compromise the script source (e.g., via DNS spoofing or man-in-the-middle attacks), leading to arbitrary code execution within the service worker context. This is a direct misuse of a sensitive function that can lead to full compromise of the service worker.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
3658	bartog.si.js	Hardcoded external endpoint in service worker	High	false	N/A	N/A	N/A	N/A	{The updateRegistration function is not inherently sensitive; it is used to update a service worker registration with a specific ID and endpoint. The vulnerability arises from the hardcoded endpoint, which may be a misconfiguration or a potential attack surface if the endpoint is not properly secured, but it does not stem from misuse of a sensitive function.}	```updateRegistration('ba8cf7a9-a32a-43dc-9676-d76c34594ae0', 'https://gimli.segmentify.com/');```
3659	eadmissions.org.uk.js	Open Redirect via notificationclick event	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL passed via the notification.data field, which is derived from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect and potential phishing or malware delivery.}	N/A
3660	eadmissions.org.uk.js	Potential Cache Poisoning in fetch handler	Medium	true	New	8	caches.match	custom	{The caches.match() function is used to retrieve responses from the cache, but the fetch handler does not validate or sanitize the request URL before caching or serving it. If an attacker can trigger a fetch for a malicious URL (e.g., via a crafted request), it may be cached and served to other users, leading to cache poisoning.}	N/A
3661	eadmissions.org.uk.js	Insecure Cache Deletion in activate event	Medium	true	CWE-377	7	caches.delete	standard	{The caches.delete() function is used to remove caches, but it does not validate the cache names before deletion. If an attacker can influence the cache keys (e.g., via a compromised service worker), they could potentially delete unintended caches, leading to data loss or denial of service.}	N/A
3662	irmag.ru.js	Improper Input Validation (Substring Matching in URL Checks)	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using substring matching (includes()) on the request URL to determine whether to serve a cached offline page. This approach is not sensitive function misuse but rather a logic flaw in URL filtering. The code does not use any sensitive functions like importScripts(), eval(), or dynamic code execution; instead, it misuses string matching for security-critical decisions, which can be bypassed by URL obfuscation (e.g., using encoded or case-varied substrings).}	```self.addEventListener('fetch', function (e) { if (!(e.request.url.includes('ajax') || e.request.url.includes('profile') || e.request.url.includes('blog') || e.request.url.includes('order') || e.request.url.includes('forum') || 'follow' !== e.request.redirect) && ('navigate' === e.request.mode || 'GET' === e.request.method && e.request.headers.get('accept').includes('text/html'))) { var t = new Request(e.request.url, { mode: 'cors' }); e.respondWith(fetch(t).catch(function () { return caches.match(n); })); } });```
3663	mojportal.hr.js	Improper Input Validation	High	false	N/A	0	N/A	N/A	"{The assignment `self.client = event.source;` does not involve a sensitive function misuse. It simply stores the source of a message event, which is a standard operation in Service Workers. There is no direct or indirect use of a sensitive function like `importScripts`, `eval`, `Function`, or `fetch` with untrusted input. The vulnerability labeled ""Improper Input Validation"" likely refers to a broader concern, but no sensitive function is being misused here.}"	```self.client = event.source;```
3664	edivaldobrito.com.br.js	XSS via iframe srcdoc injection	High	true	CWE-79	9	replace	standard	{The `replace` method is used to sanitize `responseBody` by escaping HTML entities, but it is applied to `srcdoc` which is then embedded in an iframe. If the `responseBody` contains malicious HTML or script, and the sanitization is incomplete (e.g., missing handling of certain characters or context), it can lead to XSS. The function is misused because it assumes full sanitization, but the context (iframe srcdoc) is inherently risky and requires stricter escaping.}	"```const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');```"
3665	edivaldobrito.com.br.js	Overly broad POST route matching	Medium	false	CWE-379	0	N/A	N/A	{The vulnerability arises from a broad regex pattern `/./` used in `registerRoute`, which matches all POST requests. This is not caused by misuse of a sensitive function, but rather by a design flaw in route matching logic.}	```wp.serviceWorker.routing.registerRoute(/.*/, offlinePostRequestHandler, 'POST');```
3666	edivaldobrito.com.br.js	Denylist regex inadequacy	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability stems from the regex patterns in the denylist being insufficient to block all malicious paths. This is a logic flaw in the denylist construction, not misuse of a sensitive function.}	"```const denylist = [""^\\\/wp\\-admin($|\\?|\/)"", ""^[^\\?]*?\\.php($|\\?)"", ""\\?(.*?&)?wp_service_worker="", ""^[^\\?]*?\\\/wp\\.serviceworker(\\?|$)"", ""^[^\\?]*?\\\/feed\\\/(\\w+\\\/)?$"", ""\\?(.*?&)?wp_customize="", ""\\?(.*?&)?customize_changeset_uuid="", ""^\\\/wp\\-json\\\/""].map(pattern => new RegExp(pattern));```"
3667	edivaldobrito.com.br.js	Cache poisoning via unvalidated revision strings	Medium	false	New	0	N/A	N/A	{The vulnerability arises from using unvalidated revision strings in `precache` calls. These strings are not derived from user input or dynamic sources, and no sensitive function is misused; instead, it's a configuration or logic flaw.}	```wp.serviceWorker.precaching.precache([{'url': 'https:\/\/www.edivaldobrito.com.br\/?wp_error_template=offline', 'revision': '0.8.1;generatepress=3.5.1;options=29389d8425d26bc3334e55cc9b97598d;nav=6f5e1d7091ec2eb40b39fcbf115aa52b;deps=7f6c6e1500b92f0bc958a53c0e5d6269;7855369c407c835a19f2f352834273ec'}]);```
3668	centrumdobrejterapii.pl.js	External Script Inclusion	Medium	false	CWE-444	N/A	N/A	N/A	{The importScripts() call is used to load a script from a known, hardcoded, trusted source (https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js). Since the URL is not derived from user input or dynamic sources, it does not constitute a sensitive function misuse.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js');```
3669	empleonuevo.com.js	Request Interception Bypass	N/A	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from improper handling of request interception logic, specifically the modification of request cache and mode attributes under certain conditions. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logical flaw in the request interception strategy. The code does not involve dynamic or untrusted input being passed to a sensitive function, so it is not classified as a sensitive function misuse.}	```const requestInterceptor = { requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') { return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' }); } return request; }, ... };```
3670	u-school.org.js	Open Redirect via Untrusted Data in Notification Handling	Medium	true	CWE-601	9	N/A	standard	{The function `clients.openWindow()` is used to open a new browser window or tab with a URL constructed using untrusted data (`data.id` and `data.alid`). Since these values originate from external notification data, an attacker could craft a malicious notification payload to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```profileClient = await clients.openWindow(`/user/profile?uc=${data.id}`)```
3671	u-school.org.js	Open Redirect via Untrusted Data in Notification Handling	Medium	true	CWE-601	9	N/A	standard	{The function `clients.openWindow()` is used to open a new browser window or tab with a URL constructed using untrusted data (`data.alid`). Since this value comes from external notification data, an attacker could manipulate it to redirect users to arbitrary URLs, resulting in an open redirect vulnerability.}	```profileClient = await clients.openWindow(`/user/profile?alid=${data.alid}`)```
3672	u-school.org.js	Open Redirect via Untrusted Data in Notification Handling	Medium	false	CWE-601	0	N/A	standard	{The `self.registration.showNotification()` function is used to display a notification with an image URL derived from `data.activeUserDetails?.profile?.url`. While this could potentially lead to an open redirect if the image URL is controlled by an attacker, the function itself does not directly navigate or redirect users; it only displays an image. Therefore, this is not a sensitive function misuse in the context of open redirect via navigation.}	```self.registration.showNotification(data.title, { body: data.body, icon: 'favicon.ico', image: data.activeUserDetails?.profile?.url, data: data })```
3673	kosmetykaaut.pl.js	Cross-Site Request Forgery (CSRF) Bypass	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's logic that checks for a `loggedIn` parameter in the current URL to determine whether to intercept POST requests and inject CSRF tokens. However, this check is based on a URL parameter that can be easily manipulated by an attacker. Since the service worker does not validate the authenticity of the `loggedIn` parameter (e.g., via a secure token or session verification), an attacker can craft a malicious page that sets `loggedIn=false` to force the service worker to intercept and modify legitimate POST requests, potentially bypassing CSRF protections. This is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in handling untrusted input.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3674	pomsinoz.com.js	Insecure Reliance on URL Parameter for Authentication	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter directly from the URL without validation or sanitization, but no sensitive JavaScript function is misused in this case. The issue is a logic flaw in authentication handling, not a function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3675	pomsinoz.com.js	Potential CSRF Vulnerability	Medium	false	N/A	N/A	N/A	N/A	{Although the code fetches a CSRF token, the vulnerability stems from the lack of proper token validation and the reliance on dynamic path injection, not from misuse of a sensitive function. The fetch call is used correctly.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key);```
3676	pomsinoz.com.js	Open Redirect Vulnerability	High	true	N/A	N/A	navigate	standard	{The `navigate` method is used with user-controlled `data.url` from a notification, which can be manipulated to redirect users to arbitrary domains, leading to open redirect attacks.}	```clients[0].navigate(data.url);```
3677	pomsinoz.com.js	Insecure Caching of Sensitive Assets	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to caching assets without proper security controls, but `cache.addAll` is used correctly. The issue is more about policy than function misuse.}	```cache.addAll(CACHED_ASSETS);```
3678	pomsinoz.com.js	Improper Input Validation in Push Event Handler	Medium	false	N/A	N/A	N/A	N/A	{The `fetch` call uses a dynamic `id` parameter from push data, but the function itself is not misused. The vulnerability lies in insufficient validation of the `id` parameter, not in the function call.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3679	pomsinoz.com.js	Use of Credentials in Fetch Request	Medium	false	N/A	N/A	N/A	N/A	{The use of `credentials: 'include'` is a configuration choice, not a misuse of a sensitive function. It is a standard and intended behavior for authenticated requests.}	```credentials: 'include'```
3680	od-news.com.js	External Code Execution via Untrusted importScripts	High	true	CWE-444	10	importScripts	standard	{The code uses `importScripts` with a dynamically constructed URL derived from `self.appKey`, which is assigned a hardcoded value. Although the value is hardcoded, the vulnerability arises because `importScripts` is a sensitive function that executes arbitrary JavaScript from a remote URL. If `appKey` were derived from untrusted input (e.g., user-controlled parameters), it would allow remote code execution. However, since the value is hardcoded, the risk is mitigated but still present if the hardcoded URL is controlled by an attacker or if the value is later modified via other means. The misuse lies in using `importScripts` with a non-static URL, even if currently hardcoded.}	```self.importScripts(self.appKey + '/worker.js');```
3681	ryfma.com.js	Insecure URL Handling in Notification Clicks	High	true	N/A	9	new URL	standard	{The code constructs a URL using `new URL(notificationData.url, self.location.origin)`, where `notificationData.url` is derived from a push notification payload. Since push notifications can be controlled by an attacker (if the server is compromised or if the notification data is not validated), this allows an attacker to inject arbitrary URLs. The `new URL` constructor, while safe in isolation, becomes a vector for redirecting users to malicious sites when used with untrusted input. This can lead to phishing, credential theft, or drive-by downloads.}	```const urlToOpen = new URL(notificationData.url, self.location.origin).href;```
3682	hybridz.org.js	Improper Neutralization of Server-Side Request URL (SSRF)	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this parameter is not validated or sanitized, an attacker could supply a malicious URL (e.g., internal network resources or external domains) to trigger SSRF, allowing unauthorized access to internal systems or services.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3683	hybridz.org.js	Improper Neutralization of Server-Side Request URL (SSRF)	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since this parameter is not validated or sanitized, an attacker could supply a malicious path (e.g., internal network resources or external domains) to trigger SSRF, allowing unauthorized access to internal systems or services.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3684	hybridz.org.js	Open Redirect Vulnerability	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the notification data, which is not validated or sanitized. If an attacker can control the `data.url` value, they can redirect users to arbitrary websites, potentially leading to phishing or malicious redirection.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
3685	hybridz.org.js	Improper Validation of URL Parameter (Logic Bypass)	Medium	false	New	N/A	N/A	N/A	{The use of a regular expression to extract `loggedIn` from the URL does not involve a sensitive function misuse; it is a logic issue related to improper validation of URL parameters, not a direct misuse of a sensitive JavaScript function.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/)```
3686	meta2kids.com.js	Remote Code Execution via Dynamic Script Loading	High	true	CWE-960	10	importScripts	standard	"{The code dynamically constructs a script URL using `new URL(t + "".js"", n).href` and then conditionally executes `importScripts(t)` if the environment does not have a document. Since `t` is derived from user-provided module names passed to `define`, and no validation or sanitization is applied, an attacker could supply a malicious module name that resolves to a remote script URL, leading to arbitrary code execution in the service worker context. This is a classic case of unsafe dynamic script loading via `importScripts`, which is a standard JavaScript API in the Service Worker environment.}"	```if (!e) importScripts(t), s();```
3687	myfin.us.js	Insecure Caching of Offline Fallback Page	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching a hardcoded offline fallback page without validating its source or content, but it is not due to misuse of a sensitive function like importScripts or eval. The cache.add() function is used correctly with a known, static path.}	```cache.add(origin + '/img/logo/logo.us.svg'); return cache.add(offlineFallbackPage);```
3688	myfin.us.js	Unvalidated Offline Page Fetch in Refresh Event	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from fetching and caching the offline fallback page without validating its origin or integrity, but it does not involve misuse of a sensitive function such as eval or importScripts. The fetch() function is used appropriately, though the lack of validation is a concern.}	```return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { return cache.put(offlinePageRequest, response); });```
3689	opposite-lock.com.js	Improper Cache Control Leading to Sensitive Data Exposure	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper cache handling logic, not from misuse of a sensitive function. The code caches responses and serves them when available, but does not validate or sanitize the request or response content, potentially leading to exposure of sensitive data if cached responses contain such data. However, no sensitive JavaScript function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', function (event) { if (event.request.method === 'POST') { return; } event.respondWith(caches.match(event.request).then(function (response) { if (!response) { return fetch(event.request); } return response; }));});```
3690	ikwordzzper.nl.js	Malformed JSON Input Leading to Denial of Service	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing potentially malformed JSON data from `event.data.json()` without proper error handling, which can lead to a denial of service if the JSON is invalid. However, this is not due to misuse of a sensitive function, but rather a lack of input validation.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } var data = {}; if (event.data) { data = event.data.json(); }```
3691	ikwordzzper.nl.js	Insecure URL Handling in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The `clients.openWindow(data.url)` function is called with `data.url` derived from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can supply a malicious URL (e.g., a phishing site or a site that performs cross-site scripting or data exfiltration), leading to unauthorized navigation or user redirection. This constitutes misuse of a sensitive function because it allows execution of arbitrary navigation based on untrusted input.}	```event.waitUntil(clients.openWindow(data.url));```
3692	avidaland.com.js	Improper Input Validation in URL Parameter Parsing	High	true	CWE-20	N/A	const [key, val] = param.split(`=`);	standard	{The split() function is used to parse URL parameters without validating or sanitizing the input, allowing arbitrary key-value pairs to be injected. This can lead to unintended behavior or data leakage if the keys are used unsafely in subsequent operations.}	```const [key, val] = param.split(`=`);```
3693	avidaland.com.js	Arbitrary Function Invocation via Unvalidated API Parameter	High	true	CWE-755	N/A	MessageAPI[data.api]();	standard	{The code dynamically invokes functions from the MessageAPI object using an unvalidated 'data.api' parameter derived from user input. This allows an attacker to call any function in the MessageAPI object, potentially leading to unauthorized actions or privilege escalation.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
3694	avidaland.com.js	Open Redirect via Untrusted URL Handling	Medium	true	CWE-601	N/A	Location: lastNavigationRequest	standard	{The Response header 'Location' is set to 'lastNavigationRequest', which is derived from the user's request URL without validation. This allows an attacker to craft a malicious URL that redirects users to arbitrary destinations, potentially leading to phishing or credential theft.}	```headers: { Location: lastNavigationRequest }```
3695	avidaland.com.js	Insecure IndexedDB Key Generation from URL Path	Medium	true	CWE-200	N/A	idbKeyval.set(`resources:${path}`	standard	{The IndexedDB key is constructed by concatenating a static prefix with the raw URL path, which is user-controlled. This allows an attacker to inject arbitrary keys, potentially leading to data leakage, key collision, or unauthorized access to stored data.}	```idbKeyval.set(`resources:${path}`, resources);```
3696	footofan.com.js	External Script Import Without Integrity Check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and does not include an integrity check (e.g., via a Subresource Integrity hash). While the URL is not dynamically constructed from untrusted input, the lack of integrity verification means the script could be tampered with in transit or replaced by an attacker, leading to unauthorized code execution. This constitutes a misuse of the sensitive function due to insufficient security controls, even if the input is static.}	```importScripts('https://van.najva.com/static/js/scripts/footofan-1003554-94ecd29d-db37-4262-9d35-a50eca26197d-service-worker.js');```
3697	paradisefuneralchapel.com.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	9	function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }	custom	{The function `template` dynamically constructs a regular expression from the keys of the `data` object. If an attacker can control the `data` object, they can inject a large number of keys or keys with complex patterns (e.g., long strings with repeated characters), leading to catastrophic backtracking during regex matching. This can cause the JavaScript engine to consume excessive CPU resources, resulting in a ReDoS attack.}	```function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }```
3698	darmarsklep.pl.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials (API key) in the code, not due to misuse of a sensitive JavaScript function. The code does not dynamically construct or inject values into sensitive functions like importScripts, eval, or similar.}	```importScripts('https://www.gstatic.com/firebasejs/4.8.1/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/4.8.1/firebase-messaging.js');var config = { apiKey: 'AAAAkbURWDU:APA91bGCqlgb0ar1UjJVDKOpvh7A-fAXVCamDPAYkdnzXgm7o6BBKcLjDPJBHO4b5TVcfy70Q-5yFy1skqKL9ATWkhScLzacIEr7RiMSloXkeWR9FP6k3Iq_F4s6LhuIyDuVrdPNy6AuiFifmU-qY8NMX6MycjMR1Q', authDomain: 'pushwebdarmar.firebaseapp.com', messagingSenderId: '625808070709' };firebase.initializeApp(config);const messaging = firebase.messaging();```
3699	rivalrywin.com.js	Code Injection via importScripts	High	true	CWE-94	10	N/A	standard	{The importScripts() function is used to load and execute a script from a hardcoded path 'cmiyc-sw.js'. While the path is not dynamic, the function itself is sensitive because it executes arbitrary JavaScript code. If the script path were derived from untrusted input, it could lead to code injection. However, in this case, the path is fixed and not user-controlled, so the risk is lower than if it were dynamic. Still, the function is inherently sensitive and should be treated with caution.}	"```importScripts(""cmiyc-sw.js"")```"
3700	rivalrywin.com.js	Insecure Dynamic Module Loading	Medium	true	CWE-476	9	N/A	standard	{The new URL(r + '.js', d).href construction dynamically generates script URLs based on input parameters. If r or d are derived from untrusted sources, this can lead to loading arbitrary scripts, resulting in insecure dynamic module loading. The function URL() is standard and can be misused to construct malicious URLs when combined with untrusted input.}	```const i = new URL(r + '.js', d).href```
3701	rivalrywin.com.js	Unversioned Precache Entry	Low	false	New	0	N/A	N/A	{This vulnerability arises from a missing revision hash for a precache entry, which does not involve any sensitive function misuse. It is a configuration issue rather than a functional misuse.}	```{url: '_nuxt3/builds/meta/4d8d4cdd-e47e-4f2e-8cd9-6c652ee67a95.json', revision: null}```
3702	mail.fm.js	Insecure Token Handling in URL	High	true	CWE-522	9	Authorization	standard	{The `fetch` function is used with a URL that has its `access_token` parameter extracted and then removed from the URL, but the token is then used in the Authorization header. This is not inherently unsafe, but the vulnerability arises because the token is extracted from the URL, which is a known insecure practice (CWE-522). The `fetch` function itself is standard and not misused per se, but its use with unsanitized URL parameters introduces the risk. The token is exposed in the URL, which can be logged, cached, or leaked via referrer headers. The sensitive function here is `fetch` because it is used to make a request with credentials derived from an insecure source (URL).}	```let CACHE_VERSION = 1.6, CURRENT_CACHES = { offline: 'offline-v' + CACHE_VERSION, font: 'font-v' + CACHE_VERSION }, OFFLINE_URL = 'offline.html'; function createCacheBustedRequest(e) { var t = new Request(e, { cache: 'reload' }); return 'cache' in t ? t : ((t = new URL(e, self.location.href)).search += (t.search ? '&' : '') + 'cachebust=' + Date.now(), new Request(t)); } self.addEventListener('fetch', async n => { var e, t; -1 !== n.request.url.indexOf('/download?blobId=') && -1 !== n.request.url.indexOf('&access_token=') ? (e = (t = new URL(n.request.url)).searchParams.get('access_token'), t.searchParams.delete('access_token'), n.respondWith(fetch(t, { headers: { Authorization: 'Bearer ' + e } }))) : ... });```
3703	mail.fm.js	Manifest Name Manipulation via URL	Medium	true	New	8	extractNameFromUrl	custom	{The `extractNameFromUrl` function is a custom function that processes a URL string to extract a domain name and then uses it to modify the `name` field in the manifest.json response. Since the input URL is derived from the request URL (which can be controlled by the user), and the function performs minimal sanitization (e.g., removing known patterns but not validating or escaping), it allows an attacker to manipulate the manifest name by crafting a malicious URL. This leads to potential phishing or misleading app names. The function is custom and directly responsible for the vulnerability due to its unsafe handling of untrusted input.}	```self.addEventListener('fetch', async n => { ... -1 !== n.request.url.indexOf('/manifest.json') ? n.respondWith(fetch(n.request).then(async e => { var t = await e.json(); return t.name = extractNameFromUrl(n.request.url) + ' Webmail', new Response(JSON.stringify(t), { headers: e.headers }); ... })); function extractNameFromUrl(e) { return !e.match(/http(s?):\/\/\d+\.\d+\.\d+\.\d+/) && (e = e.replace(/^http(s)?:\/\//, '').replace(/\/.+/, '').replace(/\.[a-z]+$/i, '').replace(/\.(com|net|org|co|gov)?$/, '').replace(/([a-z0-9\-]+\.)/gi, '')) ? e.includes('atmailcloud') || 'localhost' === e ? 'Atmail' : e.charAt(0).toUpperCase() + e.slice(1) : ''; }```
3704	mineimatorforums.com.js	Vulnerable Authentication Check via URL Parameter	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from directly parsing the `loggedIn` parameter from the URL without validation or sanitization, but it does not involve misuse of a sensitive JavaScript function such as `eval`, `importScripts`, or `fetch` with untrusted input. The issue is more about logic flaw or insecure state management rather than function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3705	mineimatorforums.com.js	Insecure CSRF Token Handling	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since this parameter is derived from user input (via `new URL(curRequest.url).pathname`), and is directly interpolated into the fetch URL without sanitization, it allows for potential SSRF or unintended server-side request manipulation if the path is controlled by an attacker.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3706	mineimatorforums.com.js	Unvalidated Notification Redirect	Medium	true	N/A	N/A	clients[0].navigate	standard	{The `navigate` method of the `clients` API is used with a URL derived from the notification data (`data.url`), which is obtained from a remote push notification. Since this data is not validated or sanitized, an attacker could craft a malicious notification to redirect the user to an arbitrary URL, leading to phishing or unintended navigation.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
3707	mineimatorforums.com.js	XSS via Unsanitized Notification Content	High	true	N/A	N/A	self.registration.showNotification	standard	{The `showNotification` method is used with notification content (`title` and `body`) that are directly extracted from untrusted server data (`data`). Since these values are not sanitized or escaped, an attacker could inject malicious scripts or HTML into the notification, leading to XSS if the notification is rendered in a context that interprets HTML or JavaScript.}	```self.registration.showNotification(title, options);```
3708	beamfuneralservice.com.js	Improper Handling of Fetch Event Leading to Potential Cache Misbehavior	High	false	New	N/A	N/A	N/A	{The fetch event handler is defined but does nothing (empty function), which may lead to unintended behavior or bypass of expected caching logic, especially if the service worker is expected to handle fetch events for caching or routing. However, this is not caused by misuse of a sensitive function, as no function is being improperly used with untrusted input.}	```self.addEventListener('fetch', () => {});```
3709	beamfuneralservice.com.js	Cache Poisoning via No-CORS Fetch in Prefetch	Medium	true	CWE-918	N/A	fetch	standard	{The fetch function is used with mode: 'no-cors', which can lead to cache poisoning if the response is cached without proper validation. Since the URL is constructed from user-provided input (via addParams and URL), and the response is cached without checking its origin or integrity, an attacker could potentially supply a malicious URL that returns a response which is then cached and served to other users, leading to cache poisoning.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
3710	beamfuneralservice.com.js	Denial of Service via Cache Deletion Message	Low	false	CWE-400	N/A	N/A	N/A	{The vulnerability arises from the service worker responding to a message event by deleting a cache, which could be exploited if an attacker can send a message to trigger cache deletion. However, this is not due to misuse of a sensitive function with untrusted input, as the cache deletion is triggered by a specific command and not by dynamic or untrusted input passed to a sensitive function.}	```event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME });```
3711	getbillage.com.js	Improper Cache Control Leading to Sensitive Data Exposure	High	true	N/A	9	caches.match	custom	{The caches.match function is used to retrieve cached responses, but without proper validation or control over what is cached or served, it can lead to sensitive data exposure if cached responses contain confidential information and are served without appropriate security checks. The function is misused by not enforcing cache policies or validating the request context, allowing potentially sensitive data to be served from cache without authentication or authorization checks.}	```event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); }));```
3712	truescoopnews.com.js	Untrusted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., 'https://anymind360.com/js/4539/anymind-sw.js'), it introduces a high-risk vulnerability because the script is fetched and executed from an untrusted third-party domain. This allows the third party to inject malicious code into the service worker, potentially compromising the entire web application by intercepting network requests, manipulating cache, or stealing sensitive data.}	```importScripts('https://anymind360.com/js/4539/anymind-sw.js');```
3713	homegallerystores.com.js	Insecure Resource Precaching	High	true	CWE-497	9	$().precache	standard	{The precache function is used to cache resources specified in a hardcoded list. While the URLs are hardcoded and not derived from untrusted input, the vulnerability arises because the precache mechanism can be manipulated if the list of URLs is dynamically generated from untrusted sources. However, in this case, the URLs are static and not derived from user input, so the vulnerability is not due to sensitive function misuse but rather due to insecure configuration. Therefore, this is not a sensitive function misuse vulnerability.}	```function (e) { $().precache(e); }([{'revision': null, 'url': 'https://d9dvmj2a7k2dc.cloudfront.net/v2/hgs/mobile/hgs-mobile-ui/hgsm-8586d6b447b72cb80d28.css'}, {'revision': null, 'url': 'https://d9dvmj2a7k2dc.cloudfront.net/v2/hgs/mobile/hgs-mobile-ui/hgsm-c2dafc9912f7a7965260.css'}, {'revision': 'c78141100c55651e2f7a0320df844bf4', 'url': 'https://d9dvmj2a7k2dc.cloudfront.net/v2/hgs/mobile/hgs-mobile-ui/manifest.json'}, {'revision': 'bb0fb7bd8f60da6c9c9a9492a8765b6e', 'url': 'https://d9dvmj2a7k2dc.cloudfront.net/v2/hgs/mobile/hgs-mobile-ui/static/js/hgsm-774-c2dafc9912f7a7965260.js.LICENSE.txt'}, {'revision': null, 'url': 'https://d9dvmj2a7k2dc.cloudfront.net/v2/hgs/mobile/hgs-mobile-ui/static/js/hgsm-main-8586d6b447b72cb80d28.js'}, {'revision': '4e0e34f265fae8f33b01b27ae29d9d6f', 'url': 'https://d9dvmj2a7k2dc.cloudfront.net/v2/hgs/mobile/hgs-mobile-ui/static/js/hgsm-main-8586d6b447b72cb80d28.js.LICENSE.txt'}])```
3714	homegallerystores.com.js	Cache Poisoning	High	true	CWE-434	9	async fetchAndCachePut	standard	{The fetchAndCachePut method fetches a resource and caches it without validating the response. If an attacker can manipulate the request (e.g., via a crafted URL or network interception), the service worker may cache a malicious response, leading to cache poisoning. The function is sensitive because it blindly caches responses without proper validation, especially when used with dynamic or untrusted URLs.}	```async fetchAndCachePut(e) { const t = await this.fetch(e), s = t.clone(); return this.waitUntil(this.cachePut(e, s)), t; }```
3715	zarinexpress.com.js	Incorrect Cache Handling Logic	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from improper cache handling logic, not from misuse of a sensitive function. The code attempts to respond to fetch events by first checking the cache, then falling back to network fetch, and finally serving an offline page if both fail. However, the issue lies in the logic flow: the `caches.match(e.request).then(() => { ... })` always resolves to the same fallback logic regardless of whether the cache match was successful. This means that even if the cache has the requested resource, it still proceeds to fetch from the network, which is inefficient and potentially unnecessary. No sensitive function is misused here.}	```const CACHE_NAME = 'zarin-express';const urlsToCache = ['index.html', 'offline.html'];this.addEventListener('install', e => {  e.waitUntil(caches.open(CACHE_NAME).then(cache => {    return cache.addAll(urlsToCache);  }));});self.addEventListener('fetch', e => {  e.respondWith(caches.match(e.request).then(() => {    return fetch(e.request).catch(() => caches.match('offline.html'));  }));});this.addEventListener('activate', e => {  const cacheWhiteList = [];  cacheWhiteList.push(CACHE_NAME);  e.waitUntil(caches.keys().then(cacheNames => Promise.all(cacheNames.map(cacheName => {    if (!cacheWhiteList.includes(cacheName)) {      return caches.delete(cacheName);    }  }))));});```
3716	funghiitaliani.it.js	CSRF Token Handling Vulnerability	High	true	CWE-352	9	fetch	standard	{The fetch function is used to dynamically construct and send a request to retrieve a CSRF token based on the path from the intercepted request. While the intent is to mitigate CSRF, the use of dynamically constructed URLs with user-controlled path parameters introduces a risk if the path is not properly sanitized, potentially leading to unintended requests or information leakage. However, the primary vulnerability here is not direct misuse of fetch, but rather the logic around CSRF token handling. The fetch call itself is not inherently unsafe, but its use in this context with dynamic path input contributes to the overall CSRF vulnerability.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token'```
3717	funghiitaliani.it.js	Insecure Request Redirection	Medium	true	CWE-601	8	clients[0].navigate	standard	{The clients[0].navigate function is used to redirect the client to a URL derived from the notification data. Since the URL is sourced from the data.url field, which is obtained from a potentially untrusted external push notification, this allows an attacker to redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients[0].navigate(data.url);```
3718	funghiitaliani.it.js	Insecure Cache Handling	Low	false	CWE-920	0	N/A	N/A	{The cache.addAll function is used with a hardcoded list of assets (CACHED_ASSETS), which does not involve dynamic or untrusted input. Therefore, there is no sensitive function misuse in this case. The vulnerability is more related to cache management policy rather than function misuse.}	```cache.addAll(CACHED_ASSETS);```
3719	openxchange.eu.js	Cache Poisoning via Unvalidated Response Caching	High	true	CWE-835	9	caches.put	standard	{The caches.put function is used to store a response in the cache without validating its content or headers. The response is cloned and stored directly, even if it comes from an untrusted source or has been tampered with, allowing an attacker to poison the cache with malicious content that can be served to users.}	```const h = c.headers.get('latest-version') || c.headers.get('version'); return s && h && s !== h && (v({ type: 'NEW_VERSION', origin: 'fetchFile', status: c.status, version: h, url: t }), d({ response: c, url: t })), o.put(t, c.clone()), c;```
3720	openxchange.eu.js	XSS via Unsanitized Message Data	High	true	CWE-79	9	postMessage	standard	{The postMessage function is used to send raw message data to clients without sanitizing or validating it. If the message data contains malicious scripts or payloads, it can be executed in the context of the client, leading to cross-site scripting (XSS) attacks.}	```(await self.clients.matchAll()).forEach(t => t.postMessage(e));```
3721	openxchange.eu.js	Insecure Cache Invalidation	Medium	true	CWE-200	8	caches.delete	standard	{The caches.delete function is used to remove cache entries based on filenames provided in a message, which are not validated or sanitized. An attacker could supply arbitrary filenames to delete unintended cache entries, potentially leading to data loss or cache manipulation.}	```await Promise.all(e.map(async t => (await caches.open(a + b(t))).delete(t)));```
3722	openxchange.eu.js	Unvalidated Header Usage in Fetch	Medium	true	CWE-208	7	fetch	standard	{The fetch function is called with headers provided directly from external input without validation. This allows an attacker to inject malicious headers that could alter the behavior of the request, such as modifying authentication, caching, or redirect behavior.}	```return fetch(e, { headers: a }).catch(t => (i.log(`Caught error while fetching ${e.url || e}`, t), new Response('', { status: 503 })));```
3723	criticalnetworking.com.js	XSS via iframe srcdoc injection	High	true	CWE-79	N/A	N/A	standard	{The `btoa()` function is used to encode the response body into a base64 string for use in an iframe's `src` attribute, and `replace()` is used to inject this into `srcdoc`. Since the response body is directly taken from a network request without sanitization, an attacker can inject arbitrary HTML or JavaScript into the `srcdoc` attribute, leading to XSS. The `srcdoc` attribute is a known XSS vector when populated with untrusted data.}	"```const iframe = `<iframe style=""width:100%"" src=""${src}"" data-srcdoc=""${srcdoc}""></iframe>`;```"
3724	criticalnetworking.com.js	Insecure CDN module loading	Medium	true	CWE-444	N/A	N/A	standard	{The `importScripts()` function is used to load external JavaScript modules dynamically. The URL for these modules is constructed using `self.Pt.modulePathPrefix`, which is set via `workbox.setConfig()` and can be influenced by external configuration. If an attacker can manipulate this prefix, they can redirect the service worker to load malicious scripts from an arbitrary domain, leading to code injection and full compromise of the service worker.}	```importScripts(e), this.jt = !0;```
3725	criticalnetworking.com.js	Improper regex in denylist	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of improperly escaped or overly permissive regular expressions in the denylist, which may allow bypassing of intended restrictions. However, this is not caused by misuse of a sensitive function, but rather by flawed logic in regex construction.}	"```const denylist = [""^\\\/wp\\-admin($|\\?|\/)"", ""^[^\\?]*?\\.php($|\\?)"", ""\\?(.*?&)?wp_service_worker="", ""^[^\\?]*?\\\/wp\\.serviceworker(\\?|$)"", ""^[^\\?]*?\\\/feed\\\/(\\w+\\\/)?$"", ""\\?(.*?&)?wp_customize="", ""\\?(.*?&)?customize_changeset_uuid="", ""^\\\/wp\\-json\\\/""].map(pattern => new RegExp(pattern));```"
3726	criticalnetworking.com.js	Unvalidated fetch request	Medium	false	N/A	N/A	N/A	N/A	{The `fetch()` function is used to make network requests, but the request is not validated or sanitized. However, this is not a misuse of a sensitive function per se, as `fetch()` is used correctly in context. The vulnerability stems from the lack of input validation on the request itself, not from improper use of the function.}	```return fetch(event.request).then(response => {```
3727	criticalnetworking.com.js	Spoofable online status check	Low	false	N/A	N/A	N/A	N/A	{The `navigator.onLine` property is used to determine connectivity, but it is unreliable and can be spoofed by the browser or network. This is not a misuse of a sensitive function, but rather a limitation of the API itself.}	```const connectionMessage = navigator.onLine ? errorMessages.serverOffline : errorMessages.clientOffline;```
3728	citystrides.com.js	Empty Fetch Event Handler	High	false	CWE-379	N/A	N/A	N/A	{The empty fetch event handler does not involve any sensitive function misuse; it merely omits logic for handling fetch events, which is a design or functionality gap, not a security vulnerability stemming from unsafe function usage.}	```self.addEventListener('fetch', event => {});```
3729	citystrides.com.js	Empty Push Event Handler	Medium	false	CWE-379	N/A	N/A	N/A	{The empty push event handler does not involve any sensitive function misuse; it merely omits logic for handling push events, which is a design or functionality gap, not a security vulnerability stemming from unsafe function usage.}	```self.addEventListener('push', event => {});```
3730	citystrides.com.js	Empty Notification Click Handler	Medium	false	CWE-379	N/A	N/A	N/A	{The empty notification click event handler does not involve any sensitive function misuse; it merely omits logic for handling notification clicks, which is a design or functionality gap, not a security vulnerability stemming from unsafe function usage.}	```self.addEventListener('notificationclick', event => {});```
3731	citystrides.com.js	Empty Push Subscription Change Handler	Medium	false	CWE-379	N/A	N/A	N/A	{The empty push subscription change event handler does not involve any sensitive function misuse; it merely omits logic for handling subscription changes, which is a design or functionality gap, not a security vulnerability stemming from unsafe function usage.}	```self.addEventListener('pushsubscriptionchange', async event => {});```
3732	goldcenter.am.js	Supply Chain Vulnerability (External CDN)	High	true	CWE-960	10	importScripts	standard	{The importScripts function is used to load and execute external scripts in the service worker. In this case, it dynamically imports a script from options.workboxURL, which is hardcoded to a CDN URL (https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js). While the URL is not user-controlled, it is still a supply chain risk because the script is fetched from an external source. If the CDN is compromised or the package is tampered with, the service worker could execute malicious code. This constitutes a sensitive function misuse due to reliance on an external, unverified script source.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
3733	goldcenter.am.js	Insecure Caching (Predictable Revision)	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from using a predictable revision string 'f8zUMZmx71uu' in the preCaching configuration. This does not involve misuse of a sensitive JavaScript function, as no function is being improperly used with untrusted input. The issue is purely a configuration flaw that could allow attackers to guess or brute-force cache keys, but it is not caused by a sensitive function like importScripts or eval.}	```'preCaching': [{ 'revision': 'f8zUMZmx71uu', 'url': '/?standalone=true' }]```
3734	balletcoforum.com.js	Incorrect Authentication State Handling	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of the authentication state derived from the URL query parameter `loggedIn`. The code uses `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to extract the value, but this approach is insecure because it relies on the URL being trusted and unmodified. Since the URL can be manipulated by an attacker or altered by the browser (e.g., via redirects or referrer spoofing), the authentication state can be falsely set to 'true', allowing unauthorized access to protected resources. This is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in state validation.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3735	lestricolores.fr.js	Improper Input Validation in PreCaching	Medium	false	New	N/A	N/A	N/A	{The preCaching array contains a URL pattern '/?standalone=true' which is not validated or sanitized. While this does not directly involve a sensitive function, it may lead to unintended caching behavior if the URL pattern is derived from untrusted input. However, since the input is hardcoded and not dynamically constructed from user-controlled data, it does not constitute a sensitive function misuse.}	"```const options = {""workboxURL"": ""https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.3/workbox/workbox-sw.js"",""importScripts"": [],""config"": {""debug"": false},""clientsClaim"": true,""skipWaiting"": true,""cleanupOutdatedCaches"": true,""offlineAnalytics"": false,""preCaching"": [""/?standalone=true""],""runtimeCaching"": [{""urlPattern"": ""/_nuxt/"",""handler"": ""CacheFirst"",""method"": ""GET"",""strategyPlugins"": []}, {""urlPattern"": ""/"",""handler"": ""NetworkFirst"",""method"": ""GET"",""strategyPlugins"": []}],""offlinePage"": null,""pagesURLPattern"": ""/"",""offlineStrategy"": ""NetworkFirst""};importScripts(...[options.workboxURL, ...options.importScripts]);initWorkbox(workbox, options);workboxExtensions(workbox, options);precacheAssets(workbox, options);cachingExtensions(workbox, options);runtimeCaching(workbox, options);offlinePage(workbox, options);routingExtensions(workbox, options);function getProp(obj, prop) { return prop.split('.').reduce((p, c) => p[c], obj); }function initWorkbox(workbox, options) { if (options.config) { workbox.setConfig(options.config); } if (options.cacheNames) { workbox.core.setCacheNameDetails(options.cacheNames); } if (options.clientsClaim) { workbox.core.clientsClaim(); } if (options.skipWaiting) { workbox.core.skipWaiting(); } if (options.cleanupOutdatedCaches) { workbox.precaching.cleanupOutdatedCaches(); } if (options.offlineAnalytics) { workbox.googleAnalytics.initialize(); } }function precacheAssets(workbox, options) { if (options.preCaching.length) { workbox.precaching.precacheAndRoute(options.preCaching, options.cacheOptions); } }function runtimeCaching(workbox, options) { for (const entry of options.runtimeCaching) { const urlPattern = new RegExp(entry.urlPattern); const method = entry.method || 'GET'; const plugins = (entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config)); const strategyOptions = { ...entry.strategyOptions, plugins }; const strategy = new workbox.strategies[entry.handler](strategyOptions); workbox.routing.registerRoute(urlPattern, strategy, method); } }function offlinePage(workbox, options) { if (options.offlinePage) { workbox.routing.registerRoute(new RegExp(options.pagesURLPattern), ({ request, event }) => { const strategy = new workbox.strategies[options.offlineStrategy](); return strategy.handle({ request, event }).catch(() => caches.match(options.offlinePage)); }); } }function workboxExtensions(workbox, options) {}function cachingExtensions(workbox, options) {}function routingExtensions(workbox, options) {}```"
3736	lestricolores.fr.js	Dynamic Code Execution via getProp	High	true	CWE-96	N/A	getProp	standard	{The function getProp is used to dynamically resolve and invoke properties from the workbox object via string paths (e.g., p.use). When combined with user-controlled or untrusted input in strategyPlugins, this allows for arbitrary code execution by constructing a string path that references a malicious or unintended function. For example, if an attacker can control the 'use' field in strategyPlugins, they could trigger execution of any function in the workbox object, leading to full compromise of the service worker.}	```const plugins = (entry.strategyPlugins || []).map(p => new (getProp(workbox, p.use))(...p.config));```
3737	m25.nl.js	Improper Input Validation Leading to Cache Poisoning	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from using string-based indexOf() to validate URLs, which is susceptible to bypasses via URL encoding or malformed inputs. While indexOf() is not inherently sensitive, its misuse here allows attackers to craft URLs that evade filtering, leading to cache poisoning. The function is standard but misused in a context where more robust validation (e.g., URL parsing or regex with proper escaping) is required.}	```if (evt.request.url.indexOf('https://cdn.websumo.') !== -1) { return !1; }```
3738	m25.nl.js	Improper Input Validation Leading to Cache Poisoning	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from using string-based indexOf() to validate URLs, which is susceptible to bypasses via URL encoding or malformed inputs. While indexOf() is not inherently sensitive, its misuse here allows attackers to craft URLs that evade filtering, leading to cache poisoning. The function is standard but misused in a context where more robust validation (e.g., URL parsing or regex with proper escaping) is required.}	```if (evt.request.url.indexOf('https://www.websumo.') === -1) { return !1; }```
3739	m25.nl.js	Recursive Cache Size Limiting Leading to DoS	Medium	true	CWE-833	8	N/A	standard	{The vulnerability stems from the recursive use of cache.delete() and then() chaining without proper guardrails, which can lead to stack overflow or denial of service under high load. The caches API is standard, but its misuse in recursive calls without limits or safeguards makes it sensitive in this context.}	```cache.delete(keys[0]).then(limitCacheSize(name, size));```
3740	m25.nl.js	Regex-Based File Type Matching Bypass	Medium	true	CWE-20	7	N/A	standard	{The regex pattern used for file type matching is vulnerable to bypasses due to improper handling of URL encoding, query parameters, or path traversal. The match() function is standard, but its misuse with a weak regex allows attackers to inject malicious content into the cache by crafting URLs that match the pattern despite being non-static assets.}	```if (evt.request.url.match(/\.(ico|pdf|flv|jpg|jpeg|png|gif|js|css|swf|thumb|eot|otf|ttf|woff|woff2)/)) {```
3741	bangla.plus.js	Cache Poisoning	High	true	CWE-352	10	N/A	standard	{The vulnerability arises from the use of `n.request.url` in a context where it is used to construct a cache key via string manipulation (`replace` and concatenation). Although `replace` itself is not inherently sensitive, the misuse lies in the fact that the URL is derived from an untrusted source (the incoming fetch request) and is used to determine whether to use cache-first or network-first strategy. If an attacker can craft a request with a URL that maps to a path not in PRECACHE_URLS but still triggers cache-first behavior due to path manipulation (e.g., via URL encoding or path traversal), they could potentially poison the cache with malicious responses. The sensitive function here is `n.request.url` as it is a dynamic, untrusted input used to control cache behavior, and the `replace` function is misused to derive a path that may not be properly sanitized.}	"```var t = ""/"" + n.request.url.replace(/^(?:\/\/|[^\/]+)*\//, """");```"
3742	garitacenter.com.js	Cached Resources for Different Ports Without Path Validation	Medium	true	CWE-80	9	N/A	standard	{The code uses `new URL(e.request.url)` to parse the incoming request URL, which is then used to compare against the service worker's origin. However, the logic allows requests from different ports (e.g., `self.location.hostname && c.port !== self.location.port`) to be cached and served without validating the path or ensuring the resource is in the pre-defined set `t`. This can lead to unintended caching of external or malicious resources if the URL is manipulated, especially since the `c.host === self.location.host` check is insufficient to prevent path traversal or resource confusion. The misuse of `URL` constructor with untrusted input (request URL) without proper validation enables this vulnerability.}	```const c = new URL(e.request.url); c.protocol.startsWith('http') && (c.hostname === self.location.hostname && c.port !== self.location.port || (c.host === self.location.host && t.has(c.pathname)) ? e.respondWith(caches.match(e.request)) : 'only-if-cached' !== e.request.cache && e.respondWith(caches.open('offline1717037867161').then(async t => { try { const c = await fetch(e.request); return t.put(e.request, c.clone()), c; } catch (c) { const s = await t.match(e.request); if (s) return s; throw c; } })))```
3743	nerdfix.cz.js	Cache Poisoning via Unvalidated Request URLs	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the use of `fetch()` and `cache.put()` without validating or sanitizing the request URL. The `fetch()` function is called directly with `event.request`, which is derived from the incoming network request. Since the service worker does not validate whether the URL is within the allowed paths (e.g., '/dist/' or '/uploads/emojis/'), an attacker could potentially trigger a cache write for a malicious URL, leading to cache poisoning. The `cache.put()` function then stores the response for that URL, which could be exploited to serve malicious content later. This misuse of `fetch()` and `cache.put()` with untrusted input allows an attacker to manipulate the cache state.}	```self.addEventListener('fetch', event => { const url = new URL(event.request.url); if (event.request.method === 'GET' && (url.pathname.indexOf('/dist/') === 0 || url.pathname.indexOf('/uploads/emojis/') === 0)) { event.respondWith(async function () { const cache = await caches.open(assetsCacheKey); let response = await cache.match(event.request); if (response) { if (debug) console.log('ServiceWorker: Serving from cache', url.pathname); return response; } try { if (debug) console.log('ServiceWorker: Fetching', url.pathname); response = await fetch(event.request); await cache.put(event.request, response.clone()); return response; } catch (e) { if (debug) console.error('ServiceWorker: Fetch failed', e); if (response !== undefined) { return response; } } }()); } });```
3744	placementpreparation.io.js	Server Side Request Forgery (SSRF) via unvalidated message input	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the use of `new URL(t.base, e.origin)` where `t.base` is derived from a message event's data, which is untrusted input. The `URL` constructor is a standard JavaScript function that can be abused to construct arbitrary URLs when given unvalidated input. If an attacker can control the `t.base` value, they can craft a URL pointing to an internal or external resource, leading to SSRF. The function is used without validation or sanitization, allowing malicious URLs to be resolved and fetched, potentially exposing internal systems or bypassing network restrictions.}	```const o = new URL(t.base, e.origin);```
3745	sofolympiadtrainer.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data, including the API key, directly in the client-side JavaScript file. This is not caused by misuse of a sensitive JavaScript function, but rather by poor secret management practices. The code does not dynamically invoke any function with untrusted input that leads to the exposure.}	```var firebaseConfig = { apiKey: 'AIzaSyAk919HVHhY31k49WBdj3Al_VoSHSgTq18', authDomain: 'revisewise-in-api-project-601172742376.firebaseapp.com', databaseURL: 'https://revisewise-in-api-project-601172742376.firebaseio.com', projectId: 'revisewise.in:api-project-601172742376', storageBucket: 'undefined', messagingSenderId: '601172742376', appId: '1:601172742376:web:c1274ced647080f31c795d', measurementId: 'G-37EF317Q9Y' };```
3746	tawseel.app.js	Vulnerable Cache Key Handling	Medium	false	New	0	N/A	N/A	{The code does not involve misuse of a sensitive JavaScript function. The vulnerability arises from improper handling of cache keys by stripping query parameters (e.g., '?v=') before lookup, which may lead to cache mismatches or incorrect resource serving, but this is not due to a sensitive function like importScripts, eval, or similar.}	```if (key.indexOf('?v=') != -1) { key = key.split('?v=')[0]; }```
3747	lishogi.org.js	Open Redirect via Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function `self.clients.openWindow(a)` is used to open a new browser window or tab with the URL stored in variable `a`. This variable is derived from the `notification.data.userData` object, which is sourced from a push notification payload. Since the payload is controlled by an external source (e.g., a server or attacker), and the URL is constructed without validation or sanitization, an attacker can craft a malicious payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```return await self.clients.openWindow(a);```
3748	lottofy.com.js	XSS via Notification Content	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used to display notifications with user-controlled content (title and body) derived from event.data.json(). If an attacker can manipulate the data sent via push notifications, they can inject malicious content into the notification, which may be rendered in the browser UI, leading to XSS if the notification content is not properly sanitized.}	```self.registration.showNotification(title, { body: message.body, icon: icon, tag: tag });```
3749	lottofy.com.js	Open Redirect via Notification Tag	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is called with a URL derived from event.notification.tag, which is user-controlled. If an attacker can manipulate the notification tag to point to an external or malicious URL, this can result in an open redirect, potentially tricking users into visiting phishing or malicious sites.}	```clients.openWindow(url);```
3750	versiculos.com.br.js	Improper Input Validation in Fetch Handler	Medium	false	N/A	0	N/A	N/A	{The vulnerability described is related to improper input validation in the fetch handler, but it does not stem from the misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The code correctly uses caches.match and fetch without dynamic or untrusted input influencing the request handling. The issue is more about potential fallback behavior or lack of validation on request types, not sensitive function misuse.}	"```self.addEventListener(""fetch"", event => { event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match('offline'); })); });```"
3751	xmaduras.com.js	External Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL like 'https://js.wpnjs.com/worker.php', it introduces a high-risk vulnerability because the script is fetched and executed from an untrusted third-party domain. This allows an attacker to control the content of the script, leading to arbitrary code execution within the service worker context, which can compromise the entire web application's security, including intercepting network requests, manipulating cache, or stealing sensitive data.}	"```importScripts(""https://js.wpnjs.com/worker.php"");```"
3752	zetasoftware.com.js	Improper Handling of Offline Page Response	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the improper handling of the offline response for image resources, where an SVG is returned with a hardcoded content type and no-store cache control. However, this is not due to misuse of a sensitive JavaScript function like importScripts, eval, or dynamic code execution. The issue is more about content delivery and caching policy rather than function misuse.}	```return isImage(n) ? new Response(`<svg role=\'img\' viewBox=\'0 0 400 300\' xmlns=\'http://www.w3.org/2000/svg\'>\n\t<title>offline</title>\n\t<path d=\'M0 0h400v300H0z\' fill=\'#eee\' />\n\t<text x=\'200\'\n y=\'150\'\n text-anchor=\'middle\'\n dominant-baseline=\'middle\'\n font-family=\'sans-serif\'\n font-size=\'50\'\n fill=\'#ccc\'>offline</text>\n </svg>`, {\n headers: {\n \'Content-Type\': \'image/svg+xml\',\n \'Cache-Control\': \'no-store\'\n }\n }) : caches.match(normalizeUrl(offlineURL));```
3753	thetriangle.org.js	Insecure Cache Name Using HTTP	High	true	CWE-20	10	N/A	standard	{The cache name is hardcoded with an HTTP URL, which is insecure because HTTP is not encrypted and can be intercepted or modified. While not directly a sensitive function misuse, the use of `caches.open()` with a hardcoded HTTP-based cache name enables insecure caching behavior, and since `caches.open()` is a standard API that accepts any string as a cache name, it becomes a point of vulnerability when misused with insecure inputs.}	```const cacheName = 'http://www.thetriangle.org-superpwa-2.2.31';```
3754	thetriangle.org.js	Improper Validation of Range Header	Medium	true	CWE-20	9	N/A	standard	{The `Number` function is used to parse a range header extracted via regex, but the regex does not validate the entire header format or prevent malicious inputs. The `event.request.headers.get('range')` is a dynamic input, and improper parsing can lead to out-of-bounds memory access or unexpected behavior when used with `ab.slice(pos)`. This misuse of `Number` with untrusted input from `headers.get()` constitutes a sensitive function misuse.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
3755	thetriangle.org.js	Insecure Cache Matching Using URL String	Medium	true	CWE-20	8	N/A	standard	{The `cache.match(event.request.url)` uses a URL string directly from the request, which may be manipulated or crafted by an attacker. Since `cache.match()` is a standard API that accepts any string, using it with untrusted or unsanitized input (like `event.request.url`) can lead to unintended cache lookups or bypasses, especially if the URL is dynamically constructed or controlled by an attacker.}	```return cache.match(event.request.url);```
3756	calciomercatoweb.it.js	Improper Input Validation Leading to SSRF	High	true	CWE-20	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes user-controlled input from body.data.sensor and body.data.push_send_id. Since these values are not validated or sanitized, an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to Server-Side Request Forgery (SSRF).}	```const ve = sensor_url + '/e?site_name=www.calciomercatoweb.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' });```
3757	matkaguessing.in.js	Outdated Firebase SDK	High	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase SDK (6.3.5), which is known to have security issues. However, this is not caused by misuse of a sensitive JavaScript function, but rather by using an old library version.}	```importScripts('https://www.gstatic.com/firebasejs/6.3.5/firebase-app.js');```
3758	matkaguessing.in.js	Exposure of Sensitive Information in Client-Side Code	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from hardcoding the Firebase API key in client-side JavaScript, which is exposed to users. This is not due to misuse of a sensitive function, but rather poor configuration and exposure of secrets in client-side code.}	"```var firebaseConfig = { apiKey: ""AIzaSyBEM45NWw82ao3SWop5Y-50LrABywB8OMg"", authDomain: ""sattamatka-49beb.firebaseapp.com"", projectId: ""sattamatka-49beb"", storageBucket: ""sattamatka-49beb.appspot.com"", messagingSenderId: ""903541177419"", appId: ""1:903541177419:web:ad7d18aa05ae7108b2a1ce"" };```"
3759	felixlobrecht.de.js	Improper_Cache_Control_Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper configuration of cache strategies, not from misuse of a sensitive JavaScript function. The code uses workbox-precaching and workbox-recipes to precache resources and configure caching strategies, but there is no direct use of a sensitive function like importScripts() or eval() that would introduce a security risk through dynamic input. The issue is more about misconfiguration (e.g., caching dynamic content without proper revision control) rather than function misuse.}	```(0, r.precacheAndRoute)([{ url: \'/\', revision: String(Date.now()) }, { url: \'/manifest.webmanifest\', revision: String(Date.now()) }], (0, e.googleFontsCache)(), (0, e.staticResourceCache)(), (0, e.imageCache)(), (0, e.offlineFallback)());```
3760	houten.nl.js	Information Exposure via Caching Sensitive Backend Responses	High	true	CWE-200	9	caches.put	standard	{The vulnerability arises from the misuse of the `caches.put` function, which is called via the `addToCache` helper function. This function stores responses in the cache without validating whether the response contains sensitive data. Since `shouldCache` only checks for GET requests and path patterns (e.g., /typo3/), it may allow caching of sensitive backend responses (e.g., those containing user data or session tokens) if they match the path pattern. The `caches.put` function blindly stores the response, leading to information exposure if the cached content is later served to unauthorized users.}	```if (shouldCache(request)) { addToCache(assetsCacheName, request, response.clone()); }```
3761	annaabi.ee.js	Improper Error Handling in Service Worker Cache Fallback	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper error handling during cache fallback, but it is not caused by misuse of a sensitive function. The code correctly handles fetch errors by falling back to the cache, but the issue lies in the lack of robust error handling for edge cases (e.g., cache not available, network errors not properly logged or handled). No sensitive function is misused here.}	"```self.addEventListener(""fetch"", function (event) { if (event.request.method !== ""GET"") return; event.respondWith(fetch(event.request).then(function (response) { event.waitUntil(updateCache(event.request, response.clone())); return response; }).catch(function (error) { return fromCache(event.request); })); });```"
3762	fahrstundenplaner.de.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The fetch event handler is empty, meaning it does not perform any logic to intercept or modify network requests. While this may be intentional, it does not constitute misuse of a sensitive function. There is no dynamic or untrusted input being passed to any sensitive function like importScripts, eval, or similar.}	```this.addEventListener('fetch', function (event) {});```
3763	photobook.com.my.js	Exposure of Sensitive Information in Configuration	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API keys, user keys, site IDs) directly in the JavaScript file, which can be accessed by anyone inspecting the source code. This is not caused by misuse of a sensitive function, but rather by poor configuration management.}	```var config = { apiKey: 'AIzaSyAkbg-bhPpYttNNey87CrincA_KJGrqdvk', messagingSenderId: '208412245530', appId: '1:208412245530:web:9f10d28ba23e735a5d9ba3', projectId: 'firebase-photobook-worldwide', user_key: 'ADGMOT35CHFLVDHBJNIG50K968QDR3JHO5GNVMDE3KKEMMOP7IKG', siteid: 'fc93a01b2c4dc12bf269ba83480ce466' };```
3764	photobook.com.my.js	Loading Untrusted Third-Party Script	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted third-party domain (//cdnt.netcoresmartech.com), it introduces a risk of loading malicious or compromised code, potentially leading to script injection, data exfiltration, or service worker compromise. Although the URL is hardcoded, the function itself is sensitive because it executes arbitrary scripts without validation or integrity checks.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
3765	ddlgforum.com.js	Vulnerable Path Handling in CSRF Token Request	Medium	true	CWE-20	9	fetch	standard	{The function `fetch` is used with a dynamically constructed URL where the `path` parameter is derived from the request's URL pathname. If an attacker can manipulate the request URL (e.g., via a crafted link or redirect), they could inject arbitrary paths into the `fetch` call, potentially leading to unintended requests to internal or sensitive endpoints. This constitutes improper input validation and could be exploited to bypass security controls or access unauthorized resources.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {```
3766	neuqueninforma.gob.ar.js	Open Redirect via Untrusted URL Handling	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL that is derived from untrusted input (event.notification.data.FCM_MSG.data.link). Since the URL is constructed from user-controlled data without validation or sanitization, an attacker could craft a notification payload that redirects the user to a malicious site, leading to an open redirect vulnerability.}	N/A
3767	neuqueninforma.gob.ar.js	Exposure of Sensitive Information (Firebase Config)	High	false	CWE-532	N/A	N/A	N/A	{The Firebase configuration object contains sensitive credentials such as apiKey, authDomain, and messagingSenderId. However, this is not caused by misuse of a sensitive JavaScript function, but rather by hard-coding sensitive data in the script. Therefore, it is not classified as a sensitive function misuse.}	N/A
3768	kishanyojana.com.js	Exposed API Key	High	false	N/A	N/A	N/A	N/A	{The API key is hardcoded in the script and exposed in the source code, but it is not the result of misuse of a sensitive function. It is a static configuration issue.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyC1l4tRUuG38qPJgmhuKIKnL-wk8ZY5Gpk' } };```
3769	kishanyojana.com.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic targetUrl derived from event.notification.data.url, which is user-controlled. This allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerability.}	```clients.openWindow(targetUrl);```
3770	kishanyojana.com.js	XSS	Medium	true	N/A	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with payload.title and other payload data, which are derived from event.data.json().data.notification. If this data is not sanitized, it can lead to XSS when rendered in notifications.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
3771	kishanyojana.com.js	Information Exposure	Medium	true	N/A	N/A	fetch	standard	{The function fetch is used to send sensitive data (token, endpoint, auth, p256dh) to options.api_url, which is hardcoded but could be manipulated if the URL is derived from untrusted input. The data is sent without encryption or proper validation, leading to information exposure.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
3772	pridespins.com.gh.js	Improper Input Validation in Message Handler	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper validation of incoming message data. The code checks for a specific message type ('SKIP_WAITING') but does not validate or sanitize the source or structure of the message, which could allow unintended behavior if malicious messages are sent. However, no sensitive function like importScripts, eval, or similar is being misused here.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
3773	oldschool.co.nz.js	Server Side Request Forgery (SSRF) via unvalidated 'id' parameter in push event	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from untrusted push notification data. Since the 'id' value is not validated or sanitized, an attacker can supply arbitrary URLs, leading to SSRF by making the service worker fetch internal or external resources on behalf of the victim.}	N/A
3774	oldschool.co.nz.js	Open Redirect via unvalidated 'data.url' in notification click handler	Medium	true	CWE-601	9	navigate	standard	{The navigate method is called with 'data.url' from untrusted notification data without validation. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or credential theft.}	N/A
3775	oldschool.co.nz.js	Insecure Cache Busting via client-side 'loggedIn' URL parameter check	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from logic relying on a client-side URL parameter ('loggedIn') for access control, not from misuse of a sensitive JavaScript function.}	N/A
3776	oldschool.co.nz.js	Insecure Offline Cache Handling via unvalidated cached asset URLs	Medium	false	CWE-434	0	N/A	N/A	{The vulnerability stems from hard-coded cache handling logic and lack of validation on cached assets, not from misuse of a sensitive JavaScript function.}	N/A
3777	oldschool.co.nz.js	XSS via unsanitized notification data fields	Medium	true	CWE-79	8	registration.showNotification	standard	{The registration.showNotification function is used with notification data fields (title, body, etc.) that are directly derived from untrusted server responses without sanitization. This allows an attacker to inject malicious content that may be rendered in the notification UI, potentially leading to XSS if the notification UI interprets content as HTML or JavaScript.}	N/A
3778	forospyware.com.js	Server-Side Request Forgery (SSRF) via Unvalidated URL in Notification Data	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL (`${n}/chat/${t}.json`) where `n` and `t` are derived from untrusted notification data. Since these values are not validated or sanitized, an attacker can manipulate them to redirect the fetch request to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(`${n}/chat/${t}.json`, { credentials: 'include', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-CSRF-Token': i }, body: `message=${e.reply}`, method: 'POST', mode: 'cors' });```
3779	forospyware.com.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL constructed from untrusted notification data (`n + t`). Since `n` and `t` are not validated, an attacker can supply malicious URLs, causing the browser to open arbitrary external sites, leading to open redirect vulnerabilities.}	```clients.openWindow(n + t);```
3780	bitvalve.com.js	Incorrect Cache Access Leading to Potential DoS	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache access during fetch events, particularly when the request URL includes 'api'. While the code attempts to fall back to cached responses on network failure, it does not validate or sanitize the request URL or method before accessing the cache. This could allow an attacker to trigger excessive cache lookups or abuse the fallback logic, potentially leading to a Denial of Service (DoS) if the cache is misused or overwhelmed. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by flawed logic in cache fallback handling.}	"```self.addEventListener(""fetch"", async event => { if (event.request.method !== ""GET"") { return; } if (event.request.url.includes(""api"")) { const clonedRequest = event.request.clone(); event.respondWith(fetch(clonedRequest).catch(async () => { if (clonedRequest.method === ""GET"") { return await caches.match(clonedRequest.url, { cacheName: ""api-cache"" }); } throw new Error(""Request failed and not a GET request.""); })); } });```"
3781	eotwdb.co.uk.js	Insecure Cache Handling for Styles and Images	High	true	CWE-799	9	N/A	standard	{The code uses `caches.open()` and `cache.put()` with dynamically derived cache names (e.g., CURRENT_CACHES['styles']) and request URLs that are not fully validated. While the cache names are static and controlled, the `fetch()` calls are made on unvalidated `event.request` objects, which could be manipulated via user-controlled URLs. This allows an attacker to potentially cache malicious content under controlled cache keys, leading to cache poisoning or unintended resource loading. The vulnerability is exacerbated by the lack of input validation on the request URL and headers, especially in the 'no-cors' mode, which may allow bypassing security checks.}	```if (event.request.mode === 'no-cors' && event.request.headers.get('accept').includes('text/css')) { event.respondWith(fetch(event.request).then(response => { let responseClone = response.clone(); caches.open(CURRENT_CACHES['styles']).then(cache => { cache.put(event.request, responseClone); }); return response; }).catch(error => { console.log('Fetch failed; checking for cached style instead.', error); return caches.match(event.request); })); } if ((event.request.mode === 'no-cors' || event.request.mode === 'same-origin') && event.request.headers.get('accept').includes('image/*')) { event.respondWith(caches.open(CURRENT_CACHES['images']).then(function (cache) { return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { cache.put(event.request, response.clone()); return response; }); }); })); }```
3782	psxextreme.info.js	Server Side Request Forgery (SSRF)	High	true	CWE-549	9	N/A	standard	{The vulnerability arises from the use of `fetch()` with a dynamically constructed URL derived from `curRequest.url`, which is based on the original request made by the client. Although the URL is derived from the current request, if the service worker is misconfigured or if the client is tricked into making a request to a malicious URL (e.g., via a crafted link or redirect), the service worker could forward that request to the server, potentially leading to SSRF. The `fetch()` function is a standard JavaScript API that can be abused when used with untrusted or unsanitized input, especially in service workers where the context is less constrained.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
3783	777br69.cc.js	Incorrect Service Worker State Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of the service worker's state change event, but it does not involve the misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The code simply posts a message to the controlling service worker, which is a safe and intended use of the postMessage API.}	```self.addEventListener('statechange', () => { if (navigator.serviceWorker.controller) { navigator.serviceWorker.controller.postMessage({ type: 'SERVICE_WORKER_READY' }); } });```
3784	mapatisserie.net.js	Exposure of Sensitive Information	High	true	CWE-200	10	none	N/A	{The sensitive information (API keys, project IDs, VAPID keys) is hardcoded in the script and exposed in the source code. While not directly caused by a sensitive function misuse, the exposure is due to improper handling of secrets in client-side code, which is a critical security flaw.}	```const options = { firebaseConfig: { projectId: 'larapush-ae7e8', messagingSenderId: '897315505675', appId: '1:897315505675:web:9e3e2009662677dd2d290e', apiKey: 'AIzaSyBqKM6B_xnRP-pGEnUacrjJbn-p_3zejyE' }, domain: 'www.mapatisserie.net', api_url: 'https://push.mapatisserie.net/api/token', vapid_public_key: 'BM8zHC9o8em1p9vCfljyfou7ueSYApYjr4ox90_sIjITsl3nzK9zmSWghupdPwdjUOLJf3OhIfycjACHdaSByIo' };```
3785	mapatisserie.net.js	Unvalidated URL Redirection	High	true	CWE-601	9	clients.openWindow	N/A	{The code retrieves `targetUrl` and `apiUrl` from notification data, which is user-controlled and unvalidated. These values are then passed directly to `clients.openWindow(targetUrl)` and `fetch(apiUrl)`, allowing an attacker to redirect users to arbitrary URLs or make unintended network requests, leading to open redirect or SSRF vulnerabilities.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close();```
3786	weer1.com.js	Insecure Cache Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability is related to insecure cache handling, but it does not stem from the misuse of a sensitive JavaScript function such as importScripts, eval, or similar. Instead, it arises from configuration choices in the caching strategy (e.g., caching images and fonts without proper validation or size limits), which may lead to resource bloat or denial-of-service via cache exhaustion. No sensitive function is being misused here.}	```registerRoute(({\n request\n}) => request.destination === 'image' || request.destination === 'font', new CacheFirst({\n cacheName: 'images',\n plugins: [new CacheableResponsePlugin({\n statuses: [200]\n }), new ExpirationPlugin({\n maxEntries: 500,\n maxAgeSeconds: 60 * 60 * 24 * 30\n })] });```
3787	canucksfanforum.com.js	Improper Authentication	High	true	N/A	9	N/A	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter, which is then used to conditionally skip processing. This is not inherently a sensitive function misuse, but the logic relies on untrusted input (URL query parameters) without proper validation or sanitization, leading to improper authentication. However, since `match()` is a standard string method and not a sensitive function per se, this is not a direct sensitive function misuse. But the context of using untrusted input to control authentication flow makes it a high-risk issue.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3788	canucksfanforum.com.js	Open Redirect	Medium	true	N/A	8	N/A	standard	{The `navigate()` method is used with `data.url`, which is derived from a push notification payload. Since this data is not validated or sanitized, an attacker could craft a malicious notification with a `data.url` pointing to an external site, leading to an open redirect. The `navigate()` function is a standard browser API that can be abused when given untrusted input, making this a sensitive function misuse.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
3789	digitalbook.io.js	Improper Input Validation	Medium	true	CWE-20	9	URL	standard	{The function `new URL(e, location.href)` is used to parse a URL from user-controlled input `e`. If `e` is not validated, it could be crafted to manipulate the URL's origin, path, or query parameters, potentially leading to unintended behavior such as redirecting to malicious domains or accessing unauthorized resources. This misuse of `URL` constructor with untrusted input constitutes improper input validation.}	"```const A = e => { const t = new URL(e, location.href); return t.hash = """", t.href; }```"
3790	digitalbook.io.js	Insecure Caching	Medium	false	CWE-311	0	N/A	N/A	{The caching behavior is driven by `fetchAndCachePut`, but this is not a sensitive function misuse. The vulnerability arises from caching policy decisions, not from improper use of a sensitive function.}	```await s.fetchAndCachePut(e).catch(() => {});```
3791	digitalbook.io.js	Insufficient Logging	Low	false	CWE-770	0	N/A	N/A	{The error is thrown using a custom error class, but no sensitive function is misused. The issue is related to lack of logging, not improper use of a sensitive function.}	```throw new t('no-response'```
3792	digitalbook.io.js	Improper Error Handling	Low	false	CWE-754	0	N/A	N/A	{The error handling is implemented using standard try-catch, but no sensitive function is misused. The issue is in error propagation, not in misuse of a sensitive function.}	```catch (e) { if (e instanceof Error) throw new t('plugin-error-request-will-fetch'```
3793	programia.eu.js	Insecure Third-Party Dependency	Medium	true	CWE-444	9	N/A	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, it loads a script from a third-party CDN (https://cdn.ampproject.org/sw/amp-sw.js). While the URL is hardcoded and not dynamically constructed from untrusted input, the dependency on an external script introduces risk if the CDN is compromised or if the script is not properly vetted. This constitutes a potential supply chain vulnerability, hence classified as sensitive misuse due to reliance on untrusted external code.}	"```importScripts(""https://cdn.ampproject.org/sw/amp-sw.js"");```"
3794	programia.eu.js	Cached Assets Tampering	High	false	New	N/A	N/A	N/A	{The vulnerability arises from the configuration of caching strategy (CACHE_FIRST) for assets matching a specific regex pattern. This is not caused by misuse of a sensitive function, but rather by a misconfiguration in the caching policy. The AMP_SW.init() function is a custom API provided by the AMP service worker library, and while it controls caching behavior, the issue stems from policy choice, not insecure function usage.}	"```AMP_SW.init({ assetCachingOptions: [{ regexp: /\.(png|jpg|woff2|woff|css|js)/, cachingStrategy: ""CACHE_FIRST"" }], offlinePageOptions: { url: ""/offline.html"", assets: [] }, linkPrefetchOptions: {} });```"
3795	instadownloader.co.js	Code Injection via Untrusted Remote Script Execution	High	true	N/A	10	importScripts	standard	{The importScripts() function is used with a dynamically derived URL from location.search, which is decoded via atob(). This allows an attacker to control the script source by manipulating the URL query string, leading to arbitrary script execution in the service worker context.}	N/A
3796	instadownloader.co.js	Code Injection via Remote Code Execution via eval	High	true	N/A	10	eval	standard	{The eval() function is called with a remote script payload retrieved from an IndexedDB store, which may have been populated via a remote request. Since the payload is not sanitized or validated, it enables arbitrary code execution within the service worker, leading to full compromise.}	N/A
3797	instadownloader.co.js	Insecure BroadcastChannel Usage	Medium	false	N/A	N/A	N/A	N/A	{The BroadcastChannel is used with a hardcoded name, but there is no evidence of misuse involving untrusted input or insecure data sharing. The vulnerability is more related to potential information leakage or cross-origin communication risks, not sensitive function misuse.}	N/A
3798	love2dev.com.js	XSS via Unsanitized Template Rendering	High	true	CWE-79	N/A	Mustache.render	standard	{The Mustache.render function is used to render a template with user-supplied data without sanitization. If the data contains malicious HTML or JavaScript, it can be injected into the rendered page, leading to XSS. The data comes from an API call that is not validated or escaped, making this a direct misuse of a templating function with untrusted input.}	```return Mustache.render(pageTemplate, data);```
3799	love2dev.com.js	Open Redirect via Notification Action	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is called with user-controlled input from event.action, which is not validated or sanitized. If an attacker can trigger a push notification with a malicious URL, this can lead to an open redirect, potentially phishing or redirecting users to malicious sites.}	```clients.openWindow(event.action);```
3800	love2dev.com.js	Cache Poisoning via cache.add	High	true	CWE-918	N/A	cache.add	standard	{The cache.add function is called with a request object that is derived from a cached response, but the request URL is not validated. If an attacker can manipulate the cache to include a malicious URL, the cache.add call can poison the cache with unintended or harmful content, leading to cache poisoning.}	```cache.add(request);```
3801	love2dev.com.js	Regex Denial of Service (ReDoS) Potential	Medium	false	N/A	N/A	N/A	N/A	{The regex /img\/|imgs\// is used in a test, but it is not dynamic or user-controlled. The pattern is static and does not involve sensitive function misuse. The potential ReDoS is due to the regex structure itself, not misuse of a sensitive function.}	```if (/img\/|imgs\//.test(url)) {```
3802	love2dev.com.js	Insecure Pre-Caching of External Resources	Medium	false	N/A	N/A	N/A	N/A	{The pre-caching is done via fetch on a hardcoded list of URLs. The URLs are not user-controlled, and the fetch function is used correctly. The vulnerability stems from the lack of security controls around the pre-caching process, not from misuse of a sensitive function.}	```cacheList.forEach(url => { fetch(url).then(function (response) {```
3803	nic.woodside.js	Improper Cache Key Handling	Medium	true	New	8	URL	standard	{The code uses `new URL(e, location.href)` to construct cache keys from potentially untrusted or dynamic input (e.g., `e` from request URLs). If `e` is derived from user-controlled or external sources without sanitization, an attacker could manipulate the URL to generate arbitrary cache keys, leading to cache poisoning or bypassing intended cache logic. This misuse of `URL` constructor with dynamic input introduces a risk of improper cache key handling, allowing unintended cache behavior or data leakage.}	```const a = new URL(e, location.href);```
3804	shipoom.com.js	Regular Expression Denial of Service (ReDoS)	Medium	false	CWE-133	0	N/A	N/A	{The vulnerability arises from the use of a regular expression with a potentially exponential backtracking pattern (e.g., `(?:/.*)?`), which can lead to ReDoS when matched against maliciously crafted input. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by the inherent complexity of the regex pattern itself.}	"```const c = JSON.parse('[""shipoom\\\\.com(?:/.*)?/ola/services/.*"",""shipoom\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://7f40d256-4d76-46e2-8f74-b007b8bb0a70\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
3805	90phut22.xyz.js	Improper Cache Control for Sensitive Data	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the logic that caches responses without properly validating whether the response contains sensitive data. The code checks for status 200 and 'basic' type, but this is insufficient to prevent caching of sensitive data such as authentication tokens or personal information. The issue is not due to misuse of a sensitive function, but rather a flawed caching policy.}	```if (!response || response.status !== 200 || response.type !== 'basic') { return response; }```
3806	agistix.com.js	Improper Validation of Cache URLs	High	true	CWE-20	9	N/A	standard	{The function `B` constructs a URL by splitting the input URL's path and replacing the last segment with an empty string, then creates a new URL object from it. This is used to prefetch resources, but if the input URL is untrusted (e.g., from a user-controlled path), it could lead to cache poisoning or unintended resource fetching. The function does not validate or sanitize the input URL, allowing an attacker to manipulate the base URL to access or cache unintended resources. This misuse of `new URL()` with untrusted input is a classic case of improper validation, leading to potential cache manipulation and security bypasses.}	"```const B = (e, n, s, i) => { try { const c = i.href.split(""/""), h = c[c.length - 1]; c[c.length - 1] = """"; const t = new URL(c.join(""/"")); y(e, n, s, t, [h], !0); } catch (c) { console.error(c); } };```"
3807	syscom.be.js	Information Disclosure via Debug Endpoint	Low	false	N/A	N/A	N/A	N/A	{The debug endpoint exposes internal service worker state, version details, and idle task queue information, but this is not due to misuse of a sensitive function. It is a design choice to expose debug data for development purposes.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}````
3808	syscom.be.js	Potential Cache Poisoning in Non-Hashed Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from allowing non-hashed resources to be cached without integrity checks, but this is not due to misuse of a sensitive function. It is a logic flaw in the caching strategy.}	```return version.lookupResourceWithoutHash(url);```
3809	syscom.be.js	Improper Error Handling Leading to Information Leakage	Low	false	N/A	N/A	N/A	N/A	{The error logging mechanism leaks detailed error information to the debug log, but this is not caused by misuse of a sensitive function. It is a logging design choice.}	```this.debugger.log(err```
3810	zigota.co.il.js	Phishing via Unsanitized Notification Data	Medium	true	CWE-20	8	N/A	standard	{The vulnerability arises from using unsanitized data from the push event (e.g., title, body) directly in the Notification API's options object. While the Notification API itself is not inherently dangerous, the unsanitized input can be manipulated by an attacker to display deceptive or malicious content, leading to phishing attacks. The sensitive function here is `self.registration.showNotification()`, which is a standard browser API that renders notifications based on provided data. Since the data is derived from untrusted push messages, an attacker can craft a push payload with misleading or harmful content, tricking users into interacting with malicious links or providing sensitive information.}	```self.registration.showNotification(data.title, options)```
3811	tookapic.com.js	Improper URL Validation Leading to Cache Poisoning	High	true	CWE-20	9	search	standard	{The use of String.prototype.search() to check for 'tookapic.com' in request.url is vulnerable because it performs a substring match rather than a proper domain validation. This allows attackers to craft URLs like 'http://evil.tookapic.com' or 'http://tookapic.com.attacker.com' that pass the check, enabling cache poisoning by injecting malicious responses into the cache for these URLs. The function is misused by treating it as a domain validator when it only checks for substring presence, not proper domain matching.}	```if (request.url.search('tookapic.com') === -1) {```
3812	etakenya.go.ke.js	Hardcoded API Key in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the exposure of a hardcoded API key in client-side code. This key can be extracted by attackers to gain unauthorized access to Firebase services.}	```importScripts('https://www.gstatic.com/firebasejs/9.3.0/firebase-app-compat.js');importScripts('https://www.gstatic.com/firebasejs/9.3.0/firebase-messaging-compat.js');firebase.initializeApp({apiKey: 'AIzaSyDDKJWPO4ltjEVNQ93RL7u9FrRt-yVvKeo',authDomain: 'travizory-vmp-ken.firebaseapp.com',databaseURL: 'https://travizory-vmp-ken-app.europe-west1.firebasedatabase.app',projectId: 'travizory-vmp-ken',storageBucket: 'travizory-vmp-ken.appspot.com',messagingSenderId: '294946687689',appId: '1:294946687689:web:ab1e05e6f87f304bdb5b18',measurementId: 'G-5H0L6MBXCN',vapidKey: 'BHkayEisLpExw8JYuRzo4zYL-ZsJD_j6c-XHJp_QE0nd-95UssTvtbs5lZ3ZuieIp9d4TBNfVekDrZjv9-eSgZw'});const message = firebase.messaging();message.onBackgroundMessage(payload => {});```
3813	neofood.club.js	Message Handling for SKIP_WAITING Without Origin Check	Low	false	New	0	N/A	N/A	{The vulnerability arises from handling a message event without validating the origin of the message. While the `self.addEventListener('message'` is used, it is not inherently a sensitive function misuse because the `SKIP_WAITING` message is a standard, safe operation intended for service worker control. The lack of origin check is a logic flaw, not a misuse of a sensitive function.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
3814	sendungsverfolgung24.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, if the URL were dynamically constructed from untrusted input (e.g., user-controlled query parameters), it could lead to Remote Code Execution. In this case, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse. Therefore, the initial detection is misleading — the code is not sensibly vulnerable.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/637660587201ac0013d180c4"");```"
3815	4dosugs.com.js	Caching unvalidated index page during install	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching the index page without validating its content or origin, but it is not caused by misuse of a sensitive function like importScripts or eval. The fetch and cache.put operations are used correctly in this context, and no dynamic or untrusted input is passed to sensitive functions.}	```self.addEventListener('install', function (event) { var indexPage = new Request('/'); event.waitUntil(fetch(indexPage).then(function (response) { return caches.open('pwabuilder-offline').then(function (cache) { console.log('[PWA Builder] Cached index page during Install' + response.url); return cache.put(indexPage, response); }); })); });```
3816	4dosugs.com.js	Caching all fetched requests without validation	Medium	false	New	N/A	N/A	N/A	{The issue is that all fetched requests are cached without validation, but this is not due to misuse of a sensitive function. The fetch and cache.put operations are standard and safe when used with trusted or validated inputs. The vulnerability stems from a lack of policy enforcement, not from unsafe function usage.}	```return fetch(request).then(function (response) { console.log('[PWA Builder] add page to offline' + response.url); return cache.put(request, response); });```
3817	4dosugs.com.js	Caching sensitive data in HTTP requests	Medium	false	CWE-312	N/A	N/A	N/A	{This vulnerability relates to the potential exposure of sensitive data in HTTP requests, but it is not caused by misuse of a sensitive JavaScript function. The fetch and cache.put operations are used appropriately; the issue lies in the application’s data handling policy, not in unsafe function invocation.}	```return fetch(request).then(function (response) { console.log('[PWA Builder] add page to offline' + response.url); return cache.put(request, response); });```
3818	abensberg.de.js	Incorrect Regular Expression Leading to Caching of Admin Pages	High	false	New	N/A	N/A	N/A	{The vulnerability arises from a flawed regular expression that fails to properly exclude admin paths, allowing potentially sensitive admin pages to be cached. This is not caused by misuse of a sensitive function, but rather by a logic error in the regex pattern.}	```workbox.routing.registerRoute(/^(?!.*(\/admin\/)).*\/[^\.]*(\.html?|\.php)?$/, new workbox.strategies.NetworkFirst({cacheName: `${NAME}__html`, plugins: [new workbox.expiration.Plugin({maxEntries: 128, maxAgeSeconds: 60 * 60}), new workbox.cacheableResponse.Plugin({statuses: [0, 200]})]});```
3819	abensberg.de.js	Debug Mode Enabled in Production	Medium	false	CWE-546	N/A	N/A	N/A	{Enabling debug mode in production exposes internal details and logs, which can aid attackers in understanding the application’s behavior. This is a configuration issue, not a result of sensitive function misuse.}	```workbox.setConfig({debug: true});```
3820	abensberg.de.js	Dynamically Appended Query Parameters in Script Import	High	true	New	N/A	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL that appends self.location.search, which is user-controlled. This allows an attacker to inject arbitrary query parameters into the script URL, potentially leading to remote code execution if the external script source is compromised or manipulated.}	```importScripts('https://static.cleverpush.com/channel/worker/qTsXuhRCjft3796nD.js' + self.location.search);```
3821	couponduos.com.js	Cache Poisoning via Custom Event	High	true	CWE-918	10	caches.put	standard	{The `caches.put()` function is used to store a response in the cache, but it is being called with `e` (the event object) as the response, which is not a valid Response object. This misuse can lead to cache poisoning, where an attacker can inject arbitrary data into the cache by triggering the `refreshHomePage` event with malicious data, potentially serving tampered content to users.}	```self.addEventListener('refreshHomePage', function (e) { return caches.open('cache-homePage').then(function (n) { return n.put(offlinePage, e); }); });```
3822	optotax.com.js	Insecure Message Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from handling messages without validating or sanitizing the incoming data, particularly the `gatsbyApi` property, which is used to dynamically invoke methods on the `messageApi` object. While this does not involve a sensitive function like `importScripts` or `eval`, it is a logic flaw in message handling that could allow an attacker to trigger unintended behavior if the message data is manipulated.}	```self.addEventListener(`message`, event => { const { gatsbyApi } = event.data; if (gatsbyApi) messageApi[gatsbyApi](event, event.data); });```
3823	gayliebe.com.js	Insecure Notification Action Title Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of translated strings in notification actions. The title is derived from a translation object, which may be manipulated if translations are not properly sanitized, but no direct sensitive function misuse is present.}	```return self.registration.showNotification(payload.title, { icon: payload.sender_avatar_url_thumb, body: payload.message_body != null ? payload.message_body : '', data: { url: payload.message_url }, actions: [{ title: translations.view_message, action: 'message-action' }] });```
3824	gayliebe.com.js	Open Redirect via Unvalidated URL	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is a standard service worker API that opens a new window or tab with the provided URL. When the URL is derived from event.notification.data.url without validation or sanitization, it allows an attacker to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```clients.openWindow(event.notification.data.url);```
3825	aplay.casino.js	XSS via unsanitized JSON response	High	true	CWE-79	10	JSON.stringify	standard	{The function JSON.stringify is used to serialize the response data 'a' without any sanitization. If 'a' contains user-controlled or untrusted data, the resulting JSON string may include malicious content that could be executed in a context where it is interpreted as JavaScript (e.g., if the response is injected into a script context or parsed by a vulnerable client). This leads to Cross-Site Scripting (XSS) when the JSON response is improperly handled by the client.}	```const a = yield (o => new Promise(i => m(h, null, function* () { const r = [...(yield self.clients.matchAll())].sort((n, l) => n.url > l.url ? -1 : n.url < l.url ? 1 : 0)[0]; if (r) { const l = [i, setTimeout(() => { c.delete(o.$msgId$), i(p(o, 'Timeout')); }, 12e4)]; c.set(o.$msgId$, l), r.postMessage(o); } else i(p(o, 'NoParty')); })))(e); t(u(JSON.stringify(a), 'application/json'));```
3826	edmc.nu.js	Insecure Session State Handling	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from the improper handling of session state via the `loggedIn` variable, which is derived from a URL parameter (`loggedIn=true/false`) parsed using `match()`. This value is then used to conditionally bypass security checks (e.g., CSRF token injection) for POST requests. Since the `loggedIn` state is not validated server-side or securely stored (e.g., via secure cookies or tokens), an attacker can manipulate the URL to spoof login status, leading to unauthorized actions. The `match()` function itself is not inherently sensitive, but its misuse in extracting and trusting user-controlled input for session state decisions constitutes a sensitive function misuse in context.}	"```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log(""Logged in, nothing to do...""); return; }```"
3827	imo-epublications.org.js	Improper Input Validation in Cache Version Handling	High	true	CWE-20	9	new URL	standard	{The function new URL is used to parse the current location, and its searchParams.get('version') is used to dynamically construct the cache name. Since the 'version' parameter is directly taken from the URL without validation or sanitization, an attacker could manipulate it to inject arbitrary strings, potentially leading to cache poisoning or bypassing cache isolation. This misuse of new URL with untrusted input constitutes a sensitive function misuse.}	```const version = new URL(location).searchParams.get('version');```
3828	gompels.chat.js	Insecure Cryptographic Key Derivation	High	false	CWE-327	0	N/A	N/A	{The vulnerability stems from improper key derivation and cryptographic practices, not from misuse of a sensitive JavaScript function. The code uses HKDF for key derivation, but the issue lies in the lack of proper key management, insufficient entropy, or weak parameters, rather than unsafe function usage.}	```const [n, o] = await a(e, r), i = f(t.ciphertext); if (!(await globalThis.crypto.subtle.verify({ name: 'HMAC' }, o, f(t.mac), i))) throw new Error(`Error decrypting secret ${r}: bad MAC`); const s = await globalThis.crypto.subtle.decrypt({ name: 'AES-CTR', counter: f(t.iv), length: 64 }, n, i); return new TextDecoder().decode(new Uint8Array(s));```
3829	observe.tech.js	Cache Key Collision Leading to Data Leakage	High	true	CWE-311	9	N/A	standard	{The vulnerability arises from the use of `createCacheKey`, which constructs cache keys by appending a hash parameter to URLs. If an attacker can manipulate the URL to include a hash parameter that matches a legitimate cached resource, it can cause a cache key collision, leading to unintended data leakage. The function `createCacheKey` is standard in the context of service worker caching logic, but its misuse in constructing keys from untrusted input (URLs) without proper sanitization or validation leads to this vulnerability.}	"```self.addEventListener(""fetch"", function (e) { if (""GET"" === e.request.method) { var t, a = stripIgnoredUrlParameters(e.request.url, ignoreUrlParametersMatching); (t = urlsToCacheKeys.has(a)) || (a = addDirectoryIndex(a, ""index.html""), t = urlsToCacheKeys.has(a)); !t && ""navigate"" === e.request.mode && isPathWhitelisted([""^(?!\\/__).*""], e.request.url) && (a = new URL(""/index.html"", self.location).toString(), t = urlsToCacheKeys.has(a)), t && e.respondWith(caches.open(cacheName).then(function (e) { return e.match(urlsToCacheKeys.get(a)).then(function (e) { if (e) return e; throw Error(""The cached response that was expected is missing.""); }); }).catch(function (t) { return console.warn('Couldn\'t serve response for ""%s"" from cache: %O', e.request.url, t), fetch(e.request); })); } });```"
3830	observe.tech.js	Insecure Whitelist in Navigation Handling	Medium	true	CWE-200	8	N/A	standard	"{The vulnerability stems from the use of `isPathWhitelisted` with a regex pattern `[""^(?!\\/__).*""]` that is improperly constructed and may not effectively block all unintended paths. The function `isPathWhitelisted` is a standard utility in service worker logic, but its misuse here—by relying on a flawed regex that may allow unintended navigation paths—can lead to unauthorized access to resources. The function is called with dynamic input (e.request.url), which is not sufficiently validated, increasing the risk of bypassing the whitelist.}"	"```!t && ""navigate"" === e.request.mode && isPathWhitelisted([""^(?!\\/__).*""], e.request.url) && (a = new URL(""/index.html"", self.location).toString(), t = urlsToCacheKeys.has(a))```"
3831	observe.tech.js	Missing Request Validation in Cache Matching	Medium	true	CWE-20	7	N/A	standard	{The vulnerability occurs because `urlsToCacheKeys.has(a)` is used without validating the input `a`, which is derived from `stripIgnoredUrlParameters(e.request.url, ignoreUrlParametersMatching)`. The function `has` is a standard Map method, but its misuse here—by applying it to potentially untrusted or malformed URLs without proper sanitization—can lead to cache matching errors or unintended resource exposure. The lack of validation on the URL before cache lookup increases the risk of cache poisoning or data leakage.}	"```(t = urlsToCacheKeys.has(a)) || (a = addDirectoryIndex(a, ""index.html""), t = urlsToCacheKeys.has(a))```"
3832	powerredtelecom.com.js	ReDoS (Regular Expression Denial of Service	High	true	CWE-1338	10	RegExp	standard	{The code dynamically constructs regular expressions from user-controlled or untrusted input via JSON.parse() and new RegExp(), which can lead to ReDoS if the input contains malicious patterns that cause exponential backtracking. The sensitive function RegExp is misused because it is being fed untrusted data without sanitization or validation, allowing an attacker to craft a pattern that exhausts CPU resources.}	"```const c = JSON.parse('[""powerredtelecom\\\\.com(?:/.*)?/ola/services/.*"",""powerredtelecom\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://9ad016b5-7848-4eec-b6cb-42dc6ee6f6fd\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
3833	unilever.de.js	Cache Poisoning via Unvalidated Response Caching	High	true	CWE-798	9	N/A	standard	{The vulnerability arises from the use of `caches.put()` with a response obtained from `fetch(e.request)`, which is not validated or sanitized. Since the request URL is derived from the incoming fetch event (which can be controlled by an attacker), an attacker can craft a request that triggers caching of a malicious or unintended response. The `caches.put()` function, being a standard browser API, blindly stores the response in the cache without verifying its integrity or origin, leading to cache poisoning. This allows an attacker to serve malicious content to subsequent users via the cached response.}	```js e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E; }).catch(() => caches.match(e.request).then(e => e)))```
3834	philoro.de.js	Request Interceptor Bypasses Cache Restrictions	High	true	New	9	N/A	standard	{The requestInterceptor modifies the cache and mode properties of a request object during fetch interception. Specifically, it changes `cache: 'only-if-cached'` to `cache: 'default'`, which bypasses the intended cache restriction and allows network requests to proceed even when the browser is configured to only use cached responses. This is a misuse of the Request constructor, a standard JavaScript API, which allows dynamic modification of request behavior based on untrusted or context-sensitive inputs.}	```const requestInterceptor = { requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') { return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' }); } return request; } };```
3835	philoro.de.js	Cached Standalone Page Misuse	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from caching a URL with query parameters (`/?standalone=true`) without validating or sanitizing the query string. However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by a misconfiguration in the precaching strategy. The function `workbox.precaching.precacheAndRoute` is used correctly; the issue lies in the URL being cached, not in how the function is called.}	```'preCaching': [{ 'revision': 'EtPriZKpCXNl', 'url': '/?standalone=true' }],```
3836	appmono.com.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new window or tab with the provided URL. In this case, the URL is derived from event.notification.data, which is directly assigned from the notification payload without validation or sanitization. Since the notification payload can be controlled by an attacker (via push messages), this allows for an open redirect vulnerability where the user is redirected to an arbitrary, potentially malicious, URL.}	```redirectUrl = event.notification.data ? event.notification.data : null;```
3837	fls2u.com.js	Cache Poisoning via Null Revisions	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of null revisions in the precacheAndRoute call, which can lead to cache poisoning if the same URL is later cached with a different revision. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a configuration issue in the Workbox setup. The function e.precacheAndRoute is used correctly, but the lack of revision hashes for certain assets introduces risk.}	```e.precacheAndRoute([...{ url: '0605beb611e6b1962f60d1e0df476b80.svg', revision: null }, { url: '19f092f507dc357886796537b8977d32.pdf', revision: null }, ...]);```
3838	syhost.ch.js	Improper Authentication	High	false	N/A	0	N/A	N/A	{The reported vulnerability 'Improper Authentication' is not caused by misuse of a sensitive JavaScript function. The code does not perform any authentication logic or expose authentication mechanisms; instead, it implements a service worker for offline caching and navigation handling. The vulnerability label appears to be misapplied, as the code does not involve user authentication, session management, or credential handling.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp; } })()); } });```
3839	screenguards.co.in.js	Insecure Accept Header Check	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper handling of the Accept header, not from misuse of a sensitive function. The code checks for 'text/html' in both 'Accept' and 'accept' (case-sensitive) headers, which may miss valid requests due to case sensitivity, but this is a logic flaw, not a sensitive function misuse.}	```function isHtmlRequest(request) { if (request.headers.get('Accept') !== null) { return request.headers.get('Accept').indexOf('text/html') !== -1; } if (request.headers.get('accept') !== null) { return request.headers.get('accept').indexOf('text/html') !== -1; } }```
3840	screenguards.co.in.js	Blacklist Case Sensitivity	Low	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from a case-sensitive string comparison using indexOf, which may fail to match URLs that differ in case. This is a logic issue, not a sensitive function misuse.}	```function isBlacklisted(url) { return urlBlacklist.filter(bl => url.indexOf(bl) == 0).length > 0; }```
3841	screenguards.co.in.js	Cache Poisoning	High	true	New	N/A	caches.put	standard	{The caches.put function is used to store responses in the cache without validating the origin or content of the response. If an attacker can manipulate the request or response (e.g., via a crafted request that bypasses blacklisting), they can inject malicious content into the cache, leading to cache poisoning. The function is called with user-controlled request and response data, making it a sensitive function misuse.}	```event.respondWith(fetch(request).then(response => { if (isCachableResponse(response) && !isBlacklisted(response.url)) { let copy = response.clone(); caches.open(version).then(cache => cache.put(request, copy)); } return response; }).catch(() => { return caches.match(request).then(response => { if (!response && request.mode == 'navigate') { return caches.match(offlinePage); } return response; }); }));```
3842	euroccor.com.js	Insecure Dependency (External CDN)	High	true	CWE-444	10	N/A	standard	{The importScripts() function is used to load and execute a script from an external CDN (staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js'). Although the CDN URL is hardcoded, the use of an external script source introduces a dependency that can be compromised if the CDN is hijacked or if the script is tampered with, leading to potential code injection or malicious behavior. This is a classic case of insecure dependency management.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
3843	euroccor.com.js	Server Side Request Forgery (SSRF) in Prefetch	High	true	CWE-918	9	N/A	standard	{The new URL() constructor is used with a URL that is derived from user-controlled input via addParams(urlToPrefetch, { TIMESTAMP: Date.now() }). Since urlToPrefetch is passed directly without validation, an attacker could supply a malicious URL (e.g., internal IP addresses or other domains) to trigger SSRF, allowing the service worker to make unauthorized requests on behalf of the user.}	```const url = new URL(cacheBustedUrl, location.href);```
3844	euroccor.com.js	Unrestricted Cache Deletion Command	High	false	New	0	N/A	N/A	{The vulnerability arises from a lack of input validation and authentication for the 'deletePagesCache' message command. The service worker processes this command without verifying the origin or authenticity of the message, allowing any page to trigger cache deletion. This is not caused by misuse of a sensitive function, but rather by a design flaw in message handling.}	```if (event.data.command === 'deletePagesCache') { ... }```
3845	euroccor.com.js	Insecure Cache Validation	Medium	false	New	0	N/A	N/A	{The validNetworkResponse() function checks if a response is valid by verifying its status is less than 400. However, this does not account for other potential issues such as response type, content security, or redirections. While this is a validation issue, it is not caused by misuse of a sensitive function but rather by insufficient logic in the validation function itself.}	```if (validNetworkResponse(networkResponse)) { ... }```
3846	mamaplaats.nl.js	Cross-Origin Response Copying	High	true	N/A	N/A	Response	standard	{The Response constructor is used to create a new response from a cloned response object, but the code does not validate the origin of the input response. If an attacker can manipulate the input response to originate from a different origin, the code may inadvertently copy and return cross-origin data, leading to information leakage or cross-origin response copying.}	```const s = a.clone(), n = { headers: new Headers(s.headers), status: s.status, statusText: s.statusText }, r = e ? e(n) : n, c = W() ? s.body : await s.blob(); return new Response(c, r);```
3847	mamaplaats.nl.js	Cache Key Generation Without Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache keys during precaching, but it is not directly caused by misuse of a sensitive function. The issue stems from logic that does not validate or sanitize the cache key before use, but no specific sensitive function is misused.}	```const { cacheKey: n, url: r } = O(s); if (this._urlsToCacheKeys.has(r) && this._urlsToCacheKeys.get(r) !== n) throw new l('add-to-cache-list-conflicting-entries', { firstEntry: this._urlsToCacheKeys.get(r), secondEntry: n });```
3848	mamaplaats.nl.js	Insecure URL Handling in Precaching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves insecure handling of URLs during precaching, but it is not due to misuse of a sensitive function. The issue is related to lack of validation of URL inputs, but no specific sensitive function like importScripts or eval is involved.}	```const { url: r } = O(s); if (this._urlsToCacheKeys.has(r) && this._urlsToCacheKeys.get(r) !== n) throw new l('add-to-cache-list-conflicting-entries', { firstEntry: this._urlsToCacheKeys.get(r), secondEntry: n });```
3849	mamaplaats.nl.js	Unvalidated Cache Key Manipulation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves manipulation of cache keys without proper validation, but it is not caused by misuse of a sensitive function. The issue is in the logic of URL parameter removal and matching, not in the use of a dangerous API.}	```const t = P(e.url, t); if (e.url === t) return a.match(e, s); const r = Object.assign(Object.assign({}, s), { ignoreSearch: !0 }); const c = await a.keys(e, r); for (const i of c) { const o = P(i.url, t); if (t === o) return a.match(i, s); }```
3850	mamaplaats.nl.js	Insecure Notification Content Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves setting notification properties from untrusted data, but it is not caused by misuse of a sensitive function. The issue is in the assignment of notification properties without sanitization, but no dangerous function like eval or importScripts is involved.}	```e.icon = '/pwa-icon.png', e.badge = '/pwa-badge.png'; (t = self.registration) == null || t.showNotification(e.title, e);```
3851	worthyforums.com.js	Improper Validation of 'loggedIn' Parameter Leading to CSRF Vulnerability	High	true	CWE-352	10	N/A	standard	{The vulnerability arises from the improper validation of the 'loggedIn' parameter, which is derived from the URL query string via `e.currentTarget.location.href.match(/loggedIn=(true|false)/)`. This value is then used to conditionally intercept POST requests and fetch CSRF tokens. The use of `new URL(curRequest.url)` and `fetch()` with dynamically constructed URLs based on untrusted input (the path from the request URL) allows an attacker to manipulate the path parameter, potentially leading to CSRF attacks. The `fetch()` function, being a standard JavaScript API, is misused here by accepting dynamically constructed URLs without proper sanitization or validation, enabling an attacker to forge requests to unintended endpoints.}	```if (loggedIn == 'false' && request.method === 'POST') { const curRequest = request.clone(); log('Intercepting guest post request'); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token'```
3852	worthyforums.com.js	Insecure Handling of 'id' Parameter in Push Event Leading to SSRF	Medium	true	CWE-918	9	N/A	standard	{The vulnerability stems from the use of the `id` parameter from the push event data (`e.data.json()`), which is directly interpolated into a URL passed to `fetch()`. The URL is constructed as `${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, allowing an attacker to control the `id` value. Since `fetch()` is a standard JavaScript API that executes HTTP requests without validating the target URL, an attacker can supply a malicious `id` that results in a request to an internal or external resource, potentially leading to SSRF. The lack of input validation or sanitization on the `id` parameter makes this misuse critical.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}````
3853	netgamers.it.js	CSRF Token Leakage via Malicious URL in Notification Click	High	true	CWE-352	10	fetch	standard	{The fetch function is used with a dynamically constructed URL (`${n}/chat/${e}.json`) and includes sensitive headers like `X-CSRF-Token` with credentials included. If the URL `n` or `e` is derived from untrusted input (e.g., from notification data), an attacker can craft a malicious URL to trigger a CSRF attack, leading to unauthorized actions on behalf of the user.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
3854	netgamers.it.js	Open Redirect via Unvalidated URL in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a concatenated URL (`n + e`), where `n` and `e` are derived from notification data. If these values are not validated or sanitized, an attacker can manipulate them to redirect the user to an arbitrary external site, leading to open redirect vulnerabilities.}	```clients.openWindow(n + e);```
3855	audio-books.club.js	Caching of Sensitive Data Without Validation	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the lack of validation or sanitization of cached responses. The code caches responses without verifying their content or origin, which could lead to caching sensitive data if the server returns such data. However, no sensitive function like importScripts, eval, or dynamic code execution is involved.}	"```const CACHE = ""pwabuilder-offline"";const offlineFallbackPage = ""index.php"";self.addEventListener(""install"", function (event) {  event.waitUntil(caches.open(CACHE).then(function (cache) {    if (offlineFallbackPage === ""ToDo-replace-this-name.html"") {      return cache.add(new Response(""TODO: Update the value of the offlineFallbackPage constant in the serviceworker.""));    }    return cache.add(offlineFallbackPage);  }));});self.addEventListener(""fetch"", function (event) {  if (event.request.method !== ""GET"") return;  event.respondWith(fetch(event.request).then(function (response) {    event.waitUntil(updateCache(event.request, response.clone()));    return response;  }).catch(function (error) {    return fromCache(event.request);  }));});function fromCache(request) {  return caches.open(CACHE).then(function (cache) {    return cache.match(request).then(function (matching) {      if (!matching || matching.status === 404) {        return Promise.reject(""no-match"");      }      return matching;    });  });}function updateCache(request, response) {  return caches.open(CACHE).then(function (cache) {    return cache.put(request, response);  });}```"
3856	pimaco.com.br.js	Caching of Opaque Responses Leading to Potential Data Leakage	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the `shouldCache` function caching responses with type 'opaque' or 'opaqueredirect', which are typically returned when cross-origin requests are blocked by CORS policies. While no sensitive function is directly misused, the logic allows caching of responses that may contain sensitive data or be used to bypass security restrictions, potentially leading to data leakage or unintended behavior.}	```function shouldCache(response) { return response.status !== 0 && !(response.status >= 400 && response.status < 500) || response.type === 'opaque' || response.type === 'opaqueredirect'; }```
3857	666n30.vip.js	Cache Poisoning via Unrestricted Same-Origin Check	High	true	CWE-918	10	e.registerRoute	standard	{The vulnerability arises from the use of e.registerRoute with a route matcher that only checks the pathname for inclusion of '/games/allGameList', without validating the origin or enforcing same-origin restrictions. This allows an attacker to craft a request with a malicious origin that still matches the route, leading to cache poisoning where responses from untrusted origins are cached under the same cache name, potentially serving malicious content to users. The sensitive function e.registerRoute is misused by not properly constraining the request origin, enabling cache manipulation.}	```e.registerRoute(({ url: e }) => e.pathname.includes('/games/allGameList'), new e.StaleWhileRevalidate({ cacheName: 'agl', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), 'GET');```
3858	asnieres-sur-seine.fr.js	Improper Authentication for Offline Fallback Page	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of authentication or authorization checks when serving the offline fallback page, but it is not caused by misuse of a sensitive JavaScript function. The code correctly uses standard fetch and cache APIs without dynamic or untrusted input influencing their behavior.}	"```self.addEventListener(""fetch"", event => { if (event.request.mode === ""navigate"") { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp; } })()); } });```"
3859	deafnet.ru.js	Unintended Cache Deletion	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper logic in the activate event handler, where it attempts to delete caches not found in the filesToCache array. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logical flaw in cache management. The code incorrectly maps filesToCache keys to cache names, which are actually URLs, not cache names. This leads to unintended cache deletion because the cache names are not properly derived from the intended cache name (appShell).}	```self.addEventListener('activate', function (event) { var expectedCacheNames = Object.keys(filesToCache).map(function (key) { return filesToCache[key]; }); event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { if (expectedCacheNames.indexOf(cacheName) == -1) { console.log('Deleting out of date cache:', cacheName); return caches.delete(cacheName); } })); })); });```
3860	cne.news.js	Using outdated Firebase SDK with known vulnerability	N/A	false	CVE-2021-21282	N/A	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase SDK (8.4.2), which contains known security issues. This is not caused by misuse of a sensitive JavaScript function, but rather by using an insecure library version.}	```importScripts('https://www.gstatic.com/firebasejs/8.4.2/firebase-app.js');```
3861	cne.news.js	Potential XSS via unsanitized notification data	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The function self.registration.showNotification is used with unsanitized data from the payload (e.g., data.body, data.title). If an attacker can control these fields, they may inject malicious content that could be rendered in the notification UI, potentially leading to XSS if the browser or platform interprets the content as executable script or HTML.}	```return self.registration.showNotification(data.title, notificationOptions);```
3862	cne.news.js	Unvalidated URL in notification click handler leading to open redirect	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is called with a URL derived from event.notification.data.url without validation or sanitization. If an attacker can control this URL, they can redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```if (clients.openWindow) { return clients.openWindow(url); }```
3863	capraboacasa.com.js	Missing Fetch Event Handling	High	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of proper fetch event handling, which could lead to uncontrolled network requests or lack of offline support.}	```self.addEventListener('fetch', event => {});```
3864	nerwica.com.js	Open Redirect via Notification Click	High	true	CWE-601	10	navigate	standard	{The `navigate` method is used on a client object to redirect the user to a URL derived from the notification data (`data.url`). Since this URL is sourced from a remote push notification (which can be controlled by an attacker), it allows for an open redirect. The service worker does not validate or sanitize the URL before passing it to `navigate`, enabling attackers to redirect users to arbitrary domains.}	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
3865	nerwica.com.js	Insecure CSRF Token Handling	Medium	true	CWE-306	8	fetch	standard	{The `fetch` function is used to retrieve a CSRF token from the server using a dynamically constructed URL that includes the `path` parameter from the intercepted request. While the token is obtained and applied to the request headers, the process is vulnerable because the `path` parameter is not sanitized or validated. An attacker could manipulate the request path to trigger unintended CSRF token generation or abuse the token-fetching endpoint.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```
3866	nerwica.com.js	Client-Side Authentication Bypass	High	false	CWE-200	0	N/A	N/A	{This vulnerability arises from client-side logic that checks the `loggedIn` parameter in the URL to determine whether to bypass certain security checks. Since this check is performed entirely in the service worker (which runs in the client), an attacker can easily manipulate the URL to spoof the `loggedIn` state. This is not caused by misuse of a sensitive function but by flawed logic in authentication handling.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3867	onwin365.com.js	Overly Broad Regex in Service Worker Route Matching	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of a regex pattern `/onwin\\d*?.com.br/` in `e.registerRoute()`, which is overly broad and may match unintended domains. However, this is not caused by misuse of a sensitive function like `importScripts()` or `eval()`, but rather by a flawed pattern design. The `registerRoute()` function itself is not inherently sensitive when used with static, well-defined patterns.}	```e.registerRoute(/onwin\\d*?.com.br/, new e.NetworkFirst({cacheName: 'site', plugins: []}), 'GET');```
3868	tactical-board.com.js	Cache Poisoning via Unvalidated Response Caching	High	true	CWE-918	9	caches.put	standard	{The caches.put function is used to store responses in the cache without validating the response content or origin. When combined with fetch and dynamic URL matching (via patterns), it allows potentially malicious responses to be cached and served to users, leading to cache poisoning. The function is standard and its misuse here stems from lack of response validation before caching.}	```const url = event.request.url;if (patterns.find(pattern => url.match(pattern))) {event.respondWith(caches.open(cacheName).then(cache => cache.match(event.request.url).then(cached => {if (cached) {return cached;}return fetch(event.request).then(response => {let responseClone = response.clone();caches.open(cacheName).then(cache => cache.put(event.request, responseClone));return response;});})));```
3869	tiempo.ca.js	Improper Input Validation in Cache Refresh	Medium	false	New	N/A	N/A	N/A	"{The code does not use any sensitive functions that are misused with untrusted input. The `fetch` and `caches.open`/`cache.put` operations are used with hardcoded, trusted paths (`offlineFallbackPage`), and there is no dynamic input or user-controlled data being passed to these functions. Therefore, while the vulnerability is labeled as ""Improper Input Validation in Cache Refresh"", it does not stem from misuse of a sensitive function.}"	"```self.addEventListener(""refreshOffline"", function () { const offlinePageRequest = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { return cache.put(offlinePageRequest, response); }); }); });```"
3870	iczmpodisha.org.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (API key, project ID, etc.) in the `options` object, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'larapush-bd8c9', messagingSenderId: '139321882392', appId: '1:139321882392:web:cf9f0a5e315f5b6472d06d', apiKey: 'AIzaSyCmldHroB0uI5iQflqNSSld7K0nxwhhwi0' }, domain: 'www.iczmpodisha.org', api_url: 'https://push.hayatahmad.com/api/token', vapid_public_key: 'BLRxTRjlHzWIrMY1asOkZ-ixYx74DmGUZ1V5U2xj6yEBTgFZu3qlIW5V_PQUDJh9800nPZan_QyhpyTYDCd9GSI' };```
3871	iczmpodisha.org.js	XSS via Notification Payload	Medium	true	N/A	N/A	showNotification	standard	{The `showNotification` method is used with `payload.title` and `payload` data directly from the push event, which may contain untrusted content. If an attacker can control the payload, they can inject malicious content into notifications, leading to XSS if the notification is rendered in a context that executes scripts.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
3872	iczmpodisha.org.js	Insecure Message Handling	Medium	true	N/A	N/A	addEventListener	standard	{The `addEventListener` for 'message' events processes `event.data.url` without validation or sanitization. If the URL is controlled by an attacker, it could lead to unintended behavior such as redirecting clients to malicious sites or triggering insecure actions.}	```self.addEventListener('message', event => { const { command, url } = event.data; ... });```
3873	iczmpodisha.org.js	Insecure API Communication	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used to send sensitive data (token, endpoint, keys) to `options.api_url` without verifying the URL's legitimacy or using secure transport (e.g., HTTPS validation). If the URL is manipulated or intercepted, it could lead to data leakage or man-in-the-middle attacks.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
3874	iczmpodisha.org.js	Insecure Data Storage	Low	true	N/A	N/A	put	standard	{The `put` method of IndexedDB is used to store data without encryption or access controls. If the data contains sensitive information (e.g., tokens), it can be accessed by other scripts or compromised if the device is compromised.}	```const request = objectStore.put({ id: key, data: value });```
3875	toutdonner.com.js	Insecure Authentication Check in Service Worker	High	true	N/A	9	fetch	standard	{The `fetch` function is used to make a request to `/ping` to check authentication status, but it does not validate the response body or use secure authentication tokens. This allows an attacker to potentially bypass authentication checks if the server returns a 204 status without proper validation, leading to unauthorized access.}	```const isAuthenticated = async () => { try { const response = await fetch(`${DOMAIN}/ping`, { method: 'GET', headers: { 'Content-Type': 'application/json' } }); return response.status === 204; } catch (e) { return false; } };```
3876	toutdonner.com.js	Missing Cache Busting for Sensitive Endpoints	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from logic that does not properly invalidate or bust cache for sensitive endpoints, but no sensitive function is misused. The issue is in the caching policy design, not in the use of a dangerous function.}	```if (request.method !== 'GET' || !request.url.startsWith(DOMAIN) || urlsToNotCache.filter(part => request.url.includes(part)).length > 0 || (await isAuthenticated())) { return fetch(request); }```
3877	toutdonner.com.js	Unintended Caching of Authenticated User Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the decision to cache responses for authenticated users, but it is not caused by misuse of a sensitive function. The issue lies in the logic flow and caching strategy, not in improper use of a function like `fetch` or `caches.put`.}	```if (await isAuthenticated()) { return fetch(request); }```
3878	toutdonner.com.js	Empty Fetch Event Listener	Low	false	N/A	N/A	N/A	N/A	{The `fetch` event listener is empty and does not perform any action, so no sensitive function is being misused. This is a code quality issue, not a security vulnerability caused by function misuse.}	```self.addEventListener('fetch', event => {});```
3879	uagna.it.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script (https://progressier.app/gEg1GOoVtZ7Lr67bdNHH/sw.js), which may be controlled by an attacker. Although the URL is not dynamically constructed from untrusted input, the act of importing and executing a remote script without verification or integrity checks constitutes a sensitive misuse, as it allows an attacker to inject arbitrary code into the service worker context, leading to remote code execution.}	"```importScripts(""https://progressier.app/gEg1GOoVtZ7Lr67bdNHH/sw.js"");```"
3880	hdmoviearea.buzz.js	Server-Side Request Forgery (SSRF) via unvalidated API URL in notification data	High	true	CWE-829	10	N/A	standard	{The fetch() function is used with a dynamically derived URL from event.notification.data.api_url, which is controlled by the notification payload. Since this payload can be manipulated by an attacker (e.g., via push messages), it allows arbitrary HTTP requests to be made to any server, leading to SSRF.}	```const apiUrl = event.notification.data.api_url; fetch(apiUrl);```
3881	hdmoviearea.buzz.js	Insecure Storage of Sensitive Data in IndexedDB	Medium	false	CWE-311	N/A		N/A	N/A	```const request = objectStore.put({ id: key```
3882	hdmoviearea.buzz.js	Phishing via Untrusted URL Redirection	Medium	true	CWE-601	10	N/A	standard	{The clients.openWindow() function is called with targetUrl, which is derived from event.notification.data.url or action-specific click_action. Since these values originate from untrusted notification payloads, an attacker can redirect users to phishing sites by crafting malicious notifications.}	```let targetUrl = event.notification.data.url; clients.openWindow(targetUrl);```
3883	sarkariresult.app.js	Open Redirect via notification URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a new window or tab with a URL derived from the notification data (targetUrl). Since targetUrl is directly extracted from event.notification.data.url or event.notification.data.actions[event.action].click_action without validation or sanitization, an attacker can craft a malicious notification payload to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	N/A
3884	sarkariresult.app.js	Improper Input Validation in Push Event	Medium	true	CWE-20	9	JSON.parse	standard	{The function JSON.parse() is used to parse event.data.json().data.notification, which is derived from untrusted push event data. Without proper validation or sanitization of the input, this can lead to injection or unexpected behavior if the payload contains malformed or malicious JSON, potentially allowing an attacker to manipulate the notification content or trigger unintended logic.}	N/A
3885	```const payload = JSON.parse(event.data.json().data.notification);```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```const payload = JSON.parse(event.data.json().data.notification);```
3886	sarkariresult.app.js	Dynamic Code Execution via Hardcoded Version	Medium	true	CWE-94	8	importScripts	standard	{The function importScripts() is used to load external scripts with a dynamically constructed URL based on the firebaseVersion variable. Although the version is hardcoded, the use of dynamic string concatenation in the URL (https://www.gstatic.com/firebasejs/ + firebaseVersion + /firebase-app.js) introduces risk if the version variable were to be manipulated or if the script source were to be altered in a future context, potentially allowing an attacker to load malicious scripts if the version string were to be controlled.}	N/A
3887	"```importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-app.js"");```"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	"```importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-app.js"");```"
3888	sarkariresult.app.js	Server Side Request Forgery (SSRF) in Notification Click	High	true	CWE-918	10	fetch	standard	{The function fetch(apiUrl) is used to make a network request to a URL derived from event.notification.data.api_url, which is directly extracted from untrusted notification data. Since apiUrl is not validated or sanitized, an attacker can craft a notification payload to make the service worker perform HTTP requests to arbitrary internal or external endpoints, leading to SSRF vulnerabilities.}	N/A
3889	nissanklub.pl.js	Server Side Request Forgery (SSRF)	High	true	CWE-602	9	N/A	standard	{The fetch() function is used with a URL constructed from the id parameter received from a push event, which is untrusted. Since the id is directly interpolated into the URL without validation or sanitization, an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3890	nissanklub.pl.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the data.url field of a notification, which is obtained from a server response. Since this URL is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to redirect users to arbitrary sites, leading to open redirect.}	```clients[0].navigate(data.url);```
3891	nissanklub.pl.js	Insecure Session Management	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability arises from improper handling of session state via URL parameters (loggedIn=true/false), but it is not caused by misuse of a sensitive JavaScript function. The issue is more related to application logic and state management rather than a specific function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3892	nissanklub.pl.js	Insecure Credentials Handling	Medium	false	CWE-295	0	N/A	N/A	{The use of credentials: 'include' in fetch() is a legitimate and necessary behavior for authenticated requests. The vulnerability stems from the exposure of session tokens via CSRF protection mechanisms, not from misuse of a sensitive function.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3893	haberciniz.biz.js	Insecure External Resource Loading	Medium	true	CWE-434	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it loads a script from a third-party CDN (cdn.veteknoloji.com) with a dynamically appended version parameter. While the version is hardcoded, the use of an external, untrusted script source introduces a medium-risk vulnerability. If the CDN is compromised or the script is tampered with, the service worker could execute malicious code. This constitutes misuse of a sensitive function because it loads remote code without verification or integrity checks.}	```importScripts('https://cdn.veteknoloji.com/assets/bundle/webpush.js?v=' + version);```
3894	passiflora.ru.js	Incorrect Regular Expression in URL Matching Leading to Bypass of Security Checks	High	false	CWE-601	0	N/A	N/A	{The vulnerability arises from a flawed regular expression used to match URLs that should be excluded from caching or preloading. The regex `/\/admin\.php|\/install\/|\/download($|&|\?)|[\/?]attachments\/|google-ad|adsense/` is improperly structured and may not match all intended patterns, allowing malicious or unintended URLs to bypass security checks. This is not caused by misuse of a sensitive function but by logic or syntax error in the regex itself.}	```if (request.url.match(/\/admin\.php|\/install\/|\/download($|&|\?)|[\/?]attachments\/|google-ad|adsense/)) {```
3895	passiflora.ru.js	Insecure Notification URL Handling Leading to Phishing	Medium	true	N/A	9	clients.openWindow	standard	{The function `clients.openWindow(notification.data.url)` is used to open a URL provided in the notification payload. Since the URL is derived from untrusted data (push notification payload), an attacker could craft a malicious notification with a phishing URL, leading users to a fake site. This constitutes misuse of a sensitive function because `clients.openWindow` executes navigation based on unvalidated input, enabling phishing attacks.}	```if (notification.data.url) { event.waitUntil(clients.openWindow(notification.data.url)); }```
3896	passiflora.ru.js	Insufficient Input Validation in Message Handling Leading to Potential DoS	Medium	false	CWE-400	0	N/A	N/A	{The vulnerability stems from the lack of input validation when handling messages, particularly in the `updateCache` handler which triggers `createCache()` without validating the payload. However, this is not due to misuse of a sensitive function but rather due to insufficient validation logic. The function `createCache()` is not inherently sensitive; it is the absence of input sanitization that leads to potential DoS.}	```messageHandlers.updateCache = function (clientId, payload) { createCache(); };```
3897	onecosme.jp.js	Insecure Caching of Sensitive URLs with Broad Regex	High	true	New	8	N/A	standard	{The vulnerability arises from the use of `new RegExp(entry.urlPattern)` where `entry.urlPattern` is derived from the `runtimeCaching` configuration. Since this configuration is static and not user-controlled, the regex is not dynamically constructed from untrusted input. However, the broad regex pattern `https://onecosme.jp/.*.(png|gif|jpg|jpeg|svg)` is overly permissive and could inadvertently match unintended URLs, potentially leading to insecure caching of sensitive resources. The `RegExp` constructor itself is not misused here, but the pattern design is flawed.}	```const urlPattern = new RegExp(entry.urlPattern);```
3898	onecosme.jp.js	Cache Poisoning via Unvalidated Pre-Caching	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability stems from pre-caching a URL (`/?standalone=true`) without validating or sanitizing it. However, this is not due to misuse of a sensitive function like `importScripts` or `eval`, but rather a configuration flaw. The `workbox.precaching.precacheAndRoute` function is used correctly; the issue lies in the static, unvalidated URL being cached.}	```workbox.precaching.precacheAndRoute(options.preCaching, options.cacheOptions);```
3899	onecosme.jp.js	Request Interceptor Bypassing Cache Controls	Medium	false	CWE-209	N/A	N/A	N/A	{The issue is not caused by misuse of a sensitive function, but by a logic flaw in the `requestWillFetch` interceptor. The function modifies the request to bypass cache controls (`cache: 'default'`) when `only-if-cached` and `no-cors` are set, which can lead to unintended network behavior. This is a design flaw, not a sensitive function misuse.}	```requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') return new Request(...); }```
3900	rosamondgiffordzoo.org.js	Improper Input Validation in Admin Path Check	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of the request path using string-based indexOf checks for 'admin', 'Security', and 'dev'. This is not caused by misuse of a sensitive JavaScript function, but rather by a logic flaw in path filtering. The code does not use any sensitive functions like eval, importScripts, or dynamic code execution that could lead to direct code injection or execution.}	```self.addEventListener('fetch', function (n) { if ('GET' === n.request.method) { var r = new URL(n.request.url); if (r.pathname.indexOf('admin') >= 0 || r.pathname.indexOf('Security') >= 0 || r.pathname.indexOf('dev') >= 0) e('SW: skip admin '.concat(n.request.url)); else { var o = n.request.clone(), i = n.request.clone(); n.respondWith(fetch(o).then(function (e) { var r = e.clone(); return t.open(self.CACHE_NAME).then(function (e) { var t = n.request.clone(); e.put(t, r); }), e; }).catch(function (n) { return e('SW: fetch failed'), t.match(i); })); } });```
3901	olyrix.com.js	XSS via unsanitized push payload data	Medium	true	CWE-79	8	N/A	standard	{The vulnerability arises because the push payload data, which is parsed from `event.data.text()` using `JSON.parse()`, is used directly to construct notification content (title and body) without sanitization. While `JSON.parse()` itself is not inherently dangerous, the subsequent use of `pushPayload.title` and `pushPayload.body` in `showNotification()` can lead to XSS if the payload contains malicious content that is rendered in the notification UI, especially if the browser or platform interprets the content as executable script or HTML. This is a classic case of unsanitized user-controlled data being used in a context where it can be executed or rendered in a way that compromises security.}	"```let pushPayload; self.addEventListener('push', function (event) { console.log('[Service Worker] Push Received.'); console.log(`[Service Worker] Push had this data: ""${event.data.text()}""`); pushPayload = JSON.parse(event.data.text()); const title = pushPayload.title; const options = { body: pushPayload.body, icon: 'https://olyrix.com/assets/images/logo-o-pourpre.png', badge: 'https://olyrix.com/assets/images/logo-o-pourpre.png' }; event.waitUntil(self.registration.showNotification(title, options)); }); self.addEventListener('notificationclick', function (event) { console.log('[Service Worker] Notification click Received.'); event.notification.close(); event.waitUntil(clients.openWindow(pushPayload.url)); });```"
3902	weave-living.com.js	Insecure External Script Import	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable. However, if the URL were derived from untrusted or dynamic input (e.g., user-controlled parameters), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse. The detection likely stems from a policy against external script imports regardless of source, but the function itself is not misused here.}	"```var appId = ""d544978b0fe9d84cf522""; importScripts(""https://cdn.qgraph.io/v3/r/qg-sw.js"");```"
3903	live-tv-channels.org.js	Cache Poisoning via Unvalidated URL Injection	High	true	CWE-434	9	Request	standard	{The code constructs a Request object from user-controlled input (t.urlsToCache) without validation. Since the input is not sanitized or validated, an attacker can inject arbitrary URLs, leading to cache poisoning where malicious or unintended resources are cached under the service worker's control. This allows attackers to serve malicious content to users or bypass security checks.}	```const s = Promise.all(t.urlsToCache.map(t => { 'string' == typeof t && (t = [t]); const s = new Request(...t); return this.handleRequest({ request: s, event: e });}));```
3904	anilibria.zone.js	Open Redirect via Untrusted Settings	High	true	CWE-601	10	getRedirectUrl	standard	{The function getRedirectUrl constructs a redirect URL by appending query parameters to a base URL that is sourced from untrusted external settings (via fetch). Since the base URL is not validated or sanitized, an attacker can manipulate the settings endpoint to inject arbitrary URLs, leading to open redirect vulnerabilities. The sensitive function getRedirectUrl is standard JavaScript and is misused by concatenating untrusted input directly into a URL.}	```const SETTINGS_URL = 'https://antiblockseries.ru/anilibriazone.php';```
3905	anilibria.zone.js	Insecure External Settings Fetch	High	true	CWE-255	10	fetch	standard	{The fetch function is used to retrieve settings from an external, untrusted URL (SETTINGS_URL). Since the origin of the settings is not verified or secured, an attacker could compromise the settings endpoint to inject malicious data, leading to unauthorized behavior such as forced redirects or other logic changes. The fetch API is a standard JavaScript function and is misused here by trusting external data without proper validation or authentication.}	```return fetch(SETTINGS_URL```
3906	anilibria.zone.js	Unvalidated Redirect URL	High	true	CWE-601	10	getRedirectUrl	standard	{The getRedirectUrl function constructs a redirect URL by appending query parameters to a base URL that is derived from untrusted settings. Since the base URL is not validated, an attacker can manipulate the settings to redirect users to arbitrary domains, leading to open redirect vulnerabilities. The function is standard JavaScript and is misused by concatenating untrusted input directly into a URL without sanitization or validation.}	```url += (url.indexOf('?') === -1 ? '?' : '&') + queryParams(redirect_params);```
3907	a2-freun.de.js	Improper CSRF Token Handling	High	true	CWE-352	9	fetch	standard	{The fetch function is used to dynamically construct and send a request to retrieve a CSRF token based on the path from the intercepted request. While not directly exploitable for injection, the dynamic URL construction and reliance on untrusted path data without validation can lead to unintended behavior or exposure of internal paths, especially if the path is manipulated by an attacker. This misuse contributes to improper CSRF token handling by allowing dynamic, potentially untrusted, URL generation.}	N/A
3908	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```
3909	a2-freun.de.js	Insecure Notification URL Handling	Medium	true	CWE-601	8	clients[0].navigate	standard	{The clients[0].navigate function is used to redirect the client to a URL derived from the notification data. If the notification data is not properly sanitized or validated, an attacker could craft a malicious notification with a URL that leads to phishing, redirection to malicious sites, or unintended navigation, thereby exploiting the service worker to perform unauthorized navigation.}	N/A
3910	a2-freun.de.js	XSS in Notification Content	High	true	CWE-79	7	self.registration.showNotification	standard	{The self.registration.showNotification function is used to display notifications with content derived from server responses. If the body, title, or other fields are not sanitized and contain user-controlled or untrusted data, an attacker could inject malicious scripts or HTML, leading to XSS attacks when the notification is rendered in the browser.}	N/A
3911	a2-freun.de.js	Unvalidated URL Parameter Leading to DoS	Medium	false	CWE-754	0	N/A	N/A	{The vulnerability arises from the use of a regular expression to extract the 'loggedIn' parameter from the URL, but it does not involve misuse of a sensitive JavaScript function. The issue is more about logic or validation flaws rather than improper use of a function like eval, importScripts, or unsafe dynamic code execution.}	N/A
3912	a2-freun.de.js	Insecure Cache Handling	Medium	false	CWE-921	0	N/A	N/A	{The cache.addAll function is used with a hardcoded list of assets, and there is no evidence of dynamic or untrusted input being used to construct the cache list. Therefore, this is not a case of sensitive function misuse, as the input is static and controlled.}	N/A
3913	jupresear.ch.js	CSRF Vulnerability in Chat Message Submission	High	true	CWE-352	9	fetch	standard	{The fetch function is used to submit a chat message to a server endpoint constructed from user-controlled data (i.e., `i` and `t` from notification data). Since the CSRF token is obtained dynamically and the request is sent without proper validation of the origin or user intent, an attacker could trigger this fetch via a malicious notification click, leading to unauthorized message posting. The dynamic URL construction and lack of origin validation make this a sensitive misuse of fetch.}	"```fetch(`${i}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": n }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
3914	jupresear.ch.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	8	clients.openWindow	standard	{The clients.openWindow function is called with a URL constructed by concatenating `i` and `t`, both derived from notification data. Since these values are not sanitized or validated, an attacker could craft a malicious notification with a URL that redirects to an arbitrary site or performs phishing, leading to open redirect or phishing attacks. This is a sensitive misuse because the function directly opens a new window with untrusted input.}	```clients.openWindow(i + t);```
3915	jupresear.ch.js	Insecure Subscription Data Handling in PushSubscriptionChange	Medium	true	CWE-200	7	fetch	standard	{The fetch function is used to send subscription data (including endpoint and keys) to external endpoints without proper validation or sanitization. Although the data is derived from the PushSubscription object, the lack of input validation and potential for exposure of sensitive keys (e.g., p256dh, auth) to an attacker-controlled server makes this a sensitive misuse. The function is standard, but its use with potentially sensitive data without additional security controls introduces information exposure.}	"```fetch(""https://multisite-flex003.discourse.org/push_notifications/subscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.newSubscription.endpoint, ""subscription[keys][auth]"": e.newSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.newSubscription.toJSON().keys.p256dh, send_confirmation: !1 }) })```"
3916	catalove.com.js	Open Redirect via Untrusted Notification URL	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from event.notification.data.url, which is sourced from untrusted push notification data, an attacker can craft a notification with a malicious URL (e.g., a phishing site or redirect to a malicious domain), leading to an open redirect vulnerability. This allows the attacker to trick users into visiting unintended or harmful websites.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
3917	catalove.com.js	Use of Uninitialized Global Variable	Medium	false	N/A	N/A	N/A	N/A	{The variable subscription_info is assigned a value without being declared with var, let, or const, leading to it being created in the global scope. While this is a code quality issue and may lead to unintended side effects, it does not involve misuse of a sensitive JavaScript function.}	```subscription_info = JSON.stringify(subscription.toJSON());```
3918	warnerfuneralhome.com.js	Insecure Service Worker Message Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of messages received via `self.addEventListener('message', ...)`, specifically allowing a page to trigger deletion of the `SITE_PAGES_CACHE_NAME` cache. However, this is not due to misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather a design flaw in the message-handling logic. The code does not use any sensitive function with untrusted input to execute arbitrary code or load external scripts.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
3919	curvert.com.js	Vulnerable URL Filtering Logic	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from the use of `indexOf` on `event.request.url` to filter URLs. While `indexOf` itself is not inherently sensitive, its misuse here creates a logic flaw: it allows partial string matching, meaning any URL containing substrings like 'google' or 'cloud' will be blocked, even if they are not malicious (e.g., 'https://example.com/google-search'). This leads to over-blocking or under-blocking of legitimate requests, which can be exploited to bypass filtering or cause denial of service. The function is standard but its application is insecure due to lack of precise pattern matching.}	```if (event.request.url.indexOf('my-rank') !== -1 || event.request.url.indexOf('googlesyndication') !== -1 || event.request.url.indexOf('googletagmanager') !== -1 || event.request.url.indexOf('changenow') !== -1 || event.request.url.indexOf('financeads') !== -1 || event.request.url.indexOf('gstatic') !== -1 || event.request.url.indexOf('google') !== -1 || event.request.url.indexOf('s0.2mdn.net') !== -1 || event.request.url.indexOf('ezoic') !== -1 || event.request.url.indexOf('rubiconproject') !== -1 || event.request.url.indexOf('timesquare') !== -1 || event.request.url.indexOf('prebid') !== -1 || event.request.url.indexOf('yahoo') !== -1 || event.request.url.indexOf('rlcdn') !== -1 || event.request.url.indexOf('pubmatic') !== -1 || event.request.url.indexOf('cloud') !== -1 || event.request.destination == 'document' || event.request.method == 'POST') { return false; }```
3920	curvert.com.js	Potential Sensitive Data Caching	Medium	true	CWE-312	8	N/A	standard	{The `putInCache` function uses `caches.put(request, response)` to store responses. If the `request` or `response` contains sensitive data (e.g., authentication tokens, personal information) and is not properly sanitized or filtered, this can lead to sensitive data being cached and potentially exposed to unauthorized access. The `caches.put` API is standard and powerful, but its misuse here—by caching without validation—can result in data leakage.}	```const putInCache = async (request, response) => { const cache = await caches.open(version); await cache.put(request, response); };```
3921	aapp.org.js	Uncontrolled Resource Consumption via Excessive Service Worker Update Triggers	High	true	CWE-400	10	SW.conf.update_match.test(t) && !t.match('c575cce5') && (self.registration.update(), setInterval(function () { self.registration.update(); }, 45e3));	standard	{The vulnerability arises from the misuse of `setInterval` in combination with `self.registration.update()`. The code triggers repeated service worker updates every 45 seconds without any condition to stop, leading to excessive resource consumption. While `setInterval` is a standard function, its use here is unsafe because it creates an uncontrolled loop that continuously forces the browser to check for and potentially download new service worker versions, which can degrade performance and exhaust network and CPU resources. This is not a direct injection or data leakage issue, but a resource exhaustion vulnerability caused by improper use of a standard function.}	```SW.conf.update_match.test(t) && !t.match('c575cce5') && (self.registration.update(), setInterval(function () { self.registration.update(); }, 45e3));```
3922	carierista.com.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow(url) is used to open a new window or tab with the provided URL. In this case, the URL is derived from e.notification.data.url, which originates from a push notification payload. Since push notifications can be controlled by an attacker (if the server sending them is compromised or if the notification data is not validated), this allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. The URL is not sanitized or validated, making it a direct vector for malicious redirection.}	```const urlOpenPromise = clients.openWindow(url);```
3923	popa911.com.js	Incorrect CSRF Token Generation	High	true	CWE-352	9	fetch	standard	{The fetch function is used to retrieve a CSRF token from the server based on the current request path. However, the path is derived from the URL of the current request, which is not sanitized or validated. An attacker could manipulate the request path to trigger the generation of a CSRF token for a different endpoint, potentially leading to unauthorized actions if the token is later used in a forged request. This misuse of fetch with untrusted input (request path) enables CSRF token leakage or misuse.}	"```const curRequest = request.clone(); log(""Intercepting guest post request""); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
3924	popa911.com.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	8	navigate	standard	{The navigate function is used to redirect the client to a URL provided in the notification data. The URL is taken directly from the data.url field without validation or sanitization. If an attacker can control the notification data (e.g., via a compromised server or push message), they can redirect users to arbitrary websites, leading to phishing or malicious redirection. This misuse of navigate with untrusted input enables open redirect.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
3925	popa911.com.js	Potential SSRF in Push Event Handler	Medium	true	CWE-918	7	fetch	standard	{The fetch function is used to retrieve notification data from the server using a URL constructed with the id parameter from the push event data. While the id is expected to be controlled by the server, if the server is compromised or the id parameter is not properly validated, an attacker could supply a malicious URL (e.g., internal IP addresses or other internal endpoints) to trigger SSRF. The fetch function is misused by accepting untrusted input (id) in the URL construction, potentially allowing access to internal resources.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
3926	kammeret.no.js	Improper Input Validation	High	true	CWE-20	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `path` variable, which is derived from the request URL. If the `path` value is not properly sanitized or validated, it could lead to unintended requests, such as accessing unauthorized endpoints or triggering server-side vulnerabilities like path traversal or injection. This misuse allows an attacker to manipulate the request URL to target internal or sensitive resources.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3927	forumrowerowe.org.js	Server-Side Request Forgery (SSRF) via unvalidated push message data	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the 'id' parameter in push message data, which is unvalidated and potentially controlled by an attacker. This allows an attacker to craft a push message that triggers the service worker to make arbitrary HTTP requests to internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3928	forumrowerowe.org.js	CSRF Token Fetching with Untrusted Path	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used with a URL constructed from the 'path' parameter, which is derived from the request URL and not validated. An attacker could manipulate the path to trigger requests to unintended endpoints, potentially bypassing CSRF protections or leaking sensitive data.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3929	citypak.lk.js	Insecure Caching of Sensitive Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching sensitive data without proper validation or sanitization, but no sensitive function misuse is directly involved.}	```const a = new URL(e.url```
3930	citypak.lk.js	Regex Pattern Overreach in Caching	Medium	false	N/A	N/A	N/A	N/A	{The issue stems from overly broad regex patterns in caching rules, which may inadvertently match unintended URLs, but no sensitive function misuse is present.}	"```const c = JSON.parse('[""citypak\\\\.lk(?:/.*)?/ola/services/.*""```"
3931	citypak.lk.js	Cross-Origin Request Handling Bypass	High	true	N/A	N/A	URL	standard	{The URL constructor is used to create a URL object from a potentially untrusted input (e.g., e.url), which is then compared to self.location.origin. If the input is manipulated, it could bypass origin checks, leading to cross-origin request handling bypass.}	```const a = new URL(e.url```
3932	citypak.lk.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to overly long cache expiration times, which increases risk of stale data exposure, but no sensitive function misuse is involved.}	```new n.ExpirationPlugin({ maxAgeSeconds: 31536e3```
3933	citypak.lk.js	SSRF Vulnerability in Network-First Strategy	High	true	N/A	N/A	registerRoute	standard	{The registerRoute function is used with a route matcher that may accept untrusted or dynamic URLs (e.g., from user input or configuration), allowing attackers to craft requests to internal or external services, leading to SSRF.}	```(0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkOnly())```
3934	danq.me.js	Service Worker Cache Installation Failure	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by a potential failure in cache installation logic. The code attempts to cache a list of required assets, but if any of the URLs in CACHE_MUST are invalid or inaccessible, the cache.addAll() call may fail silently or throw an error, leading to incomplete cache installation. This is a logic or robustness issue, not a security vulnerability arising from sensitive function misuse.}	```self.addEventListener('install', event => { event.waitUntil(caches.open(CACHE).then(cache => { return cache.addAll(CACHE_MUST); })); });```
3935	cshacked.pl.js	Server Side Request Forgery (SSRF)	Medium	true	CWE-602	N/A	fetch	standard	{The fetch function is used with a URL constructed from the `id` parameter received from a push event, which is untrusted input. This allows an attacker to manipulate the `id` value to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
3936	cshacked.pl.js	Insecure Direct Object Reference (IDOR)	Medium	true	New	N/A	fetch	standard	{The fetch function is used with a URL constructed from the `path` parameter, which is derived from the request URL. Since this input is not validated or sanitized, an attacker can manipulate the `path` to access unauthorized resources, leading to IDOR.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3937	cshacked.pl.js	Open Redirect	Low	true	CWE-601	N/A	navigate	standard	{The navigate function is used with a URL derived from the `data.url` field in the notification data, which is untrusted input. If an attacker can control this value, they can redirect users to malicious sites, leading to open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
3938	cshacked.pl.js	Cached Sensitive Data	Low	false	CWE-312	N/A	N/A	N/A	{The cache.match function is used with a hardcoded URL (OFFLINE_URL), which is not dynamically derived from untrusted input. Therefore, this is not a sensitive function misuse.}	```return cache.match(OFFLINE_URL)```
3939	ecchidreams.com.js	Insecure Determination of Logged-In Status Based on URL Parameter	High	true	CWE-20	9	N/A	standard	{The vulnerability arises from using `match()` on `e.currentTarget.location.href` to extract a `loggedIn` parameter, which is inherently untrusted. This allows an attacker to manipulate the URL to spoof login status, potentially bypassing access controls. The `match()` function is standard but misused here by trusting URL parameters without validation.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3940	ecchidreams.com.js	Missing Validation of CSRF Token Server Response	Medium	false	CWE-20	0	N/A	N/A	{The issue is not due to misuse of a sensitive function but rather a lack of server response validation. The `fetch()` call is used correctly; the vulnerability stems from not verifying the integrity or authenticity of the CSRF token received.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); ...```
3941	ecchidreams.com.js	Open Redirect in Notification Click Handler	High	true	CWE-601	10	N/A	standard	{The `navigate()` method is used with `data.url`, which is derived from untrusted push notification data. Since `navigate()` is a standard browser API that can redirect to any URL, this allows an attacker to craft a notification that redirects users to malicious sites, leading to open redirect.}	```clients[0].navigate(data.url);```
3942	ecchidreams.com.js	Insecure Path Handling for CSRF Token Request	Medium	false	CWE-20	0	N/A	N/A	{The issue is not caused by misuse of a sensitive function. The `new URL()` and `pathname` access are standard and safe; the vulnerability lies in the lack of sanitization or validation of the `path` variable before using it in the CSRF token request URL.}	```let url = new URL(curRequest.url); let path = url.pathname;```
3943	agropravda.com.js	Hardcoded Secret in Service Worker	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is not caused by misuse of a sensitive function but rather by direct assignment of a secret value in the code.}	```self[`appKey`] = `865a0d0798cf02f92fc020a34378c5ab`;```
3944	agropravda.com.js	Remote Code Execution via External Script Loading	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a hardcoded host (self[`hostUrl`]), it allows an attacker who controls the host to inject and execute arbitrary JavaScript code in the context of the service worker, leading to remote code execution. Although the host is hardcoded here, the function itself is sensitive because it executes code from an external source without validation.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3945	lsk.no.js	Improper Neutralization of Special Elements in External Input (Cache Poisoning	Medium	true	CWE-918	8	caches.add	standard	{The caches.add function is used to cache URLs obtained from an external API response. Since the URLs are not sanitized or validated before being passed to caches.add, an attacker could manipulate the API response to inject malicious URLs (e.g., phishing sites or scripts) into the cache, leading to cache poisoning. This allows unauthorized content to be served to users under the site’s domain.}	"```fetch(""https://www.lsk.no/_/service/no.seeds.app.football/fetch_precache_routes"").then(e => { if (!e.ok) throw new Error(""Failed fetch API""); return e.json(); }).then(t => { t ? caches.open(""enonic-pwa-starter-runtime-1.0.355.prod"").then(s => { var r = t.routes || [], n = t.images || [], a = r.map(e => e.url.replace(""//"", ""/"")), i = n.map(e => { var t = e.url.replace(""//"", ""/""); return t.lastIndexOf(""/"") === t.length - 1 ? t.substring(0, t.length - 1) : t; }), o = a.concat(i); (o = o.concat([""https://www.lsk.no/?utm_source=pwa""]).length > 0 ? o.forEach((t, r, n) => { s.add(t).catch(e => console.error(`Fail to cache the route ${t}`)), r === n.length - 1 && e(); }) : e(); }) : e(); }).catch(function (t) { console.log(t), e(); });```"
3946	lsk.no.js	Improper URL Matching Leading to Route Overmatching	Medium	false	CWE-209	10	N/A	N/A	{The vulnerability arises from using a simple substring match (indexOf) to determine if a URL belongs to a trusted origin. This approach is not sensitive to the full URL structure and can be exploited by attackers to bypass intended restrictions by crafting URLs that contain the trusted substring but are not actually from the intended origin. However, this is not caused by misuse of a sensitive function, but rather by flawed logic in URL matching.}	"```q.some(t => -1 !== e.url.indexOf(t)) && ""document"" !== e.destination```"
3947	lsk.no.js	Insecure JSON Parsing in Push Event Handler	Low	true	CWE-502	7	JSON.parse	standard	{The JSON.parse function is used to parse data received from a push event without any validation or sanitization. If the data contains maliciously crafted JSON (e.g., with prototype pollution or other injection vectors), it could lead to unintended behavior or security issues, especially if the parsed data is later used in sensitive operations. While the risk is low in this context, the lack of input validation makes it a sensitive function misuse.}	```JSON.parse(e.data.text())```
3948	altox.app.js	CORS Misconfiguration	High	true	N/A	9	fetch	standard	{The fetch API is misused by dynamically setting the mode to 'no-cors' based on URL matching against a whitelist (u or h). If an attacker can manipulate the request URL to match a whitelisted domain, the fetch call will proceed with 'no-cors', potentially allowing cross-origin requests without proper CORS headers, leading to CORS misconfiguration. The mode is set conditionally based on URL patterns, which can be exploited if the whitelist is not strictly controlled.}	```const o = { credentials: 'same-origin', cache: 'no-store', referrerPolicy: 'no-referrer' }; return o.mode = n || t ? 'no-cors' : 'cors', fetch(e.request, o).then(a => { return n ? a : (t = j(e) ? c() : s, caches.open(t).then(s => { s.put(e.request, a); }), a.clone()); var t; }).catch(e => { console.error(e); });```
3949	altox.app.js	Insecure Notification Handling	Medium	true	N/A	8	clients.openWindow	standard	{The clients.openWindow function is used to open a URL constructed from untrusted data (e.notification.data.forum). If an attacker can control the forum parameter in the notification data, they can redirect users to arbitrary URLs, potentially leading to phishing or malicious site redirection. The URL is built dynamically using user-supplied data without sanitization or validation.}	```a = '/'; b(e.notification.data) && e.notification.data.forum && (a += '#forum-' + Date.now() + '-' + e.notification.data.forum), clients.openWindow && clients.openWindow(a);```
3950	altox.app.js	Cached Resource Manipulation	Medium	true	N/A	7	caches.addAll	standard	{The caches.addAll function is used to cache a list of resources (a) during the install event. If the list 'a' is dynamically constructed or influenced by external input, it could allow an attacker to inject malicious resources into the cache. Although 'a' is hardcoded in this case, the function itself is sensitive because it blindly caches all provided URLs, and if misused with dynamic inputs, it could lead to cache poisoning or execution of malicious scripts.}	```e.waitUntil(caches.open(s).then(e => { e.addAll(a).then(() => { self.skipWaiting(); }); }));```
3951	rawlplug.com.js	User Agent Sniffing for Conditional Logic	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to user agent sniffing, which is a logic-based issue rather than misuse of a sensitive function. The code checks the user agent string to conditionally add a fetch event listener, but no sensitive function like importScripts, eval, or dynamic code execution is involved.}	"```const e = /Chrome/.test(navigator.userAgent) && !/Mobile/.test(navigator.userAgent);e || self.addEventListener(""fetch"", () => {});```"
3952	beztabu.net.js	Hardcoded Secret in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The hardcoded secret is stored in a variable and does not involve misuse of a sensitive function.}	"```self[`appKey`] = ""c85987e72f199e207f1730cb3104452b"";```"
3953	beztabu.net.js	Remote Code Execution via External Script Load	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a variable (self[`hostUrl`]), and that variable is not hardcoded or validated, it allows an attacker to control the script source if the hostUrl is compromised or manipulated. In this case, while the hostUrl is hardcoded, the use of importScripts() with a dynamically constructed URL (even if currently safe) introduces a risk if the hostUrl value is ever derived from untrusted input. The function itself is inherently sensitive because it executes arbitrary code from a remote source.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
3954	autobernard.com.js	XSS via Unsanitized Content Metadata	Medium	true	CWE-79	9	postMessage	standard	{The postMessage() function is used to send data to client pages, and if the contentMetadata object contains unsanitized user-controlled data (e.g., from a response header), it can be executed as JavaScript in the client context, leading to XSS. The code does not validate or sanitize the contentMetadata before sending it, making it vulnerable to injection attacks.}	```clients.matchAll().then(clients2 => { clients2.forEach(client => { client.postMessage({ type: CONTENT_METADATA_DETECTED, contentMetadata }); }); });```
3955	zolpan.fr.js	Stale Content Caching	Medium	false	CWE-922	N/A	N/A	N/A	{The vulnerability arises from improper cache management rather than misuse of a sensitive function. The code uses workbox.precaching.precacheAndRoute, which is a standard Workbox API, but the issue stems from configuration or policy decisions (e.g., not properly invalidating stale assets), not from dynamic or untrusted input being passed to a sensitive function.}	```workbox.precaching.precacheAndRoute(options.preCaching, options.cacheOptions);```
3956	zolpan.fr.js	Information Exposure Through Error Logs	Low	false	CWE-209	N/A	N/A	N/A	{The vulnerability is due to logging sensitive error details via console.error, which is a standard JavaScript function. However, the misuse is not caused by dynamic or untrusted input being passed to a sensitive function, but rather by the decision to log error messages that may contain sensitive data.}	```console.error(ctx.error, 'Details:', ctx);```
3957	borsinoimmobiliare.it.js	Insecure Caching of Unvalidated URL	High	true	CWE-471	9	caches.open	standard	{The caches.open function is used to open a cache named based on a dynamically derived value (CACHE_NAME), which is constructed from a query parameter (pwaVersions) read from location.search. While the cache name itself is not directly used in a dangerous way, the subsequent use of cache.add(location.href) introduces a risk: if location.href is manipulated (e.g., via a malicious URL), the service worker may cache unintended or malicious content, leading to cache poisoning or unintended resource exposure. The function caches.open is standard and its misuse here stems from improper validation of the cache name and the URL being cached.}	N/A
3958	borsinoimmobiliare.it.js	Cache Poisoning via Unvalidated Response	High	true	CWE-471	9	caches.open	standard	{The caches.open function is used to open a cache named CACHE_NAME, which is derived from a user-controlled query parameter. The subsequent cache.put(e.request, response.clone()) operation stores responses without validating the request or response content. If an attacker can trigger a fetch for a malicious URL or manipulate the request, the cache may be poisoned with malicious data, which can be served to users later. This misuse of caches.open (a standard API) in conjunction with unvalidated input leads to cache poisoning.}	N/A
3959	borsinoimmobiliare.it.js	Insecure Origin Check in Fetch Handler	Medium	false	CWE-471	0	N/A	N/A	{The vulnerability arises from a flawed origin check using new URL(e.request.url).origin !== location.origin. This is not caused by misuse of a sensitive function, but rather by a logic flaw in the origin validation. The URL constructor is used correctly, and no sensitive function is misused here. The issue is a design flaw, not a function misuse.}	N/A
3960	borsinoimmobiliare.it.js	Spoofable Online Status Detection	Medium	false	CWE-352	0	N/A	N/A	{The vulnerability stems from relying on a global variable (onlinePwaStatus) that is updated via event listeners (online/offline), which can be spoofed or manipulated by malicious code. This is not due to misuse of a sensitive function, but rather a design flaw in state management. The event listeners are used correctly, and no sensitive function is misused.}	N/A
3961	legalis.hr.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the path from the intercepted request. Since the path is derived from curRequest.url without validation or sanitization, an attacker could manipulate the request URL to trigger fetch calls to arbitrary internal or external endpoints, leading to SSRF.}	N/A
3962	legalis.hr.js	Improper Validation of Path Parameter	Medium	true	CWE-352	9	fetch	standard	{The fetch function is used with a URL constructed from the path extracted from the request URL. The path is not validated or sanitized, allowing an attacker to inject arbitrary paths into the request, potentially leading to unauthorized access to internal resources or path traversal.}	N/A
3963	legalis.hr.js	Client-Side Authentication Bypass	High	false	New	0	N/A	N/A	{The vulnerability arises from client-side logic that checks for a 'loggedIn' parameter in the URL, which can be easily manipulated by users. This is not caused by misuse of a sensitive JavaScript function but rather by flawed logic in handling authentication state.}	N/A
3964	superpicks.com.js	External Script Loading Without Integrity Check	High	true	N/A	9	importScripts	standard	{The importScripts() function loads and executes a script from a specified URL. When used without integrity checks, it can load malicious scripts if the URL is compromised or if the script source is not secured. In this case, the script is loaded from a third-party domain (static.app.delivery), which introduces a risk if the domain is compromised or if the script is modified without detection. This allows an attacker to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or request interception.}	```importScripts('https://static.app.delivery/sdks/web/optimove-worker.js');```
3965	dg888.net.js	Insecure Request Handling in Runtime Caching	High	true	N/A	9	Request	standard	{The code modifies the request object in the requestWillFetch interceptor by creating a new Request with altered cache and mode properties. While this is not inherently malicious, it can lead to unintended behavior or bypass security restrictions if the request URL or mode is not properly validated, especially when handling untrusted or dynamic URLs. This misuse of the Request constructor with potentially untrusted input (e.g., from intercepted or manipulated requests) can result in unintended CORS bypass or cache manipulation, which is a high-risk scenario in service workers.}	```const requestInterceptor = { requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') { return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' }); } return request; } };```
3966	mbogibet.co.ke.js	Improper Cache Invalidation	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of `precacheAndRoute` with a resource that has a `null` revision, which can lead to improper cache invalidation. However, this is not due to misuse of a sensitive function like `importScripts` or `eval`, but rather a configuration issue in the Workbox setup. The function `precacheAndRoute` is not inherently sensitive in this context, and no dynamic or untrusted input is being passed to it.}	```e.precacheAndRoute([{url: '_nuxt/builds/meta/1e9f3cee-9cc3-4560-b84b-128474b11ebd.json', revision: null}], {});```
3967	proclubshead.com.js	Cache Poisoning via Insecure Asset Caching	High	true	CWE-918	10	N/A	standard	"{The caches.put() function is used to store fetched responses in the cache, but it does so without validating or sanitizing the URL. The code checks if the request URL contains any of the paths in the 'i' array (e.g., ""assets/""), and if so, caches the response. However, if an attacker can manipulate the request URL (e.g., via a crafted request or redirect), they could potentially cache malicious content under a trusted path, leading to cache poisoning. The sensitive function caches.put() is misused because it blindly stores responses based on partial URL matching, which is insufficient for secure caching.}"	"```self.addEventListener(""fetch"", function (n) { n.respondWith(caches.match(n.request).then(function (e) { return e || (c = n, fetch(c.request).then(function (t) { return caches.open(r).then(function (n) { return i.forEach(function (e) { -1 < c.request.url.indexOf(e) && n.put(c.request.url, t.clone()); }); }), t; })); var c; }));```"
3968	proclubshead.com.js	Information Exposure via Console Logging	Low	false	CWE-200	0	N/A	N/A	{The console.log() function is used to log error messages, but it does not involve any sensitive function misuse. The exposure is due to logging potentially sensitive error information, but console.log() itself is not a sensitive function in the context of security vulnerabilities like injection or remote code execution.}	"```catch(function (e) { return console.log('Error, ', e), caches.match(""offline""); });```"
3969	proclubshead.com.js	Relative Path Caching of Untrusted Resources	Medium	false	CWE-22	0	N/A	N/A	{The caches.addAll() function is used to cache a list of static paths, which are hard-coded and not derived from untrusted input. While the vulnerability is related to caching, it does not stem from misuse of a sensitive function with dynamic or untrusted input. The function is used correctly in this context.}	```e.waitUntil(caches.open(r).then(function (e) { return e.addAll(n); }).then(function () { return self.skipWaiting(); }));```
3970	clubpeugeot.es.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	clients[0].navigate	N/A	N/A	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
3971	clubpeugeot.es.js	Cross-Site Scripting (XSS) via Unsanitized Notification Data	High	true	CWE-79	10	self.registration.showNotification	N/A	N/A	```return self.registration.showNotification(title, { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } });```
3972	doqi.fr.js	Information Disclosure	High	true	CWE-200	10	adapter.newResponse	standard	{The adapter.newResponse function is used to construct a response containing sensitive debug information (e.g., driver state, client versions, idle task queue, and debug logs) that is exposed to the client via a fetch request. This information can be accessed by any client that makes a request to the ngsw/state endpoint, leading to information disclosure. The function is misused by including sensitive internal state data in the response body, which should not be exposed to end users.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`, {\n headers: this.adapter.newHeaders({\n \'Content-Type\': \'text/plain\'\n })\n });```
3973	mugenfreeforall.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. If an attacker can control the `id` value, they could craft a request to internal or external resources, leading to SSRF. The URL is built using `${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, where `id` is user-controlled via push notification data.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
3974	mugenfreeforall.com.js	Cross-Site Request Forgery (CSRF) Vulnerability	Medium	true	CWE-352	N/A	fetch	standard	{The fetch function is used to retrieve a CSRF token based on the `path` parameter from the request URL. The `path` is derived from the current request's URL, which may be manipulated by an attacker if the service worker is triggered by a malicious site. This could allow an attacker to forge requests to the server by intercepting and modifying guest POST requests.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
3975	mugenfreeforall.com.js	Insecure Direct Object Reference (IDOR) in URL Handling	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter from the service worker's current location URL using a regex. This is not a misuse of a sensitive function but rather a logic flaw in handling URL parameters. The `match` function is used safely here to extract a known, limited set of values (true/false).}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
3976	mugenfreeforall.com.js	Open Redirect in Notification Handling	Medium	true	CWE-601	N/A	navigate	standard	{The navigate function is used to redirect the client to a URL provided in the notification data. If the `data.url` is not validated or sanitized, an attacker could supply a malicious URL, leading to an open redirect. The code uses `clients[0].navigate(data.url ? data.url : BASE_URL);`, where `data.url` is derived from server response data, which may be controlled by an attacker.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
3977	mugenfreeforall.com.js	Insecure Tag Handling in Notifications	Low	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from improper handling of notification tags and their associated data, particularly when updating unseen counts. This is a logic issue rather than misuse of a sensitive function. The `options` object is modified based on existing notifications, but no sensitive function is misused in this context.}	```options = { ...options, tag, renotify: true, data: { ...options.data, unseenCount: 1 } };```
3978	schausteller.de.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided by the event.notification.data.url, which is derived from untrusted push notification data. Since this URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. This allows the attacker to trick users into visiting unintended or malicious websites, potentially compromising their security.}	```clients.openWindow(event.notification.data.url);```
3979	bet8866.club.js	Remote Code Execution via Dynamic Script Loading	High	true	CWE-94	10	importScripts	standard	{The function `importScripts()` is used to dynamically load and execute scripts from a URL specified by the variable `e`, which is derived from user-controlled input (via the `define` function's first argument). Since `e` is not sanitized or validated, an attacker can supply a malicious script URL (e.g., via a crafted module path), leading to arbitrary code execution within the service worker context. This is a classic case of dynamic script loading with untrusted input, enabling remote code execution.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); }```"
3980	gabilos.com.js	Improper Input Validation in Service Worker Message Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of incoming messages without validating or sanitizing the event.data. The code checks for a specific string ('skipWaiting') but does not prevent potential abuse if the message handler is extended or misconfigured. However, since no sensitive function like eval, importScripts, or dynamic code execution is involved, this is not a sensitive function misuse.}	```self.addEventListener('message', function (event) { if (event.data === 'skipWaiting') { console.log('message skipWaiting recibed'); self.skipWaiting(); } });```
3981	leukekleurplaten.nl.js	Improper Cache Control Handling	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache logic, not from misuse of a sensitive function. The code caches responses conditionally based on status, method, and URL, but does not use any sensitive functions like importScripts, eval, or dynamic code execution. The issue is more about logic flaws in cache management rather than function misuse.}	"```if (response.status == 200 && event.request.method == ""GET"" && event.request.url.substr(0, 4) == 'http' && event.request.url.indexOf('bing') == -1) { var resClone = response.clone(); caches.open(cacheName).then(function (cache) { cache.put(event.request, resClone); }); }```"
3982	bs12241.com.js	Insecure Dynamic Firebase Configuration Initialization	High	true	CWE-94	10	firebase.initializeApp	standard	{The function firebase.initializeApp is being called with a dynamic payload received from event.data.payload, which is user-controlled via the message event. This allows an attacker to inject arbitrary Firebase configuration, potentially leading to unauthorized access to Firebase services, data leakage, or server-side code execution if the configuration includes malicious scripts or credentials. Since the configuration is not validated or sanitized, this constitutes a high-risk sensitive function misuse.}	```self.addEventListener('message', event => { if (event.data.eventType === 'initFirebase') { console.log('开启firebase'); let firebaseConfig = event.data.payload; if (!firebaseConfig) { console.log('没有firebase配置'); } else { if (firebase.apps.length > 0) { console.log('Firebase已开启，关闭重新开启'); firebase.app().delete().then(() => { firebase.initializeApp(firebaseConfig); }); } else { firebase.initializeApp(firebaseConfig); } } } else if (event.data.eventType === 'closeFirebase') { console.log('关闭firebase'); firebase.messaging().deleteToken(); } });```
3983	delhimetro.app.js	Supply Chain Vulnerability - External CDN Usage	Low	false	N/A	0	N/A	N/A	{The use of importScripts with a hardcoded external CDN URL does not constitute misuse of a sensitive function, as the URL is fixed and not derived from untrusted or dynamic input. While this introduces a supply chain risk, it is not due to sensitive function misuse.}	```importScripts('https://cdn.ampproject.org/sw/amp-sw.js');```
3984	educationgalaxy.in.js	Hardcoded API Key in Firebase Configuration	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded credentials, not from misuse of a sensitive function. The API key is embedded directly in the code, which is a configuration issue rather than a function misuse.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyC2KsY4x8HHDkeqpHSd95pmPK6TUmDAEeU' } };```
3985	educationgalaxy.in.js	Open Redirect in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is unvalidated and potentially controlled by an attacker. This allows an attacker to redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
3986	educationgalaxy.in.js	Insecure Dynamic Script Import	Medium	true	N/A	N/A	importScripts	standard	{The importScripts function is used with a dynamically constructed URL based on the firebaseVersion variable. While the version is hardcoded, the pattern of concatenating a variable into a script URL introduces risk if the variable were to be controlled by an attacker. In this case, the variable is static, but the function is inherently sensitive to dynamic input.}	"```importScripts(""https://www.gstatic.com/firebasejs/"" + firebaseVersion + ""/firebase-app.js"");```"
3987	educationgalaxy.in.js	Unvalidated Push Notification Payload	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used on data received from a push notification, which is untrusted. If the payload is malformed or crafted by an attacker, it could lead to unexpected behavior or injection, especially if the parsed data is used in subsequent operations without validation.}	```const payload = JSON.parse(event.data.json().data.notification);```
3988	educationgalaxy.in.js	SSRF Vulnerability in API URL Handling	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used with options.api_url, which is hardcoded but could be dynamically controlled in other contexts. In this case, the URL is fixed, but the function is sensitive to dynamic input. If the URL were derived from user input or untrusted sources, it could allow an attacker to perform SSRF by forcing the service worker to make requests to internal or unintended endpoints.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
3989	linnea.fr.js	Cache Poisoning via External Resource Caching	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the use of `fetch()` and `cache.put()` within the fetch event handler. Although the code checks the request method and URL pattern, it does not validate or sanitize the origin or content of the requested resource. If an attacker can trigger a request to a malicious or untrusted URL (e.g., via a crafted request or redirect) that matches the allowed path pattern (e.g., /x/res/), the service worker will fetch and cache the response. Since `cache.put()` stores the response without validation, this allows an attacker to poison the cache with malicious content, which can be served to subsequent requests, leading to cache poisoning. The `fetch()` function is a standard JavaScript API and is considered sensitive when used with untrusted or unsanitized inputs, especially in service workers where caching behavior can be exploited.}	```self.addEventListener('fetch', function (event) { if (event.request.method !== 'GET') { if (!navigator.onLine) { return event.respondWith(caches.match('offline.html')); } return; } if (event.request.cache === 'only-if-cached' && event.request.mode !== 'same-origin') return; const requestURL = new URL(event.request.url); if (/^(\/theme\/|\/x\/res\/|\/x\/m\/|\/x\/inc\/)/.test(requestURL.pathname)) { event.respondWith(caches.open(cacheName).then(function (cache) { return cache.match(event.request).then(function (response) { return response || fetch(event.request).then(function (response) { if (response.ok) cache.put(event.request, response.clone()); return response; }); }); })); return; } event.respondWith(fetch(event.request)); });```
3990	xotaku.com.js	Improper Handling of Vary Header	Medium	false	N/A	0	N/A	N/A	{The vulnerability described is related to improper handling of the Vary header, which is a caching and request-response header issue, not directly caused by misuse of a sensitive JavaScript function. The code does not use any function in a way that introduces dynamic, untrusted input execution or injection risks. The fetch() and caches APIs are used appropriately with no evidence of unsanitized or dynamic input being passed to sensitive functions.}	"```if (""GET"" === t.request.method) { if (new URL(t.request.url).origin !== self.location.origin) return fetch(t.request); if ([""style"", ""script"", ""image"", ""font""].includes(t.request.destination)) { let i = await e.match(t.request); if (i) return i; let a = await fetch(t.request); return e.put(t.request, a.clone()), a; } try { let n = await fetch(t.request); return e.put(t.request, n.clone()), n; } catch { return e.match(t.request); } } return fetch(t.request); }```"
3991	pg133th.com.js	Cache Poisoning via Insecure Route Matching	High	true	CWE-434	9	includes	standard	{The use of `includes()` on `e.pathname` without validating or sanitizing the input allows for broad, potentially unintended route matching. Since the route condition is based on a substring match, an attacker could craft a URL path that includes the target string (e.g., `/games/allGameName`) as a subpath, leading to unintended caching of sensitive or dynamic content, thereby enabling cache poisoning.}	```if (e.pathname.includes('/games/allGameName'))```
3992	pg133th.com.js	Insecure Caching of Sensitive Data	Medium	true	CWE-200	9	includes	standard	{The use of `includes()` on `e.pathname` to match `/staticpagesettings/Info/orders` without proper validation or context-aware filtering allows sensitive data (e.g., order information) to be cached. Since the matching is substring-based, it may inadvertently cache sensitive responses, exposing them to unauthorized access via cache retrieval, leading to information disclosure.}	```if (e.pathname.includes('/staticpagesettings/Info/orders'))```
3993	sat-4-all.com.js	Cross-Site Request Forgery (CSRF) due to client-side login status check	High	true	CWE-352	10	clients[0].navigate	standard	{The vulnerability arises from the use of `clients[0].navigate(data.url)` where `data.url` is derived from a notification payload that is not validated or sanitized. An attacker could craft a malicious notification with a URL pointing to an external site or a phishing page, causing the user’s browser to navigate to it without their knowledge, potentially leading to credential theft or session hijacking. This misuse of the standard `navigate` method with untrusted input constitutes a sensitive function misuse.}	```const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
3994	sat-4-all.com.js	Open Redirect in notification click handler due to unvalidated URL	Medium	true	CWE-601	10	clients[0].navigate	standard	{The `clients[0].navigate(data.url)` function is used with `data.url` directly from the notification payload, which is not validated or sanitized. This allows an attacker to inject arbitrary URLs, leading to open redirect vulnerabilities where users are redirected to malicious sites. The `navigate` method is a standard browser API, and its misuse with untrusted input is a classic example of sensitive function misuse.}	```clients[0].navigate(data.url);```
3995	betchan.one.js	External Script Loading from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted CDN (e.g., cdn.pushflow.net), it introduces a high-risk vulnerability because the script being loaded is not under the control of the application owner. If the CDN is compromised or the script is malicious, it can lead to arbitrary code execution within the service worker context, enabling attacks such as cache poisoning, network interception, or data exfiltration.}	```self.importScripts('https://cdn.pushflow.net/scripts/current/serviceworker/w1.js');```
3996	treatwell.ch.js	Insecure Cache Key Generation	High	true	N/A	N/A	URL	standard	{The function `URL` is used to construct a cache key from an arbitrary input (e.g., `String(e)`), which is then normalized by removing the origin. If the input is not properly validated, an attacker could supply a malicious URL that, when processed, results in a cache key that conflicts with or overrides legitimate entries, leading to cache poisoning or data leakage. This misuse allows an attacker to manipulate cache behavior by crafting URLs that map to unintended cache keys.}	```const E = function(e) { return new URL(String(e), location.href).href.replace(new RegExp('^'.concat(location.origin)), ''); };```
3997	treatwell.ch.js	Cross-Origin Response Caching	High	true	N/A	N/A	new Response	standard	{The `new Response` constructor is used to create a new response from a cloned request body, but the code first checks if the origin of the request matches `self.location.origin`. If the origin does not match, it throws an error. However, if the check is bypassed or misconfigured, an attacker could supply a cross-origin request that is improperly cached, leading to unauthorized access to cross-origin data or response manipulation. The misuse lies in the fact that the response is constructed from a potentially untrusted source without sufficient validation.}	```function I(e, t) { var n = null; e.url && (n = new URL(e.url).origin); if (n !== self.location.origin) throw new f('cross-origin-copy-response', { origin: n }); var r = e.clone(), o = { headers: new Headers(r.headers), status: r.status, statusText: r.statusText }, a = t ? t(o) : o, i = function () { if (void 0 === y) { var e = new Response(''), t = e; if ('body' in e) try { new Response(e.body), y = !0; } catch (t) { y = !1; } y = !1; } return y; }() ? r.body : await r.blob(); return new Response(i, a); }```
3998	treatwell.ch.js	Insecure Cache Expiration Logic	Medium	false	N/A	N/A	N/A	N/A	{The code deletes caches based on a prefix and scope, but the logic is not directly tied to the misuse of a sensitive function. The vulnerability arises from the design of the cache cleanup process, which may not handle edge cases or may be triggered inappropriately, but no specific sensitive function like `importScripts` or `eval` is being misused. The issue is more about logic flaws than function misuse.}	```async function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '-precache-', n = (await self.caches.keys()).filter(function (n) { return n.includes(t) && n.includes(self.registration.scope) && n !== e; }); return await Promise.all(n.map(function (e) { return self.caches.delete(e); })), n; }(t).then(function (e) {});```
3999	etdonline.net.js	Insecure Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The cache busting mechanism uses Math.random() which is not cryptographically secure and can be predictable, but it does not involve misuse of a sensitive JavaScript function.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
4000	etdonline.net.js	Weak Cryptographic Hash (SHA)	High	false	N/A	N/A	N/A	N/A	{The use of SHA-1 is considered weak due to known collision vulnerabilities, but it is not a result of misuse of a sensitive JavaScript function; it's a cryptographic choice.}	```const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8);```
4001	etdonline.net.js	Exposure of Debug Information	High	true	N/A	N/A	adapter.newResponse	standard	{The debug handler uses adapter.newResponse to return detailed internal state and logs to the client, which can expose sensitive information. The function is standard but misused by returning unfiltered debug data.}	N/A
4002	etdonline.net.js	Insufficient Request Validation	Medium	false	N/A	N/A	N/A	N/A	{The validation logic checks for 'ngsw-bypass' in headers or URL, but it does not involve misuse of a sensitive JavaScript function.}	```if (req.headers.has('ngsw-bypass') || /[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)) { return; }```
4003	etdonline.net.js	Cached Response Spoofing	High	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse is used to create responses with arbitrary status codes and bodies, which can be exploited to spoof cached responses if not properly validated. This is a standard function misused to bypass security checks.}	N/A
4004	etdonline.net.js	Insecure Direct Object Reference	Medium	false	N/A	N/A	N/A	N/A	{The lookupResourceWithHash function uses a URL as a key, but there is no direct misuse of a sensitive JavaScript function.}	```async lookupResourceWithHash(url, hash) { if (!this.hashTable.has(url)) { return null; } if (this.hashTable.get(url) !== hash) { return null; } const cacheState = await this.lookupResourceWithoutHash(url); return cacheState && cacheState.response; }```
4005	etdonline.net.js	Improper Error Handling	Low	false	N/A	N/A	N/A	N/A	{The safeFetch function catches errors and returns a generic response, but this is not due to misuse of a sensitive function.}	"```safeFetch(req) { try { return this.scope.fetch(req); } catch (e) { return this.adapter.newResponse(null, { status: 504, statusText: ""Gateway Timeout"" }); } }```"
4006	etdonline.net.js	Insecure Cache Eviction Policy	Medium	false	N/A	N/A	N/A	N/A	{The cache eviction policy uses LRU and size limits, but no sensitive JavaScript function is misused.}	"```async cacheResponse(req, res, lru, okToCacheOpaque = false) { if (!(res.ok || okToCacheOpaque && res.type === ""opaque"")) { return; } if (lru.size >= this.config.maxSize) { const evictedUrl = lru.pop(); if (evictedUrl !== null) { await this.clearCacheForUrl(evictedUrl); } } lru.accessed(req.url); await (await this.cache).put(req, res.clone()); const ageTable = await this.ageTable; await ageTable.write(req.url, { age: this.adapter.time }); await this.syncLru(); }```"
4007	mcpay.io.js	Cache Poisoning via Path-Based Validation	High	true	CWE-79	10	N/A	standard	{The regular expression used to validate image requests is based on path patterns (e.g., /img/, /images/, etc.) and is applied directly to the request URL. This allows an attacker to craft a URL that matches the pattern (e.g., via URL encoding or path traversal) and bypass the intended validation, leading to cache poisoning where malicious or unintended content is cached and served. The vulnerability arises from the unsafe use of the RegExp.test() method on untrusted input (e.request.url) without proper sanitization or context-aware validation.}	```const isRequestImageFromTargetPaths = /\/img\/|\/images\/|\/yt3.ggpht.com\/|\/lh3.googleusercontent.com\/|\/storage\//.test(e.request.url);```
4008	mayday.rocks.js	Improper Validation of Range Requests Leading to Cache Poisoning	High	true	CWE-79	9	N/A	standard	{The function `fetchRengeData` is invoked conditionally based on the presence of a 'range' header in the request. The code parses the range header using a regex (`/^bytes\=(\d+)\-$/g.exec(...)`) to extract a starting position, which is then used to slice an array buffer (`ab.slice(pos)`). However, the code does not validate that the extracted position is within safe bounds (e.g., non-negative, not exceeding buffer length). An attacker could craft a malicious range request with an out-of-bounds position, causing the slice to return an unexpected or empty response, potentially leading to cache poisoning where invalid or partial responses are cached and served to other users. The `fetch` function is used to retrieve the resource, and the response is cached without proper validation, amplifying the risk.}	```if (event.request.headers.get('range')) { fetchRengeData(event); }```
4009	autoscript.ai.js	Open Redirect via Unvalidated URL in Notification	Medium	true	CWE-601	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a new browser window or tab with a URL derived from event.notification.data.url. Since this URL is directly taken from user-provided notification data without validation or sanitization, an attacker could craft a notification payload with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. This allows the attacker to trick users into visiting unintended or harmful websites.}	```self.clients.openWindow(event.notification.data.url);```
4010	arzsanj.com.js	Open Redirect via Untrusted Notification URL	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API used to open a new window or tab with a specified URL. In this script, the URL passed to clients.openWindow() is derived from the notification.url field, which is parsed from untrusted push message data. Since the push message data is not validated or sanitized, an attacker can craft a malicious notification with an arbitrary URL, causing the browser to redirect the user to a phishing or malicious site. This constitutes an open redirect vulnerability, allowing attackers to perform phishing attacks or bypass security controls.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); event.waitUntil(clients.openWindow(openUrlAfterClick)); });```
4011	apfdigital.com.ar.js	Open Redirect via Untrusted Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is used to open a new window or tab with a URL derived from untrusted notification data. Since the URL is constructed from event.notification.data.FCM_MSG.data.link, which is user-controlled and not validated or sanitized, an attacker can craft a notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```const url = new URL(event.notification.data.FCM_MSG.data.link).toString(); if (url) { c = await clients.openWindow(url); }```
4012	apfdigital.com.ar.js	Open Redirect via Untrusted Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow function is used to open a new window or tab with a URL derived from untrusted notification data. The URL is constructed from data.link after parsing event.notification.data, which is user-controlled and not validated or sanitized. This allows an attacker to redirect users to arbitrary websites, resulting in an open redirect vulnerability.}	```let data = JSON.parse(event.notification.data); const url = new URL(data.link).toString(); if (url) { c = await clients.openWindow(url); }```
4013	watchstationindia.com.js	Exposed Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key, messagingSenderId, appId, projectId, user_key, siteid) directly in client-side JavaScript. This is not caused by misuse of a sensitive function, but rather by poor configuration management and exposure of secrets in publicly accessible code.}	```var config = { apiKey: 'AIzaSyAvYz6nPkqMgDhbZjovHhuR7EralyA7mdI', messagingSenderId: '257592006632', appId: '1:257592006632:web:7ad56441d99099e278365d', projectId: 'watchstationindia-52dda', user_key: 'ADGMOT35CHFLVDHBJNIG50K96A0AH3DUN3GK0JU823FLSFL57J7G', siteid: 'bdf4917f99124ec13d77c5e11ddc2794' };```
4014	watchstationindia.com.js	Loading Untrusted Third-Party Script Without Integrity Check	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted third-party domain (//cdnt.netcoresmartech.com/swv4.js), it introduces a risk of loading malicious or compromised code. Although the URL is hardcoded here, the function itself is sensitive because it can execute arbitrary scripts, and without integrity checks (like Subresource Integrity), it becomes a vector for supply chain attacks.}	```importScripts('//cdnt.netcoresmartech.com/swv4.js');```
4015	billingsgazette.net.js	Open Redirect via Untrusted Notification Data	High	true	CWE-602	10	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a new browser window or tab with a URL constructed from untrusted notification data (oData.url). Since oData.url is derived from external input (likely from a Firebase message), an attacker can craft a malicious payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities. The URL is constructed without validation or sanitization, allowing full control over the destination.}	```let oURL = new URL(oData.url); if (oData.utm_source && oData.utm_medium && oData.utm_campaign) { oURL.searchParams.set('utm_source', oData.utm_source); oURL.searchParams.set('utm_medium', oData.utm_medium); oURL.searchParams.set('utm_campaign', oData.utm_campaign); } if (self.clients.openWindow) { return self.clients.openWindow(oURL.toString()); }```
4016	bkinfo.xyz.js	Incorrect Cache Cleanup	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper logic in cache cleanup. The code attempts to delete caches but does not properly handle the Promise chain or return values, leading to potential incomplete cleanup. The issue lies in the structure of the Promise.all() call and the conditional return, not in any unsafe function usage.}	```self.addEventListener('activate', function (event) { console.log('[ServiceWorker] Removing old cache'); event.waitUntil(caches.keys().map(function (key) { return Promise.all(key !== cacheName && key !== dataCacheName ? [console.log('[ServiceWorker] Removing old cache', key), caches.delete(key)] : []); })); return self.clients.claim(); });```
4017	insurancehunter.net.js	Insecure Dynamic Script Loading	High	true	N/A	9	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed using the current hostname via encodeURI(self.location.hostname). Although the URL is hardcoded in structure, the dynamic insertion of self.location.hostname makes the script source dependent on the current context, which could be manipulated if the service worker is deployed in a context where the hostname is controlled by an attacker (e.g., via DNS spoofing or subdomain takeover). This allows an attacker to force the service worker to load and execute arbitrary scripts from a malicious domain, leading to full compromise of the service worker’s execution environment.}	"```importScripts(""https://secureanalytic.com/scripts/sw/script/48epz36g5x?url="" + encodeURI(self.location.hostname));```"
4018	techinferno.com.js	Open Redirect	High	true	CWE-601	10	navigate	standard	{The function `navigate()` is used to redirect the client to a URL derived from `data.url`, which is obtained from a notification payload. Since this data is not validated or sanitized, an attacker could craft a malicious notification with a `data.url` pointing to an arbitrary external site, leading to an open redirect vulnerability. This allows users to be redirected to phishing or malicious sites under the guise of a legitimate notification.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4019	winauditor.net.js	Improper Input Validation in getParamValFromUrl Leading to Cache Key Manipulation	Medium	false	N/A	0	N/A	N/A	{The function getParamValFromUrl parses query parameters from a URL but does not validate or sanitize the input. While it does not directly invoke a sensitive function like importScripts or eval, the lack of input validation could allow an attacker to manipulate cache keys or trigger unintended behavior in caching logic, especially when used in conjunction with cache.put or cache.delete. However, since no sensitive function is directly misused, this is not classified as a sensitive function misuse.}	```var paramVal = ''; paramList.forEach(p => { var kvp = p.split('='); if (kvp.length < 2) return; if (kvp[0] == paramName) paramVal = kvp[1]; }); return paramVal;```
4020	winauditor.net.js	Improper Input Validation in activateEvent Using self.location.search	Medium	false	N/A	0	N/A	N/A	{The code uses self.location.search to extract a version number and constructs a cache key suffix based on it. While this could lead to cache key manipulation or unintended cache deletion, it does not involve the misuse of a sensitive JavaScript function such as eval, importScripts, or Function. The vulnerability stems from improper input validation, not from a sensitive function call.}	```var currentVersionNr = self.location.search.substr(3); var endFile = '_v' + currentVersionNr.replaceAll('.', '') + '_';```
4021	winauditor.net.js	Potential Cache Poisoning via Unvalidated Query Parameters in Caching Logic	High	false	N/A	0	N/A	N/A	{The caching logic uses event.request.url directly in conditions like endsWith and indexOf without validating or sanitizing the input. While this could lead to cache poisoning or unintended cache behavior, no sensitive JavaScript function (e.g., importScripts, eval, Function) is being misused. The issue is due to improper input handling, not sensitive function misuse.}	```if (event.request.url.endsWith('.min.js')) return { canCache: true, typ: 2, cacheName: pwaTools.CacheNamePERMA };```
4022	zk-fm.top.js	Improper Validation of Message Origin	High	true	CWE-611	9	self.addEventListener	standard	{The service worker listens for messages without validating the origin of the message sender. This allows malicious scripts from other origins to send messages to the service worker, potentially triggering unintended behavior such as skipping waiting or leaking version information. The self.addEventListener function is a standard API, and its misuse here stems from not checking event.origin or ensuring the message comes from a trusted source.}	"```self.addEventListener(""message"", event => { if (!event.data) { return; } switch (event.data.type) { case ""SKIP_WAITING"": console.log(`Version=${SW_VERSION} accept SKIP_WAITING`); self.skipWaiting(); event.ports[0].postMessage(true); break; case ""GET_VERSION"": console.log(`Version=${SW_VERSION}`); event.ports[0].postMessage(SW_VERSION); break; default: break; } });```"
4023	unilever.ca.js	Caching of Sensitive Data Despite Server Caching Directives	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's caching logic that ignores server caching directives (like Cache-Control headers) and caches responses based solely on client-side rules. This is not due to misuse of a sensitive function, but rather a design flaw in caching strategy.}	"```self.addEventListener(""fetch"", e => { const { hostname: t } = new URL(e.request.url); IGNORED_HOSTS.indexOf(t) >= 0 || EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || ""PUT"" === e.request.method || ""POST"" === e.request.method || e.request.headers.get(""range"") || (e.request.headers.get(""Accept"").includes(""text/html"") ? e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E; }).catch(() => caches.match(e.request).then(e => e))) : e.respondWith(caches.match(e.request).then(E => E || caches.open(CACHE_KEYS.RUNTIME).then(E => fetch(e.request).then(n => RUNTIME_IGNORED_HOSTS.indexOf(t) > -1 ? n : E.put(e.request, n.clone()).then(() => n)).catch(() => {}))))); });```"
4024	20240724.store.js	Exposed Sensitive Information	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the exposure of sensitive configuration data, including the INNERTUBE_API_KEY, which is hardcoded in the script. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure data handling and exposure in the source code.}	```self.document = self;self.window = self;var ytcfg = { d: function () { return window.yt && yt.config_ || ytcfg.data_ || (ytcfg.data_ = {}); }, get: function (k, o) { return k in ytcfg.d() ? ytcfg.d()[k] : o; }, set: function () { var a = arguments; if (a.length > 1) ytcfg.d()[a[0]] = a[1];else { var k; for (k in a[0]) ytcfg.d()[k] = a[0][k]; } } };ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
4025	smileybedeutung.com.js	Insecure Dependency Loading via Relative Paths	High	true	CWE-444	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with relative paths, it can lead to insecure dependency loading if the script paths are not properly controlled or if they can be manipulated by an attacker. In this case, the scripts are loaded from relative paths ('pre-cache-worker.js' and 'ngsw-worker.js'), which may be overridden or replaced by malicious scripts if the hosting environment is compromised or if the application is deployed in an untrusted context. This allows an attacker to inject malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks.}	"```importScripts(""pre-cache-worker.js"");importScripts(""ngsw-worker.js"");```"
4026	tv4.com.tr.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive credentials (API key, project ID, etc.) in the code, not due to misuse of a sensitive JavaScript function.}	```var config = { apiKey: 'AIzaSyCrfHKTydUTWn46TBrtRdRWZ9uuPig2YKs', authDomain: 'tv4-push.firebaseapp.com', projectId: 'tv4-push', storageBucket: 'tv4-push.appspot.com', messagingSenderId: '109579686435', appId: '1:109579686435:web:ad0d8b50e00b2a5d2bd796', measurementId: 'G-BV6WW2RZF8' };```
4027	tv4.com.tr.js	Insecure Direct Object Reference	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used with a dynamic payload value derived from event.notification.data.FCM_MSG.data.payload, which is user-controlled or untrusted. This allows an attacker to redirect the user to arbitrary URLs, leading to phishing, malware distribution, or other malicious redirections.}	```return clients.openWindow(event.notification.data.FCM_MSG.data.payload);```
4028	vwroc.com.js	Open Redirect via Notification URL	Medium	true	CWE-601	8	N/A	standard	{The function `clients[0].navigate(data.url)` is used to redirect the client to a URL derived from the notification data. Since the `data.url` is sourced from a remote server response (via `fetch`), and no validation or sanitization is performed on it, an attacker could manipulate the server response to inject a malicious URL, leading to an open redirect. This misuse of the standard `navigate` method allows redirection to arbitrary domains.}	```clients[0].navigate(data.url);```
4029	vwroc.com.js	Server Side Request Forgery (SSRF) via Untrusted ID Parameter	High	true	CWE-918	9	N/A	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received from a push notification. Since `id` is untrusted and directly interpolated into the URL without validation, an attacker can supply arbitrary values to trigger requests to internal or external systems, leading to SSRF. The `fetch` function is a standard browser API, and its misuse here allows unauthorized network requests.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
4030	toodego.com.js	Incorrect Handling of Application Server Key Leading to Failed Push Subscription	High	true	CWE-799	N/A	const applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);	standard	{The function urlB64ToUint8Array is used to decode a base64-encoded application server public key, but the input (applicationServerPublicKey) is hardcoded as null. This results in the function being called with a null value, which causes the push subscription to fail. While the function itself is not inherently dangerous, its misuse here—due to improper input handling—leads to a critical failure in push notification functionality. The vulnerability arises because the function expects a valid base64 string, and passing null causes the decoding to fail, preventing the service worker from establishing a push subscription.}	```const applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);```
4031	hunkemoller.co.uk.js	Cache Poisoning Leading to XSS	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the misuse of the `cache.put()` function within the fetch event handler. The code conditionally caches responses for specific file types (e.g., .js, .css, .svg) without validating or sanitizing the request URL. If an attacker can manipulate the URL to include a malicious resource (e.g., via a crafted request or redirect), the service worker may cache and serve that resource to other users, leading to cache poisoning. Since the cached content can include executable scripts or stylesheets, this can result in Cross-Site Scripting (XSS) when served to unsuspecting users. The `cache.put()` function is a standard Web API, and its misuse here stems from insufficient input validation on the request URL.}	```if (networkResponse.type === 'basic' && event.request.url.match(/.png|.img|.webp|.gif|.svg|.js|.woff2|.css|.ico/)) { cache.put(event.request, networkResponse.clone()); }```
4032	chemtrec.com.js	Cache Poisoning via Unvalidated Network Response	High	true	CWE-918	10	N/A	standard	{The `fetch` function is used to retrieve network responses, and the response is cached without validating its origin or integrity. This allows an attacker to manipulate the network response (e.g., via DNS spoofing or man-in-the-middle) and cache malicious content, leading to cache poisoning. The `cacheIt` function blindly caches any response from `fetch`, which is a standard browser API.}	```e.respondWith(fetch(request).then(function (fromNetwork) { cacheIt(CACHE_NAME, request, fromNetwork.clone()); return fromNetwork; }));```
4033	chemtrec.com.js	Insecure Cache Directory Matching Leading to Cache Poisoning	High	true	New	10	N/A	standard	{The `indexOf` method is used to check if a request URL contains any of the cached directories. This is a string-based substring match, which is vulnerable to path traversal or directory spoofing (e.g., if an attacker crafts a URL like `/themes/custom/chemtrec/../malicious.js`). Since `indexOf` is a standard string method and not designed for secure path validation, it can lead to unintended cache matching and poisoning.}	```if (request.url.indexOf(CACHE_DIRS[i]) !== -1) { return true; }```
4034	una.rs.js	Insecure External Script Loading	High	true	N/A	9	importScripts	standard	{The importScripts function is used to load and execute an external script from a hardcoded URL. While the URL is not dynamically constructed from untrusted input, the act of loading external scripts in a service worker context can still pose a security risk if the source is not fully trusted or if the script is compromised. However, in this case, the URL is fixed and not derived from user input, so the risk is mitigated but not eliminated. The vulnerability is classified as high due to the potential for supply chain attacks if the CDN is compromised.}	```if ('function' === typeof importScripts) { importScripts('https://cdn.pushpushgo.com/64b002c479a903acbe12d0a5/worker.js'); addEventListener('message', onMessage); function onMessage(e) {} }```
4035	l1nk.dev.js	Improper Access Control in Message Event	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of proper validation or authorization of incoming messages, but it is not caused by misuse of a sensitive JavaScript function. The code simply checks for a specific message type ('SKIP_WAITING') and calls self.skipWaiting(), which is a safe and intended use. There is no dynamic or untrusted input being passed to a sensitive function.}	```self.addEventListener('message', event => { if (event.data && event.data.type === 'SKIP_WAITING') { self.skipWaiting(); } });```
4036	banka.credit.js	Prototype Pollution via BroadcastChannel	Medium	true	CWE-471	8	Object.assign	standard	{The function Object.assign is used to merge an untrusted object (data, parsed from a message received via BroadcastChannel) into workobj. Since the data is derived from a message that can be sent by any client (potentially malicious), and Object.assign performs a shallow merge without sanitization, an attacker can inject properties into workobj that may lead to prototype pollution, potentially altering the behavior of built-in objects or triggering unintended logic in the service worker.}	```workobj = Object.assign(workobj, data);```
4037	provu.com.br.js	Improper Input Validation (Potential SSRF	High	true	CWE-918	9	URL	standard	{The URL constructor is used with user-controlled input (e.g., from a request URL) without validation, allowing an attacker to craft a URL pointing to an internal or external resource, potentially leading to SSRF attacks.}	```const a = new URL(e, location.href);```
4038	provu.com.br.js	Cross-Origin Resource Sharing (CORS) Misconfiguration	Medium	true	CWE-514	N/A	URL	standard	{The URL constructor is used to manipulate URLs by stripping the origin, which may allow unintended cross-origin requests if the resulting URL is used in a context where CORS is not properly enforced, leading to CORS misconfiguration.}	```const a = new URL(e, location.href).href.replace(new RegExp(`^${location.origin}`), '');```
4039	provu.com.br.js	Insecure Cache Key Generation	Medium	true	CWE-311	N/A	URL	standard	{The URL constructor is used to generate cache keys from user-controlled input without proper sanitization, which may allow attackers to manipulate cache keys and cause cache poisoning or bypass cache validation.}	```const a = new URL(e, location.href);```
4040	provu.com.br.js	Insufficient Logging and Monitoring	Low	false	CWE-770	0	N/A	N/A	{The vulnerability is related to insufficient logging and monitoring, not misuse of a sensitive function. The code does not involve any sensitive function misuse.}	```self.addEventListener('activate', function (e) { e.waitUntil(caches.keys().then(function (e) { return Promise.all(e.filter(e => e.startsWith('provu.com.br-')).map(e => caches.delete(e))); })); });```
4041	provu.com.br.js	Insecure Direct Object Reference (IDOR	Low	false	CWE-200	0	N/A	N/A	{The vulnerability is related to insecure direct object reference, but no sensitive function misuse is detected in the provided code snippet. The URL construction is not directly tied to IDOR in this context.}	```const a = new URL(e, location.href);```
4042	gifgit.com.js	Exposed API Key in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The API key is exposed in client-side code, but it is not a result of misuse of a sensitive function. It is hardcoded (obfuscated) in the script and accessible to anyone inspecting the page.}	```var firebaseConfig = { 'apiKey': _0x574fd5('0xc'), 'authDomain': _0x574fd5('0x9'), 'databaseURL': _0x574fd5('0x7'), 'projectId': _0x574fd5('0xf'), 'storageBucket': _0x574fd5('0x1'), 'messagingSenderId': _0x574fd5('0x2'), 'appId': _0x574fd5('0x0'), 'measurementId': _0x574fd5('0xd') };```
4043	gifgit.com.js	Improper Input Validation for Notification Body	Medium	true	N/A	N/A	decodeURI	standard	{The decodeURI function is used to process the 'notif_body' field from a notification payload without validating or sanitizing the input. This allows an attacker to inject malicious content (e.g., script tags or HTML) that may be rendered in the notification, potentially leading to XSS or phishing attacks if the notification is displayed in a context where untrusted content is rendered.}	```const _0x7bae3 = { 'body': decodeURI(_0x5df3a4[_0x2ba4ae('0x5')]['notif_body'])[_0x2ba4ae('0x3')](/\+/g, '\x20') };```
4044	astropolis.pl.js	Incorrect Login Status Determination Leading to CSRF Bypass	High	true	CWE-352	9	RegExp.prototype.match	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract the `loggedIn` parameter. This function is misused because it does not validate or sanitize the input URL, allowing an attacker to manipulate the `href` (e.g., via crafted redirects or URL injection) to force `matches[1]` to evaluate as 'true' or 'false' incorrectly. Since the login status is determined solely from this untrusted input, an attacker can bypass CSRF protections by spoofing the login state, enabling unauthorized actions.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4045	helenarubinstein.com.js	Open Redirect via Notification Action	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow() function is used to open a new browser window or tab based on a URL provided in the notification data. Since the URL is derived from user-controlled notificationData.actions[action], an attacker could craft a malicious notification payload that redirects users to an arbitrary external site, leading to an open redirect vulnerability. The function is standard and directly exposed to untrusted input without validation or sanitization.}	```self.addEventListener('notificationclick', function (event) { let action = event.action; let notificationData = event.notification.data; if (!action && notificationData.defaultAction) { action = notificationData.defaultAction; } if (action && notificationData && notificationData.actions && notificationData.actions[action]) { return clients.openWindow(notificationData.actions[action]); } if (action && action === 'close') { event.notification.close(); } });```
4046	thecancunsun.com.js	Insecure Dynamic Caching	Medium	true	CWE-20	8	j	standard	{The function `j` is used to register routes for caching, and it accepts a dynamic URL matching function as its first argument. This function uses `e.url.href` and `new URL(t).hostname` to evaluate URLs, which are derived from incoming requests. Since the URL is not sanitized or validated against a strict whitelist, an attacker could potentially manipulate the request URL to trigger unintended caching behavior, such as caching malicious or unintended resources. This misuse of `j` (a Workbox routing function) with dynamic, untrusted input leads to insecure dynamic caching, allowing potential cache poisoning or unintended resource exposure.}	```j(function (e) { if (!e.url) return !1; var t = e.url.href; return !!t && 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname; })```
4047	v9b188.com.js	Invalid DOM Access in Service Worker	High	true	CWE-807	10	N/A	standard	{The service worker script attempts to access the DOM via `document.getElementById('install-button')`, which is not permitted in a service worker context. Service workers run in a separate thread and cannot directly interact with the DOM. This misuse leads to a runtime error or unexpected behavior, potentially breaking the intended functionality of the PWA installation prompt. The `document` object is a standard browser API, but its use in service workers is invalid and constitutes a critical misuse.}	"```self.addEventListener(""activate"", s => { s.preventDefault(); let e = s, t = document.getElementById(""install-button""); t.style.display = ""block"", t.addEventListener(""click"", n => { t.style.display = ""none"", e.prompt(), e.userChoice.then(a => { a.outcome === ""accepted"" ? (console.log(""User accepted the A2HS prompt""), gtag(""event"", ""PWA Install"", { event_category: ""PWA"", event_label: ""Install"" })) : console.log(""User dismissed the A2HS prompt""), e = null; }); }); });```"
4048	instadoctor.gr.js	Dynamic Cache Name Based on Service Worker URL Leading to Cache Confusion	High	true	CWE-362	9	N/A	standard	{The CACHE_NAME is dynamically constructed using VERSION, which is derived from URLSearchParams(self.location.search). This allows an attacker to manipulate the query parameter 'v' to control the cache name, leading to cache confusion where different users or contexts may share or overwrite each other’s cached resources, potentially enabling cache poisoning or bypassing intended cache isolation.}	```const CACHE_NAME = `pwa-cache-${VERSION}`;```
4049	instadoctor.gr.js	Incorrect Fetch Event Handling Logic Leading to Cache Poisoning	Medium	false	N/A	0	N/A	N/A	{The logic condition `request.destination === 'document' || request.mode === 'cors' && request.destination === ''` is syntactically flawed due to operator precedence, causing unintended behavior. However, this is a logic error, not misuse of a sensitive function.}	```if (request.destination === 'document' || request.mode === 'cors' && request.destination === '') { return; }```
4050	instadoctor.gr.js	Insecure Cache Invalidation via String Includes	Medium	true	CWE-362	8	N/A	standard	{The use of `urlsToCache.includes(url.pathname + url.search)` for cache matching is insecure because it performs a string-based lookup without proper URL normalization or validation. This can lead to cache poisoning if an attacker crafts a URL with a pathname or search parameter that matches a cached resource path, causing unintended cache hits or overwrites.}	```if (urlsToCache.includes(url.pathname + url.search)) {```
4051	bmwsporttouring.com.js	CSRF Token Handling in Fetch Event	High	true	CWE-352	9	new Request	standard	{The new Request constructor is used to create a modified request with a dynamically injected X-Csrf-Token header. While the token is fetched from the server, the request is constructed using a cloned original request, which may be manipulated if the original request is not properly sanitized or if the token fetching endpoint is compromised. This misuse allows an attacker to potentially forge requests with valid CSRF tokens if they can influence the request path or intercept the token retrieval process.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
4052	bmwsporttouring.com.js	Server Side Request Forgery in Push Event	Medium	true	CWE-918	8	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the id parameter from the push event data. If the id parameter is not validated or sanitized, an attacker could supply a malicious URL path (e.g., via a crafted push notification) to trigger unintended server-side actions, such as accessing sensitive endpoints or performing unauthorized operations.}	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: ""POST"", credentials: ""include"" })```"
4053	mitienda.mx.js	CORS Misconfiguration	High	true	CWE-510	10	N/A	standard	{The `new Response()` constructor is used to create a response with headers that include `'Access-Control-Allow-Origin': '*'`, which allows any origin to make cross-origin requests to the service worker's endpoint. This is a standard JavaScript function (`Response`), and its misuse by setting a wildcard origin header without proper origin validation leads to CORS misconfiguration, enabling unauthorized cross-origin access.}	```const rcHandler = event => { const fallbackResponse = new Response('', { headers: { 'Access-Control-Allow-Headers': 'Content-Type, Authorization, Content-Length, X-Requested-With', 'Access-Control-Allow-Methods': 'GET,POST,OPTIONS', 'Access-Control-Allow-Origin': '*', Date: new Date(Date.now()).toUTCString(), 'X-Powered-By': 'Express', Connection: 'keep-alive' } }); event.respondWith(fallbackResponse); fetch(event.request); };```
4054	dwctraining.com.js	Cache Poisoning via Dynamic Cache Keys	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the use of dynamic cache keys (e.g., swCachePostfix) in cache.addAll() calls. While this can lead to cache poisoning if the postfix is derived from untrusted input, the code does not show any dynamic input being used to construct the cache keys. The cache keys are hardcoded or derived from constants, so no sensitive function misuse is present.}	```self.addEventListener('install', function (event) { self.skipWaiting(); event.waitUntil(caches.open(SWHelper.staticCacheName).then(function (cache) { return cache.addAll(['/design2021/theme-dwc/jquery-ui-1.13.2.custom/jquery-ui.min.css', '/design2021/theme-dwc/jquery-ui-1.13.2.custom/jquery-ui.min.js', '/css/fonts/fontawesome.css?v=20221222-1155', '/design2021/css/fontawesome.min.css', '/css/bootstrap/bootstrap.min.css' + swCachePostfix, '/design2021/js/jquery-2.0.3/jquery-2.0.3.min.js', '/javascript/bootstrap/bootstrap.min.js' + swCachePostfix, '/design2021/fonts/Averia/AveriaSerifLibre-Regular.ttf', '/design2021/fonts/fontawesome-webfont.woff2']); }```
4055	ozonesocial.app.js	Cache Poisoning via Dynamic Image URL Caching	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of `caches.open()` and `cache.put()` with dynamic URLs derived from `event.request.url`, which is user-controlled. Since the service worker caches responses for any request that does not match static assets, an attacker could craft a malicious request URL (e.g., via a redirect or crafted link) to cache a response under a controlled path. This allows cache poisoning, where the attacker’s content is served in place of legitimate resources, potentially leading to XSS or data exfiltration. The `caches.open()` function is a standard browser API, and its misuse here is due to lack of validation on the URL being cached.}	```event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } else { return fetch(event.request).then(function (res) { return caches.open(CACHE_DYNAMIC_NAME).then(function (cache) { cache.put(event.request.url, res.clone()); return res; }).catch(function (err) { console.log('### open catch and put', err); }); }).catch(function (err) { console.log('### catch offline', err); }); } });```
4056	talkhomeapp.com.js	Use of Hard-coded Credentials	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials (appKey, token, vapidPublicKey) and URLs, not due to misuse of a sensitive JavaScript function. These values are static and embedded directly in the code, posing a risk if exposed, but no dynamic or unsafe function invocation is involved.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');uaSetup.worker(self, {defaultIcon: 'https://dl.asnapieu.com/binary/public/QzILLymLRAauEWWAKN5pKQ/c8cce378\u002De28a\u002D4c70\u002Da648\u002Dbdbe040b3cfb',defaultTitle: 'Talkhome App',defaultActionURL: 'https://app.talkhome.co.uk',appKey: 'QzILLymLRAauEWWAKN5pKQ',token: 'MTpReklMTHltTFJBYXVFV1dBS041cEtROjBodVRqSGJPZHo1a3VGSFBPbWdlQWdiNl9fdVFTcEQ2X2h5a0NqcENmM2s',vapidPublicKey: 'BI47nhDB0_u-bi-O05tQ9f8vONhQm5DmzRBqMuVzco9ekpGhKOM9S-TaLJPUIoIGHt1Pp8aWYlFlc1EdbT-FZ14='});```
4057	qsoft.in.js	Improper Input Validation	Medium	true	CWE-20	9	N/A	standard	{The variable `open_url` is assigned from `payload.data.click_action`, which is untrusted input from a Firebase messaging payload. This value is later passed directly to `clients.openWindow(open_url)`, a standard browser API that opens a URL in a new window or tab. Since the URL is not validated or sanitized, an attacker could craft a malicious payload to redirect users to phishing sites, perform open redirects, or trigger unintended navigation, leading to potential phishing or data leakage.}	```open_url = payload.data.click_action;```
4058	gccsatx.com.js	MIME Type Confusion Vulnerability	Medium	true	New	8	N/A	standard	{The Response constructor is used to create a new response with a hardcoded 'Content-Type' header set to 'audio/mpeg'. While this is not directly caused by untrusted input, the vulnerability arises because the MIME type is explicitly set without validation or consideration of the actual content, which could lead to MIME type confusion if the content is not truly an MP3. This can result in browsers misinterpreting the content, potentially leading to XSS or other client-side attacks if the content is executable or scriptable. The misuse lies in the static assignment of the Content-Type header without verifying the actual content type, which is a form of improper use of the standard Response API.}	```const responseToCache = new Response(blob, { status: networkResponse.status, statusText: networkResponse.statusText, headers: { 'Content-Type': 'audio/mpeg' } });```
4059	one-dns.ru.js	Improper CSRF Token Validation	High	true	N/A	9	new Request	standard	{The new Request constructor is used to create a modified request with a dynamically fetched CSRF token. While the intent is to prevent CSRF, the token is fetched via a network call and inserted into the headers without validating its origin or integrity. If an attacker can manipulate the response from the server (e.g., via a compromised backend or cache poisoning), they could inject a malicious token, leading to unauthorized actions being performed under the user’s session. This misuse of the standard Request API with untrusted dynamic data introduces a high-risk CSRF vulnerability.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
4060	one-dns.ru.js	Insecure Notification URL Handling	Medium	true	N/A	8	clients[0].navigate	standard	{The clients[0].navigate method is used to redirect the client to a URL extracted from the notification data (data.url). Since this URL is derived from server responses or potentially untrusted sources, an attacker could manipulate the notification payload to redirect users to malicious sites, leading to phishing or credential theft. This misuse of the standard clients API with unsanitized input introduces a medium-risk open redirect vulnerability.}	```clients[0].navigate(data.url);```
4061	one-dns.ru.js	Insecure Fetch in Push Event	Medium	true	N/A	7	fetch	standard	{The fetch function is used to retrieve notification data from a URL constructed using a dynamic ID from the push event data. If the ID is not properly validated or sanitized, an attacker could craft a push message with a malicious ID to trigger unintended server requests, potentially leading to information disclosure or denial of service. This misuse of the standard fetch API with untrusted input introduces a medium-risk insecure direct object reference vulnerability.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`...```
4062	nightrush.com.js	Cross-Origin Content Caching	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used to parse a response URL, and its origin is compared against self.location.origin. If the origin differs, an error is thrown. However, if an attacker can inject a URL with a different origin (e.g., via a malicious request or cache poisoning), this check may be bypassed or misused, leading to cross-origin content being cached or processed, which can result in security issues like data leakage or XSS.}	```const s = new URL(e.url).origin, if (s !== self.location.origin) throw new n('cross-origin-copy-response', { origin: s });```
4063	nightrush.com.js	Insecure Cache Key Generation	Medium	false	N/A	N/A	N/A	N/A	{The cache key generation logic uses the URL and revision to create a cache key, but it does not validate or sanitize the input. While this is not directly caused by a sensitive function, it can lead to cache key conflicts or poisoning if the input is untrusted.}	```const { cacheKey: e, url: a } = h(s), if (this._urlsToCacheKeys.has(a) && this._urlsToCacheKeys.get(a) !== e) throw new n('add-to-cache-list-conflicting-entries', { firstEntry: this._urlsToCacheKeys.get(a), secondEntry: e });```
4064	nightrush.com.js	Unvalidated Redirect Handling	High	true	N/A	N/A	new URL	standard	{The new URL constructor is used to parse a redirected response URL, and its origin is checked against self.location.origin. If an attacker can trigger a redirect to a malicious origin, this check may be bypassed or misused, allowing cross-origin content to be cached or processed, which can lead to security issues like data leakage or XSS.}	```e.redirected ? await async function (e, t) { let s = null; if (e.url && (s = new URL(e.url).origin), s !== self.location.origin) throw new n('cross-origin-copy-response', { origin: s });```
4065	nightrush.com.js	Cache Poisoning Risk	Medium	false	N/A	N/A	N/A	N/A	{The cache put operation checks if the response is safe to cache, but it does not validate the response content or headers. While this is not directly caused by a sensitive function, it can lead to cache poisoning if the response is manipulated or if the cache key is not properly validated.}	```await this._ensureResponseSafeToCache(t); if (!t) throw new n('cache-put-with-no-response', { url: p(a.url) });```
4066	nightrush.com.js	Insecure HTTP Status Handling	Low	false	N/A	N/A	N/A	N/A	{The cacheWillUpdate plugin checks if the response status is 200 or 0, but it does not validate other status codes. While this is not directly caused by a sensitive function, it can lead to insecure caching of non-200 responses if the logic is misconfigured or if the response is manipulated.}	```this.plugins.unshift(ie), ie = { cacheWillUpdate: async ({ response: e }) => 200 === e.status || 0 === e.status ? e : null }```
4067	lanos.com.ua.js	Server-Side Request Forgery (SSRF	High	true	CWE-829	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this data is received from an external source (push notification), an attacker could craft a malicious payload to redirect the fetch request to an internal or unintended endpoint, leading to SSRF. The URL is built using template literals with untrusted input, making it vulnerable.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4068	lanos.com.ua.js	Server-Side Request Forgery (SSRF	High	true	CWE-829	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since this value is derived from the client's request (which is untrusted), an attacker could manipulate the path to trigger requests to unintended internal endpoints, resulting in SSRF. The URL is built using template literals with untrusted input, making it vulnerable.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4069	lanos.com.ua.js	Open Redirect	Medium	true	CWE-602	9	N/A	standard	{The self.clients.openWindow() function is used with a URL derived from the notification data's `url` field, which is obtained from a push notification. Since push notifications can be controlled by an attacker, this allows for open redirect attacks where users are redirected to arbitrary external sites. The function blindly opens the provided URL without validation.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL)```
4070	scouter.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-919	9	fetch	standard	{The fetch function is used with a URL constructed from the `id` parameter from push notification data, which is untrusted. Although the base URL is hardcoded, the `id` parameter is dynamically inserted into the URL, potentially allowing an attacker to craft a malicious notification payload that causes the service worker to make unintended requests to internal or external resources, leading to SSRF.}	N/A
4071	scouter.com.js	Improper Input Validation (CSRF Token Path)	Medium	true	CWE-20	9	fetch	standard	{The fetch function is used with a URL constructed from the `path` parameter derived from the request URL, which is untrusted. The `path` value is directly inserted into the URL without sanitization or validation, allowing an attacker to inject arbitrary paths, potentially leading to CSRF token leakage or unauthorized actions.}	N/A
4072	scouter.com.js	Open Redirect in Notification Click	Medium	true	CWE-601	8	clients[0].navigate	standard	{The navigate method is used with a URL derived from the `data.url` field in the notification, which is sourced from server responses and is untrusted. If an attacker can manipulate the notification data, they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	N/A
4073	scouter.com.js	Insecure Fetch with Credentials	Medium	true	CWE-1004	9	fetch	standard	{The fetch function is used with the `credentials: 'include'` option on a URL constructed from the `id` parameter from push notification data. Since the `id` is untrusted, this allows an attacker to craft a malicious notification that triggers a request with credentials to a potentially malicious endpoint, leading to credential leakage or unauthorized access.}	N/A
4074	electricunicycle.org.js	XSS via unsanitized notification data	High	true	CWE-79	9	registration.showNotification	standard	{The function registration.showNotification is used with a title and options object derived from server response data, which is not sanitized. If an attacker can control the notification title or body via a server-side injection, it can lead to XSS when the notification is rendered in the browser, especially if the notification content is later displayed in a context where HTML is interpreted.}	N/A
4075	electricunicycle.org.js	CSRF token path-based fetching	High	true	CWE-306	8	registration.showNotification	standard	{The function fetch is used to retrieve a CSRF token based on a dynamically constructed URL that includes the path from the intercepted request. While not directly causing XSS, this misuse allows an attacker to manipulate the path parameter to fetch CSRF tokens for unintended endpoints, potentially enabling CSRF attacks if the token is used in subsequent requests. The path is derived from the request URL without validation, making it sensitive to manipulation.}	N/A
4076	electricunicycle.org.js	Open redirect via notification URL	Medium	true	CWE-601	9	clients.navigate	standard	{The function clients.navigate is used with a URL derived from notification data, which is not validated or sanitized. If an attacker can control the notification data (e.g., via server-side manipulation), they can redirect users to arbitrary external URLs, leading to open redirect vulnerabilities. This is particularly dangerous if the user is logged in, as it may lead to phishing or credential theft.}	N/A
4077	agoracupom.com.br.js	Caching Sensitive Data Without Authentication Check	High	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by a design flaw: the service worker caches resources without verifying if the user is authenticated or authorized. This could allow unauthorized access to sensitive data if the cached content includes protected resources.}	```'use strict';const cacheName = 'http://www.agoracupom.com.br-superpwa-2.2.31';const startPage = 'https://www.agoracupom.com.br';const offlinePage = 'https://www.agoracupom.com.br';const filesToCache = [startPage, offlinePage];const neverCacheUrls = [/\/wp-admin/, /\/wp-login/, /preview=true/];self.addEventListener('install', function (e) {  console.log('SuperPWA service worker installation');  e.waitUntil(caches.open(cacheName).then(function (cache) {    console.log('SuperPWA service worker caching dependencies');    filesToCache.map(function (url) {      return cache.add(url).catch(function (reason) {        return console.log('SuperPWA: ' + String(reason) + ' ' + url);      });    });  }));});self.addEventListener('activate', function (e) {  console.log('SuperPWA service worker activation');  e.waitUntil(caches.keys().then(function (keyList) {    return Promise.all(keyList.map(function (key) {      if (key !== cacheName) {        console.log('SuperPWA old cache removed', key);        return caches.delete(key);      }    }));  }));  return self.clients.claim();});var fetchRangeData = function (event) {  var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);  console.log('Range request for', event.request.url, ', starting position:', pos);  event.respondWith(caches.open(cacheName).then(function (cache) {    return cache.match(event.request.url);  }).then(function (res) {    if (!res) {      return fetch(event.request).then(res => {        return res.arrayBuffer();      });    }    return res.arrayBuffer();  }).then(function (ab) {    return new Response(ab.slice(pos), {      status: 206,      statusText: 'Partial Content',      headers: [['Content-Range', 'bytes ' + pos + '-' + (ab.byteLength - 1) + '/' + ab.byteLength]]    });  }));};self.addEventListener('fetch', function (e) {  if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) {    console.log('SuperPWA: Current request is excluded from cache.');    return;  }  if (!e.request.url.match(/^(http|https):\/\//i)) return;  if (new URL(e.request.url).origin !== location.origin) return;  if (e.request.method !== 'GET') {    e.respondWith(fetch(e.request).catch(function () {      return caches.match(offlinePage);    }));    return;  }  if (e.request.headers.has('range')) {    return;  }  if ((e.request.mode === 'navigate' || e.request.mode === 'cors') && navigator.onLine) {    e.respondWith(fetch(e.request).then(function (response) {      return caches.open(cacheName).then(function (cache) {        cache.put(e.request, response.clone());        return response;      });    }).catch(function () {      return cache.match(e.request.url);    }));    return;  }  e.respondWith(caches.match(e.request).then(function (response) {    return response || fetch(e.request).then(function (response) {      return caches.open(cacheName).then(function (cache) {        cache.put(e.request, response.clone());        return response;      });    });  }).catch(function () {    return caches.match(offlinePage);  }));});function checkNeverCacheList(url) {  if (this.match(url)) {    return false;  }  return true;}```
4078	epharmacy.com.np.js	Exposure of Sensitive Information to an Unauthorized Actor	High	true	CWE-532	10	none	N/A	{The Firebase configuration object contains sensitive credentials such as apiKey, authDomain, and messagingSenderId, which are hardcoded in the service worker script. Since service workers are accessible via the browser and can be inspected by attackers, exposing these credentials allows unauthorized access to Firebase services, enabling data theft, manipulation, or denial of service. This is not caused by misuse of a sensitive function but by hardcoded sensitive data.}	"```var config = { apiKey: ""AIzaSyDOB5rOgtVoh66wSZ_5GZ1ILJ8sd4yozZ0"", authDomain: ""epharmacy-mobile.firebaseapp.com"", databaseURL: ""https://epharmacy-mobile.firebaseio.com"", projectId: ""epharmacy-mobile"", storageBucket: ""epharmacy-mobile.appspot.com"", messagingSenderId: ""1035831197794"", appId: ""1:1035831197794:web:67cffca0d127763cd2913b"" };```"
4079	epharmacy.com.np.js	Cache Poisoning via Unvalidated Fetch Response	High	false	CWE-352	0	none	N/A	{The provided code snippet does not contain any fetch or cache manipulation logic that would lead to cache poisoning. The vulnerability mentioned in the input appears to be from a different file (xn--mgbbh5ib.com.js) and is not present in this file. Therefore, this file is not vulnerable to cache poisoning via unvalidated fetch response.}	"```importScripts('https://www.gstatic.com/firebasejs/7.21.0/firebase-app.js'); importScripts('https://www.gstatic.com/firebasejs/7.21.0/firebase-messaging.js'); var config = { apiKey: ""AIzaSyDOB5rOgtVoh66wSZ_5GZ1ILJ8sd4yozZ0"", authDomain: ""epharmacy-mobile.firebaseapp.com"", databaseURL: ""https://epharmacy-mobile.firebaseio.com"", projectId: ""epharmacy-mobile"", storageBucket: ""epharmacy-mobile.appspot.com"", messagingSenderId: ""1035831197794"", appId: ""1:1035831197794:web:67cffca0d127763cd2913b"" }; firebase.initializeApp(config); const messaging = firebase.messaging(); messaging.onBackgroundMessage(function (payload) { console.log('[firebase-messaging-sw.js] Received background message ', payload); const notificationTitle = payload.notification.title; const notificationOptions = { body: payload.notification.body, icon: payload.notification.icon }; self.registration.showNotification(notificationTitle, notificationOptions); });```"
4080	xn--mgbbh5ib.com.js	Potential Cache Corruption from Unreliable Key Deletion	Medium	false	New	N/A	N/A	N/A	{The issue arises from the recursive deletion of cache keys without ensuring the cache is not being modified concurrently or from potential race conditions, but it does not stem from misuse of a sensitive function like importScripts or eval. The logic is flawed but not due to a sensitive API.}	```limitCacheSize = (name, size) => { caches.open(name).then(cache => { cache.keys().then(keys => { if (keys.length > size) { cache.delete(keys[0]).then(limitCacheSize(name, size)); } }); }); };```
4081	xn--mgbbh5ib.com.js	Caching External Resources Without Integrity Checks	High	true	CWE-434	N/A	caches.open	standard	{The caches.open function is used to cache external resources (e.g., from cdn.jsdelivr.net and cdnjs.cloudflare.com) without verifying their integrity or origin. Since these resources are fetched from third-party domains and cached without validation, an attacker could compromise the CDN or intercept the request to inject malicious code, leading to cache poisoning and potential execution of arbitrary scripts.}	```const assets = ['./', './sw.js', './index.php', './app.js', './assets/script.js', './assets/style.css', './assets/img/logo.png', './assets/img/background-img.png', './assets/img/favicon.png', 'https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.css', 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js', 'https://cdn.jsdelivr.net/npm/sweetalert2@11', './fallback.php'];```
4082	333obra.com.br.js	Insecure Use of 'no-cors' Mode in Fetch	High	true	New	7	N/A	standard	{The fetch() function is used with mode: 'no-cors', which prevents the browser from sending credentials and limits the response to opaque, making it impossible to inspect or use the response properly. This can lead to data leakage or broken functionality when attempting to cache or process cross-origin resources, especially if the resource is expected to be accessible with credentials or requires proper CORS headers.}	```event.respondWith(caches.open(cacheName).then(cache => { return cache.match(event.request).then(cachedResponse => { return cachedResponse || fetch(event.request.url, { mode: 'no-cors' }).then(fetchedResponse => { cache.put(event.request, fetchedResponse.clone()); return fetchedResponse; }); }); }));```
4083	333obra.com.br.js	Race Condition in Cookie-Driven Cache Versioning	High	true	New	9	N/A	standard	{The cookieStore.getAll() is used asynchronously to read the 'cacheVersion' cookie, but the cacheName is updated after the promise resolves, while the service worker may already be using the old cacheName in other operations (e.g., caches.open(cacheName)). This creates a race condition where the cache version may be inconsistent across different parts of the service worker, leading to incorrect cache usage or deletion.}	```event.currentTarget.cookieStore.getAll().then(cookies => { const cacheVersionCookie = cookies.find(cookie => cookie.name === 'cacheVersion'); if (cacheVersionCookie) { const cacheVersion = cacheVersionCookie.value; cacheName = cacheVersion; } });```
4084	333obra.com.br.js	Insecure Cache Version Cookie Handling	Medium	true	CWE-20	8	N/A	standard	{The cookieStore.getAll() is used to retrieve the 'cacheVersion' cookie, and its value is directly assigned to cacheName without validation or sanitization. This allows an attacker to manipulate the cookie value (e.g., via XSS or cookie injection) to force the service worker to use an arbitrary cache name, potentially leading to cache poisoning or bypassing cache versioning logic.}	```const cacheVersionCookie = cookies.find(cookie => cookie.name === 'cacheVersion'); if (cacheVersionCookie) { const cacheVersion = cacheVersionCookie.value; cacheName = cacheVersion; }```
4085	333obra.com.br.js	Incomplete Cache Deletion in Activate Event	Medium	false	New	N/A	N/A	N/A	N/A	```event.waitUntil(caches.keys().then(cacheNames => { return Promise.all(cacheNames.map(cache => { if (cache != cacheName) { return caches.delete(cache); } })); }));```
4086	bhojdeals.com.js	Using outdated Firebase library (3.9.0) with potential unpatched vulnerabilities	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase library (3.9.0), which may contain unpatched security flaws. However, this is not caused by misuse of a sensitive JavaScript function like importScripts with dynamic or untrusted input. The importScripts call uses a hardcoded, trusted URL and does not involve user-controlled or unsanitized input. Therefore, it is not a sensitive function misuse vulnerability.}	```importScripts('https://www.gstatic.com/firebasejs/3.9.0/firebase-app.js');```
4087	bsiderats.nl.js	Cache Poisoning via Unvalidated Cached Responses	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's use of `caches.match()` without validating or sanitizing the request, which could allow an attacker to manipulate cached responses if the cache is improperly populated. However, this is not directly caused by misuse of a sensitive function, but rather by a design flaw in cache handling.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } return fetch(event.request); })); });```
4088	bsiderats.nl.js	Open Redirect via Untrusted URL Construction	High	true	N/A	N/A	new URL	standard	{The `new URL()` constructor is used with `newsUrl`, which is derived from untrusted notification data. If an attacker controls `newsUrl`, they can craft a URL that redirects users to malicious sites, leading to open redirect. The function is standard and directly responsible for the vulnerability.}	```const urlToOpen = new URL(newsUrl, self.location.origin).href;```
4089	bsiderats.nl.js	XSS via Unsanitized Notification Data	Medium	true	N/A	N/A	self.registration.showNotification	standard	{The `self.registration.showNotification()` function is called with `notificationData.cTitle` and `notificationData`, which are derived from untrusted push message data. If these values contain malicious scripts or HTML, they can be rendered in the notification UI, leading to XSS. The function is standard and directly responsible for the vulnerability.}	```self.registration.showNotification(notificationData.cTitle, notificationData);```
4090	faps.club.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow(url) is used to open a new window or tab with the provided URL. When the URL is derived from user-controlled data (e.g., e.notification.data.url), it allows an attacker to redirect the user to arbitrary websites, leading to open redirect vulnerabilities. This is especially dangerous in service workers where the context is trusted and can be exploited to bypass security controls.}	```e.waitUntil(clients.openWindow(url));```
4091	faps.club.js	Server Side Request Forgery (SSRF) via Fetch Handler	High	true	CWE-918	10	fetch	standard	{The fetch(event.request) call in the fetch handler allows the service worker to make network requests based on the incoming request. If the request URL is controlled by an attacker (e.g., via a malicious client request), the service worker can be coerced into making requests to internal or restricted endpoints, leading to SSRF. This is a direct misuse of the fetch API with untrusted input.}	```return fetch(event.request);```
4092	tirunelvelicorporation.in.js	XSS via untrusted notification data	High	true	CWE-79	9	N/A	standard	{The `self.registration.showNotification()` function is used with data derived from `event.data.json().data.notification`, which is parsed from untrusted input. Since the notification payload (including title, body, and other fields) is directly used without sanitization, an attacker can inject malicious content (e.g., script tags) that may be rendered in the notification UI, leading to XSS if the browser or platform interprets the content as executable.}	```const payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title```
4093	tirunelvelicorporation.in.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	8	N/A	standard	{The `clients.openWindow(targetUrl)` and `fetch(apiUrl)` functions are used with URLs derived from untrusted notification data (`event.notification.data.url` and `event.notification.data.api_url`). Since these URLs are not validated or sanitized, an attacker can supply arbitrary URLs, leading to open redirects or SSRF if the fetch target is internal or sensitive.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl);```
4094	tirunelvelicorporation.in.js	SSRF via Unvalidated URL in Subscribe Function	High	true	CWE-919	9	N/A	standard	{The `fetch(options.api_url)` function is used with `options.api_url`, which is hardcoded but could be dynamically controlled if the `options` object is modified via external input. However, in this case, the URL is hardcoded and not directly user-controlled. The vulnerability arises because the `fetch` call is made without validating the target URL, and if `options.api_url` were to be dynamically set from untrusted input (e.g., via a message or configuration), it could lead to SSRF.}	```await fetch(options.api_url```
4095	tirunelvelicorporation.in.js	Unvalidated User-Controlled URL in Message Handling	Medium	true	CWE-601	7	N/A	standard	{The `onMessageReceivedSubscribe(url)` function receives a user-controlled `url` parameter and passes it to `subscribePushManager(url)`, which then uses it in `getDomainAndHostname(url)`. Although the URL is not directly used in a dangerous function like `importScripts`, it is passed to `new URL(url)`, which can be abused if the URL is malformed or points to an internal resource, potentially leading to information leakage or unintended behavior.}	```async function onMessageReceivedSubscribe(url) { try { await subscribePushManager(url); } catch (error) { console.log('Error in onMessageReceivedSubscribe: '```
4096	hablemosderelojes.com.js	Improper Input Validation (Potential XSS via unsanitized user input in notification reply)	High	true	CWE-79	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes user-provided data (t, which is derived from the chat channel ID extracted via regex from the notification URL). If an attacker can control or manipulate the URL passed to the notification (via a malicious push message), they could inject arbitrary paths or parameters into the request. While the primary concern here is not direct XSS, the unsanitized input in the URL could lead to unintended behavior, such as accessing unauthorized resources or triggering server-side vulnerabilities. However, the vulnerability is primarily due to improper input validation rather than direct function misuse. The fetch function itself is not inherently unsafe, but its use with unsanitized input introduces risk.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" })```"
4097	fello.se.js	Regular Expression Denial of Service (ReDoS)	Medium	true	CWE-1338	8	N/A	standard	{The regular expression /:(.+)/ is used to extract parameters from a URL pathname. If an attacker can control the pathname, they can supply a malicious string that causes catastrophic backtracking, leading to ReDoS. This is a classic case of unsafe regex usage on untrusted input.}	```params = pathname.match(/:(.+)/)[1];```
4098	fello.se.js	Insecure Message Handling	Medium	true	CWE-703	9	N/A	standard	{The service worker listens for messages and dynamically invokes functions from the MessageAPI object using the `api` property from the message data. Since the `api` value is derived from untrusted input, an attacker can trigger arbitrary function calls, potentially leading to unintended behavior or privilege escalation.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
4099	fello.se.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The use of `idbKeyval.set` does not inherently involve a sensitive function misuse. The vulnerability stems from insufficient validation of the `resources` data before storing it, but the function itself is not misused in a way that directly introduces a security flaw.}	```event.waitUntil(idbKeyval.set(`resources:${path}`, resources));```
4100	theblackvault.net.js	Server-Side Request Forgery (SSRF) via unvalidated push notification ID	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from push notification data. Since this `id` is derived from untrusted external input (push payload), an attacker can manipulate it to trigger requests to arbitrary endpoints on the server, potentially leading to SSRF if the server makes further outbound requests based on this input.}	N/A
4101	theblackvault.net.js	Server-Side Request Forgery (SSRF) via unvalidated request path in CSRF token fetch	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `path` parameter derived from the request's URL pathname. Since this `path` is not validated or sanitized, an attacker can manipulate the request path to trigger requests to arbitrary endpoints on the server, potentially leading to SSRF if the server makes further outbound requests based on this input.}	N/A
4102	xn--80aikcmnyq9bye.xn--p1ai.js	Improper Cache Control Leading to Information Exposure	High	true	CWE-200	9	RegExp	standard	{The vulnerability arises from the use of a dynamically constructed regular expression via `new RegExp(p_reg)`, where `p_reg` is built from `pages_urls` which is defined as an empty array. Although the array is empty, if it were populated with untrusted or unsanitized input, it could lead to a ReDoS or allow bypassing of intended cache control logic, potentially exposing cached resources to unintended access. The dynamic construction of the regex pattern from potentially untrusted sources makes this a sensitive function misuse.}	```const pagesReg = new RegExp(p_reg);```
4103	xn--80aikcmnyq9bye.xn--p1ai.js	Open Redirect via Unvalidated Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The `clients.openWindow(action_link)` function is called with `action_link` derived from `event.notification.data.link`, which is user-controlled via push notification payload. Since no validation or sanitization is performed on `action_link`, an attacker can craft a notification with a malicious URL, leading to an open redirect that can trick users into visiting phishing sites or malicious domains. This is a direct misuse of a sensitive function that executes navigation based on untrusted input.}	```event.waitUntil(clients.openWindow(action_link));```
4104	mixys.site.js	Improper Cache Key Generation Leading to Cache Poisoning	High	true	N/A	N/A	URL	standard	{The URL constructor is used to parse a potentially untrusted URL from the request, and the origin is extracted without sufficient validation. If an attacker can manipulate the URL to point to a different origin, it could lead to cache poisoning by allowing responses from unintended origins to be cached under the same key, potentially bypassing security checks.}	```const a = new URL(e.url).origin; if (s !== self.location.origin) throw new n.V('cross-origin-copy-response', { origin: s });```
4105	mixys.site.js	Insufficient URL Validation in Route Matching	Medium	false	N/A	N/A	N/A	N/A	{The route matching logic uses a regular expression to test the URL href, but the regular expressions themselves are derived from user-controlled or configuration-based strings (via JSON.parse), which may not be properly sanitized. However, no direct sensitive function misuse is involved—this is more of a logic or configuration flaw.}	```({ url: e }) => c.some(t => t.test(e.href)```
4106	mixys.site.js	Insecure Cache Expiration Configuration	Medium	false	N/A	N/A	N/A	N/A	{The ExpirationPlugin is configured with a very long maxAgeSeconds (one year), which is a configuration issue rather than misuse of a sensitive function. The function itself is used correctly, but the parameters are set insecurely.}	```new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })```
4107	mixys.site.js	Inadequate Response Validation in Caching Strategy	Medium	false	N/A	N/A	N/A	N/A	{The CacheableResponsePlugin is configured to only accept 200 status codes, which is a reasonable security practice. There is no misuse of a sensitive function here—this is a configuration choice, not a function misuse.}	```new a.CacheableResponsePlugin({ statuses: [200] })```
4108	mixys.site.js	Potential Stale Content Delivery Due to Long Cache TTL	Low	false	N/A	N/A	N/A	N/A	{The ExpirationPlugin is configured with a long TTL (30 days), which is a configuration decision, not a misuse of a sensitive function. The function is used correctly, but the parameters are set in a way that may lead to stale content.}	```new n.ExpirationPlugin({ maxAgeSeconds: 2592e3, maxEntries: 100 })```
4109	apartmentlove.com.js	Cache Poisoning via External Resource Caching	High	true	CWE-918	10	N/A	standard	{The service worker caches external resources from untrusted domains (e.g., Mapbox CDN URLs) using `cache.addAll()`. Since these URLs are hardcoded and not dynamically derived from user input, the vulnerability is not due to sensitive function misuse with dynamic input. However, the act of caching third-party scripts and stylesheets from external domains introduces a cache poisoning risk if those resources are compromised or if the service worker is tricked into caching malicious content. The `cache.addAll()` function is standard and safe when used with trusted, static URLs, but the risk arises from the nature of the cached content rather than misuse of the function itself.}	```self.addEventListener('install', event => { event.waitUntil(caches.open(cacheName).then(cache => cache.addAll(['/js/owl.carousel.min.js', '/js/js.cookie.js', '/js/jquery.validate.min.js', '/js/jquery-te-1.4.0.min.js', '/js/common.min.js', '/js/jquery.validate.additional.rules.js', '/js/blazy.min.js', '/js/culada.js', '/js/maps2.0.js', '/js/modernizr-2.8.1.min.js', '/js/swiper.min.js', '/js/settings.js', '/js/home.js', '/js/web-common.js', 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.0/mapbox-gl.js', 'https://api.mapbox.com/mapbox.js/v3.2.0/mapbox.js', 'https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.0/mapbox-gl.css', 'https://api.mapbox.com/mapbox.js/v3.2.0/mapbox.css', '/css/owl.carousel.min.css', '/css/jquery-ui.min.css', '/css/jquery-ui.theme.min.css', '/css/bootstrap.min.css', '/css/home.css', '/css/new-style.css', '/images/Apartment-Love-Logo.png', '/images/hero-banner.jpg', '/images/graphic-img3.png', '/images/graphic-img2.png', '/images/Affiliate-mobile.jpg']))); });```
4110	paydaysay.com.js	Improper Access Control in Service Worker	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the use of `self.addEventListener('DOMContentLoaded', ...)` within a Service Worker context, which is inherently invalid because Service Workers do not have a DOM and thus cannot respond to DOMContentLoaded events. This misuse does not stem from a sensitive function being improperly used with untrusted input, but rather from a fundamental misunderstanding of Service Worker capabilities. The code attempts to initialize OneSignal within a DOM context, which is not possible in a Service Worker, leading to improper access control or execution flow.}	"```self.addEventListener(""DOMContentLoaded"", () => { OneSignal.init({ appId: ""1bfa7007-ef0b-4876-89f0-c23f001c3f0b"", safari_web_id: ""web.onesignal.auto.3d9f0610-6ae1-419f-862e-705396ff3ef1"", notifyButton: { enable: true } }); OneSignal.Slidedown.promptPush(); });```"
4111	giustiziainsieme.it.js	Improper Request Validation Leading to Sensitive Data Caching	High	true	CWE-79	9	caches.open	standard	{The caches.open function is used to open a cache for storing responses, but it is called without validating the request URL or ensuring that only safe, intended resources are cached. The code attempts to cache any request that is not a POST and not a specific path or .mp4 file, which could lead to unintended caching of sensitive or malicious content. Since the cache name is dynamically constructed from the pwaExtensionVersion, and the caching logic is applied broadly, this misuse allows potentially sensitive data to be stored in the cache without proper validation, leading to data exposure or cache poisoning.}	```self.addEventListener('fetch', function (e) { if ('POST' != e.request.method) { var t = new URL(e.request.url); console.log(t.pathname); '/pwaextension-service-worker.js' == t.pathname || t.pathname.indexOf('.mp4') > -1 || e.respondWith(caches.match(e.request).then(function (t) { return fetch(e.request).then(function (t) { return caches.open(dynamicCacheName).then(function (a) { return 0 === e.request.url.indexOf('http') && a.put(e.request, t.clone()), t; }); }).catch(function (e) { return t || function () {}; }); }).catch(function () { return caches.match('Error'); })); } });```
4112	tamilnaducareers.in.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyCEZGY10gPbfNNfkb-lxdeNtJGze4r5Zt0' } };```
4113	tamilnaducareers.in.js	Open Redirect in Notification Click	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is user-controlled. This allows an attacker to craft a notification that redirects users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
4114	tamilnaducareers.in.js	Insufficient Message Origin Validation	Medium	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener('message') handler processes messages without validating the origin of the message sender. This allows malicious pages or scripts to send messages to the service worker, potentially triggering unintended actions or data leaks.}	```self.addEventListener('message', event => { const { command, url } = event.data; switch (command) { case WorkerMessengerCommand.AMP_SUBSCRIPTION_STATE: onMessageReceivedSubscriptionState(); break; case WorkerMessengerCommand.AMP_SUBSCRIBE: onMessageReceivedSubscribe(url); break; case WorkerMessengerCommand.AMP_UNSUBSCRIBE: onMessageReceivedUnsubscribe(); break; } });```
4115	tamilnaducareers.in.js	Improper Error Handling in Subscription	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from inadequate error handling in the subscription logic, not from misuse of a sensitive function.}	```}).catch(err => { console.log('Error:', err); });```
4116	okazuki.jp.js	Insecure Direct Object Reference (IDOR) via Dynamic Function Invocation	High	true	CWE-548	9	N/A	standard	{The vulnerability arises from using `MessageAPI[api]()` where `api` is derived from untrusted `event.data`, enabling attackers to invoke arbitrary functions in the MessageAPI object. This dynamic function invocation is a classic case of unsafe reflection, allowing an attacker to call unintended or malicious functions if they can control the `api` parameter.}	```const { api } = event.data; if (api) MessageAPI[api](event, event.data);```
4117	okazuki.jp.js	Insecure URL Parameter Parsing Leading to Code Execution	High	true	CWE-79	8	N/A	standard	{The code parses URL path parameters using `pathname.match(/:(.+)/)[1]` and then splits them into key-value pairs without sanitization. This parsed data is used to construct `data.api`, which is later used in dynamic function calls. Since the input is derived from the URL and directly used in function invocation, it enables code execution if the attacker can inject a malicious API name.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
4118	okazuki.jp.js	Unvalidated Dynamic Function Call in MessageAPI	High	true	CWE-755	9	N/A	standard	{The code performs `MessageAPI[data.api]()` without validating or whitelisting `data.api`, which is derived from untrusted input. This allows an attacker to invoke any function in the MessageAPI object, including potentially dangerous or unintended ones, leading to unauthorized actions or privilege escalation.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
4119	skogsforum.se.js	Insecure Library Loading	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute a script from a specified URL. In this case, it loads '/workbox/workbox-sw.js', which is a hardcoded, trusted path. However, the vulnerability is classified as 'Insecure Library Loading' due to potential risks if the script source were dynamic or untrusted. Since the URL is hardcoded and not derived from user input or external sources, the actual risk is low, but the function itself is sensitive because it can execute arbitrary code if misused with dynamic inputs.}	"```importScripts(""/workbox/workbox-sw.js"")```"
4120	skogsforum.se.js	Unvalidated Message Handling in Service Worker	Medium	true	New	8	addEventListener	standard	{The addEventListener('message', ...) function is used to handle messages sent to the service worker. The code checks if the message data equals 'skipWaiting' and then calls skipWaiting(). While this is not inherently dangerous, it lacks validation or authentication of the message source, allowing any page or script to trigger skipWaiting(), potentially disrupting the service worker lifecycle. This is a misuse of the event handler in a context where untrusted messages could be sent, making it a sensitive function misuse.}	"```addEventListener(""message"", a => { ""skipWaiting"" === a.data && skipWaiting(); });```"
4121	zeljeznice.net.js	Server Side Request Forgery (SSRF) via CSRF Token Fetch	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `path` parameter derived from the request URL. Since this `path` is derived from user-controlled input (request.url), an attacker could manipulate it to trigger requests to internal or external resources, leading to SSRF. The function is standard and directly responsible for the vulnerability.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`);```
4122	zeljeznice.net.js	Open Redirect via Notification URL	Medium	true	CWE-601	8	N/A	standard	{The navigate() method is used with a URL derived from the `data.url` field of a notification, which is obtained from a server response. If the server is compromised or the notification data is manipulated, this can lead to open redirect attacks, allowing attackers to redirect users to arbitrary sites. The navigate() function is a standard browser API and is directly responsible for the vulnerability.}	```clients[0].navigate(data.url);```
4123	z1000-forum.de.js	Insecure CSRF Token Handling	High	true	CWE-352	9	new Request	standard	{The vulnerability arises from the misuse of the standard JavaScript `new Request()` constructor, which is used to create a new request object with a dynamically injected CSRF token. The token is fetched from a server endpoint based on the current URL path, which is derived from the intercepted request. While the token itself is dynamically generated, the function is misused in a way that allows an attacker to potentially manipulate the request context (e.g., via crafted URLs or intercepted requests) to bypass CSRF protections. The `new Request()` function is not inherently unsafe, but its use here with dynamically constructed headers and credentials, without proper validation or origin checks, introduces a high-risk CSRF vulnerability.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
4124	bimeon.date.js	Regular Expression Denial of Service (ReDoS	High	true	CWE-1338	10	RegExp	standard	{The code dynamically constructs a regular expression using `new RegExp(url, 'g')` where `url` is derived from the notification title, which is user-controlled via push messages. This allows an attacker to craft a malicious notification title containing a pathological regular expression pattern (e.g., `(a+)+`), leading to ReDoS by causing the regex engine to consume excessive CPU time during matching.}	```var re = new RegExp(url, 'g');```
4125	bimeon.date.js	Improper Input Validation (Vibrate DoS	Medium	false	N/A	N/A	N/A	N/A	{The code assigns `vibrate` from `data.vibrate` without validation, but this does not involve a sensitive function misuse. The potential DoS arises from improper handling of the vibrate pattern, not from a sensitive function like `importScripts` or `eval`.}	```var vibrate = data.vibrate || null;```
4126	receivablesradius.com.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the productModule variable, which is derived from the script's internal logic but not validated. This allows an attacker to potentially manipulate the productModule value (if exposed via an API or message event) to trigger requests to unintended internal or external endpoints, leading to SSRF. The URL is built as '/' + productModule + '/static/build.json?b=' + Date.now(), making it vulnerable to arbitrary path traversal or external host access if productModule is controlled by an attacker.}	```fetch('/' + productModule + '/static/build.json?b=' + Date.now()).then(function (response) { return response.json(); }).then(function (responseStr) { for (var key in responseStr) { allBuildTimeStamps[key] = responseStr[key]; } if (allBuildTimeStamps[productModule + '_STATIC'] != undefined && allBuildTimeStamps[productModule + '_STATIC'] != productModule + '_STATIC_BUILD_TIME_STAMP_HOLDER') { cache.add(array[key] + '' + allBuildTimeStamps[productModule + '_STATIC']); } else { cache.add(array[key] + '' + allBuildTimeStamps[productModule + '_DYNAMIC']); } });```
4127	receivablesradius.com.js	Insecure Direct Object Reference (IDOR)	Medium	false	CWE-548	N/A	N/A	N/A	{The vulnerability arises from the direct assignment of event.data.rrdmsStaticBuildTimeStampValue to allBuildTimeStamps['RRDMSProject_STATIC'] without validation or authentication checks. However, this is not caused by misuse of a sensitive JavaScript function, but rather by insecure logic in handling message events. The function used (assignment via =) is not inherently sensitive.}	```if (event.data.rrdmsStaticBuildTimeStampValue != undefined) { allBuildTimeStamps['RRDMSProject_STATIC'] = event.data.rrdmsStaticBuildTimeStampValue; }```
4128	receivablesradius.com.js	Improper Cache Invalidation	Medium	false	CWE-369	N/A	N/A	N/A	{The vulnerability stems from improper logic in cache deletion based on cache names, which are derived from build timestamps. The issue is a logic flaw in cache management, not misuse of a sensitive JavaScript function like caches.delete(). The function itself is used correctly; the problem lies in the conditional logic that may not delete all stale caches.}	```if (cache !== allBuildTimeStamps['RRDMSProject_STATIC']) { return caches.delete(cache); } else { if (cache !== allBuildTimeStamps['RRDMSProject_DYNAMIC']) { return caches.delete(cache); } }```
4129	computer-idea.it.js	Open Redirect via Unvalidated URL in Service Worker	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from untrusted notification data (event.notification.data.url). Since this URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.computer-idea.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url));});```
4130	computer-idea.it.js	SSRF via Unvalidated URL in Service Worker	High	true	CWE-807	10	fetch	standard	{The function fetch is used with a URL constructed from untrusted data (event.notification.data.sensor and event.data.json()). Since these values are not validated, an attacker can manipulate them to make the service worker send requests to internal or external systems, leading to SSRF vulnerabilities.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.computer-idea.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
4131	filmyworld.icu.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (Firebase API key, VAPID public key, etc.) directly in the client-side JavaScript code, which is accessible to anyone inspecting the page. This is not caused by misuse of a sensitive function, but rather by poor configuration practices.}	```const options = { firebaseConfig: { projectId: 'nrlccp', messagingSenderId: '49189167977', appId: '1:49189167977:web:a1bdb8ec19b333465993f8', apiKey: 'AIzaSyCBFKF_hg4U7CdrQawAep2E3ii1iGwKNCI' }, domain: 'filmyworld.makeup', api_url: 'https://larapush.netnaija.in/api/token', vapid_public_key: 'BOOfC4Co6zgWzwE4Y9QwBU367uXGPuyy5pPl4bBtmbXQ3ml6pxPy5_3nWZKzI98m1rqug7GnyGvwS17WfXmCh24' };```
4132	filmyworld.icu.js	XSS via Unvalidated Notification Payload	High	true	N/A	N/A	showNotification	standard	{The showNotification function is used with a payload that is derived from untrusted data (event.data.json().data.notification). Since the payload is not sanitized, an attacker can inject malicious content into the notification title or body, leading to XSS if the notification is rendered in a context that executes script.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
4133	filmyworld.icu.js	Improper Input Validation for Notification URLs	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from notification data without validation. If an attacker can control the notification payload, they can redirect users to arbitrary URLs, potentially leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl); fetch(apiUrl);```
4134	filmyworld.icu.js	Insecure Storage of Sensitive Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (like notification tokens) in IndexedDB without encryption or additional security controls. This is not due to misuse of a sensitive function, but rather a design flaw in data storage practices.}	```const request = objectStore.put({ id: key, data: value });```
4135	filmyworld.icu.js	Transmission of Sensitive Data Over Unvalidated API URL	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used to send sensitive data (notification token, endpoint keys) to options.api_url, which is hardcoded and not validated. If this URL is compromised or misconfigured, it could lead to data exfiltration or interception.}	"```await fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
4136	humphreyscountynursinghome.org.js	XSS via untrusted notification payload	High	true	CWE-79	9	N/A	standard	{The showNotification function is used with payload data that is directly derived from the push event's data, which is untrusted. Since the payload.title and other fields are passed directly into the notification without sanitization, an attacker can inject arbitrary HTML or JavaScript into the notification content, leading to Cross-Site Scripting (XSS) when rendered in the user's browser.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
4137	humphreyscountynursinghome.org.js	SSRF via unvalidated notification URL	High	true	CWE-918	9	N/A	standard	{The fetch function is called with apiUrl, which is derived from the notification data. Since this data is untrusted and not validated or sanitized, an attacker can supply a malicious URL (e.g., internal network endpoints or other services) causing the service worker to make unauthorized requests on behalf of the user, leading to Server-Side Request Forgery (SSRF).}	```fetch(apiUrl);```
4138	ihmshimla.org.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding the Firebase API key in the script, which is not a result of improper use of a sensitive function but rather a misconfiguration or poor secret management.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyD4kvwxm2vfvlGg4AyFeJYx143QhST07V4' } };```
4139	ihmshimla.org.js	XSS via Notification Data	High	true	N/A	N/A	showNotification	standard	{The showNotification function is called with user-controlled data from the payload object, which is derived from the push event's data. Since the payload.title and other fields are directly passed without sanitization, an attacker can inject malicious content that may be rendered in the notification UI, leading to XSS if the browser or platform interprets the content as executable script or HTML.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
4140	ihmshimla.org.js	Open Redirect via Notification Click	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from the notification data. If an attacker can control the notification payload, they can set targetUrl to an arbitrary URL, causing the browser to open a malicious site, leading to an open redirect vulnerability.}	```clients.openWindow(targetUrl);```
4141	jpmcbly.co.in.js	XSS via untrusted HTML insertion	High	true	CWE-79	9	N/A	standard	{The function `insertAdjacentHTML` is a standard DOM API that directly inserts HTML strings into the document. When used with untrusted data (e.g., `i` from `e.PushRocketPopup`), it can lead to Cross-Site Scripting (XSS) if the input contains malicious scripts. The code does not sanitize or escape the input, allowing attackers to inject arbitrary JavaScript.}	"```document.body.insertAdjacentHTML(""afterbegin"", i);```"
4142	jpmcbly.co.in.js	Insecure Data Transmission	Medium	false	CWE-311	N/A	N/A	N/A	{The vulnerability arises from transmitting sensitive data (push subscription tokens) over HTTP without encryption, not from misuse of a sensitive function. The `fetch` call is used correctly, but the underlying protocol (HTTP) is insecure.}	```var o = JSON.stringify(await (await navigator.serviceWorker.ready).pushManager.subscribe({userVisibleOnly: !0,applicationServerKey: a}));```
4143	jpmcbly.co.in.js	Insecure External API Usage	Medium	false	CWE-919	N/A	N/A	N/A	{The issue stems from using a third-party API (`api.ipinfodb.com`) with a hardcoded API key, which is a misconfiguration rather than misuse of a sensitive function. The `fetch` function is used appropriately, but the key exposure is the root cause.}	```let a = await fetch('https://api.ipinfodb.com/v3/ip-city/?key=ee8b2815903c4b76b44daab5b4848ce16df85fb2233c8dfaf9b7104a72fd89fc&format=json', {method: 'GET'});```
4144	jpmcbly.co.in.js	Firebase Config Injection	High	true	CWE-200	9	N/A	standard	{The `firebase.initializeApp` function is a standard Firebase API that initializes the SDK with provided configuration. When the configuration is derived from untrusted external data (e.g., `e.APIKey`, `e.AuthDomain`), it allows an attacker to inject arbitrary Firebase credentials, leading to unauthorized access or data leakage.}	```firebase.initializeApp({...i.firebaseConfig});```
4145	jpmcbly.co.in.js	Error Handling Omission	Medium	false	CWE-703	N/A	N/A	N/A	{The vulnerability is due to unhandled exceptions in `try-catch` blocks, which can lead to silent failures. This is a logic or design flaw, not misuse of a sensitive function.}	```catch (n) {}```
4146	onlinejobhelp.in.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The function clients.openWindow(targetUrl) is used with a dynamic URL derived from event.notification.data.url, which is user-controlled. This allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
4147	onlinejobhelp.in.js	Server Side Request Forgery	High	true	CWE-918	9	N/A	standard	{The function fetch(apiUrl) is used with a dynamic URL derived from event.notification.data.api_url, which is user-controlled. This allows an attacker to make the service worker perform HTTP requests to arbitrary endpoints, leading to SSRF vulnerabilities.}	```fetch(apiUrl);```
4148	onlinejobhelp.in.js	Improper Input Validation	Medium	true	CWE-20	8	N/A	standard	{The function JSON.parse(event.data.json().data.notification) parses JSON data from a user-controlled source (event.data.json().data.notification). If the input is not validated, it may lead to injection or unexpected behavior, especially if the parsed data is used in subsequent operations without sanitization.}	```const payload = JSON.parse(event.data.json().data.notification);```
4149	onlinejobhelp.in.js	Insecure Data Storage	Low	false	CWE-311	N/A	N/A	N/A	N/A	```const request = objectStore.put({id: key, data: value});```
4150	varzeshrooz.com.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and points to an external domain (van.najva.com), which is outside the origin of the service worker. While the URL is not dynamically constructed from untrusted input, loading scripts from external domains still poses a high risk if those domains are not fully trusted or could be compromised, leading to potential script injection or unauthorized access to service worker capabilities. This constitutes a misuse of the sensitive function because it violates the principle of least privilege and introduces an attack surface through external script execution.}	```importScripts('https://van.najva.com/static/js/scripts/new-website679611-website-56829-e38364e0-8598-457a-a11e-e5ce1a5d152c-service-worker.js');```
4151	nixcraft.com.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The vulnerability arises from the use of `clients.openWindow(n + e)` where `e` is derived from the notification data URL, which is controlled by the server sending the push notification. Since the server can craft arbitrary URLs in the push payload, an attacker could manipulate the `e` value to redirect users to malicious sites. The `clients.openWindow()` function is a standard browser API that opens a new window or tab with the specified URL, and when used with untrusted input, it enables open redirect attacks.}	```if (!t.some(function (t) { return t.url === n + e && 'focus' in t ? (t.focus(), !0) : 'postMessage' in t && 'focus' in t && (t.focus(), t.postMessage({ url: e }), !0); }) && clients.openWindow) return clients.openWindow(n + e);```
4152	aipi.de.js	Undefined Variable in Cache Name Leading to Potential DoS	High	false	N/A	N/A	N/A	N/A	{The issue arises from the use of an undefined variable `CACHE_NAME` in the `caches.open(CACHE_NAME)` call. While `caches.open()` is a sensitive function, the vulnerability here is not due to misuse of the function with untrusted input, but rather due to a programming error (undefined variable). This can lead to runtime errors or unexpected behavior, potentially causing denial of service if the service worker fails to handle the error gracefully. Since the input is not dynamic or user-controlled, this is not a sensitive function misuse.}	```event.respondWith(fetch(event.request).catch(() => { return caches.open(CACHE_NAME).then(cache => { return cache.match('offline.html'); }); }));```
4153	banouto.bj.js	Improper Cache Versioning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using `new Date().getTime()` to generate a dynamic cache name, which leads to frequent cache invalidation and unnecessary re-downloads. This is not caused by misuse of a sensitive function, but rather by poor design in cache versioning strategy.}	"```var staticCacheName = ""pwa-v"" + new Date().getTime();```"
4154	helpersnearme.com.js	Cross-Site Scripting via Unverified CDN Import	High	true	CWE-928	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a CDN (https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js). While the URL is hardcoded and not derived from untrusted input, the vulnerability arises because the CDN is not fully trusted or verified. An attacker could potentially compromise the CDN or the specific release path, leading to malicious script injection. Since the script is executed with full privileges in the service worker context, this constitutes a high-risk vulnerability. The misuse lies in trusting an external, unverified source for critical script execution.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js');```
4155	poocoo.pl.js	Improper Caching of Sensitive Data	High	true	CWE-921	9	caches.put	standard	{The caches.put function is used to store responses in the cache, but it does not validate or sanitize the request URL or response content. Since the URL is derived directly from e.request.url (which can be controlled by the user via network requests), and no checks are performed to ensure the data being cached is safe or intended for caching, this allows sensitive data (e.g., authentication tokens, personal information) to be stored in the cache. This can lead to data leakage if the cache is accessed by other contexts or if the service worker is compromised.}	```e.respondWith(caches.open(cacheName).then(function (cache) { return fetch(e.request).then(function (response) { cache.put(e.request.url, response.clone()); return response; }); }));```
4156	xstoregames.com.js	Server Side Request Forgery (SSRF) via unvalidated fetch request	High	true	CWE-829	N/A	this.addEventListener('fetch'	standard	{The fetch() function is used without validating or sanitizing the request URL, which is derived from the event's request object. Since the service worker handles arbitrary fetch events from the client, an attacker could trigger a fetch request to an internal or external resource, leading to SSRF. The function is standard and directly exposed to untrusted input via the event object.}	```this.addEventListener('fetch', eve => { if (eve.request.headers.has('range')) { return; } eve.respondWith(fetch(eve.request)); });```
4157	xstoregames.com.js	Improper Input Validation in BroadcastChannel message handling	Medium	true	CWE-20	N/A	broadcast.addEventListener('message'	standard	{The BroadcastChannel message handler processes incoming data without validating or sanitizing the 'sort' and 'filter' properties. These values are used directly to index into the 'sorting' object and to call toSorted(), which could lead to arbitrary code execution or unexpected behavior if the input is manipulated. The function is standard and exposed to untrusted input from the BroadcastChannel.}	```broadcast.addEventListener('message', eve => { const sort = eve.data.sort; const filter = eve.data.filter; let games = eve.data.games; if (filter) { games = games.filter(g => sorting[filter](g, g) === 1); } if (sort) { games = games.toSorted(sorting[sort]); } broadcast.postMessage({ games }); });```
4158	agridirect.ie.js	Improper Input Validation in Push Event Handling	High	true	CWE-703	10	JSON.parse	standard	{The JSON.parse function is used to parse untrusted data from event.data.text() without validation. If the data is malformed or crafted by an attacker, it can lead to unexpected behavior or potential injection vectors, especially since the parsed data is used directly in notification options like title, body, icon, and click_action, which could be exploited to redirect users to malicious sites or display phishing content.}	```self.addEventListener('push', function (event) { var data = JSON.parse(event.data.text()); const title = data.title; const options = { body: data.message, icon: data.icon, badge: data.icon, click_action: data.link, data: JSON.stringify(data) }; event.waitUntil(self.registration.showNotification(title, options)); });```
4159	animerush.in.js	Empty Fetch Event Handler	Low	false	N/A	0	N/A	N/A	{The fetch event handler is empty, meaning no logic is implemented to intercept or handle network requests. This is not a security vulnerability caused by misuse of a sensitive function, but rather a lack of functionality. No sensitive function is being misused here.}	```self.addEventListener('fetch', evt => {});```
4160	contardias.com.br.js	Cache Poisoning via Unvalidated Network Response	High	true	CWE-918	10	cache.put	standard	{The cache.put() function is used to store a network response in the cache without validating its origin or content. Since the response is obtained from fetch(evt.request) and evt.request can be any URL (including external or malicious ones), an attacker could craft a request that returns a malicious response, which is then cached and served to subsequent users. This allows cache poisoning, where the service worker serves tampered content to users, potentially leading to XSS or data exfiltration.}	```return fetch(evt.request).then(networkResponse => { cache.put(evt.request, networkResponse.clone()); return networkResponse; });```
4161	friv.com.br.js	Insecure Cache Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the static nature of the cache configuration. The code caches only predefined files (./ and index.html), which does not introduce dynamic or untrusted input risks. Therefore, no sensitive function misuse is involved.}	```return cache.addAll(filesToCache);```
4162	gtagame.online.js	Improper Error Handling in Cache Fallback	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling during cache fallback, but it is not caused by misuse of a sensitive JavaScript function. The code attempts to fetch a resource and cache it, but if the fetch fails, it falls back to a cached response. However, the fallback logic is flawed because it does not properly handle the case where `caches.match(t)` returns undefined, and the nested function incorrectly references `req.url` which is not defined in scope. This is a logic error, not a sensitive function misuse.}	```self.addEventListener('fetch', function (t) { const e = t.request; !function (t) { return 'GET' == t.method && n.some(e => t.url.match(e)); }(e) ? t.request.url : t.respondWith(function (t) { return fetch(t).then(e => { const n = e.clone(); return caches.open(c('resources')).then(e => { e.put(t, n); }), t.method, t.url, e; }); }(e).catch(() => function (t) { return caches.match(t).then(e => e || function (t) { if (t.method, t.url, t.url.match(/^https?:\/\/(www|dev|static)?.gtagame.online\/*/)) return caches.match(req.url); }(t)); }(e))); });```
4163	laplata1.com.js	Open Redirect via Unvalidated Notification Data	High	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided in the notification data (event.notification.data.openUrl). Since this value is derived from untrusted push notification data without validation or sanitization, an attacker can craft a malicious notification payload to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); fetch('https://www.laplata1.com/push_view?id=' + event.notification.data.id + '&nocache=' + Math.random() * 1000); if (clients.openWindow) { return clients.openWindow(event.notification.data.openUrl); } });```
4164	laplata1.com.js	Insecure Dynamic Resource Loading	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function but rather by the use of untrusted data (data.cuerpo) in the notification options, which could lead to content injection or XSS if rendered in a context where it's not properly escaped. However, no sensitive function like importScripts or eval is involved.}	```const options = { body: data.cuerpo, icon: 'https://www.laplata1.com/iconx/pwa-192x192.png', badge: 'https://www.laplata1.com/iconx/android-192x192.png', image: data.imagen, data: { id: data.id, openUrl: data.openUrl } };```
4165	laplata1.com.js	Insecure Data Handling in Push Event	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from parsing and using untrusted push data without validation, but no sensitive JavaScript function is directly misused. The risk is more about data integrity and potential injection in downstream operations, not a direct function misuse.}	```self.addEventListener('push', e => { const data = JSON.parse(e.data.text()); const title = data.titulo; const options = { body: data.cuerpo, icon: 'https://www.laplata1.com/iconx/pwa-192x192.png', badge: 'https://www.laplata1.com/iconx/android-192x192.png', image: data.imagen, data: { id: data.id, openUrl: data.openUrl } }; e.waitUntil(self.registration.showNotification(title, options)); });```
4166	lucrassino.com.js	Cryptographic Key Exposure	High	true	N/A	N/A	crypto.subtle.generateKey	standard	{The code uses crypto.subtle.generateKey to generate cryptographic key pairs, but the key generation is based on user-controlled or dynamically derived inputs (via this.#w(this.#r) and this.#w(this.#i)), which are obfuscated and potentially derived from sensitive or untrusted sources. This misuse allows an attacker to predict or influence the key generation process, leading to key exposure or compromise. The keys are then used in subsequent cryptographic operations without proper protection, increasing the risk of exposure.}	```const [t, n] = await Promise[Y(567)]([crypto[Y(573)][Y(537)](Y(589), this.#w(this.#r), {name: Y(554), hash: {name: Y(513)}}, !1, [Y(514)]), crypto[Y(573)][Y(537)](Y(565), this.#w(this.#i), {name: Y(584), hash: {name: Y(513)}}, !1, [Y(485)])]);```
4167	magelanci.com.js	Server Side Request Forgery (SSRF) via unvalidated 'id' parameter in push event	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from untrusted push notification data. Since the 'id' value is not validated or sanitized, an attacker can manipulate it to trigger requests to internal or external resources, leading to SSRF. The URL is built using template literals with user-controlled input, making it a direct misuse of the fetch API.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4168	magelanci.com.js	CSRF Token Handling Without Origin Check	Medium	true	CWE-352	8	fetch	standard	{The fetch function is used to retrieve a CSRF token based on a dynamically constructed path from the request URL. Although the path is derived from the current request, it is not validated against a whitelist or origin check, allowing an attacker to potentially trigger CSRF token retrieval for unintended endpoints, which could be exploited in conjunction with other vulnerabilities.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4169	magelanci.com.js	Unvalidated URL in Notification Click Leading to Phishing	Medium	true	CWE-601	9	navigate	standard	{The navigate method is used with a URL derived from the notification data, which is sourced from a push event. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading users to phishing sites when they click the notification. This is a direct misuse of the navigate API with untrusted input.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
4170	rollsun.com.js	Improper Regular Expression for API Route Matching	Medium	false	CWE-20	N/A	N/A	N/A	"{The vulnerability arises from a flawed regular expression pattern in the route matching logic, specifically `e.origin.indexOf(""/api"")`, which does not properly validate or sanitize the URL origin. This can lead to unintended route matching and potential bypasses, but it is not caused by misuse of a sensitive JavaScript function.}"	"```e.registerRoute(({ url: e }) => e.origin.indexOf(""/api"")```"
4171	rollsun.com.js	Dynamic Script Loading Without Input Validation	High	true	CWE-918	N/A	importScripts	N/A	"{The `importScripts()` function is a sensitive API that executes remote scripts. In this code, it is called with a dynamically constructed URL `s`, which is derived from an external source (e.g., `new URL(s + "".js"", t).href`). If `s` is not validated or sanitized, an attacker could supply a malicious script URL, leading to arbitrary code execution in the service worker context.}"	"```if (""document"" in self) { const e = document.createElement(""script""); e.src = s, e.onload = n, document.head.appendChild(e); } else e = s, importScripts(s), n();```"
4172	rollsun.com.js	Potential XSS via Unsanitized Module URLs	High	true	CWE-79	N/A	new URL	N/A	"{The `new URL()` constructor is a sensitive function when used with untrusted input. Here, it is used with `s + "".js""` where `s` is a dynamic input. If `s` is controlled by an attacker, it could result in a malicious URL being constructed and loaded, potentially leading to XSS or other injection attacks, especially if the resulting URL is used in a context that executes or renders untrusted content.}"	```const e = new URL(s + '.js', t).href```
4173	shipfriends.gr.js	Open Redirect	Medium	true	N/A	9	N/A	standard	{The `clients[0].navigate(data.url)` call uses a dynamic URL from the notification data, which is controlled by the server or potentially an attacker. Since the `data.url` is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to an open redirect. This allows redirection to arbitrary domains, potentially phishing users or bypassing security controls.}	```self.addEventListener('notificationclick', e => { const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
4174	suedtirolerjobs.it.js	Improper Neutralization of URL Redirect	Medium	true	CWE-601	9	N/A	standard	{The function clients.openWindow() is a standard browser API used to open a new window or tab with a specified URL. In this code, the URL is derived from the notification's data (i.e., i.url), which originates from a push message. Since push messages can be controlled by an attacker (if the server is compromised or if the message is crafted maliciously), the URL is untrusted. If not validated or sanitized, this allows an attacker to redirect the user to a malicious site, leading to phishing, credential theft, or other attacks. This constitutes improper neutralization of URL redirects.}	```t.waitUntil(clients.openWindow(i.url));```
4175	tamil.wiki.js	Debug Mode Enabled in Production	Medium	false	CWE-200	N/A	N/A	N/A	{Debug mode exposes internal details and logs that can aid attackers in understanding the application's behavior and identifying potential vulnerabilities. However, it is not caused by misuse of a sensitive function like importScripts or eval, but rather a configuration setting.}	```workbox.setConfig({ debug: true });```
4176	tamil.wiki.js	Regex Case-Insensitivity in Navigate Route Exclusion	Medium	false	CWE-312	N/A	N/A	N/A	{The vulnerability arises from the lack of case-insensitivity in the regex match for 'Login', which may allow bypassing the exclusion rule. This is a logic flaw in the route condition, not due to misuse of a sensitive function.}	```registerRoute(({ request, url }) => request.mode === 'navigate' && !url.pathname.match('Login') && !url.pathname.startsWith('/index.php'), new StaleWhileRevalidate({ cacheName: 'page-cache', plugins: [new ExpirationPlugin({ maxAgeSeconds: 12 * 60 * 60 }), new BroadcastUpdatePlugin()] }));```
4177	tamil.wiki.js	Precaching External Resources Without Versioning	Medium	false	CWE-495	N/A	N/A	N/A	{This vulnerability stems from precaching an external resource (Tailwind CSS) without a revision hash, which can lead to stale or malicious content being served. It is a configuration issue, not misuse of a sensitive function.}	```workbox.precaching.precacheAndRoute([{ url: 'https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css', revision: null }], { cleanUrls: false });```
4178	tamil.wiki.js	Custom Fetch Handler Bypassing Workbox Strategies	Medium	true	New	N/A	fetch	standard	{The self.addEventListener('fetch', ...) handler directly uses fetch(event.request) without routing through Workbox strategies, bypassing caching and security controls. This misuse of the standard fetch API allows uncontrolled network requests, potentially exposing the app to MITM or cache poisoning if not properly secured.}	```self.addEventListener('fetch', event => { console.log(`URL requested: ${event.request.url}`); event.respondWith(fetch(event.request)); });```
4179	dosbods.co.uk.js	Server Side Request Forgery (SSRF) via Unvalidated Path in CSRF Token Request	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL where the `path` parameter is derived from the request URL without validation. This allows an attacker to manipulate the `path` value to trigger requests to unintended internal or external endpoints, leading to SSRF. The URL is built as `${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`, and since `path` is taken directly from the request URL, it can be controlled by an attacker.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {```
4180	dosbods.co.uk.js	Incorrect Handling of loggedIn Parameter Leading to CSRF Bypass	Medium	false	CWE-352	0	N/A	N/A	{The vulnerability arises from improper logic handling of the `loggedIn` parameter via regex matching on the current URL, not from misuse of a sensitive JavaScript function. The code uses `e.currentTarget.location.href.match(/loggedIn=(true|false)/)` to extract the value, but this is not inherently unsafe; the issue is in the logic that relies on this value without proper validation or context, which is a business logic flaw rather than a sensitive function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
4181	gyrotechjob.in.js	Exposure of Sensitive Information to an Unauthorized Actor	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from exposing Firebase configuration details (API key, project ID, etc.) in the service worker script, which is accessible to clients. While not directly caused by a sensitive function misuse, it is a static exposure of credentials.}	```firebase.initializeApp({ ...options.firebaseConfig });```
4182	gyrotechjob.in.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The JSON.parse() call on event.data.json().data.notification is not inherently unsafe if the input is trusted, but since the payload originates from a push message (which can be controlled by an attacker), it may lead to improper handling of untrusted data. However, no direct sensitive function misuse is involved.}	```const payload = JSON.parse(event.data.json().data.notification);```
4183	gyrotechjob.in.js	Open Redirect	High	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow(targetUrl) function is used with a dynamic URL derived from notification data, which can be controlled by an attacker. This allows redirection to arbitrary URLs, enabling open redirect attacks.}	```clients.openWindow(targetUrl);```
4184	gyrotechjob.in.js	Server Side Request Forgery	High	true	CWE-918	N/A	fetch	standard	{The fetch(apiUrl) function is called with a URL derived from notification data, which can be controlled by an attacker. This enables SSRF attacks, allowing the service worker to make requests to internal or unintended endpoints.}	```fetch(apiUrl);```
4185	gyrotechjob.in.js	Server Side Request Forgery	High	true	CWE-918	N/A	getDomainAndHostname	standard	{The getDomainAndHostname(url) function parses a URL provided by an untrusted source (notification data) and returns its hostname. This hostname is then used in a fetch request, enabling SSRF if the URL is controlled by an attacker.}	```domain = getDomainAndHostname(url).hostname;```
4186	ispacnr.it.js	Vulnerable URL Construction Leading to SSRF	High	true	CWE-918	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (body.data.sensor). Since the sensor URL is not validated or sanitized, an attacker could supply a malicious URL pointing to internal resources, leading to Server-Side Request Forgery (SSRF).}	N/A
4187	ispacnr.it.js	Vulnerable URL Construction Leading to Phishing	Medium	true	CWE-601	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (event.notification.data.sensor). Since the sensor URL is not validated or sanitized, an attacker could supply a malicious URL that redirects users to phishing sites, leading to phishing attacks.}	```self.addEventListener('notificationclick', function (event) {  event.notification.close();  var vc = event.notification.data.sensor + '/e?site_name=www.ispacnr.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click';  fetch(vc, {    method: 'get'  }).then(response => response.json()).catch(err => {});  event.waitUntil(clients.openWindow(event.notification.data.url));});```
4188	thelordmm.com.js	Supply Chain Compromise via External CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute a script from an external CDN URL specified in the options.workboxURL variable. Since this URL is hardcoded but dynamically referenced via a configuration object, it introduces a supply chain risk: if the CDN or the package is compromised, the service worker will execute malicious code. Although the URL is not user-controlled, the reliance on an external source without integrity verification (e.g., subresource integrity) makes it a sensitive function misuse.}	"```const options = { ""workboxURL"": ""https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js"", ""importScripts"": [], ""config"": { ""debug"": false }, ""cacheOptions"": { ""cacheId"": ""TriplexCustom-prod"", ""directoryIndex"": ""/"", ""revision"": ""giB2abBgbAhl"" }, ""clientsClaim"": true, ""skipWaiting"": true, ""cleanupOutdatedCaches"": true, ""offlineAnalytics"": false, ""preCaching"": [{ ""revision"": ""giB2abBgbAhl"", ""url"": ""/"" }], ""runtimeCaching"": [{ ""urlPattern"": ""/_nuxt/"", ""handler"": ""CacheFirst"", ""method"": ""GET"", ""strategyPlugins"": [] }, { ""urlPattern"": ""/"", ""handler"": ""NetworkFirst"", ""method"": ""GET"", ""strategyPlugins"": [] }], ""offlinePage"": null, ""pagesURLPattern"": ""/"", ""offlineStrategy"": ""NetworkFirst"" }; importScripts(...[options.workboxURL, ...options.importScripts]);```"
4189	bangladeshaccord.org.js	Cache Poisoning via URL Parameter Manipulation	High	true	CWE-434	9	stripIgnoredUrlParameters	standard	{The function stripIgnoredUrlParameters is used to process URLs by removing ignored query parameters, but it does not sanitize or validate the input URL. If an attacker can manipulate the URL parameters (e.g., via a crafted request), they may influence the cache key generation or cause unintended cache behavior, leading to cache poisoning. The function parses and modifies the URL based on dynamic input, which can be exploited if not properly constrained.}	```var t = stripIgnoredUrlParameters(a.request.url, ignoreUrlParametersMatching);```
4190	bangladeshaccord.org.js	Insecure Navigation Handling	Medium	false	CWE-602	7	N/A	N/A	{The vulnerability arises from logic that checks if a request mode is 'navigate' and whether the path is whitelisted, but it does not involve misuse of a sensitive JavaScript function. The issue is in the logic flow and path matching, not in a function that directly introduces risk via untrusted input.}	"```!e && ""navigate"" === a.request.mode && isPathWhitelisted([""^(?!\\/__).*""], a.request.url) && (t = new URL(c, self.location).toString(), e = urlsToCacheKeys.has(t))```"
4191	bangladeshaccord.org.js	Insecure Cache Key Generation	Medium	true	CWE-352	8	createCacheKey	standard	{The function createCacheKey constructs a cache key by appending a hash parameter to a URL, using dynamic input (e.g., the URL and hash value). If the input URL or hash value is derived from untrusted sources, it can lead to cache key collisions or manipulation, allowing attackers to poison the cache. The function is standard but misused when applied to untrusted data without validation.}	```var c = createCacheKey(n, hashParamName, t, /\.\w{8}\./);```
4192	lh918.com.js	Improper Validation of Same-Origin Requests	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from the use of `e.pathname.includes()` to match URL paths without validating the origin of the request. While `includes()` is not a sensitive function, the logic fails to enforce same-origin checks, allowing requests from external origins to be cached or processed, which violates the same-origin policy. This is a logic flaw, not a sensitive function misuse.}	```({ url: e }) => e.pathname.includes('/games/allGameList')```
4193	lh918.com.js	Improper Validation of Same-Origin Requests	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from the use of `e.pathname.includes()` to match URL paths without validating the origin of the request. While `includes()` is not a sensitive function, the logic fails to enforce same-origin checks, allowing requests from external origins to be cached or processed, which violates the same-origin policy. This is a logic flaw, not a sensitive function misuse.}	```({ url: e }) => e.pathname.includes('/staticpagesettings/Info/orders')```
4194	lh918.com.js	Improper Validation of Same-Origin Requests	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from the use of `e.pathname.includes()` to match URL paths without validating the origin of the request. While `includes()` is not a sensitive function, the logic fails to enforce same-origin checks, allowing requests from external origins to be cached or processed, which violates the same-origin policy. This is a logic flaw, not a sensitive function misuse.}	```({ url: e }) => e.pathname.includes('/games/allGameName')```
4195	safekeep.online.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	N/A	new RegExp(e)	standard	"{The code dynamically creates regular expressions from user-controlled or untrusted input (via JSON.parse('[""safekeep\\\\.online(?:/.*)?/ola/services/.*"", ...]') and new RegExp(e)), which can lead to ReDoS attacks if the input contains malicious patterns that cause exponential backtracking during matching. This is a misuse of the standard RegExp constructor with untrusted data.}"	"```const c = JSON.parse('[""safekeep\\\\.online(?:/.*)?/ola/services/.*"",""safekeep\\\\.online/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://b265da41-b9f5-4914-a3c7-234610cf41e8\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4196	slaek.de.js	Caching of Dynamic Content	High	true	CWE-921	10	caches.open	standard	{The function caches.open is used to open a cache named 'slaek_0.4.0_core', and then e.add(new Request(u)) is used to cache the resource at '/de/service/offline.php'. While the URL is hardcoded, the vulnerability lies in the fact that this resource is cached without validation or sanitization, and if the URL were dynamic (e.g., derived from user input or environment variables), it could lead to unintended caching of malicious or sensitive content. However, in this specific case, the URL is static, so the vulnerability is not due to sensitive function misuse with dynamic input. But since the original detection flagged it as CWE-921 (Caching of Dynamic Content), and the function caches.open is standard and used to manage cache storage, we treat it as a sensitive function misuse in context of improper caching policy.}	"```caches.open(n).then(function (e) { return e.add(new Request(u)), e.add(new Request(""/img/icons/favicon.ico"")), l.forEach(function (n) { e.add(new Request(n)); }), i.forEach(function (n) { e.add(new Request(n)); }), e; })```"
4197	pandahut.net.js	Insecure Cache Deletion	High	true	CWE-285	10	N/A	standard	{The caches.delete() function is used to remove cache entries based on a dynamically derived key (via key.includes(`runtime`)), which is not sanitized or validated. This allows an attacker to potentially delete unintended cache entries if they can manipulate the cache key names, leading to cache poisoning or denial of service.}	```event.waitUntil(caches.keys().then(function (keyList) { return Promise.all(keyList.map(function (key) { if (key && key.includes(`runtime`)) { return caches.delete(key); } return Promise.resolve(); })); }));```
4198	pandahut.net.js	Dynamic Method Invocation	Medium	true	CWE-74	9	N/A	standard	{The code uses dynamic method invocation via MessageAPI[data.api](), where data.api is derived from user-controlled input (pathname parameters). This allows an attacker to invoke arbitrary methods in the MessageAPI object, potentially leading to unintended behavior or privilege escalation if any method performs sensitive operations.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
4199	pandahut.net.js	Unvalidated IndexedDB Resource Retrieval	Medium	true	CWE-79	8	N/A	standard	{The idbKeyval.get() function retrieves data from IndexedDB using a key constructed from the pathname, which is derived from the request URL. Since the pathname is not validated or sanitized, an attacker could craft a request with a malicious path to retrieve or manipulate unintended data, leading to information disclosure or cache manipulation.}	```const resources = await idbKeyval.get(`resources:${pathname}`);```
4200	omega-labs.ai.js	Insecure Caching of Opaque Responses	Medium	false	New	0	N/A	N/A	{The vulnerability arises from caching responses with status 0 (opaque) without proper validation, but no sensitive function misuse is directly involved.}	```const a = new t.CacheFirst({ cacheName: 'google-fonts-webfonts'```
4201	omega-labs.ai.js	Cache Poisoning via NetworkFirst Strategy	High	true	CWE-444	9	NetworkFirst	standard	{The NetworkFirst strategy is used with a custom cache name 'network-first' and a CacheableResponsePlugin that accepts status 200. However, if the cache is manipulated by an attacker via a malicious network response (e.g., via a compromised CDN or man-in-the-middle), the cached response could be poisoned and served to users, leading to cache poisoning. The misuse lies in trusting network responses without additional validation, especially when combined with a long-lived cache.}	```new t.NetworkFirst({ cacheName: 'network-first', plugins: [new a.CacheableResponsePlugin({ statuses: [200] })] })```
4202	omega-labs.ai.js	Inadequate Cross-Origin Response Validation	High	true	CWE-200	8	caches.match	standard	{The function caches.match is used without validating the origin of the response. In the context of the code, if a cross-origin request is made and the response is cached, there is no explicit check to ensure the response is safe or intended. This could allow an attacker to inject or manipulate responses from a different origin, leading to information disclosure or unauthorized access.}	```async function r(e```
4203	omega-labs.ai.js	Missing Cache Expiration for Static Resources	Medium	true	CWE-311	7	StaleWhileRevalidate	standard	{The StaleWhileRevalidate strategy is used for static resources with no expiration policy. This means cached resources may remain indefinitely, potentially serving outdated or compromised content. The misuse lies in not configuring a proper expiration policy (e.g., via ExpirationPlugin) for the cache, which is a standard security practice for static assets.}	```new t.StaleWhileRevalidate({ cacheName: 'static-resources', plugins: [new a.CacheableResponsePlugin({ statuses: [200] })] })```
4204	museum-digital.org.js	Cache Poisoning via Unvalidated Network Response	High	true	CWE-918	10	fetch	standard	{The fetch() function is used to retrieve network responses, and the code attempts to cache the response without properly validating its origin or integrity. Although the code checks for status 200 and 'basic' type, it does not verify that the response is from a trusted source or prevent caching of responses that may be manipulated by an attacker (e.g., via a man-in-the-middle attack or malicious server). This allows an attacker to poison the cache with malicious content, which can be served to users in subsequent requests, leading to potential code injection or data exfiltration.}	```return fetch(fetchRequest).then(function (response) { if (!response || response.status !== 200 || response.type !== 'basic') { return response; } var responseToCache = response.clone(); return response; })```
4205	fortunaspins.com.js	Open Redirect Vulnerability	Medium	true	CWE-601	N/A	concat	standard	{The `concat` method is used to construct a URL from a dynamically selected host (`e`) obtained from `this.getRedirectUrl()`, which is derived from a list of redirect hosts. Since the host is not validated or sanitized, an attacker could potentially control or influence the redirect target, leading to an open redirect vulnerability. The URL is constructed as `https://<untrusted_host>/ru`, allowing redirection to arbitrary domains.}	```const e = this.getRedirectUrl(); return 'https://'.concat(e, '/ru');```
4206	fortunaspins.com.js	XSS via Redirect Handling	High	true	CWE-79	N/A	concat	standard	{The `concat` method is used to inject a user-controlled redirect URL (`r`) directly into a script tag within an HTML response. The string is constructed as `<html><body><script>window.location.href = '<untrusted_redirect>'</script></body></html>`, which executes arbitrary JavaScript in the context of the victim's browser. Since the redirect URL is not sanitized, this allows for reflected XSS attacks.}	"```const n = '<html lang=""en""><body><script>window.location.href = \''.concat(r, ""'<\/script></body></html>""); return new Response(n, { headers: { ""Content-Type"": ""text/html"" }, status: 200 });```"
4207	fortunaspins.com.js	Insecure Message Handling	Medium	true	CWE-79	N/A	postMessage	standard	{The `postMessage` method is used to send messages to client pages with parameters (`name`, `params`, `scope`, `source`) that are derived from untrusted or dynamically constructed data. Since the message content is not sanitized or validated, an attacker could potentially inject malicious data into the message payload, leading to cross-origin scripting or other client-side attacks if the message is processed unsafely.}	```self.clients.matchAll().then(function (e) { e.forEach(function (e) { e.postMessage({ name: t, params: r, scope: n, source: i }); }); });```
4208	fortunaspins.com.js	Insecure Cache Handling	Medium	true	CWE-918	N/A	caches.open	standard	{The `caches.open` method is used to open a cache named 'redirect-sw-cache' and store responses without validating or sanitizing the request or response data. Since the cache key and content are derived from untrusted sources (e.g., network responses), this could allow an attacker to cache malicious content or manipulate cached responses, potentially leading to cache poisoning or data leakage.}	```caches.open('redirect-sw-cache').then(function (r) { r.put(e, t); });```
4209	podereoracao.com.js	External Script Import from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded URL from an untrusted CDN (e.g., cdn.pushalert.co), it introduces a high-risk vulnerability because the script content is not under the control of the site owner. An attacker could compromise the CDN or the script to inject malicious code, leading to full control over the service worker’s behavior, including intercepting network requests, manipulating cache, or stealing sensitive data.}	"```importScripts(""https://cdn.pushalert.co/sw-59348_4.js"");```"
4210	altt.me.js	Incorrect Offline Page Caching	Medium	false	New	N/A	N/A	N/A	"{The vulnerability arises from incorrect caching logic when offlineFallbackPage is set to ""pwa.html"", where a new Response object is created with a string instead of a URL to an actual file. This does not involve misuse of a sensitive function, but rather a logical error in caching behavior.}"	"```const CACHE = ""pwabuilder-offline""; const offlineFallbackPage = ""pwa.html""; self.addEventListener(""install"", function (event) { console.log(""Install Event processing""); event.waitUntil(caches.open(CACHE).then(function (cache) { console.log(""Cached offline page during install""); if (offlineFallbackPage === ""pwa.html"") { return cache.add(new Response(""pwa.html"")); } return cache.add(offlineFallbackPage); })); });```"
4211	port.mv.js	Cache Poisoning	High	true	N/A	N/A	new URL	standard	{The function `new URL` is used in `x(t)` to construct a URL from a split and modified path. If the input `t.href` is untrusted (e.g., from a user-controlled request), the URL construction could lead to cache poisoning by allowing an attacker to manipulate the base URL used for caching, potentially serving malicious or unintended content.}	```const x = (t) => { const e = t.href.split('/'), n = e[e.length - 1]; return e[e.length - 1] = '', { baseUrl: new URL(e.join('/')), requestedBundleName: n } };```
4212	port.mv.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of input in `E` function, but no sensitive function is misused. The issue is more about logic flow and error handling rather than direct misuse of a sensitive API.}	```const E = (t, e, n, c, o, a, s) => { try { m(t, c, o, a, g(t, e)); } catch (r) { console.error(r); } for (const r of s) try { for (const l of n) { const [u, f] = l; if (u.test(r)) { m(t, c, o, a, g(t, f)); break; } } } catch (l) { console.error(l); } };```
4213	port.mv.js	Insecure URL Handling	High	true	N/A	N/A	new URL	standard	{The `new URL` function is used to construct a URL from a user-controlled path (`t.href`). If the input is not sanitized, an attacker could inject malicious paths or redirect to unintended domains, leading to insecure URL handling and potential cache manipulation or phishing.}	```const x = (t) => { const e = t.href.split('/'), n = e[e.length - 1]; return e[e.length - 1] = '', { baseUrl: new URL(e.join('/')), requestedBundleName: n } };```
4214	port.mv.js	Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from logic in `B` function that checks for cache-control headers, but no sensitive function is misused. The issue is related to caching policy, not improper use of a sensitive API.}	```const B = t => { const e = t.headers.get('Cache-Control') || ''; return e.includes('no-cache') || e.includes('max-age=0'); };```
4215	adultreviews.com.js	Open Redirect via Untrusted Notification URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API used to open a new window or tab with a specified URL. In this code, the URL passed to clients.openWindow() is derived from event.notification.data.url, which is sourced from the push notification payload. Since this payload is controlled by the server sending the push notification (and potentially by an attacker if the server is compromised or if the notification data is not validated), an attacker could craft a notification with a malicious URL (e.g., a phishing site or a redirect to a malicious domain). This allows for an open redirect vulnerability, where users are redirected to unintended and potentially harmful destinations.}	```event.waitUntil(clients.openWindow(url));```
4216	microkredit24.kz.js	Service Worker Fetch Error Handling Missing	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the absence of proper error handling in the fetch event listener. The code does not handle cases where `caches.match` or `fetch` may fail, potentially leading to unhandled promise rejections or silent failures.}	```self.addEventListener('fetch', function (e) { e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request); })); });```
4217	saltycanary.com.js	Improper URL Validation in Ignore Paths	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from the hardcoded ignorePaths array, which is used to filter URLs during routing. However, no sensitive JavaScript function is misused here — the issue is purely a logic or configuration flaw in the path filtering logic, not a result of improper use of a function like importScripts, eval, or dynamic URL construction.}	"```const ignorePaths = [""wp-admin"", ""wp-login"", ""wp-json"", ""wp-includes"", "".txt""];```"
4218	matterhorngotthardbahn.ch.js	Insecure Dependency via importScripts	High	true	CWE-496	10	importScripts	standard	{The importScripts function is used to load and execute a remote script from a hardcoded URL (https://js.appboycdn.com/web-sdk/4.3/service-worker.js). While the URL is hardcoded and not dynamically derived from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. If the source were to be controlled by an attacker (e.g., via DNS hijacking or compromised CDN), it could lead to arbitrary code execution within the service worker context. However, since the URL is fixed and not user-controlled, the risk is mitigated but still present due to external dependency trust.}	"```importScripts(""https://js.appboycdn.com/web-sdk/4.3/service-worker.js"")```"
4219	matterhorngotthardbahn.ch.js	Potential SSRF via Permissive Regex	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from a permissive regex pattern used in registerRoute, which allows requests to cda.contenthub.dev with specific query parameters. However, this is not caused by misuse of a sensitive function but rather by overly broad route matching. The registerRoute function is used correctly; the issue lies in the regex logic, not in the function's unsafe use.}	```e.registerRoute(/https?:\/\/cda.contenthub.dev\/.*content_type=(?:regionGroup|region|webcamGroup|webcam|weatherGroup|weatherItem|weatherInformation|weatherDay|weather|transportationGroup|transportationStatus|transportation|slopeGroup|slopeStatus|slope|liftGroup|liftStatus|lift)(?:&.*)?$/, new e.NetworkFirst({ cacheName: 'contentful-cache', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 259200, purgeOnQuotaError: !0 }), { cacheKeyWillBeUsed: async ({ request: e }) => { let t = e.url; const c = e.headers.get('Accept-Language'); return c && (t += JSON.stringify({ 'Accept-Language': c })), t; } }] }), 'GET');```
4220	matterhorngotthardbahn.ch.js	Cache Poisoning via Unsanitized Accept-Language	Medium	false	CWE-442	N/A	N/A	N/A	{The vulnerability stems from unsanitized Accept-Language header values being appended to the cache key via JSON.stringify. This is not due to misuse of a sensitive function but rather a logic flaw in cache key generation. The cacheKeyWillBeUsed function is used correctly; the issue is in how the cache key is constructed, not in the function's inherent sensitivity.}	```cacheKeyWillBeUsed: async ({ request: e }) => { let t = e.url; const c = e.headers.get('Accept-Language'); return c && (t += JSON.stringify({ 'Accept-Language': c })), t; }```
4221	themalibucrew.com.js	CSRF Protection Bypass via Service Worker URL Parameter	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract the `loggedIn` parameter. This function is standard and not inherently dangerous, but its misuse here allows an attacker to manipulate the `loggedIn` parameter in the URL to bypass CSRF protection. Since the service worker processes navigation requests based on this parameter, an attacker can craft a URL with `loggedIn=true` to trick the service worker into skipping CSRF token injection, thereby bypassing security checks. The `match()` function is used to parse untrusted input (URL) without validation, leading to a logic flaw that enables CSRF bypass.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4222	redditpx.com.js	Service Worker Scope Misconfiguration	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by improper handling of request scope and origin validation in the fetch event. The code checks if the request URL's protocol starts with 'http', but does not properly validate the origin or scope of the service worker, potentially allowing requests from unintended origins to be processed. This is a logic flaw in scope enforcement, not a sensitive function misuse.}	"```if (""GET"" !== t.request.method || t.request.headers.has(""range"")) return; const n = new URL(t.request.url); n.protocol.startsWith(""http"") && (n.hostname === self.location.hostname && n.port !== self.location.port || (n.host === self.location.host && s.has(n.pathname) ? t.respondWith(caches.match(t.request)) : ""only-if-cached"" !== t.request.cache && ""image"" != t.request.destination && t.respondWith(caches.open(`offline${e}`).then(async e => { try { const n = await fetch(t.request); return e.put(t.request, n.clone()), n; } catch (n) { const s = await e.match(t.request); if (s) return s; throw n; } }))))```"
4223	vatanapp.com.js	Insecure Dynamic Code Evaluation (Missing SRI)	Medium	false	N/A	N/A	N/A	N/A	{The importScripts() call uses a hardcoded URL and does not involve dynamic or user-controlled input. Therefore, while the lack of Subresource Integrity (SRI) is a concern, it is not due to misuse of a sensitive function with dynamic input.}	```var site_url = 'https://vatanapp.com'; importScripts('https://vatanapp.com/wp-content/plugins/letspush/js/letspush_service_worker.min.js');```
4224	tcportal.online.js	Cache Poisoning via Unvalidated Cache Entries	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by improper configuration of cache strategies in Workbox. Specifically, the cache is not properly validated or restricted, allowing potentially untrusted or unintended resources to be cached under the same cache name (e.g., HTML_CACHE). This can lead to cache poisoning if an attacker can influence the request or cache key. However, no sensitive function like importScripts, eval, or dynamic script loading is involved.}	```workbox.routing.registerRoute(({\n event\n}) => event.request.destination === 'document', new workbox.strategies.NetworkFirst({\n cacheName: HTML_CACHE,\n plugins: [new workbox.expiration.ExpirationPlugin({\n maxEntries: 10\n })]\n}));```
4225	iprog.pro.js	Insecure Direct Object Reference (IDOR) via URL Parameter	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from directly extracting and trusting the `loggedIn` parameter from the service worker's current location URL without validation or sanitization. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure logic handling of URL parameters.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4226	iprog.pro.js	CSRF Token Handling Without Origin Check	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the lack of origin validation when fetching CSRF tokens, but it is not due to misuse of a sensitive JavaScript function. The `fetch` call is used correctly; the issue lies in the absence of security checks in the logic, not in the function itself.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(...)```
4227	iprog.pro.js	Open Redirect in Notification Click Handler	Medium	true	N/A	N/A	fetch	standard	{The `navigate` method is used with a URL derived from `data.url`, which is obtained from a push notification payload. Since this data is not validated or sanitized, an attacker could craft a malicious notification with a redirect URL, leading to open redirect. The `fetch` function is not directly involved, but the `navigate` method (part of the `Client` API) is sensitive and misused here.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4228	iprog.pro.js	Improper Cache Invalidation	Low	false	N/A	N/A	N/A	N/A	{The issue is due to a lack of proper cache management strategy, not misuse of a sensitive function. The `cache.addAll` function is used correctly; the problem lies in the design of cache invalidation logic, not in the function's usage.}	```return cache.addAll(CACHED_ASSETS);```
4229	vttour.fr.js	Caching Logic Error (Potential Cache Poisoning	High	true	CWE-697	9	N/A	standard	{The caching logic uses `caches.open()` and `cache.match()` with dynamic URLs derived from `event.request.url`, which is not sanitized. If an attacker can manipulate the request URL (e.g., via crafted requests or redirects), they may force the cache to store or serve unintended content, leading to cache poisoning. The use of `caches.open()` with a hardcoded cache name is safe, but the dynamic URL handling introduces risk.}	```self.addEventListener('fetch', event => { if (event.request.method != 'POST') { var response; const url = event.request.url; if ((url.indexOf('.jpg') != -1 || url.indexOf('.gif') != -1 || url.indexOf('.png') != -1 || url.indexOf('.css') != -1 || url.indexOf('.js') != -1) && url.indexOf('vttour.fr') != -1 && url.indexOf('/ajax/') != -1 && url.indexOf('/upload/') != -1 && url.indexOf('vttour.fr/sorties/photos/') == -1 && url.indexOf('vttour.fr/topos/photos/') == -1) { event.respondWith(caches.open('cache').then(function (cache) { return cache.match(event.request).then(function (response) { var fetchPromise = fetch(event.request).then(function (networkResponse) { cache.put(event.request, networkResponse.clone()); return networkResponse; }).catch(function () {}); return response || fetchPromise; }); })); } if (url == 'https://vttour.fr/') { event.respondWith(fetch(event.request).then(function (networkResponse) { return networkResponse; }).catch(function () { return caches.match('https://vttour.fr/index_cache.html').then(function (response) { return response; }); })); } } });```
4230	vttour.fr.js	Unvalidated Notification Data (Potential XSS	Medium	true	CWE-79	8	N/A	standard	{The `event.data.json()` is used to extract notification data, and the `body` and `icon` fields are directly passed to `showNotification()`. If the data is not sanitized and comes from an untrusted source, an attacker could inject malicious content (e.g., script tags in the body or a malicious icon URL), leading to XSS or other client-side attacks. The `showNotification()` function is standard and does not sanitize inputs, making it vulnerable to misuse.}	"```self.addEventListener('push', event => { const dataJSON = event.data.json(); const options = { body: dataJSON.body, icon: dataJSON.icon, badge: ""/img/badge.png"", data: { url: dataJSON.url } }; return self.registration.showNotification(dataJSON.title, options); });```"
4231	vttour.fr.js	Unvalidated URL in Notification Click (Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The `event.notification.data.url` is extracted and passed directly to `clients.openWindow(url)` without validation. If the URL is controlled by an attacker (e.g., via a malicious push notification), this can lead to an open redirect, allowing the attacker to redirect users to arbitrary websites, potentially phishing or malware distribution. The `clients.openWindow()` function is standard and does not validate URLs, making it a sensitive function when used with untrusted input.}	```self.addEventListener('notificationclick', event => { const url = event.notification.data.url; event.notification.close(); event.waitUntil(clients.openWindow(url)); });```
4232	xtra.lv.js	Improper Validation of Path Parameter Leading to CSRF Vulnerability	High	true	CWE-352	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the path parameter from the request URL. Since the path is derived from user-controlled input (request.url) without proper sanitization or validation, an attacker could craft a malicious path that tricks the service worker into making a forged request to a vulnerable endpoint, potentially leading to CSRF attacks. The use of credentials: 'include' exacerbates the risk by including session cookies in the request.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`, { method: 'POST', credentials: 'include' })```
4233	xtra.lv.js	Incorrect Login Status Determination via Service Worker URL	Medium	false	CWE-203	0	N/A	N/A	{The vulnerability arises from parsing the login status from the service worker's location.href, which is not a sensitive function misuse but rather a flawed logic design. The URL is not dynamically controlled by external input in a way that triggers a function misuse; instead, it's a static check on the service worker's own context.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4234	xtra.lv.js	Insecure Fetch with Credentials to Server	Medium	true	CWE-548	8	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the notification ID from the push event data. Since the ID is derived from external input (e.g., from a push message), and the request includes credentials: 'include', an attacker could manipulate the ID to trigger unintended server-side actions or access sensitive data, leading to unauthorized access or data leakage.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4235	xtra.lv.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	9	navigate	standard	{The navigate function is used with a URL derived from the notification data's 'url' field, which is obtained from external input (push notification). Since this URL is not validated or sanitized, an attacker could craft a notification with a malicious URL, causing the client to navigate to an arbitrary site, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url);```
4236	febs.org.js	Improper Cache Exclusion for Sensitive URLs	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the logic in the fetch event handler where requests matching patterns in neverCacheUrls are excluded from caching. However, the check uses `every(checkNeverCacheList, e.request.url)` which reverses the intended logic — it returns true only if NONE of the regexes match, meaning requests that should be excluded are actually cached. This is a logical error, not a misuse of a sensitive function.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; }```
4237	purina-arabia.com.js	User-Agent Sniffing for Caching Logic	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from user-agent sniffing logic, which is not caused by misuse of a sensitive JavaScript function. Instead, it stems from relying on `navigator.userAgent` for browser detection, which is unreliable and can be spoofed. This leads to inconsistent caching behavior across browsers, but does not involve dangerous function calls like `eval`, `importScripts`, or `fetch` with untrusted input.}	```const safariAgent = userAgentString.indexOf('Safari') > -1;```
4238	spellquiz.com.js	Open Redirect	High	true	CWE-601	9	N/A	standard	{The function clients.openWindow() is used with the value eventData.open, which is derived from the notification data received via a push event. Since this data originates from an external source (the server sending the push notification), it is untrusted and can be manipulated by an attacker to redirect the user to a malicious URL, leading to an open redirect vulnerability.}	```clients.openWindow(eventData.open);```
4239	spellquiz.com.js	Exposure of Sensitive Information to an Unauthorized Actor	Low	false	CWE-548	N/A	N/A	N/A	{The sensitive information (API key) is hardcoded in the script, but it is not the result of misuse of a sensitive function. It is a static exposure issue, not a functional misuse.}	```apiKey: 'AIzaSyB2ysZ13T8zqH-vM7HNLMo51GftxeHDp-k',```
4240	spellquiz.com.js	Exposure of Sensitive Information to an Unauthorized Actor	Low	false	CWE-548	N/A	N/A	N/A	{The use of console.log() to output the payload in background mode is a logging issue, not a misuse of a sensitive function. While it may expose sensitive data, it does not involve a function that inherently introduces dynamic risk from untrusted input.}	```console.log('Payload in background MODE:', payload);```
4241	mygnrforum.com.js	Server Side Request Forgery (SSRF) via unvalidated push notification ID	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the unvalidated `id` parameter from push notification data. Since `id` is derived from external input (push message payload), an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4242	mygnrforum.com.js	Server Side Request Forgery (SSRF) via unvalidated CSRF token path	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the unvalidated `path` parameter from the request URL. Since `path` is derived from user-controlled input (request.pathname), an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json())```
4243	mygnrforum.com.js	Open Redirect via unvalidated notification URL	Medium	true	CWE-601	10	N/A	standard	{The clients[0].navigate() function is used with a URL derived from the `data.url` field in the notification payload, which is unvalidated. An attacker can craft a notification with a malicious URL, causing the browser to navigate to an arbitrary site, leading to open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
4244	slowcookerclub.com.js	Improper URL Validation Leading to Cache Poisoning	Medium	true	CWE-20	8	new URL(t)	standard	{The code uses new URL(t) to parse a URL derived from a user-controlled input (t), which is constructed from the request URL. Although the code checks for 'https' and siteHostname, it does not validate the full URL structure or sanitize the input, allowing an attacker to craft a malicious URL that bypasses the checks and leads to cache poisoning. The URL object is created without proper validation, making it possible to inject unintended paths or domains that are not caught by the ignorePaths or siteHostname checks.}	```if (!t || 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname;```
4245	konst.se.js	Insecure Service Worker Cache Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability is related to cache handling practices, but not due to misuse of a sensitive function. The code uses `caches.open` and `cache.add` with a hardcoded `OFFLINE_URL`, which is safe and not influenced by untrusted input. There is no dynamic or user-controlled input being passed to these functions, so no sensitive function misuse is present.}	```const cache = await caches.open(CACHE_NAME); await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
4246	increazy.com.js	Empty Fetch Event Handler Leading to DoS	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from an empty fetch event handler, which does not perform any meaningful processing or respond to requests. While this does not involve misuse of a sensitive function, it can lead to denial-of-service conditions if the service worker is misconfigured or if clients repeatedly trigger fetch events without proper handling.}	```self.addEventListener('fetch', function (event) {});```
4247	jkhub.org.js	Server-Side Request Forgery (SSRF)	High	true	CWE-829	10	N/A	standard	{The fetch() function is used with a URL constructed from the `id` parameter received from a push notification. Since `id` is controlled by the server sending the push (and potentially by an attacker if the server is compromised), it allows an attacker to craft a request to arbitrary internal endpoints by manipulating the `id` value, leading to SSRF. The URL is dynamically built using template literals, making it vulnerable to injection.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' });```
4248	jkhub.org.js	Path Traversal	High	true	CWE-22	10	N/A	standard	{The fetch() function is used with a URL constructed from the `path` parameter, which is derived from the current request's URL. If an attacker can manipulate the request path (e.g., via a crafted URL), they could inject path traversal sequences (like ../) into the `path` parameter, causing the service worker to fetch internal or sensitive resources from the server, leading to path traversal.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4249	jkhub.org.js	Open Redirect	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the `data.url` field in a notification. If an attacker can control the notification payload (e.g., via a compromised server or push subscription), they can set `data.url` to an arbitrary external URL, redirecting the user to a malicious site, leading to open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4250	mashagame.com.js	Missing Origin Check in Message Event Listener	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's message event listener not verifying the origin of incoming messages. While this is a security concern, it is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by a lack of origin validation logic in the event handler. The code listens for messages without checking the sender's origin, which could allow cross-origin messages to trigger unintended behavior, but this is a design flaw rather than a sensitive function misuse.}	"```self.addEventListener(""message"", n => { n.data && ""SKIP_WAITING"" === n.data.type && self.skipWaiting(); })```"
4251	huettenland.com.js	Incorrect Logic in Cache Filtering	High	false	N/A	0	N/A	N/A	{The vulnerability stems from flawed logic in cache filtering, not from misuse of a sensitive JavaScript function. Specifically, the condition `fetchUrl.indexOf('.php')` is evaluated as a boolean without explicit comparison (e.g., `!== -1`), which causes any non-zero index to be treated as truthy, leading to incorrect exclusion of `.php` URLs from caching. This is a logical error, not a security issue arising from unsafe function usage.}	"```const CACHE_NAME = ""vom_"" + new Date().toISOString().substr(0, 10);addEventListener('activate', event => {  event.waitUntil(caches.keys().then(keyList => {    return Promise.all(keyList.map(key => {      if (CACHE_NAME.indexOf(key) === -1) {        return caches.delete(key);      }    }));  }));});self.addEventListener('fetch', function (event) {  if (!event || event.request.method !== 'GET' || event.request.url.indexOf('.pdf') !== -1 || event.request.url.indexOf('download.php') !== -1) {    return;  }  event.respondWith(caches.match(event.request).then(function (response) {    if (response) {      return response;    }    var fetchRequest = event.request.clone();    var fetchUrl = event.request.clone().url;    return fetch(fetchRequest).then(function (response) {      if (!response || response.status !== 200 || response.type !== 'basic' || fetchUrl.indexOf('.php') || fetchUrl.indexOf('.pdf')) {        return response;      }      var responseToCache = response.clone();      caches.open(CACHE_NAME).then(function (cache) {        cache.put(event.request, responseToCache);      });      return response;    });  }));});```"
4252	dos.lol.js	Caching of Sensitive Data	High	true	CWE-200	8	new URL	standard	{The function `new URL(String(r), location.href)` is used to construct a URL from an untrusted input `r`. If `r` contains sensitive data (e.g., query parameters with tokens or credentials), the resulting URL may be cached or used in subsequent requests, leading to exposure of sensitive information. The `replace` call removes the origin, but the URL object may still retain sensitive path/query components that are cached or logged, enabling information leakage.}	"```const B = r => new URL(String(r), location.href).href.replace(new RegExp(""^"".concat(location.origin)), """");```"
4253	luening-24.de.js	Cache Poisoning via Dynamic Caching	High	true	CWE-434	9	caches.put	standard	{The function caches.put is used to store responses in the cache based on dynamic URL patterns derived from dynamicCacheFiles and dynamicCacheRequests. Since these patterns are hardcoded and not validated against malicious inputs, an attacker could craft a request URL that matches these patterns (e.g., by including 'all.js' or 'pwa/fastorder/form' in a malicious URL), leading to unintended caching of potentially harmful responses. This allows cache poisoning, where an attacker can inject malicious content into the cache that is later served to users.}	```const cache = await caches.open(CACHE_DYNAMIC_NAME); for (const element of dynamicCacheFiles) { if (request.url.includes(element)) { cache.put(request.url, response.clone()); console.log(request.url, 'cloned'); } } for (const element of dynamicCacheRequests) { if (request.url.includes(element) && request.method === 'GET') { cache.put(request.url, response.clone()); } }```
4254	luening-24.de.js	Insecure Fallback Handling	Medium	true	CWE-434	8	caches.put	standard	{The function caches.put is used to cache fallback resources ('/pwa/fallback' and '/fallback/widgets/checkout/info') without validating the content or origin of the fetched responses. If an attacker can manipulate the server to return malicious content for these fallback endpoints, the service worker will cache and serve that content to users, leading to potential cache poisoning or injection of malicious scripts.}	```fetch('/pwa/fallback', { method: 'GET' }).then(res => { if (res.ok) { return caches.open(CACHE_DYNAMIC_NAME).then(function (cache) { cache.put('/pwa/fallback', res.clone()); }); } }); fetch('/fallback/widgets/checkout/info', { method: 'GET' }).then(res => { if (res.ok) { return caches.open(CACHE_DYNAMIC_NAME).then(function (cache) { console.log('cache widget'); cache.put('/fallback/widgets/checkout/info', res.clone()); }); } });```
4255	vaush.gg.js	Insecure Handling of Notification Payloads (Potential XSS	High	true	CWE-79	9	notificationOptions	standard	{The notification body is directly assigned from the payload without sanitization, and when displayed via showNotification(), it may execute arbitrary script if the payload contains malicious content, leading to XSS.}	```const notificationOptions = { body: payload.notification.body };```
4256	vaush.gg.js	Improper Permission Handling (Notification Request	Medium	false	N/A	0	N/A	N/A	{The use of Notification.requestPermission() is not inherently unsafe; it is a standard permission request. The vulnerability lies in improper handling of the permission state and lack of user consent validation, not in misuse of a sensitive function.}	```newPrompt = Notification.requestPermission();```
4257	vaush.gg.js	Exposure of Sensitive Data (VAPID Key	Medium	false	N/A	0	N/A	N/A	{The VAPID key is hardcoded and exposed in the source code, but this is not due to misuse of a sensitive function. It is a static data exposure issue, not a function misuse.}	```const VAPIDKEY = 'BPAHFhXKKkZeOa_ytx0P8bro2cHOdp3yf1kgseYPRnjW1A727E0hgft0VgKbNZZblB3hJgAcQTL5EIsT61L2KRE';```
4258	eaglesmessageboard.com.js	Improper Login Status Determination	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter directly from the URL using a regex, which is not a secure method for determining login status. This is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in authentication state handling.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4259	eaglesmessageboard.com.js	CSRF Token Generation Based on Path	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the server-side logic that generates CSRF tokens based on the path, which is a design flaw. The JavaScript code merely makes a fetch request to retrieve the token; it does not misuse any sensitive function.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(...)```
4260	eaglesmessageboard.com.js	Unvalidated Notification URL Handling	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a URL derived from the notification data, which is not validated or sanitized. If an attacker can control the notification data (e.g., via a malicious push message), they can redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4261	comeonyouspurs.com.js	CSRF Token Injection via URL Parameter	High	true	CWE-352	10	fetch	standard	{The fetch function is used to retrieve a CSRF token based on the path from a cloned request URL. While the URL is constructed using a trusted BASE_URL and a path derived from the request, the path itself is not sanitized or validated. If an attacker can manipulate the request URL (e.g., via a crafted link or redirect), they could potentially inject malicious paths that lead to unintended CSRF token generation or exposure. This misuse of fetch with dynamic, untrusted path input allows for CSRF token injection, enabling unauthorized actions on behalf of the user.}	```if (loggedIn == 'false' && request.method === 'POST') { const curRequest = request.clone(); log('Intercepting guest post request'); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); }); return; }```
4262	comeonyouspurs.com.js	Insecure Credentials in Push Notification Fetch	Medium	true	CWE-200	9	fetch	standard	{The fetch function is used to retrieve notification data with credentials: 'include', which sends cookies and authentication tokens. The URL is constructed using a dynamic id parameter from the push event data, which is untrusted. If an attacker can control or predict the id value, they could craft a request to fetch sensitive data from the server, potentially exposing private notifications or other user-specific data. This misuse of fetch with untrusted input and sensitive credentials leads to information exposure.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4263	francetransactions.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided by the notification data (data.url), which originates from a push notification payload. Since this payload is controlled by the server and potentially by an attacker, and no validation or sanitization is performed on the URL, it allows for open redirect attacks where users can be redirected to arbitrary, potentially malicious, websites.}	```event.waitUntil(clients.openWindow(data.url));```
4264	sweetheartslive.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used with a URL derived from event.notification.data.link_url, which originates from untrusted external data (push notification payload). Since this URL is not validated or sanitized, an attacker can craft a malicious payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	N/A
4265	sweetheartslive.com.js	Insecure Data Handling in BroadcastChannel (Potential XSS)	Medium	true	CWE-79	8	channel4Broadcast.postMessage	standard	{The BroadcastChannel.postMessage function is used to send notification data (including user-controlled fields like title, body, etc.) without sanitization. If any of these fields contain malicious scripts or HTML, and if the receiving context processes them unsafely (e.g., via innerHTML or eval), it could lead to XSS. The data is passed directly as-is, making it a potential vector for cross-site scripting.}	N/A
4266	sweetheartslive.com.js	Exposure of Sensitive Information in Service Worker	Medium	false	CWE-532	0	N/A	N/A	{The vulnerability stems from hardcoded Firebase credentials being exposed in the service worker script. This is not due to misuse of a sensitive function, but rather poor configuration and exposure of secrets in client-side code. No JavaScript function is misused here; the issue is static data exposure.}	N/A
4267	stackposts.com.js	External Script Loading Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks or with dynamically constructed URLs, it can lead to remote code execution if the script source is compromised or controlled by an attacker. In this case, the script is loaded from a hardcoded external URL, but since there is no integrity verification (e.g., using integrity attribute or cryptographic hash), an attacker could potentially manipulate the script at the remote location, leading to unauthorized code execution within the service worker context.}	```importScripts('https://push.hugocode.com/cdn/sw_payload.js');```
4268	minabibliotek.se.js	Insecure URL Handling in isCoverRequest	High	true	CWE-22	9	includes	standard	{The function `isCoverRequest` uses `url.includes(contentUrl)` to check if a URL matches a configured content path. Since `contentUrls` is populated from a remote configuration fetched via `fetch(configurationUrl)`, and no validation or sanitization is applied to these URLs, an attacker could manipulate the configuration to inject arbitrary strings, potentially leading to unintended URL matching and bypassing security checks. This misuse of `includes` with untrusted input allows for path traversal or unintended resource interception.}	```var isCoverRequest = url => { var valid = false; contentUrls.forEach(contentUrl => { if (url.includes(contentUrl) && url.includes('/covers/')) { valid = true; } }); return valid; };```
4269	minabibliotek.se.js	SSRF via Unvalidated Fetch Requests	High	true	CWE-918	9	fetch	standard	{The `fetch(configurationUrl)` call retrieves configuration data, which is then used to populate `contentUrls`. Since `configurationUrl` is hardcoded and not validated, and the fetched configuration is trusted without verification, an attacker could potentially control the configuration endpoint or inject malicious URLs into `contentUrls`, leading to SSRF if those URLs are later used in `fetch` calls within `isCoverRequest` or other logic. The `fetch` function is misused by accepting untrusted configuration data without validation, enabling SSRF attacks.}	```var promise = fetch(configurationUrl).then(response => { return response.json(); }).then(configuration => { contentUrls = configuration.contentUrls; console.info('ServiceWorker will intercept the following urls.', contentUrls); return getDefaultCover(); }).then(image => { defaultImageData = image; }, () => { defaultImageData = null; return Promise.reject('Failed to load the default cover. Rejecting promise and disabling interception.'); });```
4270	minabibliotek.se.js	Potential Header Information Leakage	Medium	false	New	0	N/A	N/A	{The code clones the request and re-creates it with the same headers, but since the headers are copied directly without filtering or sanitization, sensitive headers (e.g., `Authorization`, `Cookie`) could be inadvertently exposed in downstream requests or logs. However, this is not caused by misuse of a sensitive function, but rather by design choice in header propagation.}	```var fetchRequest = new Request(url, { method: fetchRequest.method, mode: 'cors', credentials: 'omit', redirect: fetchRequest.redirect, headers: fetchRequest.headers });```
4271	minabibliotek.se.js	Insecure Configuration Fetch	Medium	false	CWE-311	0	N/A	N/A	{The `fetch(configurationUrl)` call retrieves configuration data, but the vulnerability is primarily due to lack of authentication or encryption, not misuse of a sensitive function. The `fetch` function itself is used correctly; the issue lies in the insecure transport or lack of validation of the configuration endpoint.}	```var promise = fetch(configurationUrl).then(response => { return response.json(); }).then(configuration => { contentUrls = configuration.contentUrls; console.info('ServiceWorker will intercept the following urls.', contentUrls); return getDefaultCover(); }).then(image => { defaultImageData = image; }, () => { defaultImageData = null; return Promise.reject('Failed to load the default cover. Rejecting promise and disabling interception.'); });```
4272	jerelia.com.js	Cache Poisoning via 'v=' Parameter	Medium	true	CWE-918	9	caches.match	standard	{The code uses caches.match with a request URL that may contain a dynamically derived 'v=' parameter. While the parameter itself is not directly used to construct a cache key in a dangerous way, the use of a dynamic URL in caches.match without proper validation or sanitization can lead to cache poisoning if an attacker can manipulate the URL to bypass intended caching logic or trigger unintended cache behavior. The vulnerability arises from improper handling of dynamic input in a caching context, which is a misuse of the standard caches.match API.}	```if (request.url.match(/(\?|&)v=/ig)) { event.respondWith(caches.match(request).then(function (response) { return response || fetch(request).then(function (response) { addToCache(request, response); return response || serveOfflineImage(request); }).catch(function () { return serveOfflineImage(request); }); })); return; }```
4273	jerelia.com.js	Improper Input Validation in serveOfflineImage	Low	false	N/A	N/A	N/A	N/A	{The code checks if the Accept header contains 'image', but this is not a misuse of a sensitive function. The function serveOfflineImage is custom and does not invoke any sensitive JavaScript APIs with untrusted input. The issue is purely a logic flaw in input validation, not a sensitive function misuse.}	"```if (request.headers.get('Accept').indexOf('image') !== -1) { return new Response('<svg role=""img"" aria-labelledby=""offline-title"" viewBox=""0 0 400 300"" xmlns=""http://www.w3.org/2000/svg""><title id=""offline-title"">Offline</title><g fill=""none"" fill-rule=""evenodd""><path fill=""#D8D8D8"" d=""M0 0h400v300H0z""/><text fill=""#9B9B9B"" font-family=""Helvetica Neue,Arial,Helvetica,sans-serif"" font-size=""72"" font-weight=""bold""><tspan x=""93"" y=""172"">offline</tspan></text></g></svg>', { headers: { 'Content-Type': 'image/svg+xml' } }); }```"
4274	radiogyan.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-549	9	N/A	standard	{The function `fetch` is used with a URL derived from `match`, which is extracted from HTML content via a regex pattern. Since the `match` value is sourced from an untrusted external HTML page (via `fetch(url).then(dataWrappedByPromise => dataWrappedByPromise.text())`), an attacker could inject malicious URLs into the HTML content, causing the service worker to make unintended outbound requests to internal or external resources, leading to SSRF.}	```const fetch = require('node-fetch'); // Vulnerable code in pwaForWpprecacheUrl: fetch(match).then(imagedata => { cache.put(match, imagedata.clone()); });```
4275	radiogyan.com.js	XSS via IndexedDB Storage	Medium	true	CWE-79	8	N/A	custom	{The `reader.onload` callback in the POST handler for 'activity' path saves `imageData` (a data URL from a user-uploaded file) directly into IndexedDB via `saveData(db, { image: imageData })`. While the data is stored and not immediately executed, if the application later retrieves and renders this data without sanitization (e.g., in an `<img>` tag or via `eval`), it could lead to XSS. The vulnerability stems from the custom `saveData` function storing untrusted data without validation.}	```reader.onload = async event => { const imageData = event.target.result; await saveData(db, { image: imageData }); };```
4276	dealsdirect.com.au.js	Open Redirect via Unvalidated Click Action URL	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow(url) is a standard browser API used to open a new window or tab with a given URL. When the URL is derived from untrusted input (event.notification.data.FCM_MSG.notification.click_action), it allows an attacker to craft a notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities. Since the URL is not validated or sanitized, it can point to malicious domains, potentially phishing users or bypassing security controls.}	```const url = event.notification.data.FCM_MSG.notification.click_action; event.waitUntil(clients.matchAll({ type: 'window' }).then(windowClients => { for (var i = 0; i < windowClients.length; i++) { var client = windowClients[i]; if (client.url === url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } }));```
4277	projectn95.org.js	Insecure Dynamic Function Invocation	High	true	CWE-807	9	MessageAPI[data.api]()	custom	{The code dynamically invokes a function from the MessageAPI object using user-controlled input (data.api). Since the value of data.api is derived from the URL pathname via a regex match and split, an attacker could craft a URL that triggers an unintended or malicious function call if such a function exists in the MessageAPI object, leading to arbitrary code execution or unintended behavior.}	N/A
4278	projectn95.org.js	Improper Input Validation	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from insufficient validation of the URL pathname when extracting parameters. However, this is not caused by misuse of a sensitive function, but rather by flawed logic in parsing the URL. The code does not invoke any sensitive function with untrusted input; it merely splits and processes the string.}	N/A
4279	projectn95.org.js	Insecure Redirect Handling	Medium	false	CWE-601	0	N/A	N/A	{The redirect is based on the value of lastNavigationRequest, which is set from the event.request.url. While this could lead to open redirects, it does not involve the misuse of a sensitive function like location.href or window.location. The vulnerability stems from logic design, not function misuse.}	N/A
4280	projectn95.org.js	Cache Deletion Vulnerability	Medium	false	CWE-379	0	N/A	N/A	{The code deletes cache entries based on keys retrieved from caches.keys(), but it does not use any sensitive function with untrusted input. The deletion is conditional on the key containing 'runtime', which is a static string. No sensitive function is misused here.}	N/A
4281	cezma.com.js	Hardcoded Sensitive Information	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded sensitive information (Firebase API keys and private key pairs) in the source code, not due to misuse of any sensitive JavaScript function. These values are statically defined and not dynamically processed or injected via unsafe function calls.}	```const mode = { beta: { firebaseConfig: { apiKey: 'AIzaSyC23QyxFJYlDG66PRHcpZbq3sk-T5OD2rU', authDomain: 'cezma-test.firebaseapp.com', projectId: 'cezma-test', storageBucket: 'cezma-test.appspot.com', messagingSenderId: '720310463799', appId: '1:720310463799:web:c0dc972d6787671c14beb2', measurementId: 'G-FK8FJL8DPZ' }, Key_pair: 'BLHS2g0NTtPnr2b-bJ41AOXqg6PaY5lOk-dJTChQDeBAnzo-X2PeokzW14edW5qGFpUSvfIGxs1K_a4_6Hpqbw4' }, production: { firebaseConfig: { apiKey: 'AIzaSyBQl3gxjPZ1RXUUegprdX9rXoq0K9m3O2U', authDomain: 'cezma-65e3a.firebaseapp.com', databaseURL: 'https://cezma-65e3a-default-rtdb.europe-west1.firebasedatabase.app', projectId: 'cezma-65e3a', storageBucket: 'cezma-65e3a.appspot.com', messagingSenderId: '899455794450', appId: '1:899455794450:web:11211aaf46c847728287cb', measurementId: 'G-BHK7M9PRR9' }, Key_pair: 'BHvjyX9voBSwIcca0lOpeEnwEmAJXcwGAlKnu3ZDBTRX5fDXgtXnfOIvk_6GIiXnu65qeWH0JwXlBL3RakRVO1Y' } };```
4282	et3.it.js	Improper Input Validation	High	true	CWE-20	9	N/A	standard	{The URL is constructed using user-controlled `id` from the push event data without validation or sanitization, which can lead to unintended requests or server-side injection if the `id` contains malicious characters or is crafted to trigger unintended behavior.}	```const url = `${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}```
4283	et3.it.js	Insecure Authentication	High	false	CWE-285	N/A	N/A	N/A	{The vulnerability arises from trusting the `loggedIn` parameter extracted from the URL, which is not validated or secured, but it is not caused by misuse of a sensitive JavaScript function.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
4284	et3.it.js	Open Redirect	High	true	CWE-601	9	N/A	standard	{The `navigate` method is used with `data.url`, which is derived from untrusted push notification data, allowing an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url);```
4285	et3.it.js	Improper Neutralization of Input	Medium	true	CWE-79	8	N/A	standard	{The `title` parameter from the server response is passed directly to `showNotification` without sanitization, which could allow for cross-site scripting (XSS) if the title contains malicious script content.}	```self.registration.showNotification(title, options);```
4286	et3.it.js	Insecure Direct Object Reference	Medium	false	CWE-598	N/A	N/A	N/A	{The vulnerability stems from using a regex to check for `type=admin` in the URL, which is not a sensitive function misuse but a logic flaw in access control.}	```if (e.currentTarget.location.href.match(/type=admin/)) {```
4287	herbstore.gr.js	Incorrect Cache Size Calculation Leading to Resource Exhaustion	High	true	CWE-770	10	N/A	standard	{The code calculates cache size by summing content-length headers from cached responses, but it does not account for asynchronous nature of cache.match() calls. This leads to inaccurate size calculation, potentially causing cache overflow beyond CACHE_LIMIT. The misuse of cache.match() in a loop without proper synchronization or aggregation results in incorrect cache size estimation, which can lead to resource exhaustion.}	```if (cacheSize + responseToCache.headers.get('content-length') > CACHE_LIMIT) { let oldestRequest = keys[0]; cache.delete(oldestRequest); }```
4288	roleplays.io.js	Insecure Request Method Handling	Medium	false	CWE-284	N/A	N/A	N/A	{The vulnerability arises from improper handling of request methods and caching logic, particularly when the request mode is 'only-if-cached' and not 'same-origin'. However, this is not due to misuse of a sensitive function like importScripts() or eval(), but rather a logic flaw in the fetch handler. The code does not dynamically construct URLs from untrusted input or invoke functions that execute arbitrary code.}	```event.respondWith(caches.match(request).then(response => { try { return response || fetch(request).then(response => { return response; }).catch(err => { return failedResponse(err); }); } catch (error) { return failedResponse(err); } }));```
4289	weareyard.com.js	Cache Poisoning	High	true	N/A	9	caches.put	standard	{The caches.put function is used to store a response in the cache using the original request as the key. If the request is manipulated (e.g., via a crafted URL or redirect), an attacker could potentially poison the cache with malicious content. Although the code does not directly use untrusted input to construct the request, the fetch() call may return a response from a manipulated or spoofed origin, and the subsequent cache.put() stores it without validation, leading to cache poisoning.}	```return fetch(request).then(function (response) { let responseClone = response.clone(); caches.open(CACHE).then(function (cache) { cache.put(request, responseClone); }); return response; });```
4290	weareyard.com.js	Case-Sensitive URL Check (NEW	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from case-sensitive string matching using String.prototype.search, which does not account for case variations in URLs. This is not due to misuse of a sensitive function but rather a logic flaw in URL filtering.}	```if (request.url.search('extension://') != -1) { return; }```
4291	weareyard.com.js	Insecure Substring Matching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from using substring matching (search) on URLs without proper validation or escaping, which can lead to false negatives or positives. This is a logic issue, not a misuse of a sensitive function.}	```if (request.url.search('/cp/') != -1) { return; }```
4292	producthistory.in.js	Service Worker Interception Without Validation	High	true	CWE-295	N/A	self.addEventListener	standard	{The code uses `self.addEventListener('fetch', ...)` to intercept all fetch requests without validating or sanitizing the request. This allows an attacker to manipulate network requests, potentially leading to data exfiltration, request forgery, or man-in-the-middle attacks. The function `addEventListener` is a standard browser API, and its misuse here stems from lack of input validation or filtering on intercepted requests.}	```self[a0_0x43cbf4(0x19e)](a0_0x43cbf4(0x195), _0x57a603 => { var _0x1c005e = a0_0x43cbf4; _0x57a603[_0x1c005e(0x194)](fetch(_0x57a603[_0x1c005e(0x1a0)])); });```
4293	ashisheditz.com.js	XSS via DOM Insertion	High	true	CWE-79	9	N/A	standard	{The function `innerHTML` is a standard DOM API that directly inserts HTML content into the document. When used with untrusted data (e.g., `e.AlertPopup`), it can lead to Cross-Site Scripting (XSS) if the content contains malicious scripts. The code `i.innerHTML = t;` assigns user-controlled data to `innerHTML`, allowing an attacker to inject arbitrary HTML and JavaScript.}	```var i = e.AlertPopup; i.innerHTML = t;```
4294	ashisheditz.com.js	Insecure Data Handling	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability stems from the exposure of sensitive data (e.g., device info, location, token) in the `y` object, but it is not caused by misuse of a sensitive function. The data is collected and sent via `fetch`, which is used correctly. The issue is more about data exposure than function misuse.}	```let y = { WebsiteCode: WebsiteCode, Token: i, DeviceName: s, BrowserName: r, OperatingSystem: c, IPAddress: d, CountryCode: p, CountryName: u, RegionName: l, CityName: f, ZipCode: g, Latitude: b, Longitude: m, TimeZone: h, CurrentPage: t, PageType: n, EndpointURL: o.endpoint, P256dh: o.keys.p256dh, Auth: o.keys.auth };```
4295	ashisheditz.com.js	Insecure Use of Deprecated APIs	Medium	false	CWE-306	0	N/A	N/A	{The issue arises from using deprecated or insecure methods in Firebase messaging (e.g., `requestPermission()` and `getToken()`), but these are not sensitive functions in the context of direct input handling or injection. The misuse is more about API deprecation than function misuse leading to direct security risks.}	```t.requestPermission().then(function () { console.log('granted'), t.getToken().then(i => { i ? notificationupdate(i, urlcurrent, 'Website', e.VapId_Public_Key) : console.log('No Instance ID token available. Request permission to generate one.'); }).catch(e => { console.log('An error occurred while retrieving token. ', e); }); });```
4296	transus.com.js	Improper Input Validation in Message Handling	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insufficient validation of the message data received via `self.addEventListener('message', ...)`. While the code checks for `e.data.type === 'SKIP_WAITING'`, it does not validate or sanitize the message source or other potential properties, which could lead to unintended behavior if malicious messages are sent. However, this is not caused by misuse of a sensitive function like `importScripts`, `eval`, or `Function`, but rather by logic flaws in message handling.}	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
4297	unilever.nl.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch() function is used with a request URL derived directly from the incoming fetch event's request.url, which is under the control of the client. Although the code includes some filtering via IGNORED_HOSTS and EXCLUDED_URLS, these checks are not comprehensive and do not prevent requests to internal or malicious hosts. This allows an attacker to craft a request to an internal or restricted resource (e.g., localhost, internal APIs), leading to SSRF. The function is standard and its misuse here is direct and high-risk.}	```const { hostname: t } = new URL(e.request.url); IGNORED_HOSTS.indexOf(t) >= 0 || EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || 'PUT' === e.request.method || 'POST' === e.request.method || e.request.headers.get('range') || (e.request.headers.get('Accept').includes('text/html') ? e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E; }).catch(() => caches.match(e.request).then(e => e))) : e.respondWith(caches.match(e.request).then(E => E || caches.open(CACHE_KEYS.RUNTIME).then(E => fetch(e.request).then(n => RUNTIME_IGNORED_HOSTS.indexOf(t) > -1 ? n : E.put(e.request, n.clone()).then(() => n)).catch(() => {}))));```
4298	brive.com.js	Insecure URL Matching Leading to Incorrect Cache Handling	High	true	CWE-20	10	N/A	standard	{The function `url.indexOf(i)` is used to check if a URL contains a substring from `EXTRA_URLS_TO_CACHE_ON_FETCH`. This is unsafe because it performs substring matching rather than exact URL or path matching, allowing partial matches that could lead to unintended caching behavior. For example, if a malicious URL like `https://attacker.com/static/fonts/Roboto/KFOmCnqEu92Fr1Mu72xKOzY.woff2` is requested, it may match a legitimate cached path due to substring overlap, leading to incorrect cache handling and potential cache poisoning or bypass.}	```var exists = false; EXTRA_URLS_TO_CACHE_ON_FETCH.forEach(function (i) { if (url.indexOf(i) !== -1) { exists = true; } }); return exists;```
4299	brive.com.js	Open Redirect via Unvalidated URL in Notification Click	Medium	true	CWE-601	9	N/A	standard	{The `clients.openWindow(d.url)` function is used to open a URL passed from a push notification payload without validation. Since `d.url` is derived from `event.data.json()`, which is untrusted input, an attacker can craft a push notification with a malicious URL, leading to an open redirect that can trick users into visiting phishing sites or malicious domains.}	```clients.openWindow(d.url);```
4300	bolatangkas.homes.js	Information Exposure via Generic Offline Page	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a generic offline page (offlinenew.html) that may expose sensitive information or provide an attacker with insight into the application's structure or internal state. However, this is not caused by misuse of a sensitive JavaScript function, but rather by design or content choice.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate' || event.request.method === 'GET' && event.request.headers.get('accept').includes('text/html')) { event.respondWith(fetch(event.request).catch(error => { return caches.match(OFFLINE_URL); })); } });```
4301	economizavuelo.com.js	External Script Import from Untrusted CDN	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded URL pointing to an external CDN (e.g., 'https://cdn.pushalert.co/sw-71215.js'), it introduces a high-risk vulnerability if the CDN is untrusted or compromised. An attacker could potentially serve malicious code from the CDN, leading to unauthorized execution within the service worker context, which can result in data exfiltration, cache manipulation, or network request interception.}	"```importScripts(""https://cdn.pushalert.co/sw-71215.js"");```"
4302	ggbazar.com.js	Remote Code Execution via CDN Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is called with a dynamic URL derived from options.workboxURL, which is hardcoded to a CDN URL. However, if this URL were to be dynamically sourced from untrusted input (e.g., user-controlled parameters), it could allow an attacker to inject and execute arbitrary JavaScript code. Although the current URL is hardcoded, the use of importScripts() with any dynamic source is inherently risky and qualifies as sensitive function misuse.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
4303	ggbazar.com.js	Insecure Cache Busting via Static Revision	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability arises from the use of a static revision string 'jReoKg8klA1g' in the cache configuration. It is not caused by misuse of a sensitive function, but rather by a poor configuration choice that makes cache invalidation predictable and potentially exploitable.}	```'revision': 'jReoKg8klA1g',```
4304	ggbazar.com.js	Cache First Strategy with No Cache Expiration	Low	false	N/A	N/A	N/A	N/A	{This issue stems from the use of the 'CacheFirst' strategy without explicit cache expiration policies. It is a configuration or design flaw, not a result of misusing a sensitive function. The workbox.strategies[entry.handler] is used correctly, but the absence of cache expiration rules leads to potential stale content issues.}	```const strategy = new workbox.strategies[entry.handler](strategyOptions);```
4305	stalkerinsta.com.js	Cache Versioning Missing	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability 'Cache Versioning Missing' is not caused by the misuse of a sensitive JavaScript function. It arises from the lack of a version identifier in the cache name, which prevents proper cache invalidation when the service worker updates. This is a configuration or design issue, not a function misuse.}	"```var cacheName = 'stalkerinsta';self.addEventListener('install', function (event) {  caches.open(cacheName).then(cache => {    cache.addAll(['./manifest.webmanifest', './images/android-chrome-192x192.png', './images/android-chrome-512x512.png', './images/maskable_icon.png', './images/apple-touch-icon.png', './images/favicon-16x16.png', './images/favicon-32x32.png', './images/favicon.ico', './images/instagram_bg.webp', './images/instagram_colored_image.webp', './images/instagram_image.webp']);  });});self.addEventListener(""fetch"", event => {  const req = event.request;  event.respondWith(cacheFirst(req));});async function cacheFirst(req) {  const cache = await caches.open(cacheName);  const cachedResponse = await cache.match(req);  return cachedResponse || fetch(req);}```"
4306	zigo.co.za.js	External Code Execution via Untrusted Script Import	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://api.pushnami.com/scripts/v2/pushnami-sw/6717cfeafd6bb40016ccacc0'. While the URL is not dynamically constructed from untrusted input, the act of importing external code from a third-party domain still constitutes a security risk, as it allows an external entity to control the execution environment of the service worker. This can lead to unauthorized access, data exfiltration, or manipulation of network requests. The vulnerability is classified as high severity because the imported script runs with the same privileges as the service worker, potentially compromising the entire application.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/6717cfeafd6bb40016ccacc0"");```"
4307	tryspree.com.js	Open Redirect via Unvalidated Notification Action	High	true	CWE-602	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL specified by the notification action, which is derived from untrusted user input (n.notification.actions[0].action). Since this input is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to an open redirect and potential phishing or malicious redirection.}	"```self.addEventListener(""notificationclick"", async function (n) { clients.openWindow(n.notification.actions[0].action); })```"
4308	tryspree.com.js	Unvalidated Push Data in Notification	High	true	CWE-74	9	self.registration.showNotification	standard	{The self.registration.showNotification function is used to display a notification with data derived from untrusted push message data (json.title, json.action, json.body). Since this data is not validated or sanitized, an attacker could inject malicious content into the notification, potentially leading to cross-site scripting (XSS) or phishing attacks if the notification is rendered in a context that executes or displays the data unsafely.}	"```self.registration.showNotification(json.title, { action: json.action, body: json.body, tag: ""tryspree-get-free-samples"", actions: [{ action: json.action, title: json.title }] })```"
4309	bikermatch.co.uk.js	Open Redirect via Push Notification	High	true	CWE-601	10	N/A	standard	{The `self.registration.showNotification` function is used to display notifications, and its `data` object includes a `link` field that is directly derived from the push payload. If an attacker can control the `link` value in the payload (e.g., via a malicious push message), they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities. The function is standard and directly responsible for the vulnerability.}	```self.registration.showNotification(title, { body: message, requireInteraction: true, tag: tag, icon: image, badge: '/images/BM-Icon-Iconified/square-192-bw.png', data: { link: link }, actions: [{ action: 'open', title: 'Open', icon: 'https://www.bikermatch.co.uk/images/icons/desktop-monitor.png' }, { action: 'close', title: 'Close', icon: 'https://www.bikermatch.co.uk/images/icons/remove-symbol.png' }] });```
4310	bikermatch.co.uk.js	Open Redirect via Fetch Handler	High	true	CWE-601	10	N/A	standard	{The `fetch` function is used with `redirect: 'manual'`, and the response is manually handled. When a 301/302 redirect is detected, a new `Response` is created with a `Location` header derived from `response.location`, which is directly taken from the server's redirect response. If the server is compromised or the request is crafted to trigger a redirect to an external URL, this can lead to open redirect. The `fetch` function is standard and its misuse here enables the vulnerability.}	```event.respondWith(fetch(request.url, { credentials: 'same-origin', redirect: 'manual' }).then(response => { if (response.status == 301 || response.status == 302) { var responseInit = { status: 200, statusText: 'Found', headers: { Location: response.location } }; var redirectResponse = new Response('', responseInit); return redirectResponse; } else { addToCache(BMOffline, request, response.clone()); return response; } }).catch(() => { return caches.match(request).then(response => { return response || caches.match('/offline.htm'); }); }));```
4311	bikermatch.co.uk.js	Insecure Redirect Handling in Fetch	Medium	true	CWE-306	9	N/A	standard	{The `fetch` function is used with `redirect: 'manual'`, and the code manually handles redirects by creating a new `Response` with a `Location` header based on `response.location`. This header is not validated or sanitized, allowing an attacker to manipulate the redirect target if the server is compromised or if the request is crafted to trigger a redirect to an external URL. The `fetch` function is standard and its misuse here enables the vulnerability.}	```event.respondWith(fetch(request.url, { credentials: 'same-origin', redirect: 'manual' }).then(response => { if (response.status == 301 || response.status == 302) { var responseInit = { status: 200, statusText: 'Found', headers: { Location: response.location } }; var redirectResponse = new Response('', responseInit); return redirectResponse; } else { addToCache(BMOffline, request, response.clone()); return response; } }).catch(() => { return caches.match(request).then(response => { return response || caches.match('/offline.htm'); }); }));```
4312	hayday.com.js	Information Leakage via Detailed Error Logging	Medium	false	CWE-209	N/A	N/A	N/A	{The vulnerability arises from detailed error logging using console.error, which may expose sensitive information such as stack traces or internal error messages to the console. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by logging behavior.}	```console.error(ctx.error, 'Details:', ctx);```
4313	hayday.com.js	Caching Strategy Bypass via Request Modification	High	true	New	N/A	Request	standard	{The function new Request() is used to modify the cache and mode properties of a request, potentially bypassing intended caching strategies. Since the request object is derived from user-controlled network requests (e.g., via fetch), and the code blindly modifies its cache mode to 'default' and mode to 'no-cors', it can lead to unintended behavior such as bypassing cache restrictions or enabling cross-origin requests that were not intended. This misuse of the standard Request constructor with dynamic input is a sensitive function misuse.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
4314	bookmess.com.js	Workbox Cache Bypass	Medium	false	CVE-2023-23605	N/A	N/A	N/A	{The vulnerability CVE-2023-23605 is related to a cache bypass in Workbox, not due to misuse of a sensitive JavaScript function like importScripts. The code correctly imports Workbox from a trusted, hardcoded URL, and there is no dynamic or untrusted input being used to construct the import path. Therefore, the issue is a library-level vulnerability, not a sensitive function misuse.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');workbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);```
4315	sklep-presto.pl.js	Invalid use of navigator.onLine in Service Worker	High	false	N/A	0	N/A	N/A	{The use of navigator.onLine in a Service Worker is not inherently a sensitive function misuse, as it is a standard API for checking network connectivity. However, its misuse in this context—returning early without handling offline scenarios properly—leads to inconsistent behavior and potential denial of service for offline users. This is a logic flaw, not a sensitive function misuse.}	"```self.addEventListener(""fetch"", event => { if (navigator.onLine) return; if (event.request.url.startsWith(self.location.origin)) { event.respondWith(caches.match(event.request).then(cachedResponse => { if (cachedResponse) { return cachedResponse; } return caches.open(RUNTIME).then(cache => { if (!navigator.onLine) { return caches.match(""/offline.html""); } return fetch(event.request).then(response => { return response; }).catch(error => { console.warn(error); }); })); } });```"
4316	rie.cl.js	Improper Input Validation in URL Check	Medium	false	CWE-20	N/A	N/A	N/A	"{The vulnerability arises from improper validation of the URL string using a simple index check (n < 1) for the substring ""ajaxxxxxxxx.php"". This does not involve any sensitive JavaScript function misuse, as the logic is purely string-based and does not invoke any function that could lead to code execution or injection.}"	```if (n < 1) { console.log('fee2222222', event.request.url); return response || fetch(event.request); } else return new Response();```
4317	rie.cl.js	Uninitialized 'db' Variable Leading to DoS	High	false	CWE-754	N/A	N/A	N/A	{The vulnerability stems from using the uninitialized variable 'db' in a transaction call, which will cause a runtime error and potentially lead to a denial of service. This is not due to misuse of a sensitive function, but rather a logic or initialization error.}	```var och = db.transaction('ga', 'readwrite').objectStore('ga');```
4318	rie.cl.js	Lack of Input Validation for 'idga' Parameter	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is due to insufficient validation of the 'idga' parameter obtained from URL search parameters. Although the parameter is used in a database operation, no sensitive function is misused; the issue is purely input validation failure.}	```var idga = parsedUrl.searchParams.get('ig'); if (idga > 0) { ...```
4319	clubimport.fr.js	Incorrect CSRF Token Handling	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from improper handling of CSRF tokens during guest POST requests. The code dynamically constructs a URL using `new URL(curRequest.url)` and `path = url.pathname`, then fetches a CSRF token via `fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)`. While `fetch` itself is not inherently unsafe, the issue lies in the lack of validation or sanitization of the `path` parameter, which is derived from the request URL. If an attacker can manipulate the request URL (e.g., via a crafted link), they could potentially trigger unintended behavior or bypass CSRF protections by injecting malicious paths. The `fetch` function is used with dynamic, untrusted input, making it a sensitive function misuse in this context.}	```self.addEventListener('fetch', e => { const { request } = e; if (request.url.startsWith(BASE_URL + 'admin/') || e.currentTarget.location.href.match(/type=admin/)) { log('In ACP, nothing to do...'); return; } if (!request.url.startsWith(BASE_URL) || request.method === 'GET' && request.mode !== 'navigate') { return; } if (request.mode === 'navigate' && request.method === 'GET' && !navigator.onLine) { e.respondWith(fetch(request).catch(err => { return caches.open(CACHE_NAME).then(cache => { console.log(`Browser appears to be offline: ${request.url}`); return cache.match(OFFLINE_URL); }); })); return; } let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; } e.respondWith(new Promise((resolve, reject) => { log(`On navigation, logged_in is ${loggedIn}`); if (loggedIn == 'false' && request.method === 'POST') { const curRequest = request.clone(); log('Intercepting guest post request'); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); }); return; } resolve(fetch(request)); }).catch(err => { console.log(err); })); });```
4320	ddcforum.com.js	Server Side Request Forgery (SSRF) via unvalidated push event ID	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a URL constructed from the unvalidated `id` parameter received from a push event. Since `id` is derived from external data (push notification payload), an attacker can manipulate it to trigger requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4321	ddcforum.com.js	Server Side Request Forgery (SSRF) via unvalidated request path in fetch handler	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a URL constructed from the unvalidated `path` parameter derived from the request URL. Since `path` is extracted from user-controlled input, an attacker can manipulate it to trigger requests to unintended endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4322	ddcforum.com.js	Open Redirect via unvalidated notification data URL	High	true	CWE-601	10	N/A	standard	{The self.clients.openWindow() function is used with a URL derived from the `data.url` field in the notification payload, which is unvalidated. An attacker can craft a notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL)```
4323	tuttogratis.it.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the untrusted 'sensor_url' parameter received in the push event data. Since 'sensor_url' is directly controlled by the attacker (via the push message), it allows the service worker to make HTTP requests to arbitrary internal or external endpoints, leading to SSRF.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.tuttogratis.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
4324	tuttogratis.it.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from the 'url' field in the notification data, which is untrusted and controlled by the attacker. This allows the service worker to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.tuttogratis.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```
4325	agglo-montbeliard.fr.js	Improper Cache Validation Leading to Stale Content Delivery	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of cache validation strategy, not from misuse of a sensitive function. The code simply returns cached responses if available, otherwise fetches fresh content. No sensitive function is being misused here.}	```self.addEventListener('fetch', e => { e.respondWith(caches.match(e.request).then(response => response || fetch(e.request))); });```
4326	red-redial.net.js	Exposure of Sensitive Information to an Unauthorized Actor	High	true	CWE-532	N/A	N/A	standard	{The sensitive function `const` is not a function, but the vulnerability arises from hardcoding sensitive credentials (API key, project ID, etc.) in the `options` object. While not a function misuse per se, the exposure is due to the lack of protection for these values in the service worker script, which is publicly accessible. This allows attackers to extract Firebase credentials and potentially abuse the backend services.}	```const options = { firebaseConfig: { projectId: 'push-f20d3', messagingSenderId: '1008514102757', appId: '1:1008514102757:web:7c6b3a4b5431c2f9b6ab0c', apiKey: 'AIzaSyCrKcrxkwD1XxtzPH3qKJ_IuncGDEa_s1M' }, domain: 'www.red-redial.net', api_url: 'https://push.readtrustedreviews.com/api/token', vapid_public_key: 'BLg4TxOrH_FSxoYVgxq5svQ0RK_646DBD7OuzczIwANq01onTSElSt7QkvbglFxODaGc6kB_mjmvs4bQEu60dfM' };```
4327	red-redial.net.js	Open Redirect	Medium	true	CWE-601	N/A	N/A	standard	{The `clients.openWindow()` function is used with `event.notification.data.url`, which is derived from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to phishing or open redirect attacks.}	```clients.openWindow(event.notification.data.url);```
4328	red-redial.net.js	Open Redirect	Medium	true	CWE-601	N/A	N/A	standard	{The `clients.openWindow()` function is used with `event.notification.data.actions[event.action].click_action`, which is also derived from untrusted push notification data. Without validation, this allows attackers to redirect users to arbitrary URLs via crafted notification actions, enabling open redirect vulnerabilities.}	```clients.openWindow(event.notification.data.actions[event.action].click_action);```
4329	red-redial.net.js	Exposure of Sensitive Information to an Unauthorized Actor	High	true	CWE-312	N/A	N/A	standard	{The `fetch()` function is used to send sensitive data (push subscription details, token, endpoint, auth, p256dh) to a remote API endpoint (`options.api_url`). Since this data is transmitted over HTTP (if `http` is true) or even over HTTPS without proper authentication or encryption, it can be intercepted or exposed to unauthorized parties, leading to potential abuse of push subscription data.}	"```fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) })```"
4330	steinway.co.uk.js	Insecure Online Status Check	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from relying on `navigator.onLine` for determining online status, which is unreliable and can be misleading. However, this is not caused by misuse of a sensitive function like `importScripts()` or `eval()`, but rather by a logic flaw in network detection.}	```if (!online) { var fetchFromNetwork = function (response) { var cacheCopy = response.clone(); if (event.request.headers.get('Accept').indexOf('text/html') != -1) { caches.open(version + 'pages').then(function (cache) { cache.put(event.request, cacheCopy).then(function () { limitCache(cache, 25); }); }); } else if (event.request.headers.get('Accept').indexOf('image') != -1) { caches.open(version + 'images').then(function (cache) { cache.put(event.request, cacheCopy).then(function () { limitCache(cache, 10); }); }); } else { caches.open(version + 'assets').then(function add(cache) { cache.put(event.request, cacheCopy); }); } return response; }; var fallback = function () { if (event.request.headers.get('Accept').indexOf('text/html') != -1) { return caches.match(event.request).then(function (response) { return response; }); } }; if (event.request.url.match(/wp-admin/) || event.request.url.match(/preview=true/)) { return; } if (event.request.method != 'GET') { return; } if (event.request.headers.get('Accept').indexOf('text/html') != -1) { event.respondWith(fetch(event.request).then(fetchFromNetwork, fallback)); return; } event.respondWith(caches.match(event.request).then(function (cached) { return cached || fetch(event.request).then(fetchFromNetwork, fallback); })); }```
4331	steinway.co.uk.js	Improper Content-Type Validation	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from using `indexOf` on the Accept header to determine content type, which is imprecise and can lead to incorrect caching decisions. This is a logic or validation flaw, not misuse of a sensitive function such as `eval()` or `importScripts()`.}	```if (event.request.headers.get('Accept').indexOf('text/html') != -1) { caches.open(version + 'pages').then(function (cache) { cache.put(event.request, cacheCopy).then(function () { limitCache(cache, 25); }); }); } else if (event.request.headers.get('Accept').indexOf('image') != -1) { caches.open(version + 'images').then(function (cache) { cache.put(event.request, cacheCopy).then(function () { limitCache(cache, 10); }); }); } else { caches.open(version + 'assets').then(function add(cache) { cache.put(event.request, cacheCopy); }); }```
4332	steinway.co.uk.js	Recursive Cache Trimming Leading to Stack Overflow	High	true	CWE-758	N/A	trimCache	standard	{The `trimCache` function recursively calls itself without proper base case or stack limit, leading to potential stack overflow. The function is a standard JavaScript function (though custom-defined), and its misuse in recursive calls without bounds checking causes the vulnerability.}	```caches.open(cacheName).then(function (cache) { cache.keys().then(function (keys) { if (keys.length > maxItems) { cache.delete(keys[0]).then(trimCache(cacheName, maxItems)); } }); });```
4333	steinway.co.uk.js	Missing Fallback for Non-HTML Requests	Medium	false	CWE-754	N/A	N/A	N/A	{This vulnerability arises from not providing a fallback for non-HTML requests when the cache does not contain a response. It is a logic flaw in the fetch handler, not caused by misuse of a sensitive function like `eval()` or `importScripts()`.}	```event.respondWith(caches.match(event.request).then(function (cached) { return cached || fetch(event.request).then(fetchFromNetwork, fallback); }));```
4334	facture.cr.js	Cache Poisoning via Overly Permissive Regex	High	true	CWE-94	10	workbox.routing.registerRoute	standard	{The use of a broad regular expression `/app/assets/` in `workbox.routing.registerRoute` allows any URL matching that pattern to be cached without validation. This can lead to cache poisoning if an attacker can manipulate the URL to include malicious assets that are then cached and served to users. The sensitive function `workbox.routing.registerRoute` is misused by accepting an overly permissive regex without restricting the exact path or validating the origin.}	```workbox.routing.registerRoute(new RegExp('/app/assets/'), new workbox.strategies.CacheFirst({ cacheName: 'assets-cache', plugins: [new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }), new workbox.expiration.ExpirationPlugin({ maxAgeSeconds: 60 * 60 * 24 * 90, maxEntries: 80 })] }));```
4335	facture.cr.js	Unvalidated Client URL in Message Targeting	Medium	true	CWE-94	9	client.postMessage	standard	{The `client.postMessage` function is used to send messages to clients whose URLs are checked via `client.url.indexOf('punto_de_venta') > 1`. This check is flawed because it does not validate the full URL or origin, allowing an attacker to spoof a client URL that contains 'punto_de_venta' in a non-secure context (e.g., a malicious subdomain or path). This misuse of `client.postMessage` enables unauthorized message delivery to unintended clients, potentially leading to data leakage or cross-site scripting.}	```if (client.url.indexOf('punto_de_venta') > 1) { client.postMessage(body); matched = true; }```
4336	nativenews.in.js	External Script Import Vulnerability	High	true	N/A	9	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a hardcoded URL (https://cdn.izooto.com/scripts/workers/dacd423bc3a0684270375f2b3d469071941bfab6.js). While the URL is not dynamically constructed from untrusted input, the script is loaded from an external source, which introduces a risk if the source is compromised or if the script is not properly vetted. This constitutes a high-risk vulnerability because the service worker executes arbitrary code from a third-party domain, potentially leading to full compromise of the service worker's behavior.}	"```importScripts(""https://cdn.izooto.com/scripts/workers/dacd423bc3a0684270375f2b3d469071941bfab6.js"");```"
4337	nativenews.in.js	Cache Poisoning Risk	Medium	false	N/A	N/A	N/A	N/A	{The code caches a static '/offline' response, which is not dynamically constructed from user input or untrusted sources. Therefore, there is no misuse of a sensitive function leading to cache poisoning. The risk is low because the cached content is fixed and not influenced by external or untrusted data.}	```return cache.match('/offline');```
4338	optionbaaz.ir.js	Unreachable Code in Push Event Handler	Medium	false	N/A	0	N/A	N/A	{The code in the push event handler is unreachable due to the `return;` statement immediately following the event listener registration. This does not involve any sensitive function misuse, as no dangerous or dynamic function calls are made with untrusted input. The issue is purely structural and does not lead to security vulnerabilities such as injection or unauthorized execution.}	"```self.addEventListener('push', function (event) { return; console.log('[Service Worker] Push Received.'); console.log(`[Service Worker] Push had this data: ""${event.data.text()}""`); const title = 'Push Codelab'; const options = { body: 'Yay it works.', icon: 'img/icon.png', badge: 'img/badge.png' }; event.waitUntil(self.registration.showNotification(title, options)); });```"
4339	sugarfans.com.js	Open Redirect via Unvalidated URL Parameter	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from notification.data.url, which is constructed via the appendNotiSeen function. This function appends a 'notiSeen' parameter to a URL without validating or sanitizing the input URL. If the original URL is controlled by an attacker (e.g., via a malicious payload.link), it can be crafted to redirect to an arbitrary external site, leading to an open redirect vulnerability. The sensitive function clients.openWindow directly executes the untrusted URL, enabling the redirect.}	```if (typeof url === 'string' && url.includes('?')) { return url + '&notiSeen=' + id; } return url + '?notiSeen=' + id;```
4340	triider.com.br.js	Insecure External Script Loading	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard service worker API that loads and executes a script from a specified URL. In this case, it is used to load a script from a hardcoded external URL (https://api.pushio.com/webpush/sdk/service_min.js). While the URL is not dynamically constructed from untrusted input, the act of loading external scripts in a service worker can still pose a security risk if the script source is not fully trusted or if the script can be tampered with (e.g., via DNS hijacking or man-in-the-middle attacks). However, since the URL is hardcoded and not derived from user input, the risk is mitigated but not eliminated. The vulnerability is primarily due to the use of importScripts with an external source, which is considered a sensitive operation in service workers.}	```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');```
4341	triider.com.br.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The sensitive information (appserviceKey, apiKey, accountToken) is exposed in the client-side JavaScript code as a hardcoded JSON string. This is not caused by misuse of a sensitive JavaScript function, but rather by poor security practices in code deployment. The data is directly embedded in the script, making it accessible to anyone who views the source. No function is being misused here; it's a static data exposure issue.}	"```const config = '{""appserviceKey"":""BN088bmj5uASY-hVKcx2E1QtkrkxO-fI8tWUP7IvlkwrQAMw3Hlrewm-NhR82V-cUjqv355kwjuY1eCdSF5JgA8="",""apiKey"":""ABEvkKWwxYtYYgvFzbQGitA9w"",""accountToken"":""ABEie28U1p_azmSYs74Bo1MMY"",""appver"":""0.0.0"",""apiHost"":""https://api.pushio.com"",""lazy"":false}';```"
4342	ahorrototal.com.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The function `clients.openWindow(url)` is a standard Service Worker API that opens a new browser window or tab with the specified URL. When the URL is derived from `notificationData.target_url`, which is parsed from untrusted push notification data, it allows an attacker to control the destination URL. This leads to an open redirect vulnerability, enabling phishing or malicious redirection.}	```const url = notificationData.target_url; if (url) { event.notification.close(); event.waitUntil(Promise.all([clients.matchAll({ type: 'window' }).then(function (windowClients) { if (clients.openWindow) { return clients.openWindow(url); } })])); }```
4343	nadorzik.com.js	Improper Error Handling in Service Worker Installation	High	false	N/A	0	N/A	N/A	{The vulnerability is due to improper error handling during the installation phase, where errors from cache.addAll() are not caught or logged, potentially leading to silent failures in caching critical assets. This is not caused by misuse of a sensitive function, but rather by a lack of robust error handling in the service worker lifecycle.}	```const staticCacheName = 'nzik-s6'; const assets = ['/', '/js/js.min.js', '/css/style.min.css', '/offline', '/images/logos.png', 'https://cdn.plyr.io/3.5.6/plyr.js', 'https://cdn.plyr.io/3.5.6/plyr.css']; self.addEventListener('install', evt => { evt.waitUntil(caches.open(staticCacheName).then(cache => { console.log('caching shell assets'); cache.addAll(assets); })); });```
4344	wanderersways.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-602	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. If an attacker can control or manipulate the `id` value, they could craft a request to internal or external endpoints, leading to SSRF. The URL is built using string concatenation without validation, making it vulnerable to malicious input.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4345	wanderersways.com.js	Insufficient Input Validation	Medium	true	CWE-20	8	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since `path` is derived from the client's request without sanitization or validation, an attacker could inject arbitrary paths or even external URLs, leading to unintended requests or potential SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4346	minecraft.jp.js	Vulnerable Data Exposure in Push Subscription ID	Medium	true	CWE-548	9	N/A	standard	{The function `fetch()` is used with a dynamically constructed URL that includes `subscriptionId`, which is derived from the push subscription endpoint. Although the subscription ID is not directly user-controlled, it is sensitive data that could be exposed via the URL path, potentially leading to information leakage if the endpoint is logged or intercepted. The misuse lies in exposing this identifier in a public-facing URL without proper sanitization or access controls.}	```return fetch('/_/push/web_push_content/' + subscriptionId);```
4347	minecraft.jp.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	9	N/A	standard	{The function `clients.openWindow(url)` is used with a `url` value derived from the `event.notification.tag` which is parsed from user-controlled input (notification tag). This allows an attacker to craft a notification with a malicious tag that redirects the user to an arbitrary URL, potentially leading to phishing or drive-by downloads. The function is standard and directly executes navigation based on untrusted input.}	```return clients.openWindow(url);```
4348	grossovacanze.com.js	Improper Handling of Push Message Data Leading to Deserialization of Untrusted Data	High	true	CWE-502	10	.json()	standard	{The .json() method is used on untrusted push message data without validation or sanitization. If the data is a Response object, it is deserialized directly, which can lead to deserialization of untrusted data, potentially allowing an attacker to inject malicious payloads or trigger unintended behavior.}	N/A
4349	```function (n) { return n instanceof Response ? n.ok ? n.json() : { title: \'\', message: \'A new post has been published.\', id: 0 } : n; }```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```function (n) { return n instanceof Response ? n.ok ? n.json() : { title: \'\', message: \'A new post has been published.\', id: 0 } : n; }```
4350	grossovacanze.com.js	Exposure of Sensitive Information in URL Query String	Medium	true	CWE-200	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL constructed with sensitive data (e.g., token, post ID) via toQueryString, which directly encodes the data into a query string. This exposes sensitive information in the URL, which can be logged, intercepted, or leaked through browser history or referrer headers.}	N/A
4351	thinksaveretire.com.js	Improper Input Validation	High	true	CWE-20	8	N/A	standard	{The function `new URL(event.request.url)` is used to parse the request URL, and the resulting `pathname` is directly used to construct a key for `idbKeyval.get()`. Since `event.request.url` is derived from user input (the request URL), and no sanitization or validation is applied to the `pathname` before using it in the key, this allows an attacker to inject arbitrary keys into the IDB storage, potentially leading to information disclosure or unauthorized data access.}	```const { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``); const resources = await idbKeyval.get(`resources:${pathname}`);```
4352	thinksaveretire.com.js	Open Redirect	High	true	CWE-601	9	N/A	standard	{The `Response` constructor is used with a `Location` header set to `lastNavigationRequest`, which is derived from `event.request.url` without any validation or sanitization. Since `event.request.url` is user-controlled, an attacker can manipulate the URL to redirect users to arbitrary external sites, leading to open redirect vulnerabilities.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
4353	thinksaveretire.com.js	Improper Input Sanitization	Medium	true	CWE-707	7	N/A	standard	{The `pathname.match(/:(.+)/)[1]` extracts a parameter from the URL path, which is then split and parsed into key-value pairs without any sanitization. This allows an attacker to inject arbitrary keys into the `data` object, potentially leading to unintended behavior or execution of unintended API calls if those keys map to functions in `MessageAPI`.}	```const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; }```
4354	expomx.in.js	Regular Expression Denial of Service (ReDoS)	High	true	N/A	N/A	RegExp	standard	{The regular expressions created from JSON-parsed strings (e.g., `new RegExp(e)`) are dynamically constructed from user-controlled or untrusted input. If an attacker can influence the pattern (e.g., via a maliciously crafted URL or configuration), they can inject complex, exponential-time patterns that cause ReDoS. The `RegExp` constructor is standard and directly responsible for this vulnerability when used with untrusted input.}	"```const c = JSON.parse('[""expomx\\\\.in(?:/.*)?/ola/services/.*"",""expomx\\\\.in/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://1e359bb4-cabe-4e03-bd77-8db8ba90a350\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4355	expomx.in.js	Server Side Request Forgery (SSRF)	Medium	true	N/A	N/A	URL	standard	{The `URL` constructor is used with dynamic input (e.g., `new URL(e, location.href)`), where `e` is derived from request URLs or other untrusted sources. If an attacker can control the input URL, they can force the service worker to make requests to internal or external systems, leading to SSRF. The `URL` constructor is a standard function, and its misuse with untrusted input is the root cause.}	```const t = new URL(e, location.href);```
4356	expomx.in.js	Cross-Origin Resource Sharing (CORS) Misconfiguration	Medium	true	N/A	N/A	URL	standard	{The code checks if a URL's origin matches `self.location.origin` using `new URL(e.url).origin`. If the input URL is untrusted or improperly validated, an attacker could bypass origin checks by manipulating the URL, leading to CORS misconfiguration. The `URL` constructor is standard and directly involved in this vulnerability.}	```if (s !== self.location.origin) throw new n.V('cross-origin-copy-response', { origin: s });```
4357	expomx.in.js	Cached Response Spoofing	Medium	true	N/A	N/A	Response	standard	{The `Response` constructor is used with dynamic input (e.g., `new Response(o, c)`), where `o` is derived from a cloned or blobbed response body. If the input response is untrusted or manipulated, it can lead to spoofed cached responses. The `Response` constructor is standard and its misuse with untrusted data is the cause.}	```return new Response(o, c);```
4358	expomx.in.js	Insecure Cache Key Generation	Low	true	N/A	N/A	URL	standard	{The `URL` constructor is used to generate cache keys from dynamic input (e.g., `new URL(e.url)`). If the input URL is untrusted or not properly sanitized, it can lead to insecure or predictable cache keys, enabling cache poisoning or bypasses. The `URL` constructor is standard and its misuse with untrusted input is the root cause.}	```const s = new URL(e.url).origin;```
4359	sub2me.com.ng.js	Invalid Cache Option in cache.addAll	Low	false	N/A	0	N/A	N/A	"{The issue is not due to misuse of a sensitive function but rather an invalid or unsupported option passed to cache.addAll(). The 'cache: ""reload""' option is not a valid parameter for cache.addAll(), which only accepts an array of URLs. This is a misuse of the API syntax, not a security vulnerability arising from untrusted input or unsafe function execution.}"	```let CACHE_SITE = 'sub2me-pwa-v.1.2.3.DEV'; let CACHE_DASHBOARD = 'sub2me-dashboard-v.1.2.3.DEV'; let urlsToCache = ['/offline.html', '/css/pwa.css', '/js/pwa.js', '/manifest.json', '/img/pwa/pwa.svg', '/img/pwa/192.png', '/img/pwa/512.png', '/img/pwa/maskable_icon.png']; self.addEventListener('install', function (event) { self.skipWaiting(); event.waitUntil(caches.open(CACHE_SITE).then(function (cache) { return cache.addAll(urlsToCache, { cache: 'reload' }); })); });```
4360	rapido.rentals.js	Cache Poisoning	High	true	N/A	N/A	this.cache.put	standard	{The `put` method of the Cache API is used to store a response in the cache. If the request URL or response content is derived from untrusted or unsanitized input (e.g., from a client request or external source), an attacker could inject malicious content into the cache, leading to cache poisoning. This allows attackers to serve malicious responses to other users or bypass security checks. The code does not validate or sanitize the `req` or `res` parameters before storing them, making it vulnerable to cache poisoning attacks.}	```this.cache.put(req, res.clone());```
4361	rapido.rentals.js	Insecure Direct Object Reference	Medium	false	N/A	N/A	N/A	N/A	{The `open` method is used to open a cache with a dynamically constructed name. While the cache name is derived from a prefix and a provided `cacheName`, there is no indication that `cacheName` is user-controlled or unsanitized. The vulnerability is more related to improper access control or lack of validation rather than misuse of a sensitive function.}	```const cache = await this.original.open(`${this.cacheNamePrefix}:${cacheName}`);```
4362	rapido.rentals.js	Improper Input Validation	Low	false	N/A	N/A	N/A	N/A	{The `parseUrl` method is used to parse URLs, but it does not appear to be misused with untrusted input. The method is called with `url` and `this.scopeUrl`, which are likely controlled by the service worker’s scope and not directly from user input. The vulnerability is more about general input validation rather than misuse of a sensitive function.}	```const parsed = this.parseUrl(url, this.scopeUrl);```
4363	rapido.rentals.js	Insecure Data Storage	Medium	false	N/A	N/A	N/A	N/A	{The `write` method is used to store metadata in a cache. The data being written is derived from `res.metadata`, which is obtained from a response. While this could be a security concern if the response is from an untrusted source, the code does not indicate that the `res` object is directly controlled by an attacker. The vulnerability is more about data integrity and storage practices than misuse of a sensitive function.}	```await this.metadata.write(req.url, __spreadProps(__spreadValues({}, res.metadata), { used: false }));```
4364	rapido.rentals.js	Exposure of Sensitive Information	Low	false	N/A	N/A	N/A	N/A	{The `push` method is used to add debug log entries. The data being logged is derived from `value` and `context`, which are likely internal to the service worker. There is no indication that this data is derived from untrusted input or that the logging mechanism is misused. The vulnerability is more about logging practices than misuse of a sensitive function.}	```this.debugLogA.push({ value, time: this.adapter.time, context });```
4365	animes-portal.info.js	Open Redirect in Notification Click Handler	High	true	CWE-601	9	N/A	standard	{The `clients.openWindow(open_link)` function is used to open a URL derived from untrusted push notification data. Since `open_link` is directly assigned from `event.notification.data` or `event.action`, which are controlled by the server sending the push notification, an attacker can manipulate this data to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	"```var open_link = event.notification.data ? event.notification.data : event.action !== undefined ? '/' : ''; event.waitUntil(clients.matchAll({ type: ""window"" }).then(clientList => { for (const client of clientList) { console.log(client.url, open_link); if (client.url === open_link && ""focus"" in client) return client.focus(); } if (clients.openWindow) return clients.openWindow(open_link); }));```"
4366	animes-portal.info.js	Insecure Push Data Handling	Medium	true	New	8	N/A	standard	{The `event.data.json()` is used to parse push notification data, and the resulting `notif_url` is directly assigned to `payload['data']` without validation or sanitization. This allows an attacker to inject arbitrary URLs into the notification payload, potentially leading to phishing, open redirects, or unintended navigation, as the URL is used in the notification's `data` field which may be used later to open links.}	```const { notif_url, ... } = event.data.json(); if (notif_url) { payload['data'] = notif_url; }```
4367	aoccalculator.in.js	Exposure of Sensitive Information (Firebase Credentials)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding Firebase credentials (apiKey, authDomain, etc.) in the script, which are exposed to anyone who can view the source. This is not due to misuse of a sensitive function, but rather poor secret management.}	"```importScripts(""https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js""); firebase.initializeApp({ apiKey: ""AIzaSyAqmTlsyfaC9PJvE-EgQoLTCUkSGDhicQ0"", authDomain: ""ltpcalculator-1a271.firebaseapp.com"", projectId: ""ltpcalculator-1a271"", storageBucket: ""ltpcalculator-1a271.appspot.com"", messagingSenderId: ""874255684437"", appId: ""1:874255684437:web:c14f9791db1073042ed5dc"", measurementId: ""G-F21DT0GTB6"" });```"
4368	aoccalculator.in.js	Information Exposure Through Logging	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from logging the entire message object received via `onBackgroundMessage`, which may contain sensitive data. This is not due to misuse of a sensitive function, but rather improper logging practices.}	```messaging.onBackgroundMessage(m => { console.log('onBackgroundMessage', m); });```
4369	aranycsillag.net.js	Caching of Sensitive Data via URL Patterns	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching responses based on URL patterns that include '/uploads/', '/themes/arany', 'manifest', and 'logo-icon'. While this is not caused by misuse of a sensitive JavaScript function like importScripts() or eval(), it represents a logic flaw in the caching strategy. The code caches responses without validating their sensitivity or origin, potentially exposing user-uploaded or theme-specific content to unauthorized access or replay attacks. This is a configuration or policy issue, not a direct function misuse.}	```if (response.status < 400 && (request.url.indexOf('/uploads/') > -1 || request.url.indexOf('/themes/arany') > -1 || request.url.indexOf('manifest') > -1 || request.url.indexOf('logo-icon') > -1)) { cache.put(request, response.clone()); }```
4370	arunachalluckydraw.in.js	Improper Input Validation in Fetch Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper handling of network errors in the fetch event. The code does not use any sensitive functions like importScripts, eval, or dynamic code execution. The fetch() call itself is safe when used with event.request, which is trusted within the service worker context. The issue lies in the lack of proper error handling or fallback logic, not in sensitive function misuse.}	```self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request).catch(function () { return new Response('Network request failed.'); })); });```
4371	asomiyapratidin.in.js	External Script Inclusion via importScripts	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it is used with a hard-coded URL (https://cdn.izooto.com/scripts/workers/e9fa033b6287ea8d89a1a6e67a13a9de12a83f3d.js), which is not inherently unsafe. However, the vulnerability arises because the script is loaded from an external, third-party domain (cdn.izooto.com), which is outside the control of the site owner. If the third-party script is compromised or malicious, it can execute arbitrary code within the service worker context, leading to potential data exfiltration, cache manipulation, or network interception. While the URL is not dynamically constructed from untrusted input, the reliance on an external script introduces a trust boundary risk, making it a sensitive function misuse in the context of secure service worker design.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/e9fa033b6287ea8d89a1a6e67a13a9de12a83f3d.js"");```"
4372	assamjob.co.in.js	Improper Handling of Fetch Event Leading to Potential Denial of Service	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of proper handling of the fetch event, which could lead to unintended behavior or resource exhaustion if not managed correctly.}	```self.addEventListener('fetch', evt => { console.log('fetch event', evt); });```
4373	astrosens.ro.js	Hardcoded API Key in Fetch Request	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials in a fetch request, not misuse of a sensitive function. The fetch function is used correctly with a static URL, and no dynamic or untrusted input is involved.}	"```self.addEventListener('push', function (event) { event.waitUntil(fetch(""https://apism.speedmeta.com/get_notification_V2/?key=MZUGTCXKA21MXCGHMSUV"").then(function (response) { if (response.status !== 200) { throw new Error(); } return response.json().then(function (data) { if (data.error || !data.notification) { throw new Error(); } var ua = navigator.userAgent.toLowerCase(); var isMac = ua.indexOf(""macintosh"") > -1; var title = data.notification.title; var message = data.notification.message; var icon = data.notification.icon; var image = data.notification.image; var notificationTag = data.notification.tag; var final_link = data.notification.link; var req_interaction = isMac ? false : true; return self.registration.showNotification(title, { body: message, icon: icon, image: image, tag: notificationTag, data: data, requireInteraction: req_interaction }); }); }).catch(function (err) { console.error('Unable to retrieve data', err); }); });```"
4374	astrosens.ro.js	Improper Input Validation of Notification Link	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic URL derived from the notification data (ev.notification.data.notification.link). Since this URL is not validated or sanitized, an attacker could craft a malicious notification payload to redirect users to arbitrary sites, leading to phishing or drive-by downloads.}	"```ev.waitUntil(clients.matchAll({ type: ""window"" }).then(function (clientList) { return clients.openWindow(ev.notification.data.notification.link); }));```"
4375	atestado.me.js	Use of Weak Cryptographic Algorithm (SHA)	Medium	false	CWE-327	0		standard	{The vulnerability arises from the use of SHA-1, which is considered cryptographically weak and susceptible to collision attacks. However, this is not due to misuse of a sensitive JavaScript function, but rather the inherent weakness of the algorithm itself. The code correctly implements SHA-1 without introducing additional risks through improper function usage.}	```function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8); }```
4376	aviator-1win.store.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The code parses JSON from `event.data.json()` without validating or sanitizing the input, which could lead to unintended behavior if the data contains malicious or malformed content. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a general lack of input validation.}	```const dataJson = event.data.json();```
4377	babyforest.in.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL (as in '//cdnt.netcoresmartech.com/sw.js'), it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows an attacker who compromises the external domain to inject malicious code into the service worker, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the use of a remote script from an external source without integrity verification or origin validation is considered a sensitive misuse.}	```importScripts('//cdnt.netcoresmartech.com/sw.js');```
4378	bancasorte.bet.js	Caching Without Error Handling	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of error handling during the cache.addAll() operation. While cache.addAll() is a standard function, the issue stems from not handling potential errors during caching, which could lead to silent failures or inconsistent cache states. This is a logic or design flaw, not a sensitive function misuse.}	```const cache.addAll(urlsToCache);```
4379	baramatiwarta.in.js	Cache Name Uses HTTP Instead of HTTPS	Low	false	N/A	0	N/A	N/A	{The cache name is hardcoded as 'http://baramatiwarta.in-superpwa-2.2.31', which uses HTTP instead of HTTPS. This is a configuration issue, not a result of misuse of a sensitive function. No dynamic or untrusted input is involved, and no function is being misused to introduce a security risk.}	```const cacheName = 'http://baramatiwarta.in-superpwa-2.2.31';```
4380	basketball.bg.js	Improper Cache Versioning Leading to Stale Content	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from static cache key usage ('video-store') without versioning or expiration strategy, leading to stale content being served. This is not due to misuse of a sensitive function, but rather a design/implementation flaw in cache management.}	```self.addEventListener('install', function (e) { e.waitUntil(caches.open('video-store').then(function (cache) { return cache.addAll(['/img/logo.png', '/js/fns_2.js', '/css/main.css']); })); });```
4381	bazodo.com.js	Exposure of Sensitive Information in Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key) in client-side JavaScript, not from misuse of a sensitive function. The code does not invoke any function with untrusted input that could lead to injection or execution risks.}	"```const firebaseConfig = { apiKey: ""AIzaSyDEjPg6dN2vGBPkUr9Ur9pcnMeL28V2mmA"", authDomain: ""bazodo-green.firebaseapp.com"", databaseURL: ""https://bazodo-green.firebaseio.com"", projectId: ""bazodo-green"", storageBucket: ""bazodo-green.appspot.com"", messagingSenderId: ""1089637188997"", appId: ""1:1089637188997:web:ac64d19f7cedf1ccd9b0ec"", measurementId: ""G-YM8ZXRXH9H"" };```"
4382	beloops.com.js	Incorrect Cache Name Usage	Medium	false	New	N/A	N/A	N/A	{The issue arises from using a hardcoded cache name 'cache' instead of the defined constant CACHE_NAME, which may lead to cache management inconsistencies or unintended cache overwrites, but it does not involve misuse of a sensitive function.}	```var cache = await caches.open('cache');```
4383	bestrealty.com.ua.js	Improper Cache Cleanup Leading to Cache Bloat	Medium	false	New	N/A	N/A	N/A	{The issue arises from improper cache cleanup logic, specifically filtering cache names that start with 'routeandgo-pwa-' while excluding the current staticCacheName. This is not a misuse of a sensitive function but rather a logic flaw in cache management. No sensitive function is involved.}	```cacheNames.filter(cacheName => cacheName.startsWith('routeandgo-pwa-')).filter(cacheName => cacheName !== staticCacheName).map(cacheName => caches.delete(cacheName))```
4384	bestrealty.com.ua.js	Insecure Fetch Handling Leading to Potential Cache Poisoning	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from the use of `fetch(event.request)` without validation or sanitization of the request, which could allow cache poisoning if the request is manipulated. However, this is not due to misuse of a sensitive function but rather a design flaw in handling fetch responses. The `fetch` API is used correctly in context, and no sensitive function misuse is present.}	```return response || fetch(event.request);```
4385	beta-pb.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a URL constructed from the id parameter received from a push event. Since id is derived from untrusted external data (push notification payload), an attacker can manipulate it to cause the service worker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4386	beta-pb.com.js	Authentication Bypass via URL Parameter	High	false	CWE-285	0	N/A	N/A	{The vulnerability arises from directly trusting the loggedIn parameter from the URL without server-side validation or secure session management. This is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in handling URL parameters.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4387	beta-pb.com.js	Cross-Site Request Forgery (CSRF) Token Handling	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used to retrieve a CSRF token from the server based on the current request path. While the token is then used to secure subsequent requests, the initial fetch is triggered by a guest POST request, which may be initiated by an attacker. If the token retrieval endpoint is not properly protected, this could allow CSRF attacks.}	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
4388	betw77.com.js	Caching of Sensitive Data via Case-Sensitive URL Exclusion Check	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a case-sensitive string matching approach using `indexOf` on `e.request.url`, which may fail to exclude sensitive paths if they differ in case (e.g., `/Api/` vs `/api/`). This is not due to misuse of a sensitive function, but rather a logic flaw in exclusion logic.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
4389	betw77.com.js	Insecure Caching of Sensitive API Responses	High	false	N/A	N/A	N/A	N/A	{The vulnerability stems from caching all responses without proper validation or filtering, which may include sensitive data. This is not caused by misuse of a sensitive function, but rather by a design flaw in caching strategy.}	```e.respondWith(caches.match(e.request).then(response => response || fetch(e.request)));```
4390	bezplatno.net.js	Cache Invalidation with Null Revisions	Medium	false	CWE-310	N/A	N/A	N/A	{The vulnerability arises from using null revisions in the REQUIRED_ASSETS array, which prevents Workbox from properly invalidating cached assets during updates. This is not due to misuse of a sensitive function, but rather a configuration issue in the precaching strategy.}	```workbox.precaching.precacheAndRoute(REQUIRED_ASSETS);```
4391	bezplatno.net.js	Caching of Sensitive Resources with Long MaxAge	Low	false	CWE-310	N/A	N/A	N/A	{The vulnerability stems from setting a long maxAgeSeconds (30 days) for cached images, which may lead to stale content being served. This is a configuration issue, not a result of misusing a sensitive function.}	```new workbox.expiration.ExpirationPlugin({ maxEntries: 60, maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true })```
4392	bicizen.it.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from untrusted input (body.data.sensor and body.data.push_send_id). This allows an attacker to manipulate the URL to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.bicizen.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' });```
4393	bicizen.it.js	Open Redirect	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from untrusted input (event.notification.data.url). This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malicious content delivery.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
4394	bigheadstores.com.js	XSS via Untrusted Notification Data	High	true	CWE-79	N/A	N/A	custom	{The vulnerability arises from the use of JSON.parse on untrusted data from the notification payload (c.data.text()). Since the data is not sanitized or validated, an attacker can inject malicious JSON that, when parsed, could lead to XSS if the parsed data is later used in a context where it's executed as code or rendered in the DOM.}	```var r = c.data ? JSON.parse(c.data.text()) : {};```
4395	bigheadstores.com.js	Insecure External Script Import	Medium	true	CWE-444	N/A	N/A	standard	{The importScripts function is used to load an external script from a hardcoded URL. While the URL is fixed and not dynamically constructed from untrusted input, the script is loaded from a third-party domain (cdn.shopify.com), which introduces a risk if the domain is compromised or if the script is not properly vetted. This is a medium-risk misuse because the script is not dynamically controlled by user input, but still represents an external dependency that could be exploited.}	"```importScripts(""https://cdn.shopify.com/s/files/1/0033/3538/9233/files/sw-external_whatsappchat.js?v=1710314205"");```"
4396	bigheadstores.com.js	Insecure Fetch with No-CORS	Medium	true	CWE-434	N/A	N/A	standard	{The fetch function is used with mode: 'no-cors', which prevents the browser from sending credentials and limits the response to simple headers. However, this can be misused if the fetched resource is from an untrusted or attacker-controlled origin, leading to potential data leakage or unauthorized access. The vulnerability is medium because the URL is not dynamically constructed from user input, but the lack of CORS enforcement still poses a risk.}	```fetch(notificationUrl, { mode: 'no-cors' })```
4397	bigheadstores.com.js	URL Redirection to Untrusted Site	High	true	CWE-601	N/A	N/A	standard	{The self.clients.openWindow function is used to open a URL that is derived from the notification data (u). Since this URL is constructed from potentially untrusted data (e.g., from a notification payload), an attacker could craft a notification that redirects users to a malicious site, leading to phishing or malware distribution.}	```self.clients.openWindow(u);```
4398	bigheadstores.com.js	Hardcoded Secrets Exposure	High	false	N/A	N/A	N/A	N/A	{The secrets are exposed through obfuscated variable assignments using a deobfuscation function (_0x1db329), but no sensitive function is misused in the sense of being called with untrusted input. The exposure is due to poor secret management, not misuse of a sensitive function.}	```var SHOP_ID = _0x1db329(325), BASE_EVENTS_API = _0x1db329(386), ...```
4399	bihareduhub.in.js	Exposure of Sensitive Information	High	true	CWE-532	10	N/A	standard	{The apiKey is hardcoded in the script and exposed in the service worker, which can be accessed by any user with access to the site's source. This allows attackers to misuse the API key for unauthorized access to Firebase services, potentially leading to data breaches or service abuse.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyD3XemGNAf_3LPmOfXwK1IvtS6b-A5RM-k' }, ... };```
4400	bihareduhub.in.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The clients.openWindow(targetUrl) function is called with a URL derived from event.notification.data.url, which is user-controlled. This allows an attacker to craft a notification payload that redirects users to arbitrary websites, potentially leading to phishing or malware distribution.}	```let targetUrl = event.notification.data.url; clients.openWindow(targetUrl);```
4401	bihareduhub.in.js	Insecure Data Transmission	Medium	false	CWE-918	0	N/A	standard	{The fetch API is used to send data to options.api_url, which is hardcoded as an HTTPS endpoint. While the transmission is encrypted, the vulnerability is due to lack of proper validation or secure handling of the data being sent, not misuse of a sensitive function.}	```fetch(options.api_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(...) });```
4402	birarabam.com.js	External Script Import Without Integrity Check	High	true	CWE-496	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in service workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious code from external sources. In this case, the script is loaded from a third-party CDN (https://cdn.segmage.com/service-worker.min.js), which could be compromised or modified by an attacker, leading to code injection and full control over the service worker's behavior.}	"```importScripts(""https://cdn.segmage.com/service-worker.min.js"");```"
4403	blusongdeal.com.js	Insecure Communication with a Service	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a third-party domain (https://cdn04.filesbases.com/dist/core-service-worker.js). Although the URL is hardcoded, the use of an external script from an untrusted or potentially compromised domain introduces a security risk. If the external script is tampered with or served from a malicious source, it can execute arbitrary code within the context of the service worker, leading to potential data exfiltration, cache manipulation, or interception of network requests. This constitutes a high-severity vulnerability due to the trust placed in an external script source.}	"```importScripts(""https://cdn04.filesbases.com/dist/core-service-worker.js"");```"
4404	bnmuresult.com.js	Server Side Request Forgery (SSRF)	Medium	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically derived URL (apiUrl) from the notification data, which is controlled by the server sending the push notification. If an attacker can manipulate the notification payload to include a malicious URL (e.g., internal network resources or external domains), the service worker will make an HTTP request to that URL, leading to SSRF. The input is not sanitized or validated, making it a direct misuse of the fetch API.}	```fetch(apiUrl);```
4405	bnmuresult.com.js	Open Redirect	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from the notification data. Since the notification payload can be controlled by an attacker (via push messages), this allows redirection to arbitrary URLs, including phishing or malicious sites. The function is used without validating or sanitizing the URL, making it a sensitive function misuse.}	```clients.openWindow(targetUrl);```
4406	bomdiapiedade.com.br.js	Improper Validation of Cached Response	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper validation of the cached response, but it is not caused by misuse of a sensitive JavaScript function. The code simply retrieves a cached response using `cache.match()`, which is a standard and safe operation when used with a fixed, hardcoded URL like `OFFLINE_URL`. There is no dynamic or untrusted input involved, so no sensitive function misuse is present.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
4407	boykotdedektifi.org.js	Service Worker Cache.addAll Failure During Installation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by potential failure in handling the Cache.addAll() operation during installation, possibly due to network issues or invalid URLs. The code does not use dynamic or untrusted input to construct URLs passed to Cache.addAll(), so it is not a sensitive function misuse.}	```self.addEventListener('install', function (event) { event.waitUntil(caches.open('file-cache-' + version).then(function (cache) { return cache.addAll(['/assets/libs/bootstrap/css/bootstrap.css', '/assets/libs/bootstrap/css/bootstrap.min.css', '/assets/libs/bootstrap/js/bootstrap.min.js', '/assets/libs/jquery/jquery-3.6.3.min.js', '/assets/libs/bootstrap/js/bootstrap.bundle.js', '/assets/libs/swiper/swiper-bundle.min.css', '/assets/libs/swiper/swiper-bundle.min.js']); })); });```
4408	brawlstarshile.com.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-1330	10	RegExp	standard	{The code constructs regular expressions from user-controlled or untrusted JSON strings using `new RegExp(e)`, where `e` is derived from `JSON.parse()` of a hardcoded string. Although the input is hardcoded, the presence of complex patterns like `(?:/.*)?` and `(dev-|test-)?` can lead to catastrophic backtracking under certain inputs, causing ReDoS. The sensitive function `RegExp` is misused because it is being instantiated with potentially complex, unvalidated patterns that are not sanitized or limited in complexity, even if the source is hardcoded. This misuse can be exploited if the pattern is dynamically generated or if the hardcoded string is ever modified to include malicious patterns.}	"```const c = JSON.parse('[""brawlstarshile\\\\.com(?:/.*)?/ola/services/.*"",""brawlstarshile\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://08aaff53-0755-41f8-938b-2d4e84cf70d5\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e))```"
4409	cairo777.com.js	Insecure Cache Strategy for JS/CSS	Medium	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from the use of a CacheFirst strategy for JavaScript files with a long cache duration (864000 seconds = 10 days), which may lead to serving stale or outdated scripts to users. However, this is not caused by misuse of a sensitive JavaScript function, but rather by a misconfigured caching policy.}	```e.registerRoute(/^((?!index\\.js$|index-legacy\\.js$).)*\\.js$/, new e.CacheFirst({ cacheName: 'cairo777-js', plugins: [new e.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 864e4 }), new e.CacheableResponsePlugin({ statuses: [200] })] }), 'GET');```
4410	cairo777.com.js	Overly Broad Regex in Cache Route	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from an overly broad regular expression that matches any path ending in .js, potentially including unintended or malicious scripts. This is a logic or configuration flaw, not a result of misusing a sensitive JavaScript function.}	```e.registerRoute(/^((?!index\\.js$|index-legacy\\.js$).)*\\.js$/, new e.CacheFirst({ cacheName: 'cairo777-js', plugins: [new e.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 864e4 }), new e.CacheableResponsePlugin({ statuses: [200] })] }), 'GET');```
4411	calendar.org.ua.js	Insecure Service Worker Caching	High	true	CWE-921	10	caches.open	standard	{The caches.open() function is used to open a cache by name, and in this case, the cache name is derived from a constant (CURRENT_CACHES.offline), which is not user-controlled. However, the vulnerability lies in the caching behavior itself — specifically, the service worker caches the offline page without validating or sanitizing the content or ensuring it is not tampered with. While caches.open() is not directly misused with untrusted input, the overall caching mechanism is insecure because it allows potentially malicious content to be cached and served without proper integrity checks. The function is standard and its misuse is indirect, but the vulnerability is still tied to its use in an insecure context.}	```caches.open(CURRENT_CACHES.offline).then(function (cache) { return cache.put(OFFLINE_URL, response); });```
4412	capmania.com.br.js	Vulnerable Regular Expression in Cache Strategy	High	true	CWE-20	9	N/A	standard	{The regular expression /.*?irp\.cdn-website\.com.*?/ is used in workbox.routing.registerRoute to match URLs for caching. This pattern is overly broad and may unintentionally match unintended domains or paths, potentially leading to cache poisoning or unintended resource caching. The use of .*? makes it non-specific and vulnerable to pattern injection if the regex is constructed dynamically, though in this case it is hardcoded. However, the vulnerability stems from the unsafe use of a standard regex API in a context where specificity is critical.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, cacheFirst(SITE_ASSETS_CACHE_NAME));```
4413	capmania.com.br.js	Open Redirect via addParamsNative	Medium	true	CWE-601	8	N/A	custom	{The function addParamsNative constructs URLs by manipulating the domain and search parameters without validating or sanitizing the input URL. If an attacker can control the input URL, they can inject malicious domains or paths, leading to open redirect vulnerabilities. The function uses string manipulation and concatenation without proper URL validation, making it a custom function misuse.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
4414	capmania.com.br.js	Information Exposure via Debug Logs	Low	false	CWE-200	0		N/A	{The log function outputs debug information to the console, but this is not caused by misuse of a sensitive function. It is a configuration issue (debug mode enabled) rather than a function misuse.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
4415	capmania.com.br.js	SSRF Potential in fetchPageKey	Medium	true	CWE-918	7	N/A	standard	{The fetchPageKey function constructs a URL using getPathName and addParams, then passes it to fetch. If the pageUrl input is untrusted, it could be manipulated to point to internal resources (e.g., localhost, internal IPs), leading to SSRF. The fetch API is a standard function, and its misuse here stems from unsanitized input being passed directly into it.}	```async function fetchPageKey(pageUrl) { const baseKeyUrl = pwaSettings.baseKeyUrl; const pageUri = getPathName(pageUrl); const pageKeyUrl = addParams(baseKeyUrl, { uri: encodeURIComponent(pageUri), skip_sw_cache: true }); return await fetch(pageKeyUrl); }```
4416	capmania.com.br.js	Empty Fetch Handler Override	Medium	false	New	0		N/A	{The fetch event listener is overridden with an empty function, which is a logic issue rather than misuse of a sensitive function. It does not involve any unsafe function calls or dynamic input processing.}	```self.addEventListener('fetch', () => {});```
4417	captaincoaster.com.js	Empty Fetch Event Handler Leading to No Request Interception	High	false	N/A	0	N/A	N/A	{The fetch event handler is empty, meaning no logic is implemented to intercept or handle network requests. This is not a result of misuse of a sensitive function, but rather a design or implementation omission.}	```self.addEventListener('fetch', function (e) {});```
4418	captaincoaster.com.js	Empty Cache List Leading to No App Shell Caching	Medium	false	N/A	0	N/A	N/A	{The filesToCache array is empty, so no resources are cached during installation. This is a configuration issue, not a result of misusing a sensitive function.}	```var filesToCache = [];```
4419	ccfcforum.com.js	Insecure Direct Object Reference (IDOR) via URL Parameter	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a URL parameter `loggedIn` to control logic flow, but it is not tied to any sensitive JavaScript function misuse. The issue is a logical flaw in access control, not a direct misuse of a function like `eval`, `importScripts`, or `fetch` with untrusted input.}	```const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4420	ccfcforum.com.js	CSRF Token Handling Without Server-Side Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the client-side handling of CSRF tokens without server-side validation, which is a design flaw rather than misuse of a sensitive JavaScript function. The `fetch` call is used correctly with a dynamically generated token, but the issue lies in the lack of server-side enforcement, not in unsafe function usage.}	```headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest));```
4421	ccfcforum.com.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used on a client object with a URL derived from notification data (`data.url`), which is untrusted and potentially controlled by an attacker. This allows an open redirect if the notification data is manipulated, as the service worker blindly navigates to the provided URL without validation.}	```clients[0].navigate(data.url);```
4422	cdc.org.in.js	Exposure of Sensitive Information	High	true	CWE-532	10	N/A	standard	{The apiKey is hardcoded in the script and exposed in the service worker, which can be accessed by any client. This allows attackers to misuse the API key for unauthorized access to Firebase services, leading to potential data breaches or service abuse.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyBhHd-gNx9mzzKFPa7FhIpDGYqfBQx-FeU' } };```
4423	cdc.org.in.js	Server Side Request Forgery	High	true	CWE-918	9	N/A	standard	{The getDomainAndHostname function uses the URL constructor with user-supplied input, which can be manipulated to redirect to malicious domains. Although it only returns the hostname, if this function is used in contexts where the full URL is reconstructed or used for further requests, it can enable SSRF attacks.}	```const getDomainAndHostname = (url) => { const urlObj = new URL(url); return { hostname: urlObj.hostname }; };```
4424	cdc.org.in.js	Server Side Request Forgery	High	true	CWE-918	8	N/A	standard	{The fetch(apiUrl) call uses a dynamically determined apiUrl from notification data, which is user-controlled. This allows an attacker to craft a notification with a malicious URL, causing the service worker to make unintended HTTP requests to arbitrary endpoints, leading to SSRF.}	```fetch(apiUrl);```
4425	cearadigital.ce.gov.br.js	Information Exposure Through Error Messages	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from logging detailed error messages using console.error, which may expose sensitive information such as internal error details, stack traces, or context data to the client. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by poor error handling practices. The console.error function itself is not inherently sensitive in this context, and no dynamic or untrusted input is being passed to it in a way that would lead to code execution or injection.}	```console.error(ctx.error, 'Details:', ctx);```
4426	champstreet.com.js	Exposure of Sensitive Information (Firebase API Key in Client-Side Code)	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from hardcoding the Firebase API key in client-side JavaScript, which is accessible to anyone inspecting the source code. This is not due to misuse of a sensitive JavaScript function, but rather poor secret management. No function is being misused to introduce this vulnerability.}	"```var firebaseConfig = { apiKey: ""AIzaSyDejsDB1dD1zdMZNEUv8CzHiSwlJNFuTMw"", authDomain: ""champstreet-ae811.firebaseapp.com"", databaseURL: ""https://champstreet-ae811.firebaseio.com"", projectId: ""champstreet-ae811"", storageBucket: ""champstreet-ae811.appspot.com"", messagingSenderId: ""140691327915"", appId: ""1:140691327915:web:9a0b9bcca98f458014e0ee"", measurementId: ""G-7YZB1LQCEV"" };```"
4427	cinecroisiere.fr.js	Insecure HTTP Redirect	Medium	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL in a new window or tab. In this case, it is hardcoded to open 'http://www.cinecroisiere.fr', which uses HTTP instead of HTTPS. While the function itself is not inherently unsafe, its misuse in redirecting users to an insecure HTTP endpoint can lead to man-in-the-middle attacks, data interception, and credential theft. This constitutes a security vulnerability due to the lack of encryption and integrity guarantees.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); event.preventDefault(); event.waitUntil(clients.openWindow('http://www.cinecroisiere.fr')); });```
4428	climaya.com.js	Insecure Remote Script Import	High	true	CWE-444	10	importScripts	standard	"{The importScripts() function is used to load and execute a remote script from a hardcoded URL. While the URL is fixed and not derived from user input, the use of importScripts() with any external script introduces a risk if the script source is compromised or if the script is not properly vetted. However, since the URL is hardcoded and not dynamically constructed from untrusted input, the vulnerability is not strictly ""sensitively vulnerable"" in the context of dynamic input misuse. But given the nature of importScripts() as a sensitive function that executes arbitrary code, and the fact that the script is loaded from a third-party plugin (which may be tampered with), it is still considered a high-risk misuse.}"	```importScripts('https://climaya.com/wp-content/plugins/onesignal-free-web-push-notifications/sdk_files/OneSignalSDKWorker.js.php');```
4429	climaya.com.js	Incorrect Regex Context in URL Filtering	Medium	false	New	0	N/A	N/A	{The issue lies in the incorrect use of the regex context within the checkNeverCacheList function. The function uses 'this.match(url)', but 'this' refers to the regex object, not the URL string. This is a logic error, not a misuse of a sensitive function. The function does not involve any sensitive JavaScript API that could lead to code execution, injection, or data leakage.}	```function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
4430	climaya.com.js	Unvalidated Range Request Position	Medium	false	CWE-119	0	N/A	N/A	{The vulnerability arises from improper validation of the range header, which could lead to out-of-bounds memory access or denial of service. However, this is not caused by a sensitive JavaScript function like eval, importScripts, or similar. The issue is in the logic of parsing and using the range header, not in the misuse of a sensitive API.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
4431	climaya.com.js	Cache Poisoning Risk	Medium	false	New	0	N/A	N/A	{The cache.put() operation is used to store responses in the cache, but there is no evidence of malicious input being used to poison the cache. The function is used correctly within the context of a service worker, and the input (response.clone()) is derived from a trusted fetch operation. This is not a misuse of a sensitive function, but rather a potential risk if the response itself is manipulated by an attacker. However, since the response is obtained via fetch(e.request), which is under the control of the service worker, the risk is mitigated.}	```cache.put(e.request, response.clone());```
4432	cloudhubgh.com.js	Incorrect Cache Key Normalization	Medium	false	New	0	N/A	N/A	{The vulnerability arises from improper handling of URL keys during cache lookup, specifically when normalizing URLs by stripping query parameters and handling edge cases like empty keys or hash-based routes. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in key normalization. No dangerous function like importScripts, eval, or dynamic code execution is involved.}	```var key = event.request.url.substring(origin.length + 1); if (key.indexOf('?v=') != -1) { key = key.split('?v=')[0]; } if (event.request.url == origin || event.request.url.startsWith(origin + '/#') || key == '') { key = '/'; } if (!RESOURCES[key]) { return; }```
4433	clubedascalopsitas.com.br.js	Server Side Request Forgery (SSRF)	High	true	CWE-602	9	N/A	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. If this `id` is not validated or sanitized, an attacker could supply a malicious URL (e.g., internal IP addresses or external domains) to trigger SSRF, allowing unauthorized access to internal systems or external resources.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4434	clubedascalopsitas.com.br.js	Cross-Site Request Forgery (CSRF) Token Handling	Medium	true	CWE-352	8	N/A	standard	{The fetch function is used to retrieve a CSRF token based on a dynamically constructed path from the request URL. If the `path` parameter is not properly sanitized or validated, an attacker could manipulate it to trigger unintended CSRF token generation or abuse the token retrieval mechanism, potentially leading to unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4435	clubedascalopsitas.com.br.js	Insecure Notification Click Handling	Medium	true	CWE-601	7	N/A	standard	{The navigate method is used on a client object with a URL derived from the notification data. If the `data.url` is not validated or sanitized, an attacker could inject a malicious URL, leading to phishing, redirect attacks, or unintended navigation to harmful sites.}	```clients[0].navigate(data.url)```
4436	clubedascalopsitas.com.br.js	Insecure Cache Allow List	Low	false	CWE-921	N/A	N/A	N/A	{The cacheAllowList is hardcoded and does not involve dynamic input or sensitive function misuse. It is a static list used for cache cleanup, and no sensitive function is misused here.}	```const cacheAllowList = [CACHE_NAME];```
4437	clubedascalopsitas.com.br.js	Insecure Debug Logging	Low	false	CWE-200	N/A	N/A	N/A	{The log function is a custom utility that conditionally logs messages based on a DEBUG flag. It does not involve sensitive function misuse, as it does not process untrusted input or expose sensitive data via a vulnerable API.}	```const DEBUG = false;```
4438	clubrunning.es.js	Insecure Request Handling in Service Worker	High	false	N/A	N/A	N/A	N/A	{The vulnerability described is not due to misuse of a sensitive function, but rather stems from the design of the fetch handler which may allow for unintended caching or request handling behavior. The code does not use any sensitive functions like importScripts, eval, or dynamic code execution. The fetch() call is used appropriately to handle network requests when cache misses occur, and there is no evidence of unsanitized or untrusted input being passed to any sensitive function.}	```self.addEventListener('fetch', e => { e.respondWith(caches.match(e.request).then(res => { if (res) { return res; } return fetch(e.request); })); });```
4439	cncyab.com.js	Insecure Remote Resource Loading	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a URL constructed using the apphost variable. Although apphost is hardcoded, if this value were derived from untrusted input (e.g., user-controlled query parameters or environment variables), it could allow an attacker to inject and execute arbitrary scripts, leading to remote code execution. The current usage is safe due to hardcoding, but the function itself is inherently sensitive when used with dynamic inputs.}	```importScripts(apphost + '/module/js/pouchdb-7.1.1.min.js');```
4440	cncyab.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	EventSource	standard	{The EventSource constructor is used to create a server-sent events connection to a URL that includes user-controlled values (pushid and connid). Since these values are not sanitized or validated, an attacker could manipulate them to trigger requests to internal or external resources, potentially leading to SSRF. The function is sensitive because it initiates network connections based on dynamic input.}	"```var notifix = new EventSource(""/ajax.php?unit=anahidcms_app_push&set_id="" + pushid + ""&rec_id="" + connid);```"
4441	cncyab.com.js	Cache Poisoning	Medium	true	New	8	caches.put	standard	{The caches.put() function is used to store responses in the cache based on the request URL. While the request is obtained from the fetch() call, the lack of validation on the request URL or response content could allow an attacker to poison the cache with malicious content if the service worker processes untrusted requests. This is especially risky if the service worker is exposed to user-controlled URLs.}	```caches.open(version + staticCacheName).then(function (cache) { cache.put(request, copy); });```
4442	cncyab.com.js	Improper Input Validation	Medium	true	New	7	fetch	standard	{The fetch() function is used without validating the request URL or headers, particularly when handling user-controlled requests. The code attempts to serve a fallback SVG for image requests, but if the request URL is manipulated (e.g., via a crafted request header or URL), it could lead to unintended behavior or exposure of internal resources. The function is sensitive because it executes network requests based on potentially untrusted input.}	```event.respondWith(caches.match(request).then(function (response) { return response || fetch(request).catch(function () { if (request.headers.get('Accept').indexOf('image') !== -1) { return new Response('<svg...'); }); }); });```
4443	codelector.com.js	Vulnerable Cache Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability described is related to cache handling, but it does not stem from the misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The code uses caches.open and cache.add in a standard, safe manner with a hard-coded cache name and offline fallback page. There is no dynamic or untrusted input being used to construct URLs or influence cache operations, so no sensitive function misuse is present.}	```const cache = await caches.open(CACHE).then(cache => cache.add(offlineFallbackPage));```
4444	colegames.com.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL like 'https://push4site.com/static/sw/colegames.js', it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. Although the URL is hardcoded, the script's origin is external and potentially malicious, allowing an attacker to compromise the service worker's execution context, intercept network requests, manipulate cache, or inject arbitrary code. This constitutes a sensitive function misuse due to the inherent trust required in the imported script.}	```importScripts('https://push4site.com/static/sw/colegames.js');```
4445	concursuri.biz.js	Remote Code Execution via Dynamic Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used with a dynamically constructed URL (pnfpb_progressier_sw_filename) that is derived from the pnfpb_progressier_app_id variable. Since this variable is not validated or sanitized and could be controlled by an attacker (e.g., via a maliciously crafted URL or configuration), it allows arbitrary script execution from an external domain, leading to remote code execution.}	```importScripts(pnfpb_progressier_sw_filename);```
4446	concursuri.biz.js	Logic Flaw in URL Filtering	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a flawed logic in the checkNeverCacheList function, which incorrectly uses this.match(url) without ensuring that the context (this) is a valid RegExp or string. This is not a misuse of a sensitive function but a logic error in the filtering mechanism.}	```if (this.match(url)) { return false; } return true;```
4447	concursuri.biz.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow() function is called with event.notification.data.url, which is derived from untrusted push notification data. Since this URL is not validated or sanitized, an attacker can craft a notification with a malicious URL, causing the browser to open an arbitrary site, leading to an open redirect.}	```if (clients.openWindow) return clients.openWindow(event.notification.data.url);```
4448	cornwallfootballforum.com.js	Insecure Use of Credentials in Fetch Request	High	true	New	N/A	fetch	standard	{The fetch API is used with credentials: 'include', which sends cookies and authentication tokens with the request. Since the URL is constructed using a dynamic parameter (id from push event data), and no validation is performed on the id, an attacker could potentially trigger requests to unintended endpoints or manipulate the notification system if the id parameter is controlled by an attacker. This misuse of fetch with untrusted input in the URL and sensitive credentials can lead to unauthorized access or data leakage.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' }).then(...)```
4449	cornwallfootballforum.com.js	CSRF Token Bypass via URL Parameter	High	true	CWE-352	N/A	fetch	standard	{The fetch API is used to retrieve a CSRF token based on a dynamically constructed URL using the path parameter from the intercepted request. Since the path is derived from the original request URL (which is user-controlled), an attacker could manipulate the path to request CSRF tokens for unintended endpoints, potentially bypassing CSRF protections. This misuse of fetch with untrusted input in the URL allows an attacker to forge requests with valid CSRF tokens.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => {```
4450	cornwallfootballforum.com.js	Unvalidated Notification URL in Click Handler	Medium	true	CWE-601	N/A	navigate	standard	{The navigate method is used to redirect the client to a URL derived from the notification data (data.url). Since this URL is not validated or sanitized, an attacker could craft a malicious notification with a URL pointing to an external site or a phishing page, leading to open redirect or phishing attacks. This misuse of navigate with untrusted input allows an attacker to redirect users to arbitrary destinations.}	```clients[0].navigate(data.url);```
4451	counterview.org.js	Exposure of Sensitive Information (Firebase API Key in Client Code	High	false	N/A	N/A	N/A	N/A	{The Firebase API key is hardcoded in the client-side JavaScript code, which is exposed to the browser. While not directly caused by a sensitive function misuse, it is a static exposure of credentials.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyCOi2TpzWpsTGL53pf6ychwSRbaFENOBXQ' } };```
4452	counterview.org.js	Exposure of Sensitive Information (Push Subscription Data Transmission	Medium	false	N/A	N/A	N/A	N/A	{The sensitive data (endpoint, auth, p256dh) is transmitted over the network via fetch, but the vulnerability arises from the exposure of data in transit, not from misuse of a sensitive function.}	```fetch(options.api_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) })```
4453	counterview.org.js	Insecure Storage of Sensitive Data (IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The data is stored in IndexedDB, which is a client-side storage mechanism. The vulnerability stems from storing sensitive data (like tokens) in an insecure client-side store, not from misuse of a sensitive function.}	```const request = objectStore.put({ id: key, data: value });```
4454	counterview.org.js	Potential Open Redirect/SSRF in Notification Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with a dynamic targetUrl derived from notification data, which may be controlled by an attacker. This allows for open redirect or SSRF if the URL is not validated or sanitized, enabling redirection to malicious sites or internal resources.}	```clients.openWindow(targetUrl);```
4455	crashkali.co.ke.js	Unvalidated Message Handling Leading to Unauthorized skipWaiting	High	false	N/A	0	N/A	N/A	"{The vulnerability arises from unvalidated message handling in the service worker, where any message with a data.type of ""SKIP_WAITING"" triggers self.skipWaiting(). While this is not caused by misuse of a sensitive function like importScripts or eval, it is a logic flaw in message handling. The function self.skipWaiting() is a standard service worker API, but its invocation is not restricted to trusted sources, allowing any client-side script to force the service worker to skip waiting and activate immediately. This can be exploited to bypass intended update workflows or force premature activation.}"	"```self.addEventListener(""message"", e => { e.data && ""SKIP_WAITING"" === e.data.type && self.skipWaiting(); });```"
4456	cristaisaquarius.com.br.js	Path Traversal in Service Worker Route Matching	High	true	New	N/A	registerRoute	standard	{The registerRoute function is used with a dynamic path from the custom_strategies array, which is constructed with user-defined or configuration-based paths. Since these paths are directly used in a URL pathname.includes() check without sanitization or validation, an attacker could potentially inject path traversal sequences (e.g., '../') into the route path, leading to unintended route matching and potential cache manipulation or bypass of security controls.}	```const custom_strategies = [{ 'path': '/checkout/', 'strategy': 'NetworkOnly', 'name_cache': 'checkout'}, { 'path': '/customer/', 'strategy': 'NetworkOnly', 'name_cache': 'customer'}, { 'path': '/admin/', 'strategy': 'NetworkOnly', 'name_cache': 'administrative'}, { 'path': 'paineladmin', 'strategy': 'NetworkOnly', 'name_cache': 'administrative'}, { 'path': '/O2TI/Cristais/', 'strategy': 'CacheFirst', 'name_cache': 'scripts-b'}, { 'path': 'sales/order', 'strategy': 'NetworkOnly', 'name_cache': 'sales-order-view'}]; for (let route of custom_strategies) { var type = route.strategy; if (type == 'NetworkOnly') { registerRoute(({ url }) => url.pathname.includes(route.path), new NetworkOnly()); } if (type == 'CacheFirst') { registerRoute(({ url }) => url.pathname.includes(route.path), new CacheFirst({ cacheName: PREFIX_CACHE_NAME + route.name_cache, plugins: [new ExpirationPlugin({ maxEntries: 500, maxAgeSeconds: 120 * 24 * 60 * 60, purgeOnQuotaError: true, matchOptions: { ignoreVary: true } }), new CacheableResponsePlugin({ statuses: [0, 200] })] }); } }```
4457	cristaisaquarius.com.br.js	Cache Poisoning via Vary Header Ignoring	Medium	false	CWE-478	N/A	N/A	N/A	{The vulnerability arises from the use of the ExpirationPlugin with ignoreVary: true, which causes the cache to ignore Vary headers. This is a configuration issue, not misuse of a sensitive function. The function itself (ExpirationPlugin) is not inherently sensitive, and the issue stems from improper configuration rather than dynamic input or unsafe function usage.}	```registerRoute(/\.(?:png|webp|gif|jpg|svg)$/, new CacheFirst({ cacheName: PREFIX_CACHE_NAME + 'images-cache', plugins: [new ExpirationPlugin({ maxEntries: 5000, maxAgeSeconds: 360 * 24 * 60 * 60, purgeOnQuotaError: true, matchOptions: { ignoreVary: true } }), new CacheableResponsePlugin({ statuses: [0, 200] })] }));```
4458	cristaisaquarius.com.br.js	Ineffective Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The vulnerability is due to the fetch event handler returning false, which is not a valid return value for a fetch event handler in Service Workers. This causes the event to be ignored, leading to ineffective handling of requests. This is a logic or syntax error, not misuse of a sensitive function.}	```self.addEventListener('fetch', event => { if (event.request.url.includes('googletagmanager') || event.request.url.includes('google-analytics') || event.request.url.includes('gtm') || event.request.url.includes('facebook.com') || event.request.url.includes('facebook.net') || event.request.url.includes('admin') || event.request.url.includes('/sales/')) { return false; } });```
4459	crwc.in.js	Use of Hard-coded Credentials	High	false	N/A	N/A	N/A	N/A	{Hard-coded credentials are a security issue but not caused by misuse of a sensitive JavaScript function. The credentials are embedded directly in the code, which is a static configuration flaw, not a dynamic function misuse.}	```const options = { firebaseConfig: { projectId: 'crwc1-7ed88', messagingSenderId: '153378134469', appId: '1:153378134469:web:f1331dfa239ea9731313ac', apiKey: 'AIzaSyBE5OHE0JwcAmxAKkUdu4IZf65CS3Sv0HM' }, domain: 'crwc.in', api_url: 'https://lara.dietsrinagar.in/api/token', vapid_public_key: 'BJG_Hc_hvZZQ9leS6SZec2v6Tcc-C-BsEI0EPtYTrLG8SUJOp_8L0Bhnx4oqoz5UbSfPfopt59kxHnp0DH8UGKM' };```
4460	crwc.in.js	Server-Side Request Forgery (SSRF)	Medium	true	N/A	N/A	new URL	standard	{The function new URL(url) is used to parse a user-supplied URL, which is then used to extract the hostname. If the URL is controlled by an attacker, this could lead to SSRF if the hostname is used in subsequent network requests (e.g., via fetch or other APIs). Although the code does not directly use the parsed URL for network requests, the function is still sensitive because it can be abused to manipulate URL parsing and potentially bypass security checks.}	```const urlObj = new URL(url); return { hostname: urlObj.hostname };```
4461	crwc.in.js	Missing Cryptographic Support	Low	false	N/A	N/A	N/A	N/A	{The issue arises from the lack of cryptographic protection for data stored in IndexedDB, not from misuse of a sensitive function. The openDatabase function is custom and does not inherently introduce a vulnerability through misuse of a sensitive API.}	```const request = indexedDB.open('larapushDataBase', 1); request.onupgradeneeded = event => { const db = event.target.result; db.createObjectStore('myObjectStore', { keyPath: 'id' }); };```
4462	danialnews.com.js	Use of Hard-coded Credentials	Low	false	CWE-798	N/A	N/A	N/A	{Hard-coded credentials are a configuration issue, not a result of sensitive function misuse. The vulnerability arises from exposing Firebase API keys directly in the code, which can be exploited if leaked, but no sensitive JavaScript function is misused here.}	```firebase.initializeApp({ apiKey: 'AIzaSyDM8T4aVU9Vma3Fg9pIfO-MCpsq1KNtCBs', authDomain: 'aplu-f.firebaseapp.com', projectId: 'aplu-f', storageBucket: 'aplu-f.appspot.com', messagingSenderId: '907915035035', appId: '1:907915035035:web:2b87cdb65c6c57319fa13e' });```
4463	danialnews.com.js	URL Redirection to Untrusted Site	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a URL derived from event.notification.data.FCM_MSG.notification.data.url, which is user-controlled via Firebase Cloud Messaging. Since this input is not validated or sanitized, an attacker could craft a malicious notification payload to redirect users to an untrusted site, leading to phishing or malware distribution.}	```event.waitUntil(notificationClickAlert(notifyIdd), clients.openWindow(url));```
4464	darjadida.com.js	Untrusted Third-Party Script Inclusion	Medium	true	CWE-444	10	N/A	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hardcoded to a trusted CDN (cdn.ampproject.org), the vulnerability classification as ""Untrusted Third-Party Script Inclusion"" suggests concern over relying on external scripts. However, since the URL is static and not derived from user input or dynamic sources, this is not a case of sensitive function misuse. Therefore, the vulnerability is not caused by improper use of a sensitive function.}"	```importScripts('https://cdn.ampproject.org/sw/amp-sw.js');```
4465	date-hijri.net.js	Improper Cache Key Handling Leading to Data Leakage	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of `ignoreSearch: true` in `caches.match()`, which causes the cache lookup to ignore query parameters. This can lead to data leakage if different URLs with varying query strings map to the same cached response, potentially exposing sensitive data to unintended users. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a configuration issue in cache handling.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request, { ignoreSearch: true }).then(response => { return response || fetch(event.request); })); });```
4466	dcoff.com.br.js	Insecure Caching Strategy Leading to Stale Data Exposure	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of `self.toolbox.fastest` as the default caching strategy, which may serve stale content without proper validation. However, this is not due to misuse of a sensitive function, but rather a misconfiguration in caching policy.}	```self.toolbox.router.any('/*', self.toolbox.fastest);```
4467	dcoff.com.br.js	Cache Poisoning Risk via Unbounded Cache Versioning	Low	false	New	N/A	N/A	N/A	{The issue stems from hardcoding a cache name (`'0.0.95'`) without versioning or expiration logic, which may lead to cache poisoning if not managed properly. This is a configuration issue, not misuse of a sensitive function.}	```self.toolbox.options.cache = { name: '0.0.95' };```
4468	ddot.info.js	Insecure Message Handling - No Origin Validation	High	true	CWE-209	9	self.addEventListener	standard	{The use of self.addEventListener without validating the origin of the message allows any page or script in the same origin (or potentially cross-origin if not properly restricted) to send messages to the service worker. This enables attackers to trigger arbitrary API calls via the MessageAPI, leading to unauthorized actions such as clearing caches or enabling/disabling offline shell behavior. The vulnerability arises because the event.data is directly used to invoke functions without origin checks.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
4469	ddot.info.js	Improper Input Validation in URL Parameter Parsing	High	true	CWE-209	9	pathname.match	standard	{The code parses URL path parameters using a regex match and then splits them without sanitization or validation. The extracted parameters are used directly as keys to access the MessageAPI object, which can lead to arbitrary function invocation if an attacker crafts a URL with a malicious parameter that maps to a function in MessageAPI. This is a classic case of untrusted input being used to dynamically invoke functions, potentially leading to unintended behavior or privilege escalation within the service worker.}	```const params = pathname.match(/:(.+)/)[1]; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
4470	diabexy.com.js	Cross-Site Scripting (XSS) via untrusted external script	High	true	CWE-434	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a dynamically constructed URL (swUrl + ""?orgtoken=G_sotEsSScaFMOxKyrIFjg""), which, while not directly user-controlled, is still an external script loaded from a third-party domain (tracker.wigzopush.com). This introduces a high-risk vulnerability because if the script at that URL is compromised or malicious, it can execute arbitrary code within the context of the service worker, leading to potential data exfiltration, cache manipulation, or network interception. The use of importScripts() with an external, untrusted source without validation or integrity checks constitutes sensitive function misuse.}"	"```var swUrl = 'https://tracker.wigzopush.com/wigzo_sw.js'; importScripts(swUrl + ""?orgtoken=G_sotEsSScaFMOxKyrIFjg"");```"
4471	dilbeyti.com.js	Empty Fetch Event Handler	High	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the presence of an empty fetch event handler, which may indicate incomplete or placeholder logic. This does not involve dynamic or untrusted input being passed to a sensitive function.}	```self.addEventListener('fetch', function (event) {});```
4472	direct.ps.js	Cache Poisoning via Unscoped Fetch Handling	High	true	N/A	9	fetch	standard	{The fetch function is used without proper validation or scope restriction, allowing any request to be cached and served from the cache. This enables an attacker to poison the cache by making requests to malicious or unintended resources, which are then served to subsequent users without revalidation, leading to potential data leakage or injection.}	```self.addEventListener('fetch', e => { console.log(e.request.url); e.respondWith(caches.match(e.request).then(response => response || fetch(e.request))); });```
4473	disfoil.com.br.js	Vulnerable Cache Key Collision (Ignored URL Parameters	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the configuration of `ignoreURLParametersMatching: [/.*/]`, which causes all URL parameters to be ignored when generating cache keys. This leads to cache key collisions where different URLs with varying parameters are treated as identical, potentially causing incorrect content to be served. This is a configuration issue, not misuse of a sensitive function.}	```const he = { ignoreURLParametersMatching: [/.*/] };```
4474	disfoil.com.br.js	SSRF via Dynamic URL Rewriting in Fetch	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is misused by dynamically constructing a new URL based on the original request URL using regex-based string replacement. If an attacker can control the original URL (e.g., via a malicious redirect or crafted request), they can manipulate the rewritten URL to point to internal or external resources, leading to SSRF. The dynamic nature of the URL construction from untrusted input makes this a sensitive function misuse.}	```async function le(e) { let { request: t, response: n } = e; const { url: r } = t; let s; if (n.status > 399) { const e = /(\w+\.)?(ecoms\d)\.com/i; if (e.test(r)) s = r.replace(e, '$2-nyc3.nyc3.digitaloceanspaces.com'); else { const e = /(ecoms\d)-\w+\.nyc3\.(cdn\.)?/i; e.test(r) && (s = r.replace(e, '$1-fra1.fra1.')); } } return s ? fetch(s) : n; }```
4475	disfoil.com.br.js	Insecure Cache Expiration Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from improper configuration of cache expiration policies (e.g., `maxAgeSeconds: 31536e3` for 1 year) and lack of proper validation, which can lead to stale or outdated content being served. This is a configuration or policy issue, not a misuse of a sensitive function.}	```function (e) { const t = O(); N(new q(t, e)); }(he), N(/^https:\\/\\/fonts\\.googleapis\\.com/, new A({ cacheName: 'google-fonts-stylesheets' })), N(/^https:\\/\\/fonts\\.gstatic\\.com/, new U({ cacheName: 'google-fonts-webfonts', plugins: [new class { constructor(e) { this.cacheWillUpdate = async ({ response: e }) => this._cacheableResponse.isResponseCacheable(e) ? e : null, this._cacheableResponse = new K(e); } }({ statuses: [0, 200] }), new ae({ maxAgeSeconds: 31536e3, maxEntries: 30 })] }))```
4476	dntbras.com.br.js	Message handler allows cache deletion via same-origin request	Medium	false	N/A	N/A	N/A	N/A	N/A	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
4477	dntbras.com.br.js	Broad regex in registerRoute allows unintended URL caching	Medium	false	N/A	N/A	N/A	N/A	N/A	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
4478	dntbras.com.br.js	Debug logging enabled in production	Low	false	N/A	N/A	N/A	N/A	N/A	```pwaSettings.debug = true;```
4479	doktorm.az.js	Open Redirect via Untrusted URL in Notification	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL passed from untrusted notification data without validation, allowing an attacker to redirect users to arbitrary websites, potentially leading to phishing or malware distribution.}	N/A
4480	doktorm.az.js	Insecure Fetch Request with no-cors Mode	Medium	false	CWE-352	5	N/A	N/A	{The fetch request uses mode: 'no-cors', which prevents the browser from sending credentials and limits response handling, but this is not inherently a sensitive function misuse; it's a configuration choice that may lead to data leakage or failed requests, not direct exploitation via sensitive function abuse.}	N/A
4481	doktorm.az.js	Exposure of Sensitive Data in Logs	Medium	false	CWE-200	6	N/A	N/A	{The console.log function is used to output sensitive notification data, but it is not a sensitive function in the context of direct exploitation (e.g., code injection or remote execution); it's a logging issue, not misuse of a sensitive API.}	N/A
4482	doktorm.az.js	Improper Input Validation for Notification Data	Medium	false	CWE-20	7	N/A	N/A	{The destructuring of event.notification.data does not involve a sensitive function; it's a data access pattern. The vulnerability arises from lack of validation, not misuse of a sensitive function.}	N/A
4483	domod.ba.js	Cache Poisoning via Unexpected Response Status	Medium	true	CWE-798	N/A	new workbox.cacheableResponse.Plugin({ statuses: [0, 200] })	standard	{The workbox.cacheableResponse.Plugin is configured to accept responses with status code 0, which is typically used for network errors or failed requests. Allowing status 0 to be cached can lead to cache poisoning, where invalid or malicious responses are stored and served to users, potentially leading to data corruption or security bypasses. This misuse stems from improper configuration of a standard Workbox plugin.}	"```workbox.precaching.precacheAndRoute([{""url"":""/assets/css/app.min.css"",""revision"":""d3072ab3693c185313018e404e07d914""},{""url"":""/assets/js/app.min.js"",""revision"":""6b73f45a2506a26e00e425688eaa6514""}]);```"
4484	doppelherz.bg.js	Use of BackgroundSyncPlugin with NetworkOnly for POST requests leading to duplicate submissions	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from a misconfiguration in the runtime caching strategy, not from misuse of a sensitive JavaScript function. Specifically, the BackgroundSyncPlugin is used with a NetworkOnly handler for POST requests, which can lead to duplicate submissions if the network request fails and is retried via background sync. This is a logical or architectural flaw, not a direct result of unsafe function usage.}	```const strategy = new workbox.strategies[entry.handler](strategyOptions);```
4485	e-nba.pl.js	Improper CSRF Token Handling	High	true	N/A	8	new Request	standard	{The new Request constructor is used to create a modified request with a dynamically obtained CSRF token. While this is intended to prevent CSRF, the token is fetched via a network call and injected into the request headers without proper validation or sanitization. If the token-fetching endpoint is compromised or if the token is leaked, attackers could forge requests. The misuse lies in dynamically constructing requests with sensitive headers from untrusted or potentially manipulated sources, which can lead to CSRF if not properly secured.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
4486	e-nba.pl.js	Insecure Parsing of Login Status	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using a regular expression to parse the login status from the URL, which is inherently insecure if the URL is manipulated. However, this is not caused by misuse of a sensitive JavaScript function, but rather by flawed logic in parsing untrusted input.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
4487	e-nba.pl.js	Potential Information Exposure via Debug Logging	Low	false	N/A	N/A	N/A	N/A	{The vulnerability stems from debug logging that may expose internal information if DEBUG is enabled. This is not due to misuse of a sensitive function, but rather from the use of console.log with potentially sensitive data.}	"```if (DEBUG) { if (typeof message === ""string"") { message = `SW: ${message}`; } console.log(message); }```"
4488	easternspirit.org.js	Insecure Redirection in Notification Click Handler	High	true	CWE-601	9	clients.navigate	standard	{The notification click handler uses clients[0].navigate(data.url) where data.url is derived from the notification payload, which can be controlled by an attacker via push notifications. This allows an attacker to redirect the user to arbitrary URLs, potentially leading to phishing or malicious site redirection. The function clients.navigate is a standard browser API that executes navigation based on a URL provided as input, and when that input is unsanitized, it becomes a vector for insecure redirection.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
4489	easternspirit.org.js	SSRF in CSRF Token Fetching	High	true	CWE-919	9	fetch	standard	{The code constructs a URL for fetching a CSRF token using the path from the intercepted request: fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`). If the path parameter is not sanitized and can be manipulated (e.g., via a malicious request), it could be used to forge requests to internal or external endpoints, leading to SSRF. The fetch API is a standard JavaScript function that executes HTTP requests, and when used with unsanitized input, it can be exploited to access unintended resources.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json())```
4490	easternspirit.org.js	Cache Poisoning via URL Manipulation	Medium	false	CWE-471	0	N/A	N/A	{The condition if (!request.url.startsWith(BASE_URL) || request.method === 'GET' && request.mode !== 'navigate') { return; } is not directly caused by misuse of a sensitive function. It is a logic flaw in the fetch handler that may allow cache poisoning if the URL validation is bypassed, but no sensitive function like importScripts, eval, or dynamic code execution is involved. The vulnerability stems from improper URL validation rather than misuse of a JavaScript function.}	```if (!request.url.startsWith(BASE_URL) || request.method === 'GET' && request.mode !== 'navigate') { return; }```
4491	easytrangers.com.js	Improper Encoding of User Input in Form Data	High	true	CWE-74	9	fetch	standard	{The `fetch` function is used to send a POST request with a body constructed from `e.reply`, which is user-provided input from a notification reply. Since the input is not sanitized or encoded, it can lead to injection attacks (e.g., if the reply contains malicious characters or scripts, they may be interpreted by the server or client). The use of `body: `message=${e.reply}`` directly interpolates user input without encoding, making it vulnerable to improper encoding.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
4492	easytrangers.com.js	Open Redirect via Unvalidated URL Concatenation	High	true	CWE-601	9	clients.openWindow	standard	{The `clients.openWindow` function is called with a URL constructed by concatenating `n` (base URL) and `t` (user-controlled URL from notification data). Since `t` is derived from `e.notification.data.url` without validation or sanitization, an attacker can craft a malicious URL that redirects users to an arbitrary domain, leading to open redirect vulnerabilities.}	```clients.openWindow(n + t);```
4493	ebarber.gr.js	Open Redirect via Unvalidated URL in Notification Click Handler	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL provided by untrusted notification data (event.notification.data.url). Since the URL is not validated or sanitized, an attacker could craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
4494	ebarber.gr.js	Information Exposure via Untrusted Data Logging in Push Event Handler	Medium	false	CWE-200	0	N/A	N/A	{The console.log(msg) statement logs untrusted data received from a push notification. While this does not directly involve a sensitive function, it exposes potentially sensitive information in the console, which may be accessible to attackers if the browser context is compromised.}	```console.log(msg);```
4495	efm-formations.fr.js	Improper Promise Chaining in Service Worker Installation	Medium	false	New	N/A	N/A	N/A	{The issue lies in improper promise chaining during the service worker installation phase, where the `then` chain is not properly structured to handle errors or ensure correct execution flow. However, this is not caused by misuse of a sensitive function such as `importScripts`, `eval`, or `fetch` with untrusted input. The code uses standard, safe operations (`caches.open`, `cache.addAll`, `self.skipWaiting`) with hardcoded values, and no dynamic or untrusted input is involved. Therefore, it is not a sensitive function misuse.}	```self.addEventListener('install', event => { event.waitUntil(caches.open(PRECACHE).then(cache => cache.addAll(PRECACHE_URLS)).then(self.skipWaiting())); });```
4496	elforum.info.js	Incorrect logic for determining user login status leading to broken access control	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from flawed logic in parsing the `loggedIn` parameter from the URL, not from misuse of a sensitive function. The code assumes `matches[1]` will always contain a valid value, but if the regex doesn't match, `matches[1]` is undefined, leading to incorrect access control decisions. This is a logic flaw, not a sensitive function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4497	elforum.info.js	Insecure URL handling in notification click leading to open redirect	High	true	N/A	N/A	clients.navigate	standard	{The `clients.navigate(data.url)` function is a standard browser API that allows navigation to arbitrary URLs. Since `data.url` is derived from untrusted push notification data without validation or sanitization, an attacker can craft a notification with a malicious URL, causing the user's browser to navigate to an arbitrary site, leading to an open redirect vulnerability.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
4498	elitebet.cg.js	Open Redirect via Untrusted URL Handling	High	true	CWE-601	9	N/A	standard	"{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. In this case, the URL is derived from the 'url' variable, which is populated from the push notification data (data.url) and sanitized via replace(/&amp;/g, ""&""). However, this sanitization is insufficient to prevent open redirect attacks, as it does not validate or restrict the URL to a trusted origin. An attacker could craft a push notification with a malicious URL (e.g., http://malicious.com) that would be opened in the user’s browser, leading to phishing or credential theft.}"	```clients.openWindow(url);```
4499	elitebet.cg.js	Open Redirect via Untrusted URL Handling	High	true	CWE-601	9	N/A	standard	"{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. Here, the URL is derived from event.action, which comes from the notification click event. Although the value is sanitized with replace(/&amp;/g, ""&""), this does not prevent an attacker from injecting arbitrary URLs via the notification payload. Since the action URL is not validated or restricted to a trusted domain, it enables open redirect attacks, allowing attackers to redirect users to malicious sites.}"	"```clients.openWindow(event.action.replace(/&amp;/g, ""&""));```"
4500	elitebet.cg.js	Insecure Push Subscription Handling	Medium	false	CWE-327	N/A	N/A	N/A	{The vulnerability arises from the use of a hardcoded applicationServerPublicKey variable that is not defined in the code, leading to a potential misconfiguration. However, this is not due to misuse of a sensitive function like importScripts() or eval(), but rather a logic or configuration error. The function urlB64ToUint8Array() is custom and used correctly to decode the key, but the issue stems from the undefined variable, not from unsafe function usage.}	```var applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);```
4501	emedpred.net.ua.js	Cache Poisoning via Non-GET Request Caching	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching responses for non-GET requests, which is a misconfiguration rather than misuse of a sensitive function. The code uses standard caching logic with caches.open(), cache.match(), and cache.put(), but does not involve dynamic or untrusted input influencing these operations. The issue is behavioral (caching non-GET requests) rather than stemming from a sensitive function being misused with unsanitized input.}	```const CACHE_NAME = `Emedpred`;self.addEventListener('install', event => {  event.waitUntil((async () => {    const cache = await caches.open(CACHE_NAME);    cache.addAll(['/']);  })());});self.addEventListener('fetch', event => {  event.respondWith((async () => {    const cache = await caches.open(CACHE_NAME);    const cachedResponse = await cache.match(event.request);    if (cachedResponse) {      return cachedResponse;    } else {      try {        const fetchResponse = await fetch(event.request);        cache.put(event.request, fetchResponse.clone());        return fetchResponse;      } catch (e) {}    }  })());});```
4502	emilkpro.in.js	ReDoS (Regular Expression Denial of Service	High	true	CWE-400	10	RegExp	standard	{The code constructs regular expressions from user-controlled or static strings via JSON.parse and new RegExp(), which can lead to ReDoS if the patterns contain complex or nested quantifiers (e.g., (?:/.*)? in the regex). Although the patterns are hardcoded, the use of dynamic regex construction from parsed strings introduces risk, especially if the input were to be untrusted. The sensitive function RegExp is misused by directly creating regex objects from potentially complex strings without validation or sanitization.}	"```const c = JSON.parse('[""emilkpro\\\\.in(?:/.*)?/ola/services/.*"",""emilkpro\\\\.in/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://23f82525-2a82-4583-89c5-c4dd12dfad94\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4503	enaranda.es.js	Improper Handling of Malformed Range Headers Leading to Denial of Service	High	true	CWE-798	10	Number	standard	{The code uses `Number` to parse a value extracted from a malformed `Range` header via a regex. If the header is crafted to return a non-numeric or invalid string (e.g., `bytes=abc-`), `Number` may return `NaN` or `0`, leading to incorrect slicing of the response body and potentially causing unexpected behavior or denial of service due to invalid range handling. The `Number` function is misused here because it does not validate or sanitize the input from the header, which is user-controlled.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
4504	estghfar.com.js	Open Redirect	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a new browser window or tab, and it is passed the value of event.notification.data.click_action, which is derived from untrusted push notification data. Since this data is parsed from event.data.text() (which can be controlled by an attacker), an attacker can craft a push notification with a malicious URL in the click_action field, causing the browser to redirect to an arbitrary site. This constitutes an open redirect vulnerability.}	"```self.addEventListener('notificationclick', function (event) { console.log(event.notification); event.notification.close(); event.waitUntil(clients.matchAll({ type: ""window"" }).then(function (clientList) { for (var i = 0; i < clientList.length; i++) { var client = clientList[i]; if (client.url == '/' && 'focus' in client) return client.focus(); } if (clients.openWindow) { console.log(event.notification.data); if (event.notification.data && event.notification.data.click_action) { return clients.openWindow(event.notification.data.click_action); } else { return clients.openWindow('https://estghfar.com/'); } } })); }```"
4505	europa-camioane.com.js	Cache Poisoning via Shared Cache Name	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using identical cache names (CACHE_NAME and DATA_CACHE_NAME) for different purposes, leading to unintended cache overwrites or conflicts. This is a configuration issue, not caused by misuse of a sensitive JavaScript function.}	```var CACHE_NAME = 'static-cache-v12.3'; var DATA_CACHE_NAME = 'static-cache-v12.3';```
4506	europa-camioane.com.js	Case-Sensitive URL Validation Bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from using string inclusion checks (includes()) without considering case sensitivity, allowing bypass via differently cased URLs. This is a logic flaw in validation, not due to misuse of a sensitive function.}	```if ((request.url.includes('.via-mobilis') || request.url.includes('www.europa-camioane.com')) && request.url.includes('securepubads') == false && request.url.includes('google') == false && request.url.includes('criteo') == false && request.url.includes('facebook') == false && request.url.includes('bing') == false && request.url.includes('rsavm.json') == false && request.url.includes('my.via-mobilis.com') == false && request.url.includes('account.via-mobilis') == false && request.url.includes('jobs/apply-for') == false && request.url.includes('worker.js') == false && request.url.includes('buyers.js') == false) { return true; }```
4507	europa-camioane.com.js	Race Condition in Cache Verification	High	false	N/A	N/A	N/A	N/A	{The vulnerability is caused by a race condition in the verifPrecache function due to improper synchronization of asynchronous operations, not by misuse of a sensitive function.}	```const verifPrecache = async function (delay) { return new Promise((resolve```
4508	extentworld.com.js	Vulnerable HTTP Status Code Handling	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of HTTP status codes during fetch responses, specifically returning a 200 OK response for 500+ server errors or connection issues. This does not stem from misuse of a sensitive JavaScript function like importScripts, eval, or dynamic code execution, but rather from flawed logic in response handling. The code does not involve dynamic input influencing sensitive functions, so it is not a sensitive function misuse.}	```if (isNavigateReq) { if (fetchedResp.status >= 500) { return new Response(svrErrRespBlob, { status: 200, statusText: 'OK' }); } return new Response(connErrRespBlob, { status: 200, statusText: 'OK' }); }```
4509	fansplay.tv.js	Improper Cache Cleanup Leading to Stale Data	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper cache cleanup logic, but it is not due to misuse of a sensitive function. The code correctly uses standard cache APIs (caches.keys(), caches.delete()) with no dynamic or untrusted input involved. The issue is a logic flaw in cache management, not a security misusage of a sensitive function.}	```self.addEventListener('activate', event => { event.waitUntil(caches.keys().then(cacheNames => { return Promise.all(cacheNames.filter(cacheName => cacheName.startsWith('pwa-')).filter(cacheName => cacheName !== staticCacheName).map(cacheName => caches.delete(cacheName))); })); });```
4510	fansplay.tv.js	Unrestricted Offline Page Serving for Non-Navigation Requests	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from serving the offline page for any request type, including non-navigation requests, but it is not caused by misuse of a sensitive function. The code uses standard fetch and caches.match APIs with no untrusted input or dynamic URL construction. The issue is a design flaw in response handling, not a security misusage of a sensitive function.}	```self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => { return response || fetch(event.request); }).catch(() => { return caches.match('offline'); })); });```
4511	fcvalue.com.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The provided code snippet defines an empty fetch event handler, which does not perform any actions. This is not a security vulnerability caused by misuse of a sensitive function, but rather a lack of functionality. No sensitive function is being misused here.}	"```self.addEventListener(""fetch"", e => {});```"
4512	federicovalli.it.js	Improper Validation of URL in Message Handler	Medium	true	New	8	N/A	standard	{The vulnerability arises from the use of `fetch(url)` within the `pwaForWpprecacheUrl` function, where `url` is derived from a message handler's `event.data.url`. This input is not validated or sanitized before being passed to `fetch()`, which is a standard JavaScript function. If an attacker can control the `event.data.url` via a malicious message, they could trigger the service worker to fetch and cache arbitrary resources, potentially leading to cache poisoning or unintended network requests. The function `fetch()` is sensitive because it executes network requests based on untrusted input, and the lack of validation allows for misuse.}	```const pwaForWpprecacheUrl = (url) => { if (!pwaForWpisBlackListed(url)) { caches.open(CACHE_VERSIONS.content).then(cache => { cache.match(url).then(response => { if (!response) { return fetch(url); } else { return null; } }).then(response => { if (response) { fetch(url).then(dataWrappedByPromise => dataWrappedByPromise.text()).then(data => { if (data) { const regex = /<img[^>]+src=\'(https:\\/\\/[^\'>]+)\'/g; let m; while ((m = regex.exec(data)) !== null) { if (m.index === regex.lastIndex) { regex.lastIndex++; } m.forEach((match, groupIndex) => { if (groupIndex == 1) { if (new URL(match).origin == location.origin) { fetch(match).then(imagedata => { cache.put(match, imagedata.clone()); }); } } }); } }); return cache.put(url, response.clone()); } else { return null; } }); }); }); }```
4513	feidclothes.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	N/A	fetch	standard	{The code uses `fetch` with a dynamically constructed URL derived from `u[i(328)]`, which is obfuscated but likely represents a user-controlled or untrusted input. This allows an attacker to manipulate the URL to perform SSRF attacks, potentially accessing internal resources or services.}	```var o = await u[i(254)](fetch, u[i(328)])[i(375)](n => n[i(316)]())[i(375)](n => n);```
4514	feidclothes.com.js	Insecure Notification Handling	Medium	false	CWE-601	N/A	N/A	N/A	{The vulnerability arises from improper handling of notification responses, but not due to misuse of a sensitive function. The issue is in the logic flow and error handling, not a direct function misuse.}	```self[i(286)][i(366)](r[i(263)], e)[i(375)](n => (console[i(322)](i(323), n), c[i(370)].close(), t()));```
4515	feidclothes.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from insufficient validation of `analyticsData[n(380)]` against `BASE_URL`, but no sensitive function is misused. The issue is in the conditional logic, not a function call.}	```var u = s[n(370)][n(314)].analyticsData[n(380)]; e[n(256)](u, BASE_URL) && (u = \'/\');```
4516	feidclothes.com.js	XSS via Dynamic Notification Content	High	true	CWE-79	N/A	showNotification	standard	{The `showNotification` function is called with dynamic content from `r.message` and `r[i(313)]`, which are derived from untrusted input. This allows an attacker to inject malicious content into notifications, potentially leading to XSS if the content is rendered in a context that executes scripts.}	```var e = { body: (lastNotificationPayload = r).message, icon: r[i(313)], tag: r[i(374)], data: { dateOfArrival: Date[i(282)](), primaryKey: 1, analyticsData: lastNotificationPayload } };```
4517	feidclothes.com.js	Insecure Cache Usage	Low	false	CWE-311	N/A	N/A	N/A	{The vulnerability is due to insecure caching behavior, but not caused by misuse of a sensitive function. The issue lies in the cache management logic, not a direct function misuse.}	```self.registration[i(366)](r[i(263)], e)[i(375)](n => (console[i(322)](i(323), n), c[i(370)].close(), t()));```
4518	filmy4wap.gen.in.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials, not misuse of a sensitive function.}	```const options = { firebaseConfig: { apiKey: 'AIzaSyCe9J2qPWn0rKX1AERobBzg41pCVkqMgBg' } };```
4519	filmy4wap.gen.in.js	Improper Input Validation in Notification Payload Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of parsed JSON data, not from misuse of a sensitive function.}	```const payload = JSON.parse(event.data.json().data.notification);```
4520	filmy4wap.gen.in.js	Unvalidated URL Redirection in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from notification data, which is not validated or sanitized, allowing an attacker to redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
4521	filmy4wap.gen.in.js	Plaintext Storage of Sensitive Data in IndexedDB	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from insecure data storage practices, not from misuse of a sensitive function.}	```const request = objectStore.put({ id: key, data: value });```
4522	flaashmessage.com.js	Open Redirect via Notification Click Handler	High	true	N/A	9	clients.openWindow	standard	{The function clients.openWindow(url) is used to open a new browser window or tab with the specified URL. The URL is derived from event.notification.data.url, which is sourced from the push notification payload. Since this data is controlled by the server sending the push notification (and potentially by an attacker if the server is compromised or if the notification data is not validated), an attacker could craft a notification with a malicious URL (e.g., a phishing site or a redirect to a malicious domain), leading to an open redirect vulnerability. The service worker executes this without validation, allowing arbitrary navigation.}	```const url = event.notification.data.url || '/'; event.waitUntil(clients.matchAll({type: 'window', includeUncontrolled: true}).then(clientList => { for (const client of clientList) { if (client.url === url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } }));```
4523	flaashmessage.com.js	Caching Non-PHP Resources Without Cache-Control Respect	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the caching logic for non-PHP resources, which does not respect Cache-Control headers. However, this is not due to misuse of a sensitive function, but rather a design or policy issue in the caching strategy. The functions used (caches.match, fetch, caches.open, cache.put) are used appropriately and are not inherently misused in a way that introduces a security vulnerability. The issue is more about cache policy than function misuse.}	```event.respondWith(caches.match(event.request).then(response => response || fetch(event.request).then(networkResponse => caches.open(CACHE_NAME).then(cache => { cache.put(event.request, networkResponse.clone()); return networkResponse; }))))```
4524	footlive.fr.js	Hardcoded API Key	High	false	N/A	N/A	N/A	N/A	{The hardcoded API key is a static secret embedded in the code, not a result of sensitive function misuse.}	```self[`appKey`] = `d4fcf9fa28db44b3197096b123d0678b`;```
4525	footlive.fr.js	Loading External Script from Untrusted Source	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When the URL passed to it is constructed using a variable (self[`hostUrl`]) that is hardcoded but not dynamically controlled by user input, it still represents a risk if the host is not fully trusted. However, in this case, the host is hardcoded to a known domain (cdn.gravitec.net), so the risk is mitigated. But since the function itself is sensitive and could be misused if the URL were dynamic or user-controlled, it qualifies as a sensitive function misuse scenario.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
4526	footmundo.com.js	XSS via unsanitized notification data	High	true	CWE-79	9	N/A	standard	{The `self.registration.showNotification()` function is used to display notifications with user-supplied data (title, body, icon, etc.) directly from the `notification` object, which is parsed from untrusted `event.data.text()`. Since these fields are not sanitized or validated, an attacker can inject malicious content (e.g., JavaScript via HTML in the body or title) that may be rendered in the notification UI, leading to XSS if the browser or platform interprets the content as executable code.}	```const title = notification.title; const options = { body: notification.body, icon: notification.icon, badge: notification.badge, tag: notification.tag, data: { info: notification.data } }; event.waitUntil(self.registration.showNotification(title, options));```
4527	footmundo.com.js	Insecure fetch with potential SSRF	Medium	true	CWE-918	8	N/A	standard	{The `fetch()` function is used with a URL (`p_link`) that is dynamically constructed based on the response from a prior fetch call, which itself is derived from untrusted `notification.data`. If the server returns a URL under attacker control (e.g., via a malicious `r.rlink`), the `fetch()` call can be coerced into making requests to internal or external systems, enabling SSRF. The URL is not validated or sanitized before being used in the fetch.}	"```await fetch(p_link, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify(npid) }).then(response => { return response.json(); }).then(r => { pn_link = r.rlink; });```"
4528	footmundo.com.js	Unvalidated notification data in click handler	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of untrusted data (`notification.data.info.nid` or `notification.data.info`) without validation, but it does not stem from misuse of a sensitive JavaScript function. The logic simply assigns values to a variable without sanitization, which could lead to logic errors or unintended behavior, but no direct function misuse is involved.}	```if (notification.data.info.nid) { notification_id = notification.data.info.nid; } else { notification_id = notification.data.info; }```
4529	qservicecastrol.eu.js	Denial of Service via Malformed URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by improper handling of malformed URLs during fetch event processing. The code checks for valid origins and methods, but does not validate or sanitize the URL structure itself, which could lead to DoS if malformed URLs trigger unexpected behavior in the URL parsing or network stack.}	```self.addEventListener('fetch', function (e) { const url = new URL(e.request.url); if (url.origin === location.origin && url.pathname.startsWith('/wp-admin/')) { return; } if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('PWA: Current request is excluded from cache.'); return; } if (!e.request.url.match(/^(http|https):\/\//i)) return; if (new URL(e.request.url).origin !== location.origin) return; if (e.request.method !== 'GET') { e.respondWith(fetch(e.request).catch(function () { return caches.match(offlinePage); })); return; } if (e.request.mode === 'navigate' && navigator.onLine) { e.respondWith(fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); })); return; } e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }); }).catch(function () { return caches.match(offlinePage); })); });```
4530	rajexpress.co.js	Loading external scripts without integrity checks	Medium	false	CWE-928	N/A	N/A	N/A	{The use of importScripts with hardcoded URLs does not constitute sensitive function misuse because the URLs are fixed and not derived from untrusted or dynamic input. While loading external scripts without integrity checks is a security concern, it does not stem from improper use of a sensitive function with dynamic input.}	```importScripts('https://www.rajexpress.com/service-worker.js?version=1581595330850');```
4531	rajexpress.co.js	Loading external scripts without integrity checks	Medium	false	CWE-928	N/A	N/A	N/A	{The use of importScripts with hardcoded URLs does not constitute sensitive function misuse because the URLs are fixed and not derived from untrusted or dynamic input. While loading external scripts without integrity checks is a security concern, it does not stem from improper use of a sensitive function with dynamic input.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
4532	raretoonindia.online.js	Improper URL Filtering in Cache Exclusion	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper logic in the `checkNeverCacheList` function, which is used with `every()` to determine if a URL should be excluded from caching. The function incorrectly returns `true` when the URL does not match any regex pattern, but `every()` expects `true` for all elements to pass. This logic flaw causes URLs matching any pattern in `neverCacheUrls` to be incorrectly allowed into the cache, not excluded. This is not due to misuse of a sensitive function, but rather a logical error in the filtering mechanism.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; }```
4533	realizapp.com.br.js	Cache Poisoning via Unvalidated Fetch Requests	High	true	CWE-252	10	N/A	standard	{The fetch() function is used without validation or sanitization of the request URL, allowing an attacker to manipulate the request to cache malicious responses or bypass security controls. Since the service worker responds with either a cached response or the result of fetch(event.request), an attacker could craft a request that triggers a malicious fetch, potentially leading to cache poisoning or unauthorized data exposure.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (cachedResponse) { return cachedResponse || fetch(event.request); })); });```
4534	realizapp.com.br.js	Service Worker Install Failure Due to Unreliable Cache.addAll	Medium	false	N/A	0	N/A	N/A	{The cache.addAll() function is used with a hardcoded list of resources, which does not inherently introduce a security vulnerability. The issue lies in the reliability of the operation rather than misuse of a sensitive function.}	```return cache.addAll(['/', '/css/font-awesome.min.css', '/css/login.min.css', '/js/jquery.min.js', '/js/login.js']);```
4535	recursosteocraticos.com.js	Improper URL Validation in Notification Click Handler	Medium	true	CWE-602	9	clients[0].navigate	standard	{The function clients[0].navigate is used with a URL derived from the notification's data.url, which is controlled by the server-side push notification payload. If an attacker can manipulate the push notification data (e.g., via server compromise or spoofed push), they can redirect the user to arbitrary URLs, leading to phishing or malicious navigation. The URL is not validated or sanitized before use, making this a sensitive function misuse.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
4536	recursosteocraticos.com.js	Trusting Client-Side loggedIn Parameter	High	true	CWE-20	10	RegExp.match	standard	{The function RegExp.match is used to extract the 'loggedIn' parameter from the service worker's current URL, which is under client control. Since the service worker runs in the browser context, an attacker can manipulate the URL to spoof the logged-in state (e.g., by appending ?loggedIn=true). This allows bypassing security checks that rely on this parameter, leading to unauthorized access or privilege escalation.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4537	red-i.com.ar.js	Cache Poisoning	High	true	N/A	10	importScripts	standard	{The code uses importScripts() to load external scripts, but the URL is constructed from dynamic input (e.g., via location.search or user-controlled parameters). This allows an attacker to inject arbitrary scripts, leading to cache poisoning where malicious content is stored and served to users.}	N/A
4538	red-i.com.ar.js	Insecure Direct Object Reference	Medium	false	N/A	0	NA	N/A	{The vulnerability arises from improper handling of requests without validating or sanitizing the input, but no sensitive function like importScripts or eval is directly misused.}	N/A
4539	red-i.com.ar.js	Improper Input Validation	Medium	false	N/A	0	NA	N/A	{The issue stems from insufficient validation of input URLs, but no sensitive function is directly misused in a way that introduces the vulnerability.}	N/A
4540	red-i.com.ar.js	Information Exposure	Low	false	N/A	0	NA	N/A	{The vulnerability is due to exposing debug information, not from misuse of a sensitive function like importScripts or eval.}	N/A
4541	red-i.com.ar.js	Denial of Service	Medium	false	N/A	0	NA	N/A	{The vulnerability is caused by returning a 504 error without proper input validation, not from misuse of a sensitive function.}	N/A
4542	redgo.film.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	0	N/A	N/A	{The vulnerability arises from hardcoding sensitive credentials (API key) in client-side JavaScript, not from misuse of a sensitive function. The code does not dynamically invoke any function with untrusted input that could lead to injection or execution risks.}	```importScripts('https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/8.10.1/firebase-messaging.js');const firebaseConfig = { apiKey: 'AIzaSyDygyLoQA6s_zRJEQzW3c44xXlc8FL1Lzw', authDomain: 'blueonline-redcarpet.firebaseapp.com', projectId: 'blueonline-redcarpet', storageBucket: 'blueonline-redcarpet.appspot.com', messagingSenderId: '905879077885', appId: '1:905879077885:web:1083e05bd721778a210f94' };firebase.initializeApp(firebaseConfig);const messaging = firebase.messaging();messaging.onBackgroundMessage(payload => { const notificationTitle = payload.notification.title; const notificationOptions = { body: payload.notification.body, icon: payload.notification.icon }; return self.registration.showNotification(notificationTitle, notificationOptions); });```
4543	reflot.es.js	Insecure JSON Parsing in Push Event	High	true	CWE-20	10	JSON.parse	standard	{The function JSON.parse is used on untrusted input from event.data.text(), which can lead to arbitrary code execution if the input is maliciously crafted JSON. Although the code checks if the string is valid JSON, it still processes the parsed object without sanitization, potentially allowing an attacker to inject malicious payloads via push notifications.}	```const options = { body: event.data.json().content, icon: event.data.json().icon, badge: event.data.json().badge, data: { link: event.data.json().link } };```
4544	reflot.es.js	Unvalidated Redirect in Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is called with a URL extracted from event.notification.data.link, which originates from untrusted push notification data. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malware distribution.}	```const promiseChain = clients.openWindow(event.notification.data.link);```
4545	rehabilitasyon.com.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The fetch event handler is empty, meaning it does not perform any logic or interception. This is not a result of misuse of a sensitive function, but rather a lack of implementation. No sensitive function is involved.}	```self.addEventListener('fetch', event => {});```
4546	renuevatucloset.cl.js	Outdated Firebase SDK	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to using an outdated version of the Firebase SDK (5.9.4), which may contain known security flaws or lack support for modern security features. This is not caused by misuse of a sensitive function, but rather by using an old library version.}	"```importScripts(""https://www.gstatic.com/firebasejs/5.9.4/firebase-app.js""), importScripts(""https://www.gstatic.com/firebasejs/5.9.4/firebase-messaging.js"")```"
4547	restwertboerse.ch.js	Server Side Request Forgery (SSRF) via Service Worker	Medium	true	CWE-829	10	fetch	standard	{The fetch() function is used directly with e.request, which is derived from the client's network request. If the request URL is controlled by an attacker (e.g., via a crafted request in a web application), this allows the service worker to make arbitrary HTTP requests on behalf of the browser, potentially leading to SSRF. Since the request is not validated or sanitized, it can be exploited to access internal resources or perform unauthorized actions.}	```e.respondWith(fetch(e.request));```
4548	sabeq.ps.js	Improper Request Method Validation in Fetch Handling	High	true	CWE-601	9	N/A	standard	{The vulnerability arises from improper validation of request methods in the fetch handler. The code checks if the request method is 'GET' and if the accept header includes 'text/html', but it does not properly validate or restrict other potentially dangerous methods (e.g., POST, PUT, DELETE). This could allow an attacker to bypass intended security controls or trigger unintended behavior, especially if the service worker is used in a context where such methods should be blocked. The sensitive function here is `fetch`, which is a standard JavaScript API that executes network requests based on the provided request object. When used without proper method validation, it can lead to unintended resource access or manipulation.}	```event.respondWith(fetch(event.request).catch(function () { return caches.match(event.request).then(function (response) { if (response) { return response; } if (event.request.mode === 'navigate' || event.request.method === 'GET' && event.request.headers.get('accept').includes('text/html')) { console.log('[Serviceworker]', 'Fetching offline content', event); return caches.match('/offline.html'); } }); }));```
4549	sahtekutum.com.js	Improper Validation of Cached Offline Page	High	true	CWE-20	N/A	self.addEventListener('install'	standard	{The fetch() function is used to retrieve the offline page during installation, but there is no validation or sanitization of the URL or response. This allows an attacker to potentially manipulate the offline page if it is served from an untrusted or compromised source, leading to improper caching of malicious content.}	```self.addEventListener('install', function (event) {  var offlinePage = new Request('/Themes/offline.php');  event.waitUntil(fetch(offlinePage).then(function (response) {    return caches.open('pwabuilder-offline').then(function (cache) {      console.log('[PWA Builder] Cached offline page during Install' + response.url);      return cache.put(offlinePage, response);    });  }));});```
4550	sahtekutum.com.js	Information Exposure via Offline Page	Medium	true	CWE-200	N/A	self.addEventListener('fetch'	standard	{The fetch() function is used to serve network requests, but when the network fails, it falls back to the cached offline page without validating its content. If the offline page contains sensitive information or is improperly secured, it may be exposed to unauthorized users, especially if the page is accessed offline without proper authentication or access controls.}	```self.addEventListener('fetch', function (event) {  event.respondWith(fetch(event.request).catch(function (error) {    console.error('[PWA Builder] Network request Failed. Serving offline page ' + error);    return caches.open('pwabuilder-offline').then(function (cache) {      return cache.match('/Themes/offline.php');    });  }));});```
4551	salatey.com.js	Caching of Sensitive Data via PUT/POST Requests	Medium	true	CWE-798	N/A	cache.put(event.request, fetchResponse.clone());	standard	{The cache.put() function is used to store responses in the service worker's cache. When used with requests that are not properly validated (e.g., PUT or POST requests), it can lead to caching of sensitive data such as authentication tokens or user-specific data. Since the request object is directly derived from event.request without filtering, any request type can be cached, potentially exposing sensitive data to unauthorized access or replay attacks.}	```cache.put(event.request, fetchResponse.clone());```
4552	santsahitya.in.js	Exposure of Sensitive Information in Client Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the hardcoded exposure of sensitive configuration data, specifically the databaseURL, which points to a phpMyAdmin interface with potentially sensitive database credentials. This is not caused by misuse of a sensitive JavaScript function, but rather by poor configuration management and hardcoding of sensitive URLs in client-side code.}	```const config = { databaseURL: 'https://cloud815.thundercloud.uk:2083/cpsess0901098503/3rdparty/phpMyAdmin/index.php?route=/sql&pos=0&db=kkteamin_agrokranti&table=tbl_sant_tokens' };```
4553	sarg.lt.js	Incorrect determination of user authentication state leading to potential CSRF vulnerabilities	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter directly from the URL, which can be manipulated by an attacker to bypass authentication checks. This is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in authentication state determination.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4554	sarg.lt.js	CSRF token handling without proper validation on server-side	High	false	N/A	N/A	N/A	N/A	{This vulnerability stems from the server-side lack of CSRF token validation, not from misuse of a sensitive JavaScript function. The client-side code fetches a CSRF token, but the issue lies in server-side implementation, not in how JavaScript functions are used.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4555	sarg.lt.js	Insecure navigation to unvalidated URL in notification click handler	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a URL derived from `data.url`, which is obtained from a push notification payload. Since this data is not validated or sanitized, an attacker could craft a malicious notification to redirect the user to an arbitrary URL, leading to phishing or other attacks.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4556	sarkarifayde.com.js	XSS via unsanitized HTML insertion	High	true	CWE-79	N/A	"document.body.insertAdjacentHTML(""afterbegin"", i);"	standard	{The function insertAdjacentHTML is a standard DOM API that directly inserts HTML strings into the document. When used with untrusted data (like the variable 'i' from an external API response), it can execute arbitrary HTML and JavaScript, leading to XSS. The input is dynamic and not sanitized, making it a direct vector for injection.}	"```document.body.insertAdjacentHTML(""afterbegin"", i);```"
4557	sarkarifayde.com.js	XSS via unsanitized HTML insertion	High	true	CWE-79	N/A	i.innerHTML = t;	standard	{The innerHTML property is a standard DOM API that parses and executes HTML strings. Assigning untrusted data (like 't' from an external API) to innerHTML can result in arbitrary script execution, causing XSS. The data is not sanitized or escaped, and the source is dynamic, making this a high-risk misuse.}	```i.innerHTML = t;```
4558	sarkarifayde.com.js	Insecure dynamic data loading	High	true	CWE-444	N/A	firebase.initializeApp({ ...i.firebaseConfig });	standard	{The function firebase.initializeApp is a standard Firebase API that initializes the SDK with configuration data. When the configuration (i.firebaseConfig) is derived from untrusted external sources (like API responses), it can lead to insecure dynamic loading of Firebase services, potentially allowing attackers to inject malicious configuration or credentials.}	```firebase.initializeApp({ ...i.firebaseConfig });```
4559	sarkarifayde.com.js	Improper input validation	Medium	true	CWE-20	N/A	self.registration.showNotification(i.title, { body: i.body, icon: i.icon, image: i.image, tag: i.tag, badge: i.badge, actions: [{ action: n, title: a, icon: o, url: s }, { action: r, title: c, icon: d, url: p }], data: { url: i.url, url2: s, url3: p, fcmMessageId: '' } });	standard	{The showNotification API is a standard service worker function that displays notifications. When its parameters (like title, body, actions, and URLs) are derived from untrusted data (i.e., from push message payloads), it can lead to improper input validation, allowing attackers to inject malicious content or redirect users to phishing sites via crafted URLs.}	```self.registration.showNotification(i.title, { body: i.body, icon: i.icon, image: i.image, tag: i.tag, badge: i.badge, actions: [{ action: n, title: a, icon: o, url: s }, { action: r, title: c, icon: d, url: p }], data: { url: i.url, url2: s, url3: p, fcmMessageId: '' } });```
4560	sarkarizone.org.js	Hardcoded Sensitive Information (API Key	High	false	CWE-798	N/A	N/A	N/A	{The vulnerability arises from hardcoded API keys in the code, not from misuse of a sensitive JavaScript function. The API key is embedded directly in the configuration object and is not dynamically processed or passed to any function that could introduce runtime risk.}	```firebase.initializeApp({ ...options.firebaseConfig});```
4561	sarkarizone.org.js	Insecure Client-Side Storage of Sensitive Data	Medium	false	CWE-312	N/A	N/A	N/A	{The vulnerability stems from storing sensitive data (like notification tokens) in IndexedDB, which is client-side and not protected by any sensitive function misuse. The writeData function uses standard IndexedDB APIs correctly, but the risk is due to storage location, not function misuse.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value });```
4562	sarkarizone.org.js	Unvalidated User-Controlled Input in Notification Handling	Medium	true	CWE-20	N/A	fetch	standard	{The fetch function is used with user-controlled URLs derived from event.notification.data.url and event.notification.data.actions[event.action].api_url. Since these values are not validated or sanitized, an attacker could supply malicious URLs, leading to unintended network requests or potential SSRF.}	```let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl);```
4563	sarkarizone.org.js	Reliance on Client-Side Platform Detection	Low	false	New	N/A	N/A	N/A	{This vulnerability is due to client-side platform detection using navigator.platform, which is inherently unreliable and not caused by misuse of a sensitive function. The code does not invoke any function that could lead to security issues through input processing.}	```let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction;```
4564	sarkarizone.org.js	Potential SSRF via Untrusted URL Handling	Medium	true	CWE-918	N/A	fetch	standard	{The fetch function is called with a URL derived from user-controlled input via getDomainAndHostname(url). If the input URL is not validated, an attacker could craft a request to internal or external resources, leading to SSRF. The function is standard and misused due to lack of input sanitization.}	"```domain = options.domain; if (http) { domain = getDomainAndHostname(url).hostname; } await fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) }).then(async res => { if (res.status == 200) { await this.writeData(""notification_token"", token); console.log(""Notification Token Sent.""); return res.json(); } console.log(""Notification Token Send Error "", res.status); });```"
4565	scanapp.org.js	Vulnerable Cache Deletion Logic	High	false	N/A	0	N/A	N/A	{The vulnerability arises from a logic error in the activate event handler, where `self.cacheName` is used instead of `cacheName` to compare cache names. This causes the code to incorrectly delete all caches because `self.cacheName` is undefined, leading to unintended cache deletion. However, this is not due to misuse of a sensitive function, but rather a variable name typo.}	```self.addEventListener('activate', event => { event.waitUntil(function (e) { return caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { if (self.cacheName !== cacheName) { return caches.delete(cacheName); } })); }); }); }());```
4566	schemesofwork.com.js	Caching of cross-origin resources without origin validation	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching responses without validating the origin of the requested resource. However, this is not due to misuse of a sensitive function, but rather a lack of origin validation logic in the caching strategy.}	```return fetch(request).then(function (response) { return cache.put(request, response); });```
4567	schemesofwork.com.js	Caching sensitive data without authentication checks	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from caching responses without verifying if the data is sensitive or if the user is authenticated. This is a logic flaw, not a direct misuse of a sensitive function.}	```if (response.status !== 404) { fulfill(response); }```
4568	schemesofwork.com.js	Fetching non-GET requests leading to unintended side effects	High	false	New	N/A	N/A	N/A	{The vulnerability occurs because the service worker fetches any request type without restricting to GET, potentially triggering unintended side effects. This is a misconfiguration, not misuse of a sensitive function.}	```return fetch(request).then(function (response) { return cache.put(request, response); });```
4569	schmalzauctions.com.js	Regular Expression Denial of Service (ReDoS	High	true	CWE-400	10	RegExp	standard	{The code dynamically constructs regular expressions from user-controlled or untrusted JSON input using `new RegExp(e)`, where `e` is derived from `JSON.parse()` of a string containing potentially complex or malicious regex patterns. This allows an attacker to supply a regex with exponential backtracking behavior (e.g., `(a+)+`), causing the service worker to consume excessive CPU resources and become unresponsive, leading to a ReDoS attack.}	"```const c = JSON.parse('[""schmalzauctions\\\\.com(?:/.*)?/ola/services/.*"",""schmalzauctions\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://16b7988b-ca4a-488c-9aa5-20fe32e46a9b\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4570	scoutnet.se.js	Incorrect Use of Service Worker Location Object	Low	false	N/A	0	N/A	N/A	{The code uses `new URL(location)` to parse the current URL, which is not inherently unsafe. The `location` object in a service worker context refers to the script's installation URL, and accessing its search parameters is a common practice for conditional logic (e.g., dev mode). There is no evidence of dynamic or untrusted input being used to construct URLs or invoke sensitive functions like `importScripts`, `eval`, or `fetch` with unsafe parameters. Therefore, this is not a sensitive function misuse.}	"```self.addEventListener('install', evt => { const app_env = new URL(location).searchParams.get('app_env'); if (app_env === ""dev"") { console.log('service worker has been installed', evt); } });```"
4571	scrabblemania.it.js	External Script Loading Without Integrity Check	High	true	CWE-78	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of arbitrary code from remote sources. In this case, the script is loaded from a hardcoded external URL (https://cdn.pushmaster-cdn.xyz/...), which, while not dynamically constructed, still poses a high risk if the source is compromised or if the script is not verified. This constitutes a sensitive function misuse because it enables remote code execution without validation.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/62e3e47f1b42760009633538/service-worker.js"");```"
4572	seir.com.gt.js	Insecure HTTP Cache Name	Medium	false	N/A	N/A	N/A	N/A	{The cache name uses an insecure HTTP scheme, which may lead to mixed content issues or cache poisoning in HTTPS environments, but this is not caused by misuse of a sensitive JavaScript function.}	```const cacheName = 'http://seir.com.gt-superpwa-2.2.31';```
4573	seir.com.gt.js	Incorrect Regex Logic in Cache Exclusion	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from incorrect logic in the checkNeverCacheList function, where the regex pattern is improperly applied using 'this.match(url)', which is not the intended usage for regex objects. This is a logical error, not a misuse of a sensitive JavaScript function.}	```function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
4574	sgmy123.com.js	XSS via Unsanitized Message Handling	High	true	CWE-79	10	postMessage	standard	{The postMessage function is used to send a message back to the source, but it concatenates unsanitized user input (e.g., e.data) directly into the message string. This allows an attacker to inject arbitrary content, potentially leading to cross-site scripting (XSS) if the message is later processed in a context where script execution is possible, such as in a page that reflects the message.}	```this.addEventListener('message', function (e) { e.source.postMessage('Hello! Your message was: ' + e.data); });```
4575	sharats.dev.js	Improper Neutralization of Server-Side Request Forgery (SSRF via cache.addAll)	High	true	CWE-918	10	caches.addAll	standard	{The function caches.addAll is used to add resources to the cache, and if the resources array contains URLs derived from untrusted or unsanitized sources, it can lead to SSRF. In this case, swconf.resources is not shown to be sanitized or validated, and if it contains malicious URLs (e.g., internal network endpoints), the service worker may attempt to fetch and cache them, leading to SSRF.}	```e || t.waitUntil(caches.open(swconf.cacheName).then(e => e.addAll(swconf.resources)))```
4576	sharats.dev.js	Improper URL Validation in Cache Bypass Logic	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability arises from insufficient URL validation logic, but it is not directly caused by misuse of a sensitive function. The code checks protocol and path prefixes, but the logic is flawed and could allow bypasses. However, no sensitive function like fetch or importScripts is being misused here.}	```if (!s.protocol.startsWith('http')) return !1; for (const e of t.urlPrefixes) if (s.href.startsWith(e)) return !1; for (const e of t.paths) if (n.startsWith(e)) return !1;```
4577	sharpmoneyexpert.com.js	Hardcoded API Token in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The hardcoded token is not a result of sensitive function misuse but rather a direct exposure of credentials in client-side code.}	"```async function sendToPushServer(event, eData = {}) { var data = { ""eventType"": event.type, ""eventData"": event?.notification?.data ?? eData }; let response = await fetch(""https://wpntgglo.com/api/"" + ""event"", { method: 'POST', headers: { 'Content-Type': 'application/json', 'Token': '01d69d4e9289ca0992948206be640caf' }, body: JSON.stringify(data) }); }```"
4578	sharpmoneyexpert.com.js	Unvalidated URL Redirection in Notification Click Handler	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with user-controlled data from N.data['clickURL'] without validation or sanitization, allowing an attacker to redirect users to arbitrary URLs, potentially leading to phishing or malware distribution.}	```prom = clients.openWindow(N.data['clickURL']);```
4579	sharpmoneyexpert.com.js	Lack of Input Validation for Push Event Data	Medium	false	N/A	N/A	N/A	N/A	{The issue arises from insufficient validation of event.data.json(), but this is not due to misuse of a sensitive function; it is a data handling flaw.}	```let data = event.data.json();```
4580	sharpmoneyexpert.com.js	Insecure Error Handling in Push Event Listener	Medium	false	N/A	N/A	N/A	N/A	{The error handling is flawed due to improper use of event.waitUntil(N) without ensuring N is a Promise, but this is not a sensitive function misuse; it is a logic or control flow issue.}	```event.waitUntil(N);```
4581	siam212th5.com.js	Cache Poisoning via Missing SameOrigin Check	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of a sameOrigin check in the route matching logic for `/games/allGameList`, which allows requests from external origins to be cached. This is not due to misuse of a sensitive function like `importScripts` or `eval`, but rather a logical flaw in the route condition. The `e.registerRoute` function is used correctly; the issue is in the route predicate logic, not in the function's unsafe usage.}	"```define(""./service-worker.js"", [""./workbox-c9728ebb""], function (e) { ""use strict""; importScripts(), e.setCacheNameDetails({ prefix: ""siam212_v1"" }), self.skipWaiting(), e.registerRoute(({ url: e, sameOrigin: r }) => ""/"" === e.pathname && !e.search && r, new e.StaleWhileRevalidate({ cacheName: ""html"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameList""), new e.StaleWhileRevalidate({ cacheName: ""agl"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/staticpagesettings/Info/orders""), new e.StaleWhileRevalidate({ cacheName: ""ord"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameName""), new e.StaleWhileRevalidate({ cacheName: ""agn"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""); });```"
4582	signalshop.rs.js	Open Redirect via Untrusted URL in Notification	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API used to open a new window or tab with a specified URL. In this case, the URL is derived from the notification's data.url, which originates from untrusted push message data. Since the URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or other malicious destinations.}	```event.waitUntil(clients.openWindow(clickedNotification.data.url));```
4583	silentijewelry.com.js	External Script Inclusion	Medium	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded, trusted URL (as in this case), it is not inherently vulnerable. However, if the URL were derived from untrusted or dynamic input (e.g., from user-controlled parameters), it could lead to arbitrary script execution. Since the URL is hardcoded and not influenced by user input, the vulnerability is not due to sensitive function misuse. Therefore, this is not a case of sensitive function misuse.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
4584	skladnicaksiegarska.pl.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a new browser window or tab with a URL derived from the push notification payload (push.link). Since push.link is populated from untrusted data (event.data.json().data), an attacker can manipulate the push notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with unsanitized input.}	```var event = clients.openWindow(push.link);```
4585	skladnicaksiegarska.pl.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing event.data.json().data without validating or sanitizing the input. While JSON.parse is used, the issue is not due to misuse of a sensitive function but rather a lack of input validation on the parsed data. The function itself is not inherently unsafe when used correctly, and no sensitive function is misused here.}	```var payload = event.data.json().data;```
4586	soliver.hr.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is used to load and execute a script from a hardcoded path ('/sw-redirect-cache.js'). While the path is not dynamically constructed from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. In a service worker context, this can lead to Remote Code Execution if the script is compromised or if the source is not properly secured. However, in this case, the URL is hardcoded and not derived from user input, so the risk is lower than if it were dynamic. But since the vulnerability was flagged as High and importScripts is inherently sensitive, it is marked as sensitively vulnerable with high confidence.}	"```importScripts(""/sw-redirect-cache.js"")```"
4587	soliver.rs.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a new window or tab with a URL derived from notification data. Since the URL is sourced from untrusted data (t.notification.data.url or t.notification.data[t.action]), an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with unsanitized input.}	"```self.addEventListener(""notificationclick"", function (t) { t.notification.close(); let n = t.notification.data.url; t.notification.data[t.action] && (n = t.notification.data[t.action]); const i = clients.openWindow(n); t.waitUntil(i); });```"
4588	sonhar.info.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from a potentially untrusted source (e.g., 'https://s3.amazonaws.com/sdk.zowpo.com/zowpo-sw.js'), it introduces a risk of remote code execution if the script at that URL is compromised or controlled by an attacker. Although the URL is hardcoded, the source is external and not under the developer’s direct control, making it a sensitive function misuse.}	```importScripts('https://s3.amazonaws.com/sdk.zowpo.com/zowpo-sw.js');```
4589	sportzorg24.tv.js	Cache-based Data Leakage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by improper logic in the fetch handler that may lead to unintended cache behavior or data leakage under certain conditions. The code does not use any sensitive functions like importScripts, eval, or dynamic code execution.}	"```(function () { ""use strict""; var c = ""Luxeritas 3.25.0 PWA - www.sportzorg24.tv"", s = ""https://www.sportzorg24.tv/"", o = ""https://www.sportzorg24.tv/wordcupsoccer-qatar2022/"", i = ""https://www.sportzorg24.tv/wp-content/uploads/2017/09/cropped-guguspo-192x192.png"", f = [s, o, i], n = [""\/wp-admin"", ""\/wp-login"", ""preview=true"", ""\/wp-includes\/js\/dist""]; function r(e) { return !this.match(e); } try { self.addEventListener(""install"", function (e) { return console.log(""PWA: service worker installation""), e.waitUntil(caches.open(c).then(function (e) { return console.log(""PWA: service worker caching dependencies""), f.map(function (s) { return e.addAll([s, o]).catch(function (r) { return console.log('PWA: ' + String(r) + ' ' + s); }); }); })); }); } catch (e) { console.error(""pwa.install.error: "" + e.message); } try { self.addEventListener(""activate"", function (e) { return console.log(""PWA: service worker activation""), e.waitUntil(caches.keys().then(function (l) { return Promise.all(l.map(function (k) { if (k !== c) return console.log(""PWA: old cache removed"", k), caches.delete(k); })); })), self.clients.claim(); }); } catch (e) { console.error(""pwa.activate.error: "" + e.message); } try { self.addEventListener(""fetch"", function (e) { n.every(r, e.request.url) ? e.request.url.match(/^(http|https):\/\//i) && new URL(e.request.url).origin === location.origin && (""GET"" === e.request.method ? ""navigate"" === e.request.mode && navigator.onLine ? e.respondWith(fetch(e.request).then(function (t) { return caches.open(c).then(function (a) { return a.put(e.request, t.clone()), t; }); }).catch(function () { return caches.match(o); })) : e.respondWith(caches.match(e.request).then(function (t) { return t || fetch(e.request).then(function (t) { return caches.open(c).then(function (a) { return a.put(e.request, t.clone()), t; }); }); }).catch(function () { return caches.match(o); })) : e.respondWith(fetch(e.request).catch(function () { return caches.match(o); }))) : false; }); } catch (e) { console.error(""pwa.fetch.error: "" + e.message); } })();```"
4590	squaredz.com.js	Invalid Cache URL Leading to Service Worker Installation Failure	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from an empty array in `filesToCache`, which causes the `cache.addAll()` call to attempt caching no resources. This does not involve misuse of a sensitive function, as no dynamic or untrusted input is being processed by a function that could lead to security risks such as code injection or unauthorized resource access. The issue is a logic or configuration error, not a security vulnerability stemming from sensitive function misuse.}	```var filesToCache = [''];```
4591	srbattel.com.js	Missing Subresource Integrity (SRI) for External Script	High	false	N/A	0	N/A	N/A	{The vulnerability arises from loading an external script without Subresource Integrity (SRI), which allows an attacker to compromise the integrity of the script if the CDN is compromised. However, this is not due to misuse of a sensitive function, but rather a lack of security hardening. The importScripts() call is used correctly with a hardcoded, trusted URL, so no dynamic or untrusted input is involved.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/3.5.0/workbox-sw.js');```
4592	sredime.hr.js	Stack Overflow in Cache Trimming	High	true	CWE-770	N/A	function trimCache(maxItems) { caches.open(CACHE).then(cache => { cache.keys().then(keys => { if (keys.length > maxItems) { cache.delete(keys[0]).then(() => { trimCache(maxItems); }); } } }); });	standard	{The function trimCache recursively calls itself without a proper base case or termination condition. When the cache contains more than maxItems entries, it deletes the first key and then immediately calls trimCache again, leading to infinite recursion. This results in a stack overflow, which can crash the service worker or cause denial of service. The misuse lies in the recursive call without checking if the condition (keys.length > maxItems) is still met after deletion, and the lack of a termination condition.}	```function trimCache(maxItems) { caches.open(CACHE).then(cache => { cache.keys().then(keys => { if (keys.length > maxItems) { cache.delete(keys[0]).then(() => { trimCache(maxItems); }); } } }); });```
4593	stadium.com.uy.js	Loading external script from untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted CDN (e.g., cdn.connectif.cloud), it introduces a high-risk vulnerability because the script being loaded is not under the control of the site owner. If the CDN is compromised or the script is malicious, it can lead to full control over the service worker, enabling attacks such as cache manipulation, network interception, or script injection.}	```importScripts('https://cdn.connectif.cloud/scripts/service-worker.js');```
4594	stanovinis.rs.js	Improper Error Handling Leading to Information Exposure	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling in the networkAndCache function, where exceptions during fetch are caught and silently handled by returning a cached offline page. However, this does not involve misuse of a sensitive function such as importScripts, eval, or dynamic code execution. The error handling is flawed in that it may mask underlying issues, but no sensitive function is being misused with untrusted input.}	```const cache = await caches.open(cacheName); try { const fresh = await fetch(req); return fresh; } catch (e) { return cache.match('./offline.html'); }```
4595	subhadrayojana.website.js	Vulnerable Data Deserialization	High	true	CWE-20	10	json	standard	{The function `json()` is called on `event.data`, which is untrusted data from a push event. If the data is maliciously crafted (e.g., containing prototype pollution or other deserialization attacks), it can lead to unintended behavior or code execution. Since the data is not validated or sanitized before use, this constitutes a deserialization vulnerability.}	```var notificationData = event.data.json();```
4596	subhadrayojana.website.js	Open Redirect Vulnerability	Medium	true	CWE-602	9	clients.openWindow	standard	{The `clients.openWindow(landingURL)` function is called with `landingURL` derived from `event.notification.data.click_action`, which is user-controlled data from a notification. If an attacker can manipulate this value, they can redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```var landingURL = event.notification.data.click_action || '/';```
4597	sykkel.org.js	CSRF Token Generation for Guest Users	High	true	CWE-352	9	fetch	standard	{The fetch function is used to retrieve a CSRF token from the server based on the path of the intercepted request. While the path is derived from the request URL, which is not directly user-controlled in this context, the vulnerability arises because the service worker dynamically constructs and sends a request to a server endpoint with a path parameter that could be manipulated if the original request is crafted by an attacker. This allows an attacker to potentially forge requests with valid CSRF tokens, leading to CSRF attacks. The misuse lies in the dynamic construction of the fetch URL without proper validation or sanitization of the path parameter.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); })```
4598	sykkel.org.js	Open Redirect via Notification Click Handler	Medium	true	CWE-601	8	clients[0].navigate	standard	{The clients[0].navigate function is used to redirect the user to a URL specified in the notification data. The URL is derived from the data.url field, which is populated from server responses and is not validated or sanitized. This allows an attacker to craft a notification with a malicious URL, leading to an open redirect that can be exploited for phishing or other attacks. The function is standard and directly responsible for the vulnerability due to its direct use of untrusted input.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4599	synallagma.gr.js	Improper Cache Expiration Based on Manipulable Date Header	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from relying on the 'date' header of cached responses to determine cache freshness. While no sensitive function is misused per se, the logic is flawed because the 'date' header can be manipulated by an attacker or spoofed by a malicious server, leading to premature cache invalidation or indefinite caching. This is a logic flaw, not a misuse of a sensitive function like importScripts or eval.}	```const cacheName = 'synallagma-0.1'; self.addEventListener('fetch', event => { event.respondWith(caches.open(cacheName).then(cache => cache.match(event.request, { ignoreSearch: true })).then(response => { if (!response) { return fetch(event.request); } const date = new Date(response.headers.get('date')); if (Date.now() > date.getTime() + 1000 * 60 * 60) { return fetch(event.request); } return response || fetch(event.request); })); });```
4600	t8thai.vip.js	Improper Use of importScripts Leading to Denial of Service	High	true	CWE-79	10	importScripts	standard	{The importScripts() function is called without any arguments, which may cause the service worker to attempt to load and execute scripts from an undefined or unexpected source. While the immediate call does not use dynamic input, its invocation without a specified URL can lead to unpredictable behavior, potentially causing a denial of service if the browser attempts to load a default or fallback script that is not properly defined. This misuse is considered sensitive because importScripts() can execute arbitrary code from remote sources when misused with dynamic inputs, and even its improper use without arguments can disrupt service worker execution.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); }, r = (r, n) => { Promise.all(r.map(e)).then(e => n(1 === e.length ? e[0] : e)); }, n = { require: Promise.resolve(r) }; self.define = (r, s, t) => { n[r] || (n[r] = Promise.resolve().then(() => { let n = {}; const o = { uri: location.origin + r.slice(1) }; return Promise.all(s.map(r => { switch (r) { case ""exports"": return n; case ""module"": return o; default: return e(r); } })).then(e => { const r = t(...e); return n.default || (n.default = r), n; }); })); }; } define(""./service-worker.js"", [""./workbox-c9728ebb""], function (e) { ""use strict""; importScripts(), e.setCacheNameDetails({ prefix: ""ta6prod_v1"" }), self.skipWaiting(), e.registerRoute(({ url: e, sameOrigin: r }) => ""/"" === e.pathname && !e.search && r, new e.StaleWhileRevalidate({ cacheName: ""html"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameList""), new e.StaleWhileRevalidate({ cacheName: ""agl"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/staticpagesettings/Info/orders""), new e.StaleWhileRevalidate({ cacheName: ""ord"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameName""), new e.StaleWhileRevalidate({ cacheName: ""agn"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""); });```"
4601	takhfif.co.js	XSS via unsanitized error message in iframe	High	true	CWE-79	10	`new Response(body, init)`	standard	{The `new Response()` constructor is used to create a response with a body that includes unsanitized user-controlled content (via `responseBody` from a failed fetch). This content is embedded into an iframe via `srcdoc` and `src`, which can execute arbitrary HTML/JS if the content is not properly sanitized, leading to XSS. The vulnerability arises because the `body` string is constructed using `replace()` with dynamic content from `responseBody` without escaping, and then passed directly to `new Response()`, which is a standard API that does not sanitize its input.}	"```const init = { status: errorResponse.status, statusText: errorResponse.statusText, headers: errorResponse.headers }; let body = text.replace('{{{WP_SERVICE_WORKER_ERROR_MESSAGE}}}', errorMessages.error); body = injectNavigationRequestProperties(body, event.request, response); body = body.replace(/({{{WP_SERVICE_WORKER_ERROR_TEMPLATE_BEGIN}}})((?:.|\n)+?)({{{WP_SERVICE_WORKER_ERROR_TEMPLATE_END}}})/, details => { if (!responseBody) { return ''; } const src = 'data:text/html;base64,' + btoa(responseBody); const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); const iframe = `<iframe style=""width:100%"" src=""${src}"" data-srcdoc=""${srcdoc}""></iframe>`; details = details.replace('{{{error_details_iframe}}}', iframe); details = details.replace('{{{iframe_src}}}', src); details = details.replace('{{{iframe_srcdoc}}}', srcdoc); details = details.replace('{{{WP_SERVICE_WORKER_ERROR_TEMPLATE_BEGIN}}}', ''); details = details.replace('{{{WP_SERVICE_WORKER_ERROR_TEMPLATE_END}}}', ''); return details; }); return new Response(body, init);```"
4602	takvimi-ks.com.js	Caching of Untrusted Resources Without Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from caching a hardcoded list of resources without validating their origin or integrity. However, no sensitive JavaScript function (like importScripts, eval, or dynamic script loading) is misused here. The code simply caches predefined static assets, which is a configuration issue rather than a misuse of a sensitive function.}	"```var REQUIRED_FILES = [""/assets/img/favicon.svg"", ""/assets/img/icon/72x72.png"", ""/assets/img/icon/96x96.png"", ""/assets/img/icon/128x128.png"", ""/assets/img/icon/144x144.png"", ""/assets/img/icon/152x152.png"", ""/assets/img/icon/192x192.png"", ""/assets/img/icon/384x384.png"", ""/assets/img/icon/512x512.png"", ""/assets/img/logo.svg"", ""/assets/img/kohet/festat.webp"", ""/assets/img/kohet/sabahu.webp"", ""/assets/img/kohet/lindja-e-diellit.webp"", ""/assets/img/kohet/dreka.webp"", ""/assets/img/kohet/ikindia.webp"", ""/assets/img/kohet/akshami.webp"", ""/assets/img/kohet/jacia.webp"", ""/assets/img/kohet/gjatesia-e-dites.webp"", ""/assets/css/style.css"", ""/assets/js/lib/bootstrap.bundle.min.js"", ""/assets/js/base.js""];```"
4603	tanpen.net.js	Improper Input Validation in Cache Population	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded URLs in urlsToCache, which are not dynamically sourced from untrusted input. Therefore, no sensitive function misuse is involved.}	```return cache.addAll(urlsToCache);```
4604	tanpen.net.js	Insecure Cache Deletion Logic	Low	false	N/A	N/A	N/A	N/A	{The logic uses a simple string inclusion check on cache keys, which is not driven by untrusted input or sensitive function misuse.}	```if (!CACHE_NAME.includes(key)) { return caches.delete(key); }```
4605	tanpen.net.js	Cached Content Exposure via Fetch Handler	Medium	false	N/A	N/A	N/A	N/A	{The fetch handler uses caches.match() and fetch() with the event.request, which is not inherently unsafe as it does not involve dynamic or untrusted input being passed to sensitive functions.}	```return response || fetch(event.request);```
4606	tanpen.net.js	Unvalidated Offline Page Handling	Low	false	N/A	N/A	N/A	N/A	{The offline page is hardcoded as 'static/offline.html' and not derived from user input or dynamic sources, so no sensitive function misuse occurs.}	```return caches.match('static/offline.html');```
4607	taraji.net.js	CSRF Token Bypass via URL Parameter Manipulation	High	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of a URL parameter (`loggedIn`) to determine user state, but it is not caused by misuse of a sensitive JavaScript function. The issue lies in logic that trusts the `loggedIn` parameter without proper validation or server-side enforcement.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4608	taraji.net.js	Server Side Request Forgery (SSRF) via Unvalidated Path Parameter	High	true	CWE-919	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL where the `path` parameter is derived from the request URL without sanitization or validation. This allows an attacker to manipulate the `path` parameter to trigger requests to internal or unintended endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json())```
4609	taraji.net.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	N/A	navigate	standard	{The `navigate` method is used with a URL derived from the `data.url` field in the notification payload, which is not validated or sanitized. This allows an attacker to craft a notification with a malicious URL, redirecting users to arbitrary sites, leading to open redirect.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4610	taxlok.com.js	Exposure of Sensitive Information, Firebase Configuration Details Exposed In Client-Side Code	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coding Firebase configuration details (including apiKey, authDomain, projectId, etc.) directly in the client-side JavaScript file. This is not caused by misuse of a sensitive JavaScript function, but rather by poor secret management practices. Since the configuration is static and not dynamically derived from untrusted input, no sensitive function is involved in the exposure.}	"```importScripts('https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js');importScripts('https://www.gstatic.com/firebasejs/8.10.0/firebase-messaging.js');var firebaseConfig = {apiKey: ""AIzaSyBu3vDmY8wJn_IOD4w-WLYlHVea4H6rs9I"",authDomain: ""demowebnotification-fc61a.firebaseapp.com"",projectId: ""demowebnotification-fc61a"",storageBucket: ""demowebnotification-fc61a.appspot.com"",messagingSenderId: ""969326084500"",appId: ""1:969326084500:web:5440caf87d7f6c8ab3cf81""};firebase.initializeApp(firebaseConfig);var messaging = firebase.messaging();messaging.onBackgroundMessage(function (payload) {console.log('Received background message: ', payload);var notificationData = JSON.parse(payload.data.notification);var notificationTitle = notificationData.title;var notificationOptions = {body: notificationData.body,icon: notificationData.icon,image: notificationData.image,actions: notificationData.actions,requireInteraction: true};self.registration.showNotification(notificationTitle, notificationOptions);});self.addEventListener('notificationclick', function (event) {var action = event.action;if (action === 'visit-site') {clients.openWindow('https://www.taxlok.com');} else {clients.openWindow('/');}event.notification.close();});```"
4611	tech360hindi.in.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL derived from untrusted notification data (event.notification.data.FCM_MSG.notification.data.url). Since this URL is not validated or sanitized, an attacker could craft a malicious notification payload containing a redirect to an arbitrary external site, leading to an open redirect vulnerability.}	```self.addEventListener('notificationclick', function (event) { const notification = event.notification; const urls = event.notification.data.FCM_MSG.notification.data.url; const url = typeof urls == 'string' ? urls : urls[0]; let url2 = typeof urls == 'object' ? urls[1] : urls[0]; const notifyIdd = event.notification.data.FCM_MSG.notification.data.notification_id; if (event.action === 'open_url') { event.waitUntil(notificationClickAlert(notifyIdd), clients.openWindow(url)); } else if (event.action === 'open_url_2') { event.waitUntil(notificationClickAlert(notifyIdd), clients.openWindow(url2)); } else if (event.action === 'close') { notification.close(); } else { event.waitUntil(notificationClickAlert(notifyIdd), clients.openWindow(url)); } });```
4612	technukti.com.js	Hardcoded Sensitive Information (Firebase API Key	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded sensitive data (Firebase API key) in the code, not due to misuse of a sensitive function.}	```const options = { firebaseConfig: { projectId: 'push-e4ef3', messagingSenderId: '1032524993417', appId: '1:1032524993417:web:03a36c16768f462752c758', apiKey: 'AIzaSyA6BOdDdZjXv6IhE5U1sdoadYxpp15-bMo' }, domain: 'technukti.com', api_url: 'https://push.sreenidhi.org/api/token', vapid_public_key: 'BBnc5ip79TuKrZZW9vd5XS648wZA_iItvzlpps_1fRUkQQCbU9FP2FUrbGyOpZWq2PV4i4ojeSO1OGMMgPVLKW0' };```
4613	technukti.com.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a URL derived from event.notification.data.url or event.notification.data.actions[event.action].click_action, which are untrusted and unvalidated inputs. This allows an attacker to craft a notification payload that redirects users to arbitrary URLs, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
4614	technukti.com.js	Unencrypted Storage of Sensitive Data (Notification Token	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from storing sensitive data (notification token) in IndexedDB without encryption. This is a data protection issue, not a misuse of a sensitive function.}	```writeData = async (key, value) => { const db = await this.openDatabase(); const transaction = db.transaction('myObjectStore', 'readwrite'); const objectStore = transaction.objectStore('myObjectStore'); const request = objectStore.put({ id: key, data: value }); return new Promise((resolve, reject) => { transaction.oncomplete = () => { resolve(); }; transaction.onerror = () => { reject(transaction.error); }; }); };```
4615	teknoce.com.js	External Script Inclusion Vulnerability	High	true	N/A	10	importScripts	standard	"{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded as 'https://www.bildir.mobi/sw.js', which is not user-controlled. However, since the vulnerability is labeled as ""External Script Inclusion Vulnerability"" and the script is being imported from an external domain, it may be considered a risk if the external source is untrusted. Despite the lack of dynamic input, the use of importScripts() with an external URL introduces potential supply chain risks if the external script is compromised.}"	```importScripts('https://www.bildir.mobi/sw.js');```
4616	telugujobspoint.com.js	Exposure of Sensitive Information to an Unauthorized Actor	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded sensitive credentials (API key, project ID, etc.) in the code, not from misuse of a sensitive JavaScript function.}	```var options = { firebaseConfig: { projectId: 'telegujobspoint', messagingSenderId: '610138620238', appId: '1:610138620238:web:e1b9d975ac74338b9ade1f', apiKey: 'AIzaSyCbzvU2pkL0afTFCXYszN9XDPQmCAxqgOM' }, domain: 'telugujobspoint.com', api_url: 'https://mohan.ltd/api/token', vapid_public_key: 'BIrm8ruqskyf_Kn9NQWmWcxetYsJGOEfXueES0PYvOKXomskBtCDEaKODNbUYdebaugkkadKQ30vJ2WirGAVvjQ' };```
4617	telugujobspoint.com.js	Insecure API Communication	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from sending sensitive data (push subscription details) over an insecure or unvalidated endpoint, not from misuse of a sensitive JavaScript function.}	```fetch(options.api_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) })```
4618	telugujobspoint.com.js	Cross-Site Scripting (XSS)	High	true	N/A	N/A	showNotification	standard	{The showNotification function is used with user-controlled payload.title, which is not sanitized. If an attacker can control the notification payload, they can inject malicious content that may be rendered in the notification UI, leading to XSS if the browser or OS renders it in a context where script execution is possible.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
4619	telugujobspoint.com.js	Open Redirect	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from event.notification.data.url or action-specific click_action. If these values are not validated or sanitized, an attacker can manipulate them to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
4620	telugujobspoint.com.js	Insecure Data Storage	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from storing sensitive data (e.g., notification tokens) in IndexedDB without encryption or proper access controls, not from misuse of a sensitive JavaScript function.}	```const request = objectStore.put({ id: key, data: value });```
4621	thedandys.ie.js	Offline Page Caching Without Revalidation	High	false	N/A	0	N/A	N/A	{The vulnerability arises from caching offline resources during installation without revalidating them on subsequent fetches. However, this is not due to misuse of a sensitive function like importScripts() or eval(), but rather a design flaw in cache management. No sensitive function is being misused with untrusted input.}	"```const domainRoot = 'https://www.thedandys.ie/'; const offlineResources = ['site/themes/thedandys.ie_2023/images/reload.png', 'site/themes/thedandys.ie_2023/images/noconnection.png', 'site/themes/thedandys.ie_2023/images/logo.png', 'offline.html']; self.addEventListener('install', function (event) { var offlineResource; for (var i = 0; i < offlineResources.length; i++) { offlineResource = new Request(domainRoot + offlineResources[i]); event.waitUntil(fetch(offlineResource).then(function (response) { return caches.open('pwabuilder-offline').then(function (cache) { return cache.add(offlineResource, response); }); }, function (err) { console.log(""[PWA Builder] Error caching: "" + err); })); } }); self.addEventListener('fetch', function (event) { var url = event.request.url; url = url.split(""/""); if (url[url.length - 1].indexOf(""."") == -1) { event.respondWith(fetch(event.request).catch(function (error) { return caches.open('pwabuilder-offline').then(function (cache) { return cache.match('https://www.thedandys.ie/offline.html'); }); })); } }); self.addEventListener('refreshOffline', function (response) { return caches.open('pwabuilder-offline').then(function (cache) { return cache.put(offlinePage, response); }); });```"
4622	thedarkblues.co.uk.js	Open Redirect via Notification Click Handler	High	true	CWE-601	10	clients[0].navigate	standard	{The notification click handler uses `clients[0].navigate(data.url)` where `data.url` is derived from the notification payload, which is controlled by the server or potentially an attacker via push notifications. Since the URL is not validated or sanitized, an attacker could craft a notification with a malicious URL (e.g., redirecting to a phishing site), leading to an open redirect vulnerability.}	```self.addEventListener('notificationclick', e => { const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
4623	thedarkblues.co.uk.js	Server-Side Request Forgery (SSRF) in Push Event Handler	High	true	CWE-918	9	fetch	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received in the push notification data. Although the URL is built using a base URL (`BASE_URL`), the `id` parameter is directly inserted into the URL without validation. If the server allows arbitrary paths or if the `id` parameter can be manipulated to point to internal resources (e.g., via path traversal or external endpoints), this could lead to SSRF, allowing an attacker to make requests to internal systems.}	```self.addEventListener('push', e => { if (!e.data) { console.log('Invalid notification data'); return; } const pingData = e.data.json(); const { id } = pingData; const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' }).then(response => { if (!response.ok) { throw new Error('Invalid response'); } return response.json(); }).then(data => { if (data.error) { throw new Error('Server error'); } ... });```
4624	thedarkblues.co.uk.js	Insecure CSRF Token Handling in Fetch Interception	Medium	true	CWE-347	8	fetch	standard	{The service worker intercepts POST requests from guests and fetches a CSRF token from the server using a URL constructed from the request path. The `fetch` call uses `path` from the request URL, which is user-controlled. If the path is not properly sanitized, an attacker could craft a request to a malicious path, potentially leading to CSRF token leakage or misuse, especially if the token is used in subsequent requests without proper validation.}	```e.respondWith(new Promise((resolve, reject) => { log(`On navigation, logged_in is ${loggedIn}`); if (loggedIn == 'false' && request.method === 'POST') { const curRequest = request.clone(); log('Intercepting guest post request'); let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); }); return; } resolve(fetch(request)); }).catch(err => { console.log(err); });```
4625	thefourthnews.in.js	Untrusted External Script Inclusion	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., cdn.izooto.com), it introduces a high-risk vulnerability because the script may be controlled by a third party and could contain malicious code. Although the URL is hardcoded, the source is external and not under the developer’s direct control, making it a sensitive function misuse.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/853477c0d48aeb149fca6e40cae850e3ec41642c.js"");```"
4626	thepornapp.com.js	Improper Output Neutralization for Logs	Low	false	N/A	N/A	N/A	N/A	{The console.log function is not a sensitive function in the context of security vulnerabilities such as injection or remote code execution. While logging untrusted data can lead to information leakage or log injection, it does not constitute a sensitive function misuse in the same way as functions like importScripts, eval, or dynamic code execution. The vulnerability here is more about logging untrusted input without sanitization, but not due to misuse of a sensitive function.}	```console.log(event.request.url);```
4627	thetolet.com.js	Improper Input Validation	Medium	true	CWE-20	9	clients.openWindow	standard	{The notification URL is derived from the payload.data.url field, which is user-controlled via Firebase messaging. This value is then passed directly to self.clients.openWindow(url), a standard browser API that opens a new window or tab with the specified URL. If an attacker can manipulate the payload to include a malicious URL (e.g., a phishing site or a site that performs cross-site scripting), the user’s browser will be redirected to that URL, leading to potential phishing, data theft, or further exploitation. This constitutes improper input validation and misuse of a sensitive function.}	```let notificationUrl = '/'; if (payload.data) { notificationUrl = payload.data.url ?? notificationUrl; } const notificationOptions = { actions: [{ action: notificationUrl, title: 'Explore' }], vibrate: [200, 100, 200, 100, 200, 100, 200] }; self.registration.showNotification(notificationTitle, notificationOptions);```
4628	tiktok18.porn.js	Untrusted Service Worker with Malicious Domain	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL '/sw.js' is hardcoded and not dynamically derived from untrusted input, the vulnerability classification suggests concern over the script's origin or trustworthiness. However, since the URL is static and not constructed from user-controlled or untrusted data, this does not constitute a sensitive function misuse in the traditional sense (e.g., no dynamic injection). Therefore, the vulnerability is not due to sensitive function misuse, but rather due to the potential untrusted nature of the script being imported.}	```importScripts('/sw.js');```
4629	todoroca.com.js	Open Redirect via Untrusted Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is used to open a URL derived from untrusted notification data (event.notification.data.FCM_MSG.data.link). Since the URL is constructed without validation or sanitization, an attacker could craft a notification payload with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or malicious domains.}	N/A
4630	todoroca.com.js	Credential Exposure in Firebase Config	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoded Firebase credentials in the script, but no sensitive function is misused. The exposure is due to static data leakage, not dynamic function misuse.}	N/A
4631	todoroca.com.js	Insecure External Script Loading	Medium	true	CWE-444	8	importScripts	standard	{The importScripts function is used to load external scripts from a hardcoded URL. While the URL is not dynamic, the function itself is sensitive because it executes arbitrary JavaScript code from remote sources. If the source were to be dynamically controlled by an attacker (e.g., via a compromised CDN or misconfigured domain), it could lead to remote code execution. However, in this case, the URLs are fixed and trusted, so the risk is mitigated but still present due to the nature of the function.}	N/A
4632	```importScripts('https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js'); importScripts('https://www.gstatic.com/firebasejs/10.11.0/firebase-messaging-compat.js');```	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	```importScripts('https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js'); importScripts('https://www.gstatic.com/firebasejs/10.11.0/firebase-messaging-compat.js');```
4633	todoroca.com.js	Potential XSS via Unsanitized Notification Payload	Medium	false	CWE-79	N/A	N/A	N/A	{The vulnerability stems from assigning the entire payload.data object to notificationOptions without sanitization. However, no sensitive function is directly misused to inject or execute malicious content. The risk is more related to data handling and potential misuse in downstream rendering, not a direct function misuse in the service worker context.}	N/A
4634	tonesbeat.com.js	Open Redirect	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a new window or tab with a URL specified by the event.notification.data, which is derived from untrusted push notification data. Since this data is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or malicious domains.}	```var redirectUrl = null;if (event.notification.data) {redirectUrl = event.notification.data ? event.notification.data : null;} else {redirectUrl = 'https://www.tonesbeat.com';}event.waitUntil(clients.openWindow(redirectUrl));```
4635	tonesbeat.com.js	Improper Input Validation	Medium	false	CWE-20	0	N/A	N/A	{The JSON.parse(event.data.text()) call is not inherently unsafe if the input is trusted or properly validated. However, since the input comes from a push notification, which is potentially untrusted, the lack of input validation could lead to issues if the data is malformed or malicious. But this is not directly caused by misuse of a sensitive function, as JSON.parse is not a sensitive function in this context unless used with untrusted data in a way that leads to injection or execution (e.g., eval).}	```let _data = event.data ? JSON.parse(event.data.text()) : {};```
4636	topbet.rs.js	Denial of Service via 5s Delay on HTML Responses	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a 5-second delay introduced when an HTML response is detected (via `<` at the start of the response body), but it is not caused by misuse of a sensitive JavaScript function. The delay is implemented using `setTimeout`, which is a standard function, but its use here is not inherently unsafe or sensitive—it is a logic-based timing issue rather than a function misuse vulnerability.}	```self.addEventListener('fetch', function (e) { var n = e.request.url, t = ['js/dependencies.6d9a23ba714c01f4.js', 'js/app.6fdb5d04ba29f7c2.js', ...].some(function (e) { return n.includes(e); }); if (e.clientId && t) try { e.respondWith(fetch(e.request, { mode: 'same-origin' }).then(function (t) { return t.clone().text().then(function (n) { return '<' === n[0] ? self.clients.get(e.clientId).then(function (e) { return e ? (e.postMessage({ type: 'SEVEN:InvalidJSFile' }), new Promise(function (e) { setTimeout(function () { e(n); }, 5e3); })) : t; }) : t; }); }).catch(function () {}); } catch (e) { console.error(e); } });```
4637	topconsulenten.nl.js	Open Redirect via Unvalidated User Input	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a URL passed from untrusted input (t.notification.data.url). Since the URL is derived from user-controlled data (via push notification payload), an attacker can manipulate the path to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```e.data.url = `${e.data.url}${a.path}`;```
4638	topup.co.zw.js	XSS via Untrusted Notification Data	High	true	CWE-79	10	N/A	standard	{The showNotification function is used with untrusted data from event.data.json(), which can be manipulated by an attacker to inject arbitrary content into the notification, leading to XSS if the notification is rendered in a context that executes script or evaluates untrusted strings.}	```event.waitUntil(self.registration.showNotification(data.title, options));```
4639	topup.co.zw.js	Phishing via Unvalidated Notification Actions	Medium	true	CWE-601	9	N/A	standard	{The clients.openWindow function is called with user-controlled action URLs from notification actions, allowing an attacker to redirect users to phishing sites or malicious domains without user consent.}	```clients.openWindow(action[0].action);```
4640	topup.co.zw.js	Cache Poisoning via Unvalidated Precache List	Medium	false	N/A	0	N/A	N/A	N/A	```toolbox.precache(CACHE_FILES);```
4641	totana.com.js	Open Redirect via Untrusted Click Action	High	true	CWE-601	9	showNotification	standard	{The showNotification function is used to display notifications, and the click_action field from the payload is passed directly into the notification options without sanitization. If an attacker can control the payload (e.g., via a crafted background message), they can set click_action to a malicious URL, leading to an open redirect when the user clicks the notification. This is a misuse of a standard browser API that allows execution of arbitrary navigation based on untrusted input.}	```return self.registration.showNotification(notificationTitle, notificationOptions);```
4642	tripclap.com.js	Insecure Handling of Notification Links	Medium	true	CWE-601	8	N/A	standard	{The `clients.openWindow(link)` function is used to open a URL specified in the notification data. If the `link` value is derived from untrusted or unsanitized input (e.g., from a push notification payload), it can lead to an open redirect or phishing attack, allowing an attacker to redirect users to malicious sites.}	```clients.openWindow(link);```
4643	tripclap.com.js	Uncontrolled Resource Consumption (Dynamic Cache Name Leading to Excessive Cache Storage)	Medium	false	CWE-400	N/A	N/A	N/A	N/A	```var staticCacheName = 'pwa-v' + new Date().getTime();```
4644	tripclap.com.js	Open Redirect	High	false	CWE-601	N/A	N/A	N/A	N/A	```event.waitUntil(clients.matchAll({type: 'window', includeUncontrolled: true}).then(function (clientList) { if (clientList.length > 0) { let client = clientList[0]; for (let i = 0; i < clientList.length; i++) { if (clientList[i].focused) { client = clientList[i]; } } return client.redirectTo(notificacion.data.redirectTo); } return clients.openWindow('/');```
4645	tuturno.io.js	Insecure Data Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by insecure handling of data passed to the showNotification method. The data.titulo and data.cuerpo fields are directly used without sanitization, which could lead to potential issues if these fields contain malicious content, though no direct function misuse is present.}	"```self.addEventListener(""push"", function (event) { const data = event.data.json(); event.waitUntil(registration.showNotification(data.titulo, { body: data.cuerpo, icon: data.data.pictureUrl, vibrate: [125, 75, 125, 275, 200, 275, 125, 75, 125, 275, 200, 600, 200, 600], openUrl: ""/"", data: data.data, actions: data.actions })); });```"
4646	udelny.com.js	XSS via Unsanitized Notification Data	High	true	CWE-79	N/A	JSON.parse	standard	{The code uses JSON.parse on untrusted input from c.data.text(), which can lead to XSS if the data contains malicious JavaScript. Since the input is not sanitized or validated, an attacker could inject arbitrary JavaScript that executes in the context of the service worker, potentially leading to data exfiltration or further exploitation.}	```var r = c.data ? JSON.parse(c.data.text()) : {};```
4647	udelny.com.js	Insecure Fetch Handling	Medium	true	CWE-829	N/A	fetch	standard	{The code uses fetch with a request that is not properly validated or sanitized, allowing an attacker to manipulate the request URL or headers. This could lead to unintended network requests, data leakage, or bypassing security controls if the request is constructed from untrusted sources.}	```n[t(293)](i[t(327)](fetch, n.request));```
4648	udelny.com.js	Obfuscated Code with Potential Malicious Logic	High	false	CWE-697	N/A	N/A	N/A	{The code uses obfuscation techniques (e.g., _0x22b8 array and _0x5673 function) to hide logic, but there is no direct misuse of a sensitive function. The obfuscation itself is not a function misuse, though it may conceal malicious behavior.}	```_0x5673 = function (n, t) { return _0x22b8[n -= 254]; }```
4649	udelny.com.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	N/A	self.clients.openWindow	standard	{The code uses self.clients.openWindow with a URL derived from untrusted data (u), which is constructed from potentially malicious input. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing or malware distribution.}	```self.clients.openWindow(u);```
4650	uk49slottoprediction.com.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a remote script whose URL is constructed using the current hostname via encodeURI(self.location.hostname). Although the hostname is not directly user-controlled, it can be manipulated via DNS rebinding or subdomain takeover, allowing an attacker to force the service worker to load and execute arbitrary JavaScript from a malicious domain, leading to full compromise of the service worker's execution context.}	N/A
4651	uk49slottoprediction.com.js	Server Side Request Forgery (SSRF) via Unvalidated Push Data	High	true	CWE-918	9	fetch	standard	{The fetch() function is called with a URL derived from unvalidated push notification data (data.ntf). Since the service worker has no validation or sanitization of this input, an attacker can send a push notification with a malicious URL (e.g., internal IP addresses, private endpoints) causing the service worker to make unauthorized requests on behalf of the user, potentially exposing internal systems or bypassing authentication.}	N/A
4652	uk49slottoprediction.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	8	clients.openWindow	standard	{The clients.openWindow() function is used to open a URL derived from unvalidated notification data (event.notification.data.url). Since this URL is not sanitized or validated, an attacker can craft a notification that redirects the user to an arbitrary external site, potentially leading to phishing, malware distribution, or session hijacking.}	N/A
4653	ukff.com.js	Client-Side Enforcement of Server-Side Security	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from client-side logic that checks for a `loggedIn` parameter in the URL, which can be manipulated by users. This does not involve misuse of a sensitive JavaScript function but rather a logical flaw in security enforcement.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4654	ukff.com.js	Improper Server-Side Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from server-side input validation issues, not from misuse of a sensitive JavaScript function. The URL construction is performed in JavaScript, but the actual risk lies in how the server processes the `path` parameter, which is outside the scope of JavaScript function misuse.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4655	ukff.com.js	URL Redirection to Untrusted Site	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a dynamic `data.url` value obtained from a push notification, which is untrusted. If an attacker can control the notification payload, they can redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4656	ukr-mova.in.ua.js	External Script Import from Untrusted Source	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., https://sandbox-api-esp.piano.io/esp-service-worker.js), it introduces a high-risk vulnerability because the script could be malicious or modified by an attacker, leading to unauthorized code execution, data exfiltration, or service disruption. Although the URL is hardcoded, the source is external and not under the control of the application, making it a sensitive function misuse.}	```importScripts('https://sandbox-api-esp.piano.io/esp-service-worker.js');```
4657	lronhubbard.org.js	Caching of Sensitive URLs via Broad Regex Patterns	High	true	CWE-918	9	toolbox.router.get	standard	{The vulnerability arises from the misuse of the `toolbox.router.get` function, which is a custom service worker routing API. It is used with a broad regex pattern `/(.*)((\.js)|(\/))$/` that matches any URL ending in .js or a trailing slash. This allows potentially untrusted or malicious JavaScript files to be cached and served without proper validation, enabling cache poisoning or script injection if an attacker can control the URL. The function is not inherently unsafe, but its misuse with overly permissive patterns introduces a high-risk vulnerability.}	N/A
4658	lronhubbard.org.js	Caching of Sensitive urls via Broad Regex Patterns	High	true	CWE-918	9	toolbox.router.get	standard	{The vulnerability arises from the misuse of the `toolbox.router.get` function, which is a custom service worker routing API. It is used with a broad regex pattern `/(.*)((\.jpg)|(\/))$/` that matches any URL ending in .jpg or a trailing slash. This allows potentially untrusted or malicious image files to be cached and served without proper validation, enabling cache poisoning or content injection if an attacker can control the URL. The function is not inherently unsafe, but its misuse with overly permissive patterns introduces a high-risk vulnerability.}	N/A
4659	lronhubbard.org.js	Caching of Sensitive urls via Broad Regex Patterns	High	true	CWE-918	9	toolbox.router.get	standard	{The vulnerability arises from the misuse of the `toolbox.router.get` function, which is a custom service worker routing API. It is used with a broad regex pattern `/(.*)((\.png)|(\/))$/` that matches any URL ending in .png or a trailing slash. This allows potentially untrusted or malicious image files to be cached and served without proper validation, enabling cache poisoning or content injection if an attacker can control the URL. The function is not inherently unsafe, but its misuse with overly permissive patterns introduces a high-risk vulnerability.}	N/A
4660	pepe.lt.js	Case-Sensitive Regex in NeverCacheUrls Leading to Sensitive Data Caching	Medium	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from the use of case-sensitive regex patterns in the neverCacheUrls array, which may fail to match URLs with different letter casing (e.g., ""/WP-Admin"" vs ""/wp-admin""), leading to unintended caching of sensitive administrative pages. This is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in pattern matching.}"	```if (this.match(url)) { return false; }```
4661	pepe.lt.js	Unvalidated Range Request Handling Leading to Potential DoS	High	true	N/A	N/A	Number	standard	{The Number() function is used to parse a range header value extracted from a user-controlled request header. If the header contains a non-numeric or malicious value (e.g., a very large number or a string that coerces to a large number), it can lead to excessive memory usage or denial of service when slicing the response body. The input is derived from event.request.headers.get('range'), which is untrusted and dynamic, making this a sensitive function misuse.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
4662	nic.jpmorgan.js	Improper Cache Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of cache entries, but no sensitive function misuse is directly involved. The issue stems from the use of a broad regex pattern that may allow unintended URLs to be cached without proper integrity checks.}	"```const c = JSON.parse('[""nic\\\\.jpmorgan(?:/.*)?/ola/services/.*"",""nic\\\\.jpmorgan/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://00d2dc22-eb9a-4de9-acaa-ead28992b836\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4663	nic.jpmorgan.js	Overly Permissive Route Regex	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to overly permissive regex patterns used in route matching, which may allow unintended URLs to be matched and processed. This is a logic flaw rather than misuse of a sensitive function.}	"```const c = JSON.parse('[""nic\\\\.jpmorgan(?:/.*)?/ola/services/.*"",""nic\\\\.jpmorgan/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://00d2dc22-eb9a-4de9-acaa-ead28992b836\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4664	nic.jpmorgan.js	Insecure Cache Deletion	Medium	true	N/A	N/A	caches.delete	standard	"{The caches.delete function is used with a dynamic filter based on cache names starting with ""nic.jpmorgan-"", which could be manipulated if the cache names are derived from untrusted sources. This allows an attacker to potentially delete unintended caches if the scope is not properly constrained.}"	"```e.waitUntil(caches.keys().then(function (e) { return Promise.all(e.filter(e => e.startsWith(""nic.jpmorgan-"")).map(e => caches.delete(e))); }));```"
4665	nic.jpmorgan.js	SSRF Vulnerability in Route Handling	High	true	N/A	N/A	registerRoute	standard	{The registerRoute function is used with a dynamic regex pattern derived from JSON.parse, which may allow an attacker to inject arbitrary URLs into the route matching logic. If the regex is not properly sanitized, it could lead to SSRF by allowing requests to internal or external resources not intended by the developer.}	```(0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkOnly());```
4666	nic.jpmorgan.js	Insecure Cache Expiration Configuration	Low	false	N/A	N/A	N/A	N/A	{The vulnerability is due to overly long cache expiration times, which is a configuration issue rather than misuse of a sensitive function. The ExpirationPlugin is used correctly, but the parameters are set to allow long-term caching, which may lead to stale content being served.}	```new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })```
4667	connecttosupport.org.js	Information Exposure via Console Logging	Low	false	N/A	N/A	N/A	N/A	{The vulnerability arises from logging sensitive information (URLs and deprecation messages) to the console, but this is not due to misuse of a sensitive JavaScript function. The console.warn() call is used appropriately and does not involve dynamic or untrusted input that could lead to code execution or injection.}	"```let obsoleteApis = [];fetch(self.registration.scope.replace(/\/$/, '') + ""/api/Technical/ObsoleteEndpoints"").then(async response => {  return await response.json();}).then(data => {  obsoleteApis = data.Data;});self.addEventListener(""fetch"", event => {  const obsoleteEndpoint = obsoleteApis.find(x => new URL(event.request.url).pathname.toLowerCase().startsWith(x.Url.toLowerCase()));  if (!!obsoleteEndpoint) {    console.warn(`Detected usage of the obsolete endpoint ${event.request.url}. Deprecation message: ${obsoleteEndpoint.Message}`);  }});```"
4668	vkagar.com.js	Loading untrusted external script via importScripts	High	false	N/A	0	N/A	N/A	{The script uses importScripts with a hard-coded path '/dist/sw/sw.8d80eb3c.js', which is not dynamically constructed from untrusted input. Since the URL is fixed and not derived from user-controlled or external sources, it does not constitute a sensitive function misuse.}	```importScripts('/dist/sw/sw.8d80eb3c.js');```
4669	riverbelle.casino.js	Improper Request Validation in Fetch Handler	High	true	CWE-80	9	N/A	standard	{The fetch handler uses `caches.match(e.request)` followed by `fetch(e.request)` without validating or sanitizing the incoming request URL. Since `e.request` is derived from the network request (which can be controlled by an attacker), this allows arbitrary resource fetching. The `fetch()` function is a standard JavaScript API that can be exploited to load malicious content or exfiltrate data if the request URL is not properly validated.}	"```self.addEventListener('fetch', function (e) { console.log(""Requested from network::"" + e.request.url); e.respondWith(caches.match(e.request).then(function (response) { console.log(""MATCH: "" + e.request); return response || fetch(e.request); })); });```"
4670	gornergrat.ch.js	Cache Poisoning via Accept-Language Header Manipulation	Medium	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of the `cacheKeyWillBeUsed` plugin callback in workbox, which modifies the cache key by appending a JSON stringified version of the Accept-Language header to the request URL. Since the Accept-Language header is user-controlled, an attacker can manipulate it to generate different cache keys for the same resource, leading to cache poisoning. Although `cacheKeyWillBeUsed` is not a direct sensitive function like `importScripts`, its misuse in this context allows for cache key manipulation based on untrusted input, which is a form of sensitive function misuse in the context of service worker security.}	```const c = e.headers.get('Accept-Language'); return c && (t += JSON.stringify({ 'Accept-Language': c })), t;```
4671	uk420.com.js	Server Side Request Forgery (SSRF	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this data is received from an external source (push notification), an attacker could manipulate the `id` value to cause the service worker to make unintended requests to internal or external endpoints, leading to SSRF. The URL is built using string concatenation, which allows for arbitrary path injection.}	N/A
4672	uk420.com.js	Server Side Request Forgery (SSRF	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since this value is derived from the client's request (which is untrusted), an attacker could manipulate the `path` to cause the service worker to make unintended requests to internal or external endpoints, leading to SSRF. The URL is built using string concatenation, which allows for arbitrary path injection.}	N/A
4673	uk420.com.js	Improper Access Control	High	false	CWE-285	0	N/A	N/A	{The vulnerability arises from improper logic in handling the `loggedIn` parameter from the URL, which is used to conditionally skip certain logic. However, this is not caused by misuse of a sensitive JavaScript function, but rather by flawed access control logic. The `match` function is used safely to extract the parameter, and no sensitive function is misused.}	N/A
4674	uk420.com.js	Open Redirect	Medium	true	CWE-601	8	clients[0].navigate	standard	{The navigate method is used with a URL derived from the notification data, which is received from an external source (push notification). Since the `data.url` is not validated or sanitized, an attacker could supply a malicious URL, causing the client to be redirected to an arbitrary site, leading to an open redirect. The method is directly invoked with untrusted input.}	N/A
4675	tswhost.com.js	Improper Handling of Non-GET Requests Leading to Caching of Sensitive Data	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the logic that allows non-GET requests to be handled by fetching and potentially caching responses, but it does not involve misuse of any sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The issue is more about logic flow and policy enforcement rather than function misuse.}	```self.addEventListener('fetch', function (e) { if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; } if (!e.request.url.match(/^(http|https):\/\//i)) return; if (new URL(e.request.url).origin !== location.origin) return; if (e.request.method !== 'GET') { e.respondWith(fetch(e.request).catch(function () { return caches.match(offlinePage); })); return; }```
4676	tswhost.com.js	Improper Validation of Range Headers Leading to Denial of Service	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from insufficient validation of the 'range' header, which could lead to out-of-bounds memory access or denial of service due to malformed or oversized range requests. However, this is not caused by misuse of a sensitive JavaScript function like eval or importScripts, but rather by improper input validation on a header value.}	```var fetchRangeData = function (event) { var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]); console.log('Range request for', event.request.url, ', starting position:', pos); event.respondWith(caches.open(cacheName).then(function (cache) { return cache.match(event.request.url); }).then(function (res) { if (!res) { return fetch(event.request).then(res => { return res.arrayBuffer(); }); } return res.arrayBuffer(); }).then(function (ab) { return new Response(ab.slice(pos), { status: 206, statusText: 'Partial Content', headers: [['Content-Range', 'bytes ' + pos + '-' + (ab.byteLength - 1) + '/' + ab.byteLength]] }); })); };```
4677	everyday-astrology.com.js	External Script Import Without Integrity Check	High	true	CWE-78	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can lead to code injection if the remote script is compromised or if the URL is dynamically controlled by an attacker. In this case, although the URL is hardcoded, the lack of integrity verification (e.g., subresource integrity) means that if the remote server is compromised, the script could be altered to execute malicious code. This constitutes a high-risk vulnerability because it allows an attacker to inject arbitrary JavaScript into the service worker, potentially leading to data exfiltration, session hijacking, or manipulation of network requests.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/65416776ffff4d0013e17e15"");```"
4678	cvdazzle.com.js	Cache Poisoning	High	true	N/A	9	caches.put	standard	{The caches.put function is used to store responses in the cache, but it is called with a request object that is derived from a network fetch. If the response is not properly validated (e.g., for content type or origin), an attacker could potentially inject malicious content into the cache, leading to cache poisoning. The function is standard and its misuse here allows untrusted responses to be cached.}	```return caches.open(cacheName).then(cache => cache.put(request, response.clone())).then(() => response);```
4679	cvdazzle.com.js	Insecure Cache Configuration	Medium	true	N/A	8	caches.open	standard	{The caches.open function is called with a cacheName derived from self.location.pathname, which is user-controllable via URL path. This allows an attacker to manipulate the cache name, potentially leading to cache isolation bypass or unintended cache sharing across different contexts. The function is standard and its misuse here stems from using dynamic, untrusted input as the cache identifier.}	```const cacheName = self.location.pathname;```
4680	phxitsolutions.com.js	Insecure Cache Strategy	Medium	false	N/A	N/A	N/A	N/A	N/A	```const a = new t.NetworkOnly();```
4681	phxitsolutions.com.js	Insecure Cache Strategy	Medium	false	N/A	N/A	N/A	N/A	N/A	```const a = new t.NetworkFirst({ cacheName: 'network-first' });```
4682	phxitsolutions.com.js	Insecure Cache Strategy	Medium	false	N/A	N/A	N/A	N/A	N/A	```const a = new t.StaleWhileRevalidate({ cacheName: 'static-resources' });```
4683	phxitsolutions.com.js	Insecure Cache Strategy	Medium	false	N/A	N/A	N/A	N/A	N/A	```const a = new t.CacheFirst({ cacheName: 'google-fonts-webfonts' });```
4684	phxitsolutions.com.js	Insecure Cache Strategy	Medium	false	N/A	N/A	N/A	N/A	N/A	```const a = new t.CacheFirst({ cacheName: 'images-fonts' });```
4685	inventale.com.js	Vulnerable Dynamic Function Execution	High	true	N/A	9	const { api } = event.data; if (api) MessageAPI[api](event, event.data);	standard	{The code dynamically invokes a function from the MessageAPI object using user-controlled input from event.data.gatsbyApi. This allows an attacker to trigger arbitrary functions within the MessageAPI object, potentially leading to unauthorized operations such as clearing IndexedDB or enabling/disabling offline shell features, which can be exploited for privilege escalation or data manipulation.}	```const { api } = event.data; if (api) MessageAPI[api](event, event.data);```
4686	inventale.com.js	Unvalidated User Input in IndexedDB Key	Medium	true	N/A	8	idbKeyval.set(`resources:${path}`, resources);	custom	{The function idbKeyval.set() is used with a key constructed from user-controlled 'path' input. This allows an attacker to inject arbitrary keys into IndexedDB, potentially leading to key collisions, data leakage, or unauthorized data access if the key structure is not properly validated or sanitized.}	```idbKeyval.set(`resources:${path}`, resources);```
4687	inventale.com.js	Open Redirect Vulnerability	High	true	N/A	9	Location: lastNavigationRequest	standard	{The Response header 'Location' is set to 'lastNavigationRequest', which is derived from the URL of a navigation request. Since this value is not validated or sanitized, an attacker can manipulate the URL to redirect users to arbitrary external sites, leading to phishing or malicious redirection attacks.}	```headers: { Location: lastNavigationRequest }```
4688	inventale.com.js	Insecure Dynamic API Call	High	true	N/A	9	MessageAPI[data.api]();	standard	{The code dynamically calls a function from the MessageAPI object using 'data.api', which is derived from user-controlled input parsed from the URL pathname. This allows an attacker to invoke any function in the MessageAPI object, potentially leading to unauthorized operations such as clearing IndexedDB or modifying offline shell behavior, resulting in a dynamic function execution vulnerability.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
4689	unilever-southlatam.com.js	Server Side Request Forgery (SSRF) via unvalidated fetch requests	High	true	CWE-918	9	fetch	standard	{The fetch function is used with a request object derived from e.request.url, which is dynamically constructed from the incoming fetch event. Since the URL is not validated against a whitelist or sanitized, an attacker could trigger the service worker to make requests to internal or external hosts, leading to SSRF. The service worker does not restrict the hostname or URL scheme, allowing arbitrary outbound requests.}	N/A
4690	unilever-southlatam.com.js	Insecure URL Exclusion Check via substring matching	Medium	false	CWE-20	7	N/A	N/A	{The vulnerability arises from using substring matching (indexOf) to check if a URL contains an excluded path. This is not a sensitive function misuse but a logic flaw in the exclusion mechanism. The function itself (indexOf) is not inherently dangerous, but its misuse leads to incomplete filtering.}	N/A
4691	unilever-southlatam.com.js	Caching of Untrusted Content via Dynamic PRE_CACHE_URLS	Medium	true	CWE-20	8	caches.addAll	standard	{The caches.addAll function is used with PRE_CACHE_URLS, which is populated from an external, potentially untrusted source (OUTER_PRE_CACHE_URLS). Since the URLs are not validated or sanitized, an attacker could inject malicious URLs into the cache, leading to unintended caching of untrusted content. This is a misuse of a standard caching API with dynamic, untrusted input.}	N/A
4692	trending.bid.js	Vulnerable Service Worker Fetch Handling	Low	false	N/A	0	N/A	N/A	{The provided code does not misuse any sensitive JavaScript function. The fetch event handler simply returns true, which is a benign operation and does not involve dynamic or untrusted input being passed to a sensitive API.}	```self.addEventListener('fetch', function onFetch(event) { return true; });```
4693	mlotto.win.js	Cache Poisoning via CacheFirst Strategy	High	true	CWE-918	10	workbox.routing.registerRoute	standard	{The vulnerability arises from the use of workbox.routing.registerRoute with a CacheFirst strategy, which caches responses without validation. If an attacker can manipulate the URL pattern or request headers (e.g., via crafted requests), the service worker may cache malicious or unintended content, leading to cache poisoning. The function is sensitive because it allows arbitrary caching behavior based on dynamic URL patterns and strategies, which can be exploited if not properly constrained.}	```workbox.routing.registerRoute(urlPattern, strategy, method);```
4694	mapitom.net.js	Forced Client Navigation on Fetch Error	Medium	false	New	N/A	N/A	N/A	{The code navigates the client to its current URL upon fetch failure, which is not inherently unsafe or caused by misuse of a sensitive function. The navigation is triggered by a controlled error-handling flow and does not involve dynamic, untrusted input influencing the navigation target.}	```self.clients.matchAll({type: 'window', includeUncontrolled: true}).then(clients => { if (clients && clients.length > 0) { clients[0].navigate(clients[0].url); } });```
4695	halotracker.com.js	Open Redirect via Notification Click	High	true	N/A	N/A	importScripts	standard	"{The vulnerability arises from the use of `clients.openWindow(i)` where `i` is derived from untrusted data in the push notification payload. Although `importScripts` is not directly used in the code, the detection of ""Open Redirect via Notification Click"" implies a misuse of functions that can navigate or open arbitrary URLs. However, in this specific code, the sensitive function responsible is `clients.openWindow`, not `importScripts`. Since the provided vulnerability detection incorrectly attributes the issue to `importScripts`, and the actual function used is `clients.openWindow`, which is a standard Web API, we must correct this. The correct sensitive function is `clients.openWindow`, which allows navigation to any URL provided by the notification data, enabling open redirect attacks if the URL is controlled by an attacker.}"	"```self.addEventListener(""notificationclick"", t => { let i; t.action ? i = t.notification.data.actions.find(n => n.key === t.action).url : i = t.notification.data.url, t.waitUntil(clients.matchAll({ type: ""window"", includeUncontrolled: !0 }).then(e => { let n = null; for (let a = 0; a < e.length; a++) { const o = e[a]; if (o.url === i) { n = o; break; } } return n ? n.navigate(i).then(a => a.focus()) : clients.openWindow(i); })); });```"
4696	toca-life.com.js	Loading untrusted external script in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function in Service Workers executes JavaScript from a specified URL. When used with a hardcoded external URL like 'https://servw.bid/sApxijiOVA.js', it introduces a high-risk vulnerability because the script is loaded from an untrusted third-party domain. This allows an attacker to inject malicious code into the service worker, potentially compromising the entire web application by intercepting network requests, manipulating cached resources, or stealing sensitive data.}	```importScripts('https://servw.bid/sApxijiOVA.js');```
4697	cecpower.net.js	Cache Poisoning via Broad Regex Patterns	High	true	CWE-918	9	/workbox.routing.registerRoute(/.*?irp\\.cdn-website\\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));	standard	"{The use of a broad regex pattern /.*?irp\\.cdn-website\\.com.*?/ in workbox.routing.registerRoute allows any URL containing the substring ""irp.cdn-website.com"" to be routed through networkFirst, which may cache responses from unintended or malicious domains if the pattern matches user-controlled or third-party URLs. This can lead to cache poisoning where an attacker's content is cached and served to other users.}"	N/A
4698	cecpower.net.js	SSRF via PrefetchUrl	High	true	CWE-919	9	N/A	standard	{The fetch API is used with a Request object constructed from a URL that is derived from user input via addParams, which is not validated or sanitized. The mode: 'no-cors' allows the fetch to bypass CORS restrictions, enabling the service worker to make requests to internal or private endpoints, leading to SSRF.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
4699	cecpower.net.js	Insecure Debug Logging	Medium	false	CWE-200	0	N/A	N/A	{The debug logging is enabled via pwaSettings.debug = true, but this does not involve misuse of a sensitive function; it is a configuration setting that exposes debug information.}	N/A
4700	cecpower.net.js	URL Injection in addParamsNative	Medium	true	CWE-113	8	N/A	custom	{The addParamsNative function constructs URLs by concatenating user-supplied parameters without proper sanitization or validation. The template function is used to interpolate parameters, but if the input contains malicious characters (e.g., JavaScript or control sequences), it can lead to URL injection, potentially altering the intended destination or triggering unintended behavior.}	```const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : '');```
4701	lemmy.studio.js	Insecure Cache Expiration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache expiration logic, but not due to misuse of a sensitive function. The code uses standard Workbox patterns for cache management, and the issue stems from configuration or logic flaws rather than direct invocation of a dangerous API.}	```const [e] = this.handleAll(t); return e;```
4702	lemmy.studio.js	Cache Poisoning via Message Handling	High	true	N/A	N/A	importScripts	standard	{The vulnerability occurs because the code processes incoming messages containing URLs to cache without validating or sanitizing them. The sensitive function importScripts() is not directly used here, but the code's reliance on dynamic URL construction from untrusted message payloads (e.g., e.urlsToCache) creates a risk of cache poisoning. However, upon closer inspection, the code does not use importScripts() at all. The actual issue is in the handling of message data for caching, which could be exploited if the service worker were to dynamically load scripts based on such data. Since importScripts() is not present, the sensitive function responsible is not applicable.}	```const s = Promise.all(e.urlsToCache.map(e => { 'string' == typeof e && (e = [e]); const s = new Request(...e); return this.handleRequest({ request: s, event: t }); }));```
4703	zkh.com.js	Insufficient Cache Management	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the declaration of an empty cacheList array without any logic to manage or populate it, which does not involve any sensitive function misuse.}	```var cacheList = [];```
4704	zkh.com.js	Empty Service Worker Event Handlers	Medium	false	New	N/A	N/A	N/A	{The event handlers for 'install', 'fetch', and 'activate' are empty, which may lead to poor functionality but does not involve misuse of any sensitive JavaScript function.}	```self.addEventListener('install', e => {});```
4705	zkh.com.js	Empty Service Worker Event Handlers	Medium	false	New	N/A	N/A	N/A	{The event handlers for 'install', 'fetch', and 'activate' are empty, which may lead to poor functionality but does not involve misuse of any sensitive JavaScript function.}	```self.addEventListener('fetch', function (e) {});```
4706	zkh.com.js	Empty Service Worker Event Handlers	Medium	false	New	N/A	N/A	N/A	{The event handlers for 'install', 'fetch', and 'activate' are empty, which may lead to poor functionality but does not involve misuse of any sensitive JavaScript function.}	```self.addEventListener('activate', e => {});```
4707	teologiapolityczna.pl.js	Insecure Caching of Network Responses Without Validation	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the lack of validation or integrity checks on cached responses, not from misuse of a sensitive function. The code uses standard fetch and caches.match, which are safe when used correctly. The issue is architectural—caching responses without verifying their origin or integrity could allow stale or malicious content to be served, but no sensitive function is misused.}	```self.addEventListener('fetch', function (evt) { evt.respondWith(fetch(evt.request).catch(function () { return caches.match(evt.request); })); });```
4708	megaflowers.com.js	Loading untrusted external script in Service Worker	High	true	N/A	9	importScripts	standard	{The importScripts() function in Service Workers executes JavaScript from a specified URL. When used with a hardcoded URL pointing to an external domain (e.g., 'https://megaflowers.ru/sw.js'), it introduces a high-risk vulnerability if the external script is not fully trusted, as it can execute arbitrary code within the service worker context, potentially leading to cache manipulation, network interception, or data exfiltration.}	```importScripts('https://megaflowers.ru/sw.js');```
4709	hoosiersportsnation.com.js	Open Redirect via Notification Click	High	true	CWE-602	10	clients[0].navigate(data.url)	standard	{The service worker uses clients[0].navigate(data.url) to redirect the client to a URL provided in the notification data. Since this URL is derived from server-sent push notification data (which can be controlled by an attacker), it allows for open redirect attacks. An attacker can craft a push notification with a malicious URL, causing the user’s browser to navigate to an arbitrary site, potentially leading to phishing or credential theft.}	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
4710	hoosiersportsnation.com.js	Insecure Client-Side Login State	Medium	false	CWE-697	N/A	N/A	N/A	{The vulnerability arises from relying on a URL parameter (loggedIn=true/false) to determine user login state, which can be easily manipulated by users. However, this is not caused by misuse of a sensitive JavaScript function, but rather a flawed logic design. No sensitive function is being misused here.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4711	mon-poeme.fr.js	External Script Execution Without Integrity Check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to load a script from a third-party CDN without any integrity checks or validation. This allows an attacker who compromises the CDN or intercepts the request to inject malicious code into the service worker, leading to potential data exfiltration, session hijacking, or full control over the service worker’s behavior.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/623b311fe999c100099724b3/service-worker.js"");```"
4712	picklebet.com.js	Importing external script without integrity checks	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious code from an external source. In this case, the script is loaded from a third-party CDN (js.appboycdn.com), which could be compromised or modified, leading to code injection and full control over the service worker's behavior.}	"```self.importScripts(""https://js.appboycdn.com/web-sdk/3.3/service-worker.js"");```"
4713	nic.ipiranga.js	Regular Expression Denial of Service (ReDoS	High	true	CWE-400	10	RegExp	standard	{The code constructs regular expressions from user-controlled or untrusted JSON strings using `new RegExp(e)`, where `e` is derived from `JSON.parse()` of potentially malicious input. This allows an attacker to craft a regex with catastrophic backtracking patterns (e.g., `(a+)+`), leading to ReDoS. The `RegExp` constructor is a standard JavaScript function, and its misuse here is directly responsible for the vulnerability.}	"```const c = JSON.parse('[""nic\\\\.ipiranga(?:/.*)?/ola/services/.*"",""nic\\\\.ipiranga/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://8a33f53a-227c-49f7-8ba6-58f9a0f80cba\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4714	nic.ipiranga.js	Regular Expression Denial of Service (ReDoS	High	true	CWE-400	10	RegExp	standard	{The code constructs regular expressions from user-controlled or untrusted JSON strings using `new RegExp(e)`, where `e` is derived from `JSON.parse()` of potentially malicious input. This allows an attacker to craft a regex with catastrophic backtracking patterns (e.g., `(a+)+`), leading to ReDoS. The `RegExp` constructor is a standard JavaScript function, and its misuse here is directly responsible for the vulnerability.}	"```const o = JSON.parse('[""nic\\\\.ipiranga(?:/.*)?/f/.*"",""https://blog\\\\.apps\\\\.secureserver\\\\.net/v1/website/8a33f53a-227c-49f7-8ba6-58f9a0f80cba/feed/post/"",""https://blog\\\\.apps\\\\.secureserver\\\\.net/v1/website/8a33f53a-227c-49f7-8ba6-58f9a0f80cba/feed""]').map(e => new RegExp(e));```"
4715	nic.dupont.js	Overly Broad Cache Regex Patterns	Medium	false	CWE-20	N/A	const c = JSON.parse('[\'nic\\\\.dupont(?:/.*)?/ola/services/.*\']').map(e => new RegExp(e))	N/A	{The vulnerability arises from overly broad regex patterns used in cache matching, but no sensitive JavaScript function is misused. The issue is in the pattern design, not function misuse.}	```const c = JSON.parse('[\'nic\\\\.dupont(?:/.*)?/ola/services/.*\']').map(e => new RegExp(e))```
4716	nic.dupont.js	Long-Term Cache Expiration for Fonts	Low	false	CWE-923	N/A	new t.CacheFirst({ cacheName: 'google-fonts-webfonts', plugins: [new a.CacheableResponsePlugin({ statuses: [0, 200] }), new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })] })	N/A	{The vulnerability stems from long-term cache expiration settings, but no sensitive function is misused. The issue is in configuration, not function misuse.}	```new t.CacheFirst({ cacheName: 'google-fonts-webfonts', plugins: [new a.CacheableResponsePlugin({ statuses: [0, 200] }), new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })] })```
4717	nic.dupont.js	Potential Sensitive URL Precaching	Medium	false	CWE-538	N/A	"const h = JSON.parse('[\'/\'].map(e => ({ url: e, revision: ""1724173491287"" }))"	N/A	{The vulnerability involves precaching a root URL, but no sensitive function is misused. The issue is in the URL selection, not function misuse.}	"```const h = JSON.parse('[\'/\'].map(e => ({ url: e, revision: ""1724173491287"" }))```"
4718	ihsafootball.com.js	Improper Error Handling in Service Worker	Medium	false	CWE-754	N/A	N/A	N/A	{The vulnerability is due to improper error handling in the fetch event handler, where errors during network requests are caught and handled by returning a cached fallback response. However, this does not involve misuse of a sensitive function like importScripts or eval, which could lead to code injection or arbitrary code execution. The error handling is functional but lacks robustness, such as logging or more granular error classification, but it does not stem from a sensitive function misuse.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp; } })()); } });```
4719	condolences.com.js	Overly Permissive Cache Regex	High	true	CWE-20	8	N/A	standard	{The regex /.*?irp\\.cdn-website\\.com.*?/ is overly permissive and matches any URL containing the substring 'irp.cdn-website.com', which could allow unintended resources to be cached or processed by the networkFirst strategy. This is not directly caused by a sensitive function misuse, but the vulnerability arises from the use of the standard RegExp API with a poorly defined pattern that could be exploited to cache malicious or unintended content.}	```workbox.routing.registerRoute(/.*?irp\\.cdn-website\\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
4720	condolences.com.js	Debug Mode Enabled in Production	Medium	false	CWE-532	N/A	N/A	N/A	{Debug mode is enabled via pwaSettings.debug = true, which may expose internal logs and debugging information in production. This is a configuration issue, not a misuse of a sensitive function.}	```pwaSettings.debug = true;```
4721	condolences.com.js	Use of No-CORS Mode in Fetch	Medium	false	CWE-434	N/A	N/A	N/A	{The fetch call uses mode: 'no-cors', which prevents access to response data and may lead to unexpected behavior or errors. This is a configuration choice, not a misuse of a sensitive function.}	```fetch(new Request(url, { mode: 'no-cors' }));```
4722	condolences.com.js	Potential URL Injection in addParams	Medium	true	CWE-113	9	N/A	standard	{The addParams function uses new URL(url) to parse and modify URLs. If the input 'url' is derived from untrusted sources (e.g., user input), it could lead to URL injection, allowing attackers to manipulate the URL structure, potentially redirecting to malicious domains or bypassing security checks. The sensitive function here is the standard URL constructor, which is vulnerable when used with untrusted input.}	```const ur = new URL(url);```
4723	airlinepilot.life.js	XSS via Unsanitized User Input in Notification Reply	High	true	CWE-79	10	fetch	standard	{The fetch function is used to send a POST request with the user-provided `e.reply` value directly interpolated into the request body via template literals (`body: `message=${e.reply}``). Since `e.reply` is user-controlled and not sanitized or validated, an attacker can inject malicious scripts or HTML, leading to Cross-Site Scripting (XSS) when the response is rendered in the context of the application. This misuse of fetch with unsanitized input allows for script injection, which is a high-severity vulnerability.}	"```if (""reply"" === e.action) { let n; fetch(""/session/csrf"", { credentials: ""include"", headers: { Accept: ""application/json"" } }).then(e => { if (!e.ok) throw new Error(""Network response was not OK""); return e.json(); }).then(o => { n = o.csrf; let s = t.match(chatRegex); if (s.length > 0) { let t = s[1]; fetch(`${i}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": n }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" }); } }); }```"
4724	autotrader.pl.js	Dynamic Script Loading from Untrusted Host	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed using location.hostname, which is user-controllable via the host in the URL. This allows an attacker to supply a malicious hostname, causing the service worker to load and execute arbitrary JavaScript from an untrusted source, leading to code injection and potential full compromise of the service worker's execution context.}	```self.importScripts('https://' + location.hostname + '/sw.js');```
4725	vectoranalytics.ru.js	Cache Poisoning via Incomplete URL Parameter Sanitization	High	true	CWE-918	N/A	const e = urlsToCacheKeys.has(t) || (t = addDirectoryIndex(t, r), e = urlsToCacheKeys.has(t))	standard	{The vulnerability arises from the use of `new URL()` and `stripIgnoredUrlParameters()` on user-controlled input (the request URL) without sufficient sanitization. The `stripIgnoredUrlParameters()` function processes the URL’s query string by splitting and filtering parameters, but it does not validate or sanitize the resulting URL structure. If an attacker can manipulate the URL to include a path traversal or a crafted URL that bypasses the whitelist, the resulting `t` may resolve to a URL that maps to a cached resource not intended for caching. This allows an attacker to poison the cache with malicious content, leading to cache poisoning. The `new URL()` function is standard and is misused here because it is applied to untrusted input without proper validation.}	```const e = urlsToCacheKeys.has(t) || (t = addDirectoryIndex(t, r), e = urlsToCacheKeys.has(t))```
4726	b4bschwaben.de.js	Offline Page Availability on Install Failure	Medium	false	N/A	0	N/A	N/A	{The vulnerability described relates to the availability of an offline page during install failure, but it does not stem from the misuse of a sensitive JavaScript function. The code correctly uses `caches.open` and `cache.add` with a hard-coded URL (`OFFLINE_URL`), which is not derived from untrusted or dynamic input. Therefore, no sensitive function misuse is present.}	```const cache = await caches.open(CACHE_NAME); await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));```
4727	becassubes.com.js	Improper Input Validation - Range Header Handling	High	true	CWE-20	N/A	Number	standard	{The Number() function is used to convert a string extracted from the 'range' header into a numeric position. However, the input is not validated or sanitized, allowing an attacker to supply malformed or out-of-bounds values (e.g., negative numbers, extremely large numbers) that could lead to unexpected behavior or memory corruption when used with ab.slice(pos). This constitutes improper input validation.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
4728	becassubes.com.js	Insecure Cache Name - HTTP Usage	Medium	false	CWE-311	N/A	N/A	N/A	{The cache name contains an HTTP URL scheme, which is not inherently a misuse of a sensitive function but rather a configuration issue. No sensitive function is misused here.}	```const cacheName = 'http://becassubes.com-superpwa-2.2.31';```
4729	becassubes.com.js	Improper Restriction of Byte Range Access	High	true	CWE-119	N/A	ab.slice	standard	{The ab.slice(pos) function is used to return a subset of the ArrayBuffer based on the parsed 'range' header. Since the 'pos' value is derived from untrusted input without bounds checking, an attacker could supply a position that exceeds the buffer length or is negative, leading to potential memory corruption or denial of service. This is a classic case of improper restriction of byte range access.}	```return new Response(ab.slice(pos), { status: 206, statusText: 'Partial Content', headers: [['Content-Range', 'bytes ' + pos + '-' + (ab.byteLength - 1) + '/' + ab.byteLength]] });```
4730	tateesq.com.js	Improper Cache Validation in CacheFirst Strategy	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the CacheFirst strategy being applied without proper validation of the response or cache integrity, but it is not caused by misuse of a sensitive JavaScript function such as importScripts or eval. The issue lies in the strategy configuration and caching logic, not in dynamic input being passed to a dangerous function.}	```const strategy = new workbox.strategies[entry.handler](strategyOptions);```
4731	tateesq.com.js	Static Cache Revision Without Dynamic Validation	Low	false	N/A	0	N/A	N/A	{This issue stems from a hardcoded revision string 'i8y795p0qgaI' used in preCaching, which does not dynamically validate or update based on changes. It is not caused by misuse of a sensitive function like importScripts or eval, but rather by static configuration.}	```'revision': 'i8y795p0qgaI'```
4732	blacksidersociety.pro.js	Improper Access Control due to incorrect loggedIn determination	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improperly parsing the `loggedIn` parameter from the URL using a regex match, which can be manipulated by an attacker to bypass authentication checks. This is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in access control.}	"```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log(""Logged in, nothing to do...""); return; }```"
4733	blacksidersociety.pro.js	Open Redirect via notification data	Medium	true	N/A	N/A	clients.navigate	standard	{The `clients.navigate()` function is used with user-controlled data from the notification's `data.url` field, which is not validated or sanitized. This allows an attacker to craft a notification that redirects the user to an arbitrary URL, leading to an open redirect vulnerability.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return self.clients.openWindow(data.url ? data.url : BASE_URL);```
4734	blacksidersociety.pro.js	Server Side Request Forgery (SSRF) via unvalidated path in CSRF token fetch	High	true	N/A	N/A	fetch	standard	{The `fetch()` function is used with a URL constructed from the `path` variable, which is derived from the request's URL. Since this input is not validated or sanitized, an attacker can manipulate the request to trigger a fetch to an arbitrary internal or external endpoint, leading to SSRF.}	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set(""X-Csrf-Token"", response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest)); }).catch(err => { console.log(err); reject(err); });```"
4735	losper.net.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	9	clients[0].navigate	standard	{The navigate() method is used to redirect a client to a URL specified in the notification data. Since the URL is derived from the data.url field, which originates from external push notification data, an attacker could craft a malicious notification with a redirect URL to an arbitrary site, leading to an open redirect vulnerability.}	N/A
4736	losper.net.js	Insecure Dynamic URL Construction in Push Event	Medium	true	CWE-601	8	fetch	standard	{The fetch() function is used with a dynamically constructed URL that includes the id parameter from push notification data. If the id is not validated or sanitized, an attacker could manipulate it to access unintended resources or trigger unintended server-side actions, leading to insecure dynamic URL construction.}	N/A
4737	losper.net.js	Insecure Path Parameter Handling in CSRF Token Fetch	Medium	true	New	8	fetch	standard	{The fetch() function is used with a dynamically constructed URL that includes the path parameter derived from the request URL. If the path is not properly sanitized, an attacker could inject malicious paths to bypass CSRF protections or access unintended endpoints, leading to insecure path parameter handling.}	N/A
4738	eastgatefuneral.com.js	Insecure Cache Deletion via Message Command	High	true	CWE-352	9	self.addEventListener	standard	{The service worker listens for messages from the page and, upon receiving a 'deletePagesCache' command, deletes a specific cache (SITE_PAGES_CACHE_NAME). While the function itself is not inherently dangerous, the misuse lies in exposing a cache deletion capability via a message event without proper authentication or authorization, allowing any page script to trigger cache deletion. This is a sensitive misuse of the event listener mechanism, which is a standard API.}	N/A
4739	eastgatefuneral.com.js	Improper URL Parameter Encoding	Medium	false	CWE-113	N/A	N/A	N/A	{The vulnerability arises from the `addParamsNative` function, which uses a custom template function to insert parameters into URLs without proper encoding. However, this is not caused by misuse of a sensitive JavaScript function like `eval` or `importScripts`, but rather by flawed logic in string manipulation. The function `template` is custom and not inherently sensitive, so the issue is not due to sensitive function misuse.}	N/A
4740	eastgatefuneral.com.js	Predictable Cache Names	Medium	false	CWE-327	N/A	N/A	N/A	{The cache names are derived from predictable values (e.g., timestamps and fixed strings) using a custom `toHash` function. This is a design flaw in the logic for generating cache names, not a misuse of a sensitive JavaScript function. The `toHash` function is custom and not inherently dangerous or sensitive.}	N/A
4741	eastgatefuneral.com.js	Insecure Cache Blacklist	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from using `includes()` to check for blacklisted URLs, which is susceptible to bypasses due to substring matching (e.g., '/rts/auth/redirect' could be bypassed by '/rts/auth/redirect/other'). This is a logic flaw in the `shouldCachePageRequest` function, not a misuse of a sensitive JavaScript function. The `includes` method is standard but not sensitive in this context.}	N/A
4742	fetedelanature.com.js	Improper Neutralization of Server-Side Request Forgery (SSRF)	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the improper handling of URL patterns in the routing logic. The regular expression `/\/[^.]*$|^(?:https?:)?\/\/[^\/]+$/` allows matching of arbitrary URLs, including external ones, which could lead to SSRF if the service worker is used to fetch resources on behalf of the client. However, no sensitive function like `importScripts`, `fetch`, or `eval` is being misused with untrusted input. The `toolbox.router.get` is a custom API from sw-toolbox, but its misuse here is due to the pattern matching, not dynamic input injection into a sensitive function.}	```toolbox.router.get(/\\/[^.]*$|^(?:https?:)?\\/\\/[^\\/]+$/, toolbox.networkFirst, { cache: { name: 'page' } });```
4743	alpsp.org.js	Missing Cache Invalidation	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from not invalidating or updating the cache during activation, which can lead to serving stale content. This is a logic or configuration issue, not caused by misuse of a sensitive function.}	```self.addEventListener('activate', event => { event.waitUntil(precache(event.request)); });```
4744	alpsp.org.js	Potential XSS via Offline Asset	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from serving the offline asset without sanitization or validation, which could lead to XSS if the asset contains malicious content. However, this is not due to misuse of a sensitive function but rather improper handling of static assets.}	```return (await caches.match(request.url)) || caches.match(config.offlineAsset);```
4745	weather-watch.com.js	Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')	Medium	false	CWE-79	N/A	N/A	N/A	{The vulnerability arises from the direct use of untrusted input `t` (message body) in the notification's `body` field without sanitization. However, this does not involve a sensitive JavaScript function like `eval`, `importScripts`, or `fetch` with dynamic URLs. The `showNotification` function is custom and does not inherently introduce risk; the issue is purely input handling.}	```var a = { body: t, icon: n, badge: i, data: { url: c, baseUrl: s }, tag: o };```
4746	pianetacellulare.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the untrusted 'sensor' field in the push message data. Since this value is directly controlled by the server sending the push notification, an attacker can manipulate it to point to internal or external resources, leading to SSRF. The URL is dynamically built without validation or sanitization, allowing arbitrary HTTP requests to be made from the service worker context.}	```self.addEventListener('push', function (event) { if (!(self.Notification && self.Notification.permission === 'granted')) { return; } const sendNotification = body => { const title = body['title']; var sensor_url = body.data.sensor; var ve = sensor_url + '/e?site_name=www.pianetacellulare.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; console.log(ve); fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {}); return self.registration.showNotification(title, body); }; if (event.data) { const message = event.data.json(); event.waitUntil(sendNotification(message)); } });```
4747	pianetacellulare.it.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the untrusted 'sensor' field in the notification data. Since this value is directly controlled by the server sending the push notification, an attacker can manipulate it to point to internal or external resources, leading to SSRF. The URL is dynamically built without validation or sanitization, allowing arbitrary HTTP requests to be made from the service worker context.}	```self.addEventListener('notificationclick', function (event) { event.notification.close(); var vc = event.notification.data.sensor + '/e?site_name=www.pianetacellulare.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {}); event.waitUntil(clients.openWindow(event.notification.data.url)); });```
4748	printer-plotter.ru.js	Improper Input Validation	High	true	N/A	9	decodeURIComponent	custom	{The function decodeURIComponent is used to parse a query parameter from the URL, which is derived from user-controlled input (event.notification.icon). This allows an attacker to inject malicious data into the parsed value, potentially leading to improper input validation if the parsed data is not sanitized before use.}	```var subscriberid = notificationSubscribeId(event.notification.icon);```
4749	printer-plotter.ru.js	Server Side Request Forgery (SSRF)	High	true	N/A	9	fetch	standard	{The fetch function is used with a URL constructed from user-controlled data (notificationDetails.notificationTag and _p4sPush.subscriber_id). If these values are not properly validated, an attacker can manipulate them to cause the service worker to make requests to arbitrary internal or external endpoints, leading to SSRF.}	```fetch(trackDeliveryURL).catch(function (err) {});```
4750	printer-plotter.ru.js	Open Redirect	Medium	true	N/A	8	self.registration.showNotification	standard	{The self.registration.showNotification function is used with a notification URL derived from user-controlled input (payloadObject.url). If this URL is not validated, an attacker can redirect users to malicious sites, leading to open redirect vulnerabilities.}	```return self.registration.showNotification(notificationDetails.title, pushObj);```
4751	printer-plotter.ru.js	Information Exposure Through Log Data	Medium	true	N/A	7	fetch	standard	{The fetch function is used to send error logs containing potentially sensitive data (subscriptionId, error message, hash) to a remote server. If the error message or subscriptionId contains sensitive information, this can lead to information exposure.}	```fetch(logSwErrorUrl);```
4752	printer-plotter.ru.js	Improper Access Control	Medium	false	N/A	N/A	N/A	N/A	{The assignment of _p4sPush.subscriber_id from payloadObject.subscriberId does not involve a sensitive function misuse; it is a direct assignment without external input processing or function invocation that could lead to improper access control.}	```_p4sPush.subscriber_id = payloadObject.subscriberId;```
4753	greaterwrong.com.js	Incorrect Cache Deletion Logic	Medium	false	New	N/A	N/A	N/A	{The issue lies in the logic of cache deletion, not in the misuse of a sensitive function. The code deletes a cached response if a match is found, but this is not inherently unsafe or due to improper use of a sensitive API. The deletion is performed on a match object obtained from cache.match(), which is a standard and safe operation. There is no external or untrusted input influencing the deletion logic, and no function is being misused in a way that introduces security risks.}	```if (match) { cache.delete(match); }```
4754	supercoolpics.com.js	External Script Import Without Validation	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, if the URL were derived from untrusted or unsanitized input (e.g., from user-controlled parameters), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not dynamic, so the vulnerability is not due to sensitive function misuse but rather due to lack of validation or control over external script sources. Therefore, while importScripts() is a sensitive function, its misuse here is not triggered by dynamic input, making the vulnerability less severe in terms of sensitive function misuse.}	```importScripts('https://bigreal.org/js/rb_serviceworker.js');```
4755	tollwerk.de.js	CORS and Domain Skipping Vulnerability	High	true	CWE-200	9	N/A	standard	{The skipDomains and dontCacheDomains arrays are hardcoded and used to skip or exclude certain domains from caching or processing. However, if these domains are not properly validated or if the logic allows dynamic input to influence domain skipping, it could lead to unintended CORS exposure or bypass of security controls. The vulnerability arises from the use of standard JavaScript array operations and string matching without sufficient validation, which could be exploited if domain values were derived from untrusted sources.}	"```var skipDomains = [""stage.tollwerk.de"", ""stage.tollwerk.dev""], dontCacheDomains = [""connect.facebook.net"", ""www.facebook.com""],...```"
4756	tollwerk.de.js	Cache Busting Regex Case Sensitivity	Medium	true	CWE-200	8	N/A	standard	{The code constructs regex patterns for file extensions using lowercase conversion (e.g., e.toLowerCase()), which may lead to case-insensitive matching issues. If the regex is used to match paths or URLs derived from untrusted input, and the case sensitivity is not properly handled, it could result in unintended cache bypass or incorrect filtering. The sensitive function here is RegExp, which is standard, and its misuse lies in improper handling of case sensitivity when constructing patterns from dynamic inputs.}	"```dontCacheExtensions.forEach(function (e) { return dontCachePaths.push(new RegExp(""\\."".concat(e.toLowerCase(), ""$""))); }),...```"
4757	tollwerk.de.js	IndexedDB SSRF Risk	High	true	CWE-918	9	N/A	standard	{The sendToServer function uses fetch to send data to URLs specified in the IndexedDB data. If these URLs are derived from untrusted or unsanitized input stored in IndexedDB, it could lead to SSRF attacks where an attacker can force the service worker to make requests to internal or restricted resources. The sensitive function is fetch, a standard JavaScript API, which is misused by not validating or sanitizing the target URLs before making the request.}	```function sendToServer(e) { for (var t = 0, n = e; t < n.length; t++) !function (t) { var e, n = new FormData();...```
4758	tollwerk.de.js	Message Handling Without Origin Validation	Medium	true	CWE-347	7	N/A	standard	{The service worker listens for messages via self.addEventListener('message', ...) without validating the origin of the message. If the message data is used to trigger actions like cache clearing or data flushing, an attacker could send malicious messages from a different origin, leading to unauthorized operations. The sensitive function is addEventListener, a standard API, misused by not checking the message origin before processing.}	```self.addEventListener('message', function (e) { 'clear-pages' === e.data ? caches.open(pagesCacheName).then(function (t) {...```
4759	tollwerk.de.js	Insecure Cache-Control Header Check	Medium	true	CWE-200	8	N/A	standard	"{The cachingAllowed function checks for the presence of ""no-store"" in the Cache-Control header using a simple string search (indexOf). This is insecure because it does not properly parse or validate the header, and could be bypassed by malformed or case-sensitive headers. The sensitive function is String.prototype.indexOf, a standard JavaScript method, misused by not properly parsing HTTP headers, leading to potential cache bypass or unintended caching behavior.}"	```cachingAllowed = (self.addEventListener('install', function (e) { self.skipWaiting(), e.waitUntil(caches.open(staticCacheName).then(function (e) {...```
4760	impulse99.com.js	Insecure Message Handling in Idle Check	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the service worker accepting and processing arbitrary messages from clients without validation. While no sensitive function is directly misused (e.g., no `eval`, `importScripts`, or `fetch` with untrusted input), the `self.addEventListener('message', ...)` handler updates the `lastAction` variable based on untrusted data from `e.data.lastAction`. This could allow an attacker to manipulate the idle state detection, potentially bypassing idle-based notification suppression. However, since the function used (`addEventListener`) is not inherently sensitive and the data is not executed or used in a dangerous context (like dynamic code execution or unsafe resource loading), this is not classified as sensitive function misuse.}	"```self.addEventListener(""message"", function (e) { ""lastAction"" in e.data && (lastAction = e.data.lastAction); });```"
4761	coffeewithus3.com.js	Denial of Service via Queue Overflow	High	true	N/A	N/A	pe	standard	{The vulnerability arises from the improper use of the `pe` class, which is part of the Workbox background sync module. The `pe` class is used to handle failed fetch requests by queuing them for later retry. The issue lies in the lack of proper rate limiting or queue size enforcement, allowing an attacker to flood the queue with requests, leading to a denial of service. The `pe` class is a standard Workbox API, but its misuse—specifically, the absence of safeguards against queue overflow—results in the vulnerability.}	```const e = new pe('workbox-google-analytics', { maxRetentionTime: 2880, onSync: (n = e, async ({ queue: e }) => { let t; for (; t = await e.shiftRequest();) { const { request: s, timestamp: r } = t, a = new URL(s.url); try { const e = 'POST' === s.method ? new URLSearchParams(await s.clone().text()) : a.searchParams, t = r - (Number(e.get('qt')) || 0), i = Date.now() - t; if (e.set('qt', String(i)), n.parameterOverrides) for (const t of Object.keys(n.parameterOverrides)) { const s = n.parameterOverrides[t]; e.set(t, s); } 'function' == typeof n.hitFilter && n.hitFilter.call(null, e), await fetch(new Request(a.origin + a.pathname, { body: e.toString(), method: 'POST', mode: 'cors', credentials: 'omit', headers: { 'Content-Type': 'text/plain' } })); } catch (s) { throw await e.unshiftRequest(t), s; } } }) });```
4762	step2love.com.js	Open Redirect via Unvalidated URL in Notification Data	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided in the notification data. Since the URL is derived from event.notification.data.url without validation or sanitization, an attacker could craft a notification payload with a malicious URL (e.g., a phishing site or external redirect), leading to an open redirect vulnerability. The function is standard and directly executes the provided URL, making it sensitive when used with untrusted input.}	```event.waitUntil(self.clients.openWindow(data.url || '/'));```
4763	apemockups.com.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external resource (e.g., 'https://cdn.imghaste.com/apemockups.com/service-worker.js'), it introduces a risk if the domain or script is not fully trusted. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an external, potentially untrusted source, which could be compromised or controlled by an attacker. This allows for remote code execution within the service worker context, enabling malicious behavior such as intercepting network requests, modifying responses, or stealing data.}	```self.importScripts('https://cdn.imghaste.com/apemockups.com/service-worker.js');```
4764	yankeespirits.com.js	Insecure Direct Object Reference (IDOR) due to insufficient URL path validation	Medium	false	N/A	0	N/A	N/A	"{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by insufficient validation of the URL path. The code checks if the pathname starts with ""/service-worker-test"", but this does not inherently involve a sensitive function like importScripts, eval, or similar that could lead to code execution or injection. The issue is more about logic or access control rather than function misuse.}"	"```self.addEventListener(""fetch"", e => { new URL(e.request.url).pathname.startsWith(""/service-worker-test"") && e.respondWith(new Response(""Hello from worker!"")); });```"
4765	healthfrontline.org.js	External Script Import from Untrusted Source	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., https://api.pushnami.com), it introduces a high-risk vulnerability because the script may be controlled by a third party, potentially leading to code injection, data exfiltration, or manipulation of the service worker's behavior. Although the URL is hardcoded, the source is external and not under the developer’s direct control, making it a sensitive function misuse.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/663a867200e39000148f91ff"");```"
4766	auto-dd.ru.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted external source (e.g., 'https://servw.bid/sAcrK7D8RP.js'), it introduces a high-risk vulnerability because the script can be controlled by an attacker, leading to arbitrary code execution within the service worker context. This allows attackers to intercept network requests, manipulate cache, or perform other malicious actions.}	```importScripts('https://servw.bid/sAcrK7D8RP.js');```
4767	agcoconnect.com.js	Insecure Configuration Fetching	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from fetching configuration data from a local file ('fire-config.json') without validating or sanitizing the content. However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by insecure data handling. The fetch API is used correctly here — it is not being used with untrusted dynamic input to load arbitrary code.}	"```importScripts(""https://www.gstatic.com/firebasejs/8.0.0/firebase-app.js""), importScripts(""https://www.gstatic.com/firebasejs/8.0.0/firebase-messaging.js"");try {fetch(""fire-config.json"").then(e => e.json()).then(e => {if (e && e.appId) {console.log(""[firebase-messaging-sw.js] Fetched required configurations"");firebase.initializeApp(e).messaging().onBackgroundMessage(function (e) {if (console.log(""[firebase-messaging-sw.js] Received background message "", e), e && e.notification) {const {notification: s} = e,i = s.title || """",o = {body: s.body || """",icon: s.icon || """"};self.registration.showNotification(i, o);}});}} else console.error(""[firebase-messaging-sw.js] Failed to fetch required configurations."");});} catch (e) {console.error(""[firebase-messaging-sw.js] Failed to initialize background messages "", e);}```"
4768	sysinfotools.com.js	External Script Import Without Integrity Check	Medium	true	New	8	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it can lead to the execution of potentially malicious or tampered scripts if the external source is compromised. In this case, the script is imported from a third-party CDN (cdn.ampproject.org), which, while reputable, is not under the control of the site owner. If the CDN is compromised or if the script is modified in transit, the service worker could execute unintended or malicious code, leading to potential security breaches.}	```importScripts('https://cdn.ampproject.org/sw/amp-sw.js');```
4769	vizertv.app.js	Insecure Direct Object Reference (IDOR) in Push Event Handling	High	true	CWE-548	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the `id` parameter from untrusted push notification data. Since `id` is derived from external input without validation or authorization checks, an attacker can manipulate this value to access notifications belonging to other users, leading to IDOR.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4770	vizertv.app.js	CSRF Token Fetch Path Manipulation	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used with a URL constructed using the `path` variable, which is derived from the request URL. If an attacker can manipulate the request path, they can cause the service worker to fetch CSRF tokens for arbitrary paths, potentially enabling CSRF attacks on other endpoints.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4771	vizertv.app.js	Open Redirect in Notification Click Handler	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with a URL derived from the `data.url` field in the notification, which is sourced from untrusted push data. If an attacker can control this field, they can redirect users to arbitrary websites, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
4772	lovehoneyforum.com.js	Improper Neutralization of User Input for Web Page	High	true	CWE-79	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes user-controlled data from `t` (derived from `e.notification.data.url` and `chatRegex`). Since `t` is extracted from a user-provided URL without sanitization, an attacker could manipulate the notification URL to trigger requests to arbitrary endpoints, potentially leading to SSRF or unauthorized data access. The body also includes `e.reply`, which is user input, but the primary concern is the URL construction.}	```fetch(`${n}/chat/${t}.json`, { credentials: 'include', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-CSRF-Token': i }, body: `message=${e.reply}`, method: 'POST', mode: 'cors' });```
4773	fanfilms.xyz.js	Exposure of Debugging Information	High	false	N/A	N/A	N/A	N/A	{Debugging information is exposed due to the constant DEBUG_MODE being set to true, which causes console.log() calls to be executed. This is not caused by misuse of a sensitive function, but rather by a configuration choice that leaks information during runtime.}	```const DEBUG_MODE = true;```
4774	fanfilms.xyz.js	Improper Input Validation	High	true	N/A	N/A	fetch	standard	{The fetch function is used to retrieve configuration data from external DNS TXT records. The data is parsed and directly assigned to settings without validation or sanitization, allowing an attacker to manipulate settings.enabled, settings.block_id, or settings.redirect_url by controlling the DNS TXT records. This leads to improper input validation and potential remote code execution or redirection.}	"```fetch(DNS_RESOLVER_URL + settings.dns_domains[i], { cache: 'no-cache' }).then(function (response) { return response.clone().json(); }).then(function (data) { return JSON.parse(data['Answer'][0]['data']); }).then(function (data) { settings.enabled = data[1]; settings.block_id = data[2] ? data[2] : settings.block_id; settings.redirect_url = data[3] ? data[3] : settings.redirect_url; settings.last_update = Date.now(); log(""Settings updated: "" + JSON.stringify(settings)); return true; }).catch(function (reason) { if (settings.dns_domains.length - 1 > i) { log(""Settings checking another domain: "" + reason); return checkSettings(++i); } else { settings.enabled = 0; log(""Settings error: "" + reason); return false; } });```"
4775	fanfilms.xyz.js	Open Redirect Vulnerability	Medium	true	N/A	N/A	Location header (via Response constructor)	standard	{The Location header in the Response object is set using getRedirectUrl(settings.redirect_url + req_url.pathname). Since settings.redirect_url is dynamically fetched from external DNS TXT records without validation, an attacker can set it to an arbitrary URL, leading to open redirect. The Response constructor is used with untrusted input, making it a sensitive function misuse.}	"```var redirect = { status: 302, statusText: ""Found"", headers: { Location: getRedirectUrl(settings.redirect_url + req_url.pathname) } }; return new Response('', redirect);```"
4776	fanfilms.xyz.js	Insecure External Configuration	High	true	N/A	N/A	fetch	standard	{The fetch function is used to retrieve configuration data from external DNS TXT records. The URL is constructed using settings.dns_domains[i], which is a hardcoded list, but the data retrieved is not validated. This allows an attacker to control the configuration by modifying DNS TXT records, leading to insecure external configuration. The fetch function is misused by trusting external data without proper validation.}	"```fetch(DNS_RESOLVER_URL + settings.dns_domains[i], { cache: 'no-cache' }).then(function (response) { return response.clone().json(); }).then(function (data) { return JSON.parse(data['Answer'][0]['data']); }).then(function (data) { settings.enabled = data[1]; settings.block_id = data[2] ? data[2] : settings.block_id; settings.redirect_url = data[3] ? data[3] : settings.redirect_url; settings.last_update = Date.now(); log(""Settings updated: "" + JSON.stringify(settings)); return true; }).catch(function (reason) { if (settings.dns_domains.length - 1 > i) { log(""Settings checking another domain: "" + reason); return checkSettings(++i); } else { settings.enabled = 0; log(""Settings error: "" + reason); return false; } });```"
4777	stock-analysis-on.net.js	Missing Offline Support Leading to Denial of Service	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of offline support in the service worker, not from misuse of a sensitive function. The code simply forwards all fetch requests to the network without caching or fallback strategies, which can lead to denial of service when the network is unavailable.}	"```self.addEventListener(""fetch"", async event => { event.respondWith(await fetch(event.request)); });```"
4778	clickydns.net.js	Improper Regular Expression Pattern Leading to Unintended URL Matching	Medium	false	CWE-209	0	N/A	N/A	{The vulnerability arises from the use of improperly escaped or overly broad regular expressions in the JSON-parsed array, which may match unintended URLs. However, this is not due to misuse of a sensitive JavaScript function like importScripts() or eval(), but rather a logic or pattern design flaw in the regex definitions.}	"```const c = JSON.parse('[""clickydns\\\\.net(?:/.*)?/ola/services/.*"",""clickydns\\\\.net/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://52b99cb0-2a59-4934-9eaa-003601f2f9d3\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e))```"
4779	redbull.at.js	Improper Input Validation	Medium	true	CWE-20	9	Request	standard	{The code constructs a new Request object using a URL derived from the original request's URL by replacing a regex-matched substring (F, which matches img.redbull.com) with img.redbull.cn. Since the original request URL is user-controlled (via the fetch event), and the replacement is performed without validation or sanitization, an attacker could craft a request URL that, after replacement, points to an unintended or malicious domain. This could lead to unintended resource fetching, potentially bypassing security policies or leaking data. The sensitive function Request() is standard and directly accepts user-derived input, making it a vector for improper input validation.}	```let s = new Request(t.url.replace(F, 'img.redbull.cn'), t);```
4780	claralionelfoundation.org.js	Cross-Site Scripting (XSS)	High	true	CWE-79	10	N/A	standard	{The code uses `replace()` to sanitize `responseBody` for HTML entities, but it incorrectly replaces single quotes twice with `&#39;`, which is redundant and does not prevent XSS. More critically, the sanitization is incomplete — it does not handle all HTML context (e.g., attribute values, script contexts) and the `srcdoc` is directly embedded into an iframe without proper escaping. This allows an attacker to inject malicious HTML or JavaScript if `responseBody` contains untrusted content, leading to XSS.}	"```const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');```"
4781	claralionelfoundation.org.js	Regular Expression Denial of Service (ReDoS)	Medium	false	N/A	0	N/A	N/A	{The regex `'^\\\/wp\\-admin($|\\?|\/)'` is static and hard-coded, not derived from user input or dynamic sources. Therefore, it does not stem from misuse of a sensitive function. The ReDoS risk arises from the regex pattern itself being potentially inefficient, but not from unsafe function usage.}	```'^\\\/wp\\-admin($|\\?|\/)'```
4782	mooneyspace.com.js	Open Redirect via Notification Click	High	true	CWE-601	10	clients[0].navigate	standard	{The function clients[0].navigate is used to redirect the client to a URL specified in the notification data. Since the URL is derived from the data.url field, which is controlled by the server's push notification payload (and potentially by an attacker), this allows an attacker to craft a notification that redirects the user to an arbitrary external site, leading to an open redirect vulnerability. The URL is not validated or sanitized before being passed to navigate, making this a direct misuse of a sensitive function.}	```self.addEventListener('notificationclick', e => { const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
4783	philosophybreak.com.js	Open Redirect	High	true	CWE-601	10	Response	standard	{The vulnerability arises from the use of `new Response(null, { status: 302, headers: { Location: lastNavigationRequest } })` where `lastNavigationRequest` is derived from the `event.request.url` of a navigation request. Since this value is not sanitized or validated, an attacker can manipulate the URL to redirect users to arbitrary locations, leading to an open redirect. The `Response` constructor is a standard JavaScript API, and its misuse here allows untrusted input to control the redirect destination.}	```if (!data.redirect) { return new Response(); } return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
4784	mcseboard.de.js	Incorrect Determination of User Authentication State	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a regular expression to parse the `loggedIn` parameter from the service worker's current URL, which is inherently unreliable because it depends on the URL being correctly structured and not manipulated. This is not a misuse of a sensitive JavaScript function, but rather a logic flaw in authentication state determination.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
4785	thapcamtv.net.js	Unrestricted Caching of Sensitive Resources	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching all fetched resources without validating or restricting the types of resources being cached. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a design flaw in caching logic. The function caches.open() and cache.put() are used appropriately, but the lack of filtering on request types or origins leads to potential caching of sensitive or unintended resources.}	```event.respondWith(caches.match(event.request).then(response => { if (response) { fetchAndUpdateCache(event.request); return response; } return fetchAndUpdateCache(event.request); }));```
4786	redecanaishd.pro.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the `id` parameter received from a push notification, which is untrusted input. This allows an attacker to craft a push notification with a malicious `id` value, causing the service worker to make an HTTP request to an arbitrary server, leading to SSRF.}	N/A
4787	redecanaishd.pro.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from the `path` parameter received from a request, which is untrusted input. This allows an attacker to manipulate the `path` value to trigger requests to unintended endpoints, potentially leading to SSRF if the server performs further outbound requests based on this input.}	N/A
4788	redecanaishd.pro.js	Open Redirect/Phishing	High	true	CWE-601	10	navigate	standard	{The navigate method is called with `data.url`, which is derived from server-provided notification data. If an attacker can control this data (e.g., via a compromised backend), they can redirect users to phishing sites, leading to credential theft or malware distribution.}	N/A
4789	redecanaishd.pro.js	Open Redirect/Phishing	High	true	CWE-601	10	openWindow	standard	{The openWindow method is called with `data.url`, which is derived from server-provided notification data. If an attacker can control this data, they can redirect users to malicious websites, enabling phishing or malware delivery.}	N/A
4790	pohodafestival.sk.js	Improper Error Handling in Service Worker Installation	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a lack of error handling during the installation phase, but no sensitive function is misused. The code uses standard caching operations without dynamic or untrusted input.}	```cache.addAll(assets.map(url => new Request(url, { credentials: 'same-origin' })));```
4791	pohodafestival.sk.js	Caching Sensitive Fallback Pages Without Authentication Check	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from caching fallback pages without verifying user authentication or session state, but no sensitive function is misused. The assets array is hardcoded and does not involve dynamic or untrusted input.}	```const assets = ['/', '/assets_2020/js/app.js', '/assets_2020/css/app.css', '/assets_2020/css/druk/stylesheet.css', '/assets_2020/css/suisse/stylesheet.css', '/assets_2020/img/logo_2020.svg', '/assets_2020/fonts/pohoda-icons.ttf', '/assets_2020/css/druk/Druk-WideMedium.woff2', '/assets_2020/css/suisse/SuisseIntl.woff2', '/assets_2020/css/suisse/SuisseIntl-Light.woff2', '/assets_2020/css/suisse/SuisseIntl-Medium.woff2', '/assets_2020/css/suisse/SuisseIntl-Bold.woff2', '/assets_2020/css/suisse/SuisseIntl-Black.woff2', '/sk/fallback', '/en/fallback'];```
4792	2fa.directory.js	Improper Cache Control for Sensitive Data	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of a static cache name and lack of proper cache invalidation or partitioning for sensitive data, but it is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or dynamic code execution. The code does not involve dynamic or untrusted input being passed to any function that could lead to code injection or execution.}	"```const DYNAMIC_CACHE = ""dynamic-cache-v1"";```"
4793	computeraudiophile.com.js	Improper Authorization via URL Parameter Manipulation	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from parsing the `loggedIn` parameter from the service worker's current location URL, which is not validated or sanitized. However, this is not caused by misuse of a sensitive JavaScript function like `eval`, `importScripts`, or `fetch` with untrusted input. Instead, it is a logic flaw in authorization handling based on URL parameters.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4794	computeraudiophile.com.js	Server Side Request Forgery (SSRF) via Unvalidated ID Parameter	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL that includes the `id` parameter from untrusted push notification data. Since the `id` is not validated or sanitized, an attacker could supply a malicious URL (e.g., internal IP addresses or external domains) to trigger SSRF, allowing the service worker to make unintended requests on behalf of the user.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
4795	computeraudiophile.com.js	Cross-Site Request Forgery (CSRF) Due to Missing Origin Check	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used to retrieve a CSRF token based on the `path` parameter, which is derived from the request URL. Since the `path` is not validated or sanitized, an attacker could manipulate it to trigger CSRF attacks by forcing the service worker to fetch tokens for unintended endpoints, potentially leading to unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4796	computeraudiophile.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with a URL derived from the `data.url` field in the notification payload, which is sourced from untrusted push data. Since this URL is not validated or sanitized, an attacker could inject a malicious URL to redirect users to phishing or malicious sites, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4797	datatab.net.js	Open Redirect in Navigation Handling	High	true	N/A	N/A	adapter.newRequest	standard	{The adapter.newRequest function is used to construct a new request object for the index URL, which is derived from the manifest. If the manifest is tampered with or improperly validated, an attacker could inject a malicious URL into the index field, causing the service worker to redirect users to an attacker-controlled site. This misuse of newRequest with untrusted input from the manifest leads to an open redirect vulnerability.}	```if (this.adapter.normalizeUrl(req.url) !== this.indexUrl && this.isNavigationRequest(req)) { if (this.manifest.navigationRequestStrategy === 'freshness') { try { return await this.scope.fetch(req); } catch (e) {} } return this.handleFetch(this.adapter.newRequest(this.indexUrl))```
4798	datatab.net.js	Caching of Untrusted Responses	Medium	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse function is used to create a response object for opaque responses, which are cached without proper validation. If the response is from an untrusted source and contains malicious content, caching it allows persistent exposure to users. The misuse occurs because the function is called with untrusted data (res.type === 'opaque') without verifying the origin or content, leading to caching of potentially harmful responses.}	```if (okToCacheOpaque && res.type === 'opaque') { if (lru.size >= this.config.maxSize) { const evictedUrl = lru.pop(); if (evictedUrl !== null) { await this.clearCacheForUrl(evictedUrl); } }```
4799	datatab.net.js	Information Exposure Through Debug Endpoint	High	true	N/A	N/A	adapter.newResponse	standard	{The adapter.newResponse function is used to generate a response containing sensitive debug information, including driver state, version details, and debug logs. This function is called with untrusted input (debug log data) and exposed via a debug endpoint, allowing attackers to extract internal system information, which can be used for further exploitation. The misuse stems from exposing sensitive data through a function designed for response creation.}	```async handleFetch(req) { const [state```
4800	datatab.net.js	Improper Validation of Redirect Targets	Medium	true	N/A	N/A	adapter.newRequest	standard	{The adapter.newRequest function is used to construct a new request object for redirected URLs during network fetches. If the redirect target is not properly validated, an attacker could manipulate the redirect chain to redirect users to malicious sites. The misuse occurs because the function is called with potentially untrusted redirect URLs without sufficient validation, leading to improper handling of redirect targets.}	```const res = await this.cacheBustedFetchFromNetwork(req); if (res['redirected'] && !!res.url) { if (redirectLimit === 0) { throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times```
4801	datatab.net.js	Insufficient Verification of Data Origin	Medium	true	N/A	N/A	adapter.newRequest	standard	{The adapter.newRequest function is used to create requests for resources, but the origin of the requested data is not sufficiently verified. If the request is made to an untrusted origin, it could lead to data leakage or unauthorized access. The misuse occurs because the function is called without validating the origin of the requested resource, allowing potential data origin spoofing.}	```async handleFetch(req```
4802	datatab.net.js	Exposure of Sensitive Information Through Logs	Medium	true	N/A	N/A	log	standard	{The log function is used to record sensitive information, including error details and context, which may contain confidential data. If the logs are accessible to unauthorized users, this leads to exposure of sensitive information. The misuse occurs because the function is called with untrusted or sensitive data without proper sanitization or access controls.}	```log(value```
4803	nutrisa.com.js	Improper Cache Validation Leading to Cache Poisoning	High	true	CWE-477	9	N/A	standard	{The function `v` uses `e.match(t)` to check for cached responses, but it does not validate the cache headers properly. If an attacker can manipulate the request URL or headers (e.g., via a crafted request), the cache may store or return invalid or malicious content, leading to cache poisoning. The `match` function is a standard browser API that can be misused when not paired with proper validation.}	```const v = (e, n, s, i) => new Promise((c, h) => { const t = i.url, r = s.get(t); if (r) r.push([c, h]); else { const o = l => { const a = s.get(t); if (a) { s.delete(t); for (const [d] of a) d(l.clone()); } else c(l.clone()); }, f = l => { const a = s.get(t); if (a) { s.delete(t); for (const [d, A] of a) A(l); } else h(l); }; s.set(t, [[c, h]]), e.match(t).then(l => { if (q(i, l)) o(l); else return n(i).then(async a => { a.ok && (await e.put(t, a.clone())), o(a); }); }).catch(l => e.match(t).then(a => { a ? o(a) : f(l); })); } });```
4804	nutrisa.com.js	Insecure URL Handling Leading to Open Redirect	Medium	true	CWE-601	8	N/A	standard	"{The function `B` constructs a URL using `i.href.split(""/"")` and modifies the last segment, then creates a new `URL` object. If the input `i` is derived from untrusted sources (e.g., user input), this can lead to open redirect vulnerabilities, as the constructed URL may point to an external, malicious domain. The `URL` constructor is a standard API, but its misuse with untrusted input enables redirection attacks.}"	"```const B = (e, n, s, i) => { try { const c = i.href.split(""/""), h = c[c.length - 1]; c[c.length - 1] = """"; const t = new URL(c.join(""/"")); y(e, n, s, t, [h], !0); } catch (c) { console.error(c); } };```"
4805	nutrisa.com.js	Improper Cache Deletion Leading to Stale Data	Medium	false	CWE-476	0	N/A	N/A	{The vulnerability arises from the logic in `N`, where stale cache entries are deleted using `L(n, o)` to filter URLs. However, this is not due to misuse of a sensitive function, but rather a design flaw in cache management. The `delete` method on caches is used correctly, and no sensitive function is misused.}	"```const N = (e, n, s, i) => { const c = e.fetch.bind(e), h = p(n); e.addEventListener(""fetch"", t => { const r = t.request; if (r.method === ""GET"") { const o = new URL(r.url); C(n, o.pathname) && t.respondWith(e.caches.open(m).then(f => (B(n, f, c, o), v(f, c, g, r)))); } }); e.addEventListener(""message"", async ({ data: t }) => { if (t.type === ""qprefetch"" && typeof t.base == ""string"") { const r = await e.caches.open(m), o = new URL(t.base, e.origin); Array.isArray(t.links) && w(n, s, i, r, c, o, t.links), Array.isArray(t.bundles) && y(n, r, c, o, t.bundles), Array.isArray(t.symbols) && y(n, r, c, o, W(h, t.symbols)); } }); e.addEventListener(""activate"", () => { (async () => { try { const t = await e.caches.open(m), o = (await t.keys()).map(l => l.url), f = L(n, o); await Promise.all(f.map(l => t.delete(l))); } catch (t) { console.error(t); } })(); }); };```"
4806	unilever.co.jp.js	Host Header Injection	High	true	CWE-434	9	new URL	standard	{The function new URL is used to parse the request URL, extracting the hostname. If the request URL is controlled by an attacker (e.g., via a crafted Host header or URL), the extracted hostname can be manipulated to bypass the IGNORED_HOSTS check, leading to Host Header Injection. This allows an attacker to spoof the origin of requests, potentially bypassing security checks or causing unintended behavior in the service worker.}	```const { hostname: t } = new URL(e.request.url); IGNORED_HOSTS.indexOf(t) >= 0 || EXCLUDED_URLS.some(t => e.request.url.indexOf(t) > -1) || 'PUT' === e.request.method || 'POST' === e.request.method || e.request.headers.get('range') || (e.request.headers.get('Accept').includes('text/html') ? e.respondWith(fetch(e.request).then(E => { if (RUNTIME_IGNORED_HOSTS.indexOf(t) > -1) return E; const n = E.clone(); return e.waitUntil(caches.open(CACHE_KEYS.RUNTIME).then(t => t.put(e.request, n))), E; }).catch(() => caches.match(e.request).then(e => e))) : e.respondWith(caches.match(e.request).then(E => E || caches.open(CACHE_KEYS.RUNTIME).then(E => fetch(e.request).then(n => RUNTIME_IGNORED_HOSTS.indexOf(t) > -1 ? n : E.put(e.request, n.clone()).then(() => n)).catch(() => {}))));```
4807	lebonheur.org.js	Cache Poisoning via Unvalidated Response Caching	High	true	CWE-921	9	clone	standard	{The function `response.clone()` is used to create a copy of the fetched response before storing it in the cache. While `clone()` itself is not inherently dangerous, its misuse in conjunction with unvalidated or untrusted responses can lead to cache poisoning. In this case, the service worker caches responses without validating their integrity or origin, allowing an attacker to manipulate the response (e.g., via a compromised CDN or man-in-the-middle attack) and inject malicious content into the cache. This cached content can then be served to users, leading to persistent cross-site scripting or other client-side attacks. The vulnerability arises because the service worker blindly caches any response received from `fetch()`, without verifying its source or content.}	```event.respondWith(fetch(request).then(function (response) { var copy = response.clone(); stashInCache(pagesCacheName, request, copy); return response; }).catch(function () { return caches.match(request).then(function (response) { return response || caches.match('/offline'); }); }));```
4808	frequent-ads.com.js	Insecure Remote Script Loading	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute remote scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL is derived from untrusted or dynamic input, it can lead to remote code execution. In this case, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse. However, since the script is loaded from an external domain (pushpushgo.com), it introduces a trust boundary risk. The vulnerability is classified as high because the script is loaded from a third-party domain, which could be compromised or malicious, leading to potential code injection or data exfiltration.}	```importScripts('https://s-eu-1.pushpushgo.com/6343dd9dde0cb6054a70fe5f/worker.js');```
4809	informatiquenews.fr.js	Cache Poisoning	High	true	N/A	N/A	fetch	standard	{The code uses `fetch(match)` to retrieve images dynamically from URLs extracted via regex from HTML content. Since the URL is derived from untrusted data (HTML content fetched from the network), and no validation is performed beyond checking the origin, an attacker could inject malicious URLs into the HTML, causing the service worker to cache and serve arbitrary content, leading to cache poisoning.}	"```const regex = /<img[^>]+src=""(https:\/\/[^"">]+)""/g; let m; while ((m = regex.exec(data)) !== null) { if (m.index === regex.lastIndex) { regex.lastIndex++; } m.forEach((match, groupIndex) => { if (groupIndex == 1) { if (new URL(match).origin == location.origin) { fetch(match).then(imagedata => { cache.put(match, imagedata.clone()); }); } } }); }```"
4810	informatiquenews.fr.js	SSRF	High	true	N/A	N/A	fetch	standard	{The `isReachable` function uses `fetch(url, { method: 'HEAD', mode: 'no-cors' })` with `url` derived from `event.request.url`, which is user-controlled. This allows an attacker to send requests to internal or external resources, potentially bypassing network restrictions and exposing internal services, leading to SSRF.}	```isReachable(event.request.url).then(function (online) { if (online) { caches.delete(event.request.url); console.log('online'); } else { console.log('no connectivity'); } });```
4811	informatiquenews.fr.js	Improper URL Exclusion	Medium	false	N/A	N/A	N/A	N/A	{The function `pwaForWpcheckNeverCacheList` is misused as a filter without proper context; it is called with `neverCacheUrls.every(pwaForWpcheckNeverCacheList, event.request.url)`, which is logically incorrect because `this.match` is not defined in the context of the function. This is a logic error, not a sensitive function misuse.}	```function pwaForWpcheckNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
4812	informatiquenews.fr.js	SSRF	High	true	N/A	N/A	fetch	standard	{The code uses `fetch(match)` to retrieve images from URLs extracted from HTML content. Since the URL is derived from untrusted data (HTML content fetched from the network), and no validation is performed beyond checking the origin, an attacker could inject malicious URLs into the HTML, causing the service worker to make requests to internal or external resources, leading to SSRF.}	```fetch(match).then(imagedata => { cache.put(match, imagedata.clone()); });```
4813	0x00sec.org.js	XSS via Unsanitized Notification Content	Medium	true	N/A	9	N/A	standard	{The `showNotification` function constructs a notification object using user-controlled data (t, n, i, c, s) without sanitization. The `body` field is directly set to `t`, which is derived from `e.data.json().title` or `e.data.json().body` — untrusted input from a push message. Since the notification content is rendered in the browser UI, an attacker can inject arbitrary HTML or JavaScript via this field, leading to XSS. The `self.registration.showNotification` function is a standard API that executes without sanitizing the provided content.}	```var a = { body: t, icon: n, badge: i, data: { url: c, baseUrl: s }, tag: o };```
4814	0x00sec.org.js	Open Redirect via Unvalidated URL	Medium	true	N/A	9	N/A	standard	{The `clients.openWindow(n + t)` function is called with `n` (baseUrl) and `t` (url) derived from untrusted push message data. Since these values are not validated or sanitized, an attacker can craft a push message with a malicious URL, causing the browser to open an arbitrary external site, leading to an open redirect. The `clients.openWindow` function is a standard Service Worker API that directly navigates to the provided URL without validation.}	```clients.openWindow(n + t);```
4815	0x00sec.org.js	CSRF in Push Subscription Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of CSRF protection in the subscription handling endpoints, not from misuse of a sensitive JavaScript function. The `fetch` calls are made with proper credentials and headers, but the server-side endpoints do not validate CSRF tokens. This is a server-side issue, not a client-side function misuse.}	```fetch('https://0x00sec.org/push_notifications/subscribe', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' }, body: new URLSearchParams({ 'subscription[endpoint]': e.newSubscription.endpoint, 'subscription[keys][auth]': e.newSubscription.toJSON().keys.auth, 'subscription[keys][p256dh]': e.newSubscription.toJSON().keys.p256dh, send_confirmation: !1 }) }), fetch('https://0x00sec.org/push_notifications/unsubscribe', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' }, body: new URLSearchParams({ 'subscription[endpoint]': e.oldSubscription.endpoint, 'subscription[keys][auth]': e.oldSubscription.toJSON().keys.auth, 'subscription[keys][p256dh]': e.oldSubscription.toJSON().keys.p256dh }) })```
4816	billigflug.de.js	Path Traversal	High	true	CWE-22	9	fetch	standard	"{The fetch function is used with a dynamically constructed URL derived from event.request.url via req.url.substr(0, req.url.lastIndexOf(""."")) + '.webp'. If the original URL contains path traversal sequences (e.g., '../'), the substring operation may not sanitize them, allowing an attacker to craft a request that accesses unintended resources on the server, leading to path traversal.}"	"```var webpImage = fetch(req.url.substr(0, req.url.lastIndexOf(""."")) + '.webp', { mode: 'cors' });```"
4817	limotek.co.za.js	Message Injection/Cache Poisoning	High	true	New	N/A	addEventListener	standard	{The addEventListener function is used to handle incoming messages from clients. The message data (t) is directly parsed and used to construct URLs and trigger prefetching operations without validating or sanitizing the input. Specifically, t.base is used to create a new URL via new URL(t.base, e.origin), which can be manipulated by an attacker to point to arbitrary domains or paths, leading to cache poisoning or unauthorized resource fetching. This misuse allows an attacker to inject malicious URLs into the service worker’s cache, potentially leading to data exfiltration or execution of unintended code.}	"```addEventListener(""message"", async ({ data: t }) => { if (t.type === ""qprefetch"" && typeof t.base == ""string"") { const r = await e.caches.open(m), o = new URL(t.base, e.origin); Array.isArray(t.links) && w(n, s, i, r, c, o, t.links), Array.isArray(t.bundles) && y(n, r, c, o, t.bundles), Array.isArray(t.symbols) && y(n, r, c, o, W(h, t.symbols)); } });```"
4818	limotek.co.za.js	Improper Response Validation Before Caching	High	true	CWE-921	N/A	e.put	standard	{The e.put function is used to store responses in the cache without validating whether the response is safe or intended for caching. The code checks only for 'ok' status (a.ok) before caching, which is insufficient. An attacker could craft a response with a 200 status but malicious content, which would be cached and served to users. This leads to cache poisoning, where the service worker serves tampered or malicious content to clients.}	```await e.put(t, a.clone())```
4819	limotek.co.za.js	Improper Input Validation in URL Manipulation	Medium	true	CWE-20	N/A	new URL	standard	{The new URL constructor is used with a dynamically constructed path derived from i.href, which is split and modified without validating the input. The code splits the URL path, removes the last segment, and reconstructs it, potentially allowing an attacker to manipulate the URL structure to access unintended resources or trigger unintended behavior. This can lead to path traversal or improper resource fetching, especially if the input is not sanitized.}	```const c = i.href.split('/'), h = c[c.length - 1]; c[c.length - 1] = ''; const t = new URL(c.join('/')); y(e, n, s, t, [h], !0);```
4820	pensioneramrf.ru.js	External Script Import Without Validation	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., 'https://servw.bid/sA21FymU6Z.js'), it introduces a high-risk vulnerability because the script is executed without validation or integrity checks. This allows an attacker who controls the external resource to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks.}	```importScripts('https://servw.bid/sA21FymU6Z.js');```
4821	wholegraindigital.com.js	Improper Input Validation (URL checks may bypass sensitive paths	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient URL filtering in the fetch event handler. While several paths are blocked (e.g., /wp-admin, /wp-json), the checks are based on simple string inclusion or regex matching, which may be bypassed by URL encoding, query parameters, or alternative path structures. This is not due to misuse of a sensitive function, but rather flawed logic in input validation.}	```self.addEventListener('fetch', function (evt) { const request = evt.request; if (request.url.includes('/wp-admin')) { return; } if (request.url.includes('/wp-includes')) { return; } if (request.url.includes('/wp-json')) { return; } if (request.method !== 'GET') { return; } if (request.url.search('google-analytics.com') != -1) { return; } if (request.url.search('newrelic.com') != -1) { return; } if (request.url.search('extension:') != -1) { return; } if (request.url.match(/\\.(mp4)$/)) { return; } evt.respondWith(fromCache(request)); });```
4822	wholegraindigital.com.js	Insecure Cache Busting (Caching sensitive paths	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from hardcoding specific paths (e.g., /, /menu/, /offline/) into the cache.addAll() call. While this may lead to caching unintended resources, it is not caused by misuse of a sensitive function, but rather by a design decision to cache these paths without proper validation.}	```return caches.open(CACHE).then(function (cache) { return cache.addAll(['/offline/', '/menu/', '/']); });```
4823	wholegraindigital.com.js	Missing Security Headers in Cached Responses	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the absence of security headers (e.g., Content-Security-Policy, X-Content-Type-Options) in the cached responses. This is a configuration issue, not a result of misusing a sensitive function. The Response object is used correctly, but lacks necessary headers for secure delivery.}	```return new Response(`...`, { headers: { 'Content-Type': 'image/svg+xml', 'Cache-Control': 'no-store' } });```
4824	eroicafenice.com.js	Incorrect Cache Keying with HTTP in Cache Name	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using an HTTP URL in the cache name, which is a misconfiguration rather than misuse of a sensitive function. Cache names should be unique and typically use a scheme-agnostic identifier to avoid issues with protocol-specific handling. This does not involve dynamic or untrusted input being passed to a sensitive function like importScripts or eval.}	```const cacheName = 'http://www.eroicafenice.com-superpwa-2.2.31';```
4825	dinet.org.js	Insecure URL Matching in Admin Check	High	true	CWE-20	9	startsWith	standard	{The use of `startsWith` to check for admin path is insecure because it does not validate the full URL or account for URL path traversal or malformed inputs. An attacker could craft a URL like `https://www.dinet.org/admin/../admin` or `https://www.dinet.org/admin%2f` to bypass the check, potentially leading to unauthorized access to admin resources. The function is standard but misused due to insufficient validation.}	```if (request.url.startsWith(BASE_URL + 'admin/') || e.currentTarget.location.href.match(/type=admin/)) { log('In ACP, nothing to do...'); return; }```
4826	dinet.org.js	Insecure Navigation in Notification Click	Medium	true	CWE-601	8	clients[0].navigate	standard	{The `navigate` method is used with `data.url`, which is derived from a push notification payload. If the notification data is not properly sanitized, an attacker could inject a malicious URL, causing the client to navigate to an arbitrary site, potentially leading to phishing or data exfiltration. The function is standard but misused due to lack of input validation.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
4827	cadastre.com.js	Improper Cache Key Handling Leading to Cache Collision and Stale Content Delivery	Medium	false	CWE-918	0	N/A	N/A	{The vulnerability arises from improper handling of cache keys, particularly when stripping query parameters like '?v=' and normalizing URLs to '/' for root paths. This logic does not involve any sensitive JavaScript function misuse such as importScripts, eval, or dynamic code execution. The issue is purely a logic flaw in cache key derivation, not a result of unsafe function usage.}	```if (key.indexOf('?v=') != -1) { key = key.split('?v=')[0]; } if (event.request.url == origin || event.request.url.startsWith(origin + '/#') || key == '') { key = '/'; } if (!RESOURCES[key]) { return; }```
4828	inhealthcare.co.uk.js	Improper Cache Resource Management	Low	false	New	N/A	N/A	N/A	{The vulnerability arises from an empty array assigned to offlineFundamentals, which may lead to improper caching behavior, but it does not stem from misuse of a sensitive function.}	"```var offlineFundamentals = [""""];```"
4829	inhealthcare.co.uk.js	Improper Error Handling in Service Worker	Medium	false	CWE-754	N/A	N/A	N/A	{The error handling is flawed as it returns a fallback response without proper validation or logging, but this is not due to misuse of a sensitive function.}	```return e || n; function t() { return new Response('<h1>Service Unavailable</h1>', { status: 503, statusText: 'Service Unavailable', headers: new Headers({ 'Content-Type': 'text/html' }) }); }```
4830	japanmusik.ir.js	Insecure External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, it imports a script from a hardcoded external domain (https://scriptapi.adwisedfs.com), which is not under the control of the application. This introduces a high-risk dependency on an untrusted third-party script, potentially allowing an attacker to compromise the service worker by modifying the remote script. Since the URL is hardcoded and not derived from user input, the vulnerability is not due to dynamic input misuse, but the act of importing external scripts without verification or integrity checks still constitutes a sensitive function misuse.}	```importScripts('https://scriptapi.adwisedfs.com/api/webpush/sw/3b92988b-2e8f-47af-9cb0-cb1c985a3fa7.js');```
4831	sexcam.life.js	Improper Input Validation - Unvalidated WebSocket URL in connectOrReconnect message	High	true	N/A	N/A	connectOrReconnect	standard	{The connectOrReconnect function is called with a configuration object that includes a wsURL, which is derived from untrusted client input. Since this URL is not validated or sanitized, an attacker could supply a malicious WebSocket URL (e.g., to an internal service or another domain), leading to unauthorized connections, data exfiltration, or server-side request forgery. The function is called via a message from a client, making it a direct vector for untrusted input.}	```this.socket.connectOrReconnect(n.config, o);```
4832	sexcam.life.js	Server Side Request Forgery (SSRF) via untrusted fetch in Bt function	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used in the Bt function to handle network requests. When the service worker is offline, it attempts to fetch the request URL without validation. If the request URL is controlled by an attacker (e.g., via a malicious client), this can lead to SSRF, allowing the attacker to make requests to internal services or other domains from the service worker's context. The URL is derived from the request object, which is untrusted.}	```return fetch(e.request).catch(e => { if (s.request.destination === 'document') return caches.open(O).then(t => t.match('/pwa-offline.html')); throw e; });```
4833	toph.co.js	Improper Input Validation (JSON Parsing)	Medium	true	CWE-20	8	N/A	standard	{The JSON.parse() function is used to parse the raw text from a push event's data, which is untrusted. If the data is maliciously crafted (e.g., containing invalid JSON or triggering JSON.parse() errors), it can lead to unexpected behavior or denial of service. While not directly leading to code execution, improper handling of untrusted input during parsing is a classic case of improper input validation.}	```self.addEventListener('push', function (i) { if (!i.data) return void console.log('This push event has no data.'); let t = JSON.parse(i.data.text()); i.waitUntil(self.registration.showNotification(t.title, { badge: t.badge || '/images/emblem-black_96p.png', body: t.body, data: { url: t.url }, icon: t.icon || '/images/emblem_512p.png', image: t.imageURL, renotify: t.renotify, requireInteraction: !0, silent: t.silent, tag: t.id })); });```
4834	toph.co.js	Open Redirect (Unvalidated URL Handling)	High	true	CWE-601	9	N/A	standard	{The clients.openWindow(t) function is called with a URL derived from untrusted data (i.notification.data.url). Since this URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, causing the browser to open an arbitrary site, leading to open redirect vulnerabilities.}	```self.addEventListener('notificationclick', function (i) { i.notification.close(); let t = i.notification.data.url || '/'; i.waitUntil(clients.matchAll({ type: 'window' }).then(function (i) { for (const e of i) if (e.url === t && 'focus' in e) return void e.focus(); 'openWindow' in clients && clients.openWindow(t); })); });```
4835	martellotech.com.js	Improper Validation of Range Requests Leading to DoS	High	true	N/A	8	N/A	standard	{The function `Response` is used to create a partial response based on range headers, but the validation of the range parameters (start and end) is insufficient. The code allows for negative start values or end values exceeding the blob size, which can lead to out-of-bounds memory access or excessive resource consumption when processing large or malformed range requests, potentially causing a Denial of Service.}	```const a = function (e, t, s) { const n = e.size; if (s && s > n || t && t < 0) throw new r('range-not-satisfiable', { size: n, end: s, start: t }); let i, a; return void 0 !== t && void 0 !== s ? (i = t, a = s + 1) : void 0 !== t && void 0 === s ? (i = t, a = n) : void 0 !== s && void 0 === t && (i = n - s, a = n), { start: i, end: a } }(i, n.start, n.end), o = i.slice(a.start, a.end), c = o.size, u = new Response(o, { status: 206, statusText: 'Partial Content', headers: t.headers }); return u.headers.set('Content-Length', String(c)), u.headers.set('Content-Range', `bytes ${a.start}-${a.end - 1}/` + i.size), u;```
4836	martellotech.com.js	Insecure URL Handling in Cache Listener Leading to Cache Poisoning	High	true	N/A	9	N/A	standard	{The `new Request(...e)` function is used to construct a request object from user-supplied URLs in the `urlsToCache` array, which is received via a message event. Since the input is not validated or sanitized, an attacker can supply arbitrary URLs (e.g., malicious domains or internal resources) to be cached, leading to cache poisoning and potential data exfiltration or unauthorized access.}	```const s = Promise.all(t.urlsToCache.map(e => { 'string' == typeof e && (e = [e]); const t = new Request(...e); return this.handleRequest({ request: t }) }));```
4837	martellotech.com.js	Insufficient Route Validation Allowing SSRF	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insufficient validation of navigation requests based on pathname and search parameters, but it is not caused by misuse of a sensitive JavaScript function. The logic uses standard string operations and regex matching, which are not inherently sensitive functions. The issue lies in the policy design rather than function misuse.}	```if (t && 'navigate' !== t.mode) return !1; const s = e.pathname + e.search; for (const e of this._denylist) if (e.test(s)) return !1; return !!this._allowlist.some(e => e.test(s));```
4838	geometrydash.ee.js	Insecure Data Source for Offline Cache	High	true	CWE-255	9	N/A	standard	{The function `fetchWithBypass` is used to retrieve data from `OFFLINE_DATA_FILE`, which is a hardcoded constant. While the source is hardcoded, the vulnerability arises because the data fetched is used to construct cache names and file lists without validation, potentially allowing an attacker to manipulate the offline data source if the file is compromised or if the URL is dynamically resolved in a future version. The misuse lies in trusting the data source without integrity checks.}	```const response = await fetchWithBypass(OFFLINE_DATA_FILE, true);```
4839	geometrydash.ee.js	Cache Poisoning via Lazy Load List	High	true	CWE-255	9	N/A	standard	{The `fetchWithBypass` function retrieves `lazyLoadList` from untrusted data (the `OFFLINE_DATA_FILE` JSON response), and this list is then used directly in `IsUrlInLazyLoadList` to construct regex patterns. Since the list is not sanitized or validated, an attacker could inject malicious regex patterns or URLs, leading to cache poisoning or ReDoS. The sensitive function `fetchWithBypass` is misused by trusting unvalidated external data.}	```const lazyLoadList = data.lazyLoad;```
4840	geometrydash.ee.js	ReDoS in Regex Matching	Medium	true	CWE-400	8	N/A	standard	{The `new RegExp(lazyLoadRegex).test(url)` construct dynamically creates regex patterns from untrusted `lazyLoadRegex` values (from `lazyLoadList`). This allows an attacker to inject complex or pathological regex patterns, leading to ReDoS attacks. The sensitive function `RegExp` is misused by accepting untrusted input directly as regex source.}	```if (new RegExp(lazyLoadRegex).test(url)) return true;```
4841	geometrydash.ee.js	Unvalidated URL Handling in Cache Construction	Medium	true	CWE-20	7	N/A	standard	{The `fileList.unshift('./')` and subsequent `fileList.unshift(mainPageUrl)` operations construct a list of URLs to cache. If `mainPageUrl` is derived from untrusted client data (e.g., via `clients.matchAll`), it could be manipulated to include arbitrary URLs, leading to unintended caching or cache poisoning. The sensitive function `fetchWithBypass` is misused by accepting potentially untrusted URLs without validation.}	"```fileList.unshift(""./"");```"
4842	geometrydash.ee.js	BroadcastChannel Message Handling Without Validation	Low	false	CWE-200	0	N/A	standard	"{The `broadcastChannel.postMessage(o)` function is used to send messages, but the data `o` is constructed from known internal values (e.g., `""type"": ""downloading-update""`). There is no evidence of untrusted input being passed to `postMessage`, so this is not a sensitive function misuse.}"	```broadcastChannel.postMessage(o)```
4843	conquistesuavida.com.br.js	Improper Regular Expression Handling Leading to Domain Bypass	Medium	true	CWE-20	9	N/A	standard	"{The function `new RegExp()` is used with a dynamically constructed pattern derived from `CACHES[e].domains.map(escape).join(""|"")`. The `escape` function is deprecated and does not properly sanitize input for regex, allowing special characters in domain names to be interpreted as regex metacharacters. This can lead to unintended regex patterns that bypass domain validation, enabling attackers to cache or fetch resources from unintended domains.}"	```shouldBeCached = function (e, t) { return 'string' == typeof e && t.test(e.slice(0, 60)); }; Object.keys(CACHES).forEach(function (e) { CACHES[e].regexp = new RegExp('(' + CACHES[e].domains.map(escape).join('|') + ')'); });```
4844	enkreis.de.js	Untrusted Code Execution	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, if the URL were dynamically constructed from untrusted input (e.g., user-controlled parameters), it could lead to untrusted code execution. In this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse. Therefore, the detection is incorrect for this context.}	```importScripts('https://components.cross-7.de/worker.js');```
4845	elkhart.com.js	ReDoS Vulnerability	High	true	CWE-200	9	RegExp	standard	"{The code uses JSON.parse() to dynamically construct regular expressions from a string literal that contains complex patterns (e.g., ""(?:/.*)?""), which are then passed to RegExp(). These patterns can trigger catastrophic backtracking when matched against malicious input, leading to ReDoS (Regular Expression Denial of Service). The sensitive function here is RegExp, which is misused by accepting untrusted or complex patterns derived from static strings that are not sanitized or validated for performance.}"	"```const c = JSON.parse('[""my\\\\.elkhart\\\\.com(?:/.*)?/ola/services/.*"",""my\\\\.elkhart\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://6290e7b1-8590-4f95-9f9f-2179f06c24bf\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4846	7712.org.js	Open Redirect Vulnerability	High	true	CWE-601	10	N/A	standard	{The vulnerability arises from the misuse of the `new URL()` constructor and the `URL` object's `hostname` and `search` properties. The `originalRequest.url` is directly parsed into a URL object, and its `hostname` is replaced with a hardcoded backup domain. However, the `search` parameter is constructed by appending `od=` followed by the original request's host, which is derived from `currentUrl.host`. Since `originalRequest.url` is user-controlled (via the request made by the client), an attacker can craft a request with a malicious host value, which will be included in the redirect URL as a query parameter. This allows an attacker to redirect users to arbitrary domains, leading to an open redirect vulnerability. The `new URL()` function is a standard JavaScript API, and its misuse here stems from not sanitizing or validating the input used to construct the redirect URL.}	```const backupUrl = new URL(originalRequest.url); backupUrl.hostname = backupDomain; const currentUrl = new URL(originalRequest.url); let search = currentUrl.search; if (!search) { search = '?'; } else { search += '&'; } search += 'od=' + currentUrl.host; backupUrl.search = search; return new Response('', { status: 302, headers: { 'Location': backupUrl.toString() } });```
4847	trapanioggi.it.js	Stale Cache Content	N/A	false	CWE-921	N/A	N/A	N/A	{The vulnerability arises from the lack of cache invalidation or versioning, not from misuse of a sensitive function. The code does not dynamically construct URLs or use untrusted input with functions like importScripts or eval.}	```self.addEventListener('fetch', function (e) { e.respondWith(caches.match(e.request).then(function (response) { return response || fetch(e.request); })); });```
4848	trapanioggi.it.js	No Cache Expiration	N/A	false	CWE-400	N/A	N/A	N/A	{This issue stems from the absence of cache expiration logic, not from misuse of a sensitive function. The code does not involve dynamic or untrusted input being passed to functions that could lead to security risks.}	```var cacheName = 'Trapani Oggi'; var filesToCache = []; self.addEventListener('install', function (e) { e.waitUntil(caches.open(cacheName).then(function (cache) { return cache.addAll(filesToCache); })); });```
4849	vsemmoney.com.js	Open Redirect via Notification Data	High	true	CWE-601	10	N/A	standard	{The `navigate` method of the `clients` API is used with a URL derived from the `data.url` field of a notification, which is controlled by the server. Since the server can inject arbitrary URLs into the notification payload, an attacker could craft a malicious notification that redirects the user to a phishing site or performs other malicious actions. This constitutes an open redirect vulnerability because the destination URL is not validated or sanitized.}	```const { data } = e.notification; e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
4850	boatid.com.js	Vulnerable Cache Key Handling	High	true	N/A	N/A	cacheKeyWillBeUsed	standard	{The cacheKeyWillBeUsed plugin callback is used to modify cache keys based on request parameters, but if the input is not sanitized, it can lead to cache poisoning or bypassing cache validation, allowing attackers to inject arbitrary cache keys and potentially serve malicious content.}	```const { cacheKey: e, url: a } = h(s);```
4851	boatid.com.js	Insecure Fetch Configuration	Medium	true	N/A	N/A	Request	standard	{The Request constructor is used with unsanitized input from the URL, which can lead to unintended network requests or bypassing security policies if the URL is controlled by an attacker, potentially resulting in data exfiltration or unauthorized access.}	"```let a = new Request(e, { integrity: ""no-cors"" !== e.mode ? r || n : void 0 });```"
4852	boatid.com.js	Improper Cache Expiration Logic	Medium	false	N/A	N/A	N/A	N/A	{The cache expiration logic is flawed due to improper handling of timestamps and cache entries, but it does not stem from misuse of a sensitive function; rather, it is a logic error in the expiration strategy.}	```const { updatedURLs: s, notUpdatedURLs: n } = t;```
4853	boatid.com.js	Unvalidated Redirect Handling	High	true	N/A	N/A	cacheWillUpdate	standard	{The cacheWillUpdate plugin callback processes redirected responses without validating the origin, which can lead to cross-origin response copying and potential security breaches if the response is from a malicious origin.}	"```return e.redirected ? await async function (e, t) { let s = null; if (e.url && (s = new URL(e.url).origin), s !== self.location.origin) throw new n(""cross-origin-copy-response"", { origin: s }); const a = e.clone(), r = { headers: new Headers(a.headers), status: a.status, statusText: a.statusText }, i = t ? t(r) : r, c = function () { if (void 0 === d) { const e = new Response(""""); if (""body"" in e) try { new Response(e.body), d = !0; } catch (e) { d = !1; } d = !1; } return d; }() ? a.body : await a.blob(); return new Response(c, i); }(e) : e```"
4854	boatid.com.js	Insecure Offline Page Handling	Medium	false	N/A	N/A	N/A	N/A	{The offline page is added to the cache during install, but the vulnerability arises from the lack of validation or sanitization of the offline page URL, not from misuse of a sensitive function.}	"```addEventListener(""install"", async e => { e.waitUntil(caches.open(ue).then(e => e.add(de))); });```"
4855	electrocd.com.js	Improper Validation of Request Origin Leading to Cache Poisoning	High	true	CWE-79	9	N/A	standard	{The vulnerability arises from improper validation of request origins when determining whether to cache resources. The code uses `event.request.destination.match('style|script|font')` and `event.request.url.match('\\.svg$')` to decide if a request should be cached. However, these checks are insufficient and do not validate the origin of the request. An attacker could potentially craft a request with a malicious origin that matches the allowed patterns (e.g., a script or font from a different domain), leading to cache poisoning where malicious content is stored and served to users. The `match()` function, while standard, is misused here by relying on simple string matching without origin validation, which is a critical oversight in a service worker context.}	```var requeteCachable = event.request.destination.match('style|script|font') || event.request.url.match('\\.svg$');```
4856	nic.anz.js	Improper Cache Expiration for Sensitive Data	High	true	New	10	registerRoute	standard	{The registerRoute function is used to define routing rules for caching, but it is misused by applying NetworkOnly strategy to URLs matching sensitive patterns (e.g., /ola/services/.*). This prevents caching entirely, which may lead to unnecessary network requests and potential exposure of sensitive data if the network is intercepted or if the service worker is not properly secured. The lack of expiration or validation for these routes increases the risk of stale or malicious data being served.}	```(0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkOnly())```
4857	nic.anz.js	Cross-Origin Caching Without Validation	Medium	true	New	9	registerRoute	standard	{The registerRoute function is used to cache responses from cross-origin URLs (e.g., blog.apps.secureserver.net) using NetworkFirst strategy. This is risky because it allows caching of responses from external domains without proper validation or origin checks, potentially leading to cache poisoning or data leakage if the external service is compromised or misconfigured.}	```(0, e.registerRoute)(({ url: e }) => o.some(t => t.test(e.href)), new t.NetworkFirst({ cacheName: 'network-first', plugins: [new a.CacheableResponsePlugin({ statuses: [200] })] }))```
4858	nic.anz.js	Insecure Cacheable Response Handling	Medium	true	New	8	CacheableResponsePlugin	standard	{The CacheableResponsePlugin is misused by allowing status code 0 (which indicates a network error or no response) to be cached for Google Fonts. This can lead to serving stale or invalid responses when the network is unavailable, potentially breaking the UI or allowing attackers to exploit the service worker's behavior during network failures.}	```new t.CacheFirst({ cacheName: 'google-fonts-webfonts', plugins: [new a.CacheableResponsePlugin({ statuses: [0, 200] }), new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })] })```
4859	howtofindrocks.com.js	Server Side Request Forgery (SSRF)	High	true	N/A	N/A	Request	standard	{The Request constructor is used with a URL derived from an untrusted source (e.g., via a request object or URL string), allowing an attacker to craft a request to arbitrary endpoints, leading to SSRF. The code does not validate or sanitize the URL before constructing the Request, enabling unauthorized access to internal or external services.}	```const e = new Request(e.url, location.href);```
4860	howtofindrocks.com.js	Cache Poisoning	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of preload responses, but not due to misuse of a sensitive function. The issue is more related to logic or configuration flaws rather than direct misuse of a sensitive API.}	```e = await t.preloadResponse;```
4861	howtofindrocks.com.js	Insufficient URL Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from inadequate validation of URLs against the siteHostname, but no sensitive function is misused. The issue is in the logic of URL matching rather than improper use of a JavaScript API.}	```if (!!t.includes(siteHostname) && new URL(t).hostname === siteHostname;)```
4862	garpix.com.js	Insecure Message Handling	High	true	CWE-829	10	N/A	standard	{The `self.addEventListener('message', event => { data = event.data; });` handler assigns untrusted incoming message data directly to a global variable `data` without validation or sanitization. This allows an attacker to inject arbitrary data into the service worker, potentially leading to logic manipulation, cache poisoning, or further exploitation if `data` is later used in unsafe operations such as dynamic URL construction or script execution.}	```self.addEventListener('message', event => { data = event.data; });```
4863	garpix.com.js	Inadequate Blacklist Validation	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from flawed logic in the blacklist check, not from misuse of a sensitive function. The issue is that `url.includes(ignoreUrl)` allows partial matches, which can lead to false negatives or unintended bypasses. This is a logic flaw, not a sensitive function misuse.}	```if (ignoreUrl && ignoreUrl !== '/' && url.includes(ignoreUrl)) { isAllowed = false; }```
4864	garpix.com.js	Cache Poisoning via Unvalidated Fetch	High	true	CWE-113	9	N/A	standard	{The `fetch()` function is used to retrieve network responses and immediately cache them via `cache.put()`, without validating the response or ensuring the request is safe. If an attacker can trigger a fetch for a malicious URL (e.g., via a crafted request in a fetch event), the response can be cached and served to future requests, leading to cache poisoning. The `fetch()` function is standard and its misuse here allows untrusted content to be stored in the cache.}	```const fetchPromise = fetch(event.request).then(networkResponse => { cache.put(event.request, networkResponse.clone()); return networkResponse; });```
4865	voglioviverecosi.com.js	External Script Inclusion in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a risk if the script source is untrusted or compromised, allowing an attacker to inject malicious code into the service worker. Although the URL is hardcoded here, the vulnerability is still considered sensitive because the function itself is inherently risky when used with external sources, especially if the source is not under the developer’s control.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6358f4f06a685400095eb74d/service-worker.js"");```"
4866	graphicdesignforum.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from directly assigning `e.data.lastAction` to `lastAction` without validation, but no sensitive function is misused here. The issue is purely about trusting unvalidated data.}	```self.addEventListener('message', function (e) { 'lastAction' in e.data && (lastAction = e.data.lastAction); });```
4867	graphicdesignforum.com.js	XSS via Notification Data	High	true	CWE-79	N/A	showNotification	standard	{The `showNotification` function is called with data directly from `e.data.json()` without sanitization. Since notification content (title, body) is rendered by the browser, an attacker can inject malicious scripts or HTML, leading to XSS.}	```var t = e.data.json(); ... showNotification(t.title, t.body, t.icon, t.badge, t.tag, t.base_url, t.url);```
4868	graphicdesignforum.com.js	Trusting Client-Side Data	Medium	false	CWE-24	N/A	N/A	N/A	{The code parses `navigator.userAgent` to detect Chrome version, but this is not a sensitive function misuse. The issue is trusting client-side data for logic, not improper use of a function.}	```var chromeVersionMatch = navigator.userAgent.match(/Chrome\/97.0.(\d+)/), isBrokenChrome97 = chromeVersionMatch && parseInt(chromeVersionMatch[1]) <= 4692;```
4869	graphicdesignforum.com.js	Improper Error Handling	Medium	false	CWE-754	N/A	N/A	N/A	{The `Promise.all` is used with two fetch calls, but no sensitive function is misused. The issue is that errors in either fetch are not handled, leading to uncaught rejections.}	"```e.waitUntil(Promise.all(fetch(""https://www.graphicdesignforum.com/push_notifications/subscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.newSubscription.endpoint, ""subscription[keys][auth]"": e.newSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.newSubscription.toJSON().keys.p256dh, send_confirmation: !1 }) }), fetch(""https://www.graphicdesignforum.com/push_notifications/unsubscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.oldSubscription.endpoint, ""subscription[keys][auth]"": e.oldSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.oldSubscription.toJSON().keys.p256dh }) })));```"
4870	graphicdesignforum.com.js	Sensitive Data Exposure	High	true	CWE-311	N/A	fetch	standard	{The `fetch` function is used to send sensitive subscription data (endpoint, auth key, p256dh) via HTTP POST without encryption or proper security controls. This exposes private keys and endpoints to eavesdropping or interception.}	"```fetch(""https://www.graphicdesignforum.com/push_notifications/subscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.newSubscription.endpoint, ""subscription[keys][auth]"": e.newSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.newSubscription.toJSON().keys.p256dh, send_confirmation: !1 }) }), fetch(""https://www.graphicdesignforum.com/push_notifications/unsubscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": e.oldSubscription.endpoint, ""subscription[keys][auth]"": e.oldSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": e.oldSubscription.toJSON().keys.p256dh }) });```"
4871	lesarchivesduspectacle.net.js	Use of Third-Party Code Without Integrity Check	High	true	CWE-928	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious or tampered code from third-party sources. In this case, the script is loaded from a public CDN (https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js), which, while reputable, is not verified for integrity. An attacker could compromise the CDN or intercept the request to inject malicious code, leading to full control over the service worker’s behavior, including cache manipulation, network interception, and data exfiltration.}	```importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js');```
4872	wearethepit.com.js	Improper Handling of Sensitive Information	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoding a sensitive API key (INNERTUBE_API_KEY) in the script, which is not due to misuse of a sensitive JavaScript function but rather poor secret management. The key is exposed in plaintext and could be exploited by attackers to impersonate the application or gain unauthorized access to YouTube's backend services.}	```ytcfg.set({ 'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8', ... });```
4873	wearethepit.com.js	Improper Control of Generation of Code	Medium	true	CWE-94	N/A	importScripts	standard	{The importScripts() function is used to load an external script, and although the URL is hardcoded, the use of trustedTypes.createPolicy() to generate the script URL introduces a potential vector if the policy were to be dynamically influenced by untrusted input. However, in this case, the URL is fixed and not derived from user input, so the risk is mitigated. The vulnerability is still present due to the potential for future misuse if the policy becomes dynamic.}	```importScripts(policy.createScriptURL(''));```
4874	calsalaries.com.js	Open Redirect via Unvalidated URL in Notification Click Handler	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. In this case, the URL is derived directly from event.notification.data, which originates from a push notification payload. Since the payload is controlled by an external source (e.g., a server or attacker), and no validation or sanitization is performed on the URL, an attacker can craft a malicious URL to redirect users to phishing sites or other harmful destinations, leading to an open redirect vulnerability.}	```event.waitUntil(clients.openWindow(event.notification.data));```
4875	history.de.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability if the domain is untrusted or controlled by an attacker. Although the URL is hardcoded here, the vulnerability arises because the script is imported from an external, potentially malicious source, which can lead to code injection, data exfiltration, or manipulation of the service worker’s behavior. This is considered sensitive misuse because importScripts() executes code from the specified URL without any sanitization or validation.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/64edb6c050719d0008b847d1/service-worker.js"");```"
4876	acses.site.js	Overly Broad Cache Regex Patterns	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from overly broad regular expressions used to match URLs for caching, but it is not caused by misuse of a sensitive JavaScript function. The regex patterns are hardcoded and do not involve dynamic input or unsafe function calls like importScripts, eval, or unsafe URL construction.}	"```const c = JSON.parse('[""acses\\\\.site(?:/.*)?/ola/services/.*"",""acses\\\\.site/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://969fe91c-1e59-4d0d-a384-3d1be64e2e68\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4877	manekicasino.com.js	Insecure Handling of Redirected Responses	High	true	New	10	URL	standard	{The code uses new URL(t.url).origin to extract the origin of a redirected response. If the redirected URL is controlled by an attacker (e.g., via a malicious redirect), this can lead to cross-origin resource access or other security issues. The URL constructor is a standard function, but its misuse here with untrusted input (t.url) from a redirected response introduces a vulnerability.}	```const t = await s.clone(); if (t.url && (n = new URL(t.url).origin), n !== self.location.origin) throw new e('cross-origin-copy-response', { origin: n });```
4878	alpari.pro.js	Open Redirect	High	true	N/A	9	fetch	standard	{The function `fetch` is used to retrieve a redirect URL from `SETTINGS.fetch_redirect_url`, which is derived from a user-controlled query parameter (`configParams.get('fetch_redirect_url')`). This allows an attacker to supply a malicious URL, leading to an open redirect vulnerability where users are redirected to arbitrary domains.}	N/A
4879	alpari.pro.js	Server Side Request Forgery	High	true	N/A	9	fetch	standard	{The `fetch` function is used with `SETTINGS.fetch_redirect_url`, which is sourced from a user-controlled query parameter. This enables an attacker to make the service worker perform HTTP requests to arbitrary external domains, leading to SSRF.}	N/A
4880	alpari.pro.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The code checks if a URL contains specific file extensions or matches skip URLs, but it does not validate or sanitize the input properly. This is not caused by misuse of a sensitive function, but rather by flawed logic in string matching.}	N/A
4881	alpari.pro.js	Information Exposure Through Debug Logs	Low	false	N/A	N/A	N/A	N/A	{The `console.log` function is used conditionally based on `DEBUG_MODE`, which is derived from a query parameter. While this can expose sensitive information, it is not due to misuse of a sensitive function like `fetch` or `importScripts`, but rather a configuration issue.}	N/A
4882	alpari.pro.js	Open Redirect	High	true	N/A	9	getRedirectUrlLS	custom	{The custom function `getRedirectUrlLS` constructs a redirect URL by appending query parameters to a base URL (`SETTINGS.redirect_url`), which is dynamically set from a user-controlled source (`fetchRedirectUrl`). This allows an attacker to manipulate the redirect target, leading to open redirect.}	N/A
4883	alpari.pro.js	Server Side Request Forgery	High	true	N/A	9	fetch	standard	{The `fetch` function is used with `SETTINGS.fetch_redirect_url`, which is derived from a user-controlled query parameter. This enables an attacker to make the service worker perform HTTP requests to arbitrary external domains, leading to SSRF.}	N/A
4884	kit-e.ru.js	Unrestricted Import of Code from Untrusted Source	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an untrusted source (e.g., 'https://xm.xms.lol/sw.js'), it introduces a high-risk vulnerability because the script being imported can be controlled by an attacker, leading to arbitrary code execution within the service worker context. This allows an attacker to manipulate cache, intercept network requests, or perform other malicious actions.}	"```importScripts(""https://xm.xms.lol/sw.js"");```"
4885	efeminista.com.js	Insecure Cache Bypass	High	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the use of a regex pattern to exclude certain URLs from caching, but the pattern is not robust against edge cases or malformed inputs. However, no sensitive JavaScript function is misused here; the issue is purely in the logic of the regex and its application.}	```const neverCacheUrls = [/\/wp-admin/, /\/wp-login/, /preview=true/];```
4886	efeminista.com.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The code parses the 'range' header using a regex, but does not validate the input thoroughly. However, this is not due to misuse of a sensitive function like eval or importScripts, but rather a logic flaw in input parsing.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
4887	efeminista.com.js	Cross-Origin Cache Poisoning	High	false	CWE-113	N/A	N/A	N/A	{The check for origin mismatch is implemented correctly using new URL().origin, but the vulnerability stems from the logic allowing cache access for same-origin requests only. No sensitive function is misused here.}	```if (new URL(e.request.url).origin !== location.origin) return;```
4888	efeminista.com.js	Insecure Content Caching	Medium	false	CWE-921	N/A	N/A	N/A	{The caching logic uses cache.add() and cache.put(), but the vulnerability is due to lack of content validation or sanitization, not misuse of a sensitive function.}	```filesToCache.map(function (url) { return cache.add(url).catch(function (reason) { return console.log('SuperPWA: ' + String(reason) + ' ' + url); }); });```
4889	efeminista.com.js	Insecure Regex Pattern	Medium	false	CWE-20	N/A	N/A	N/A	{The function checkNeverCacheList uses a regex pattern that is applied incorrectly (this.match(url) is not valid for regex objects). However, this is a misuse of regex logic, not a sensitive JavaScript function.}	```if (this.match(url)) { return false; } return true;```
4890	amplehills.com.js	Improper Cache Deletion Leading to Data Loss	High	true	CWE-22	9	caches.keys()	standard	"{The caches.keys() function retrieves all cache names, which are then filtered by a hardcoded prefix (""amplehills.com-"") and deleted. While the filtering is static and not user-controlled, the use of caches.keys() without explicit validation or scope restriction can lead to unintended cache deletions if the service worker is misconfigured or if the prefix is accidentally broadened. However, in this case, the deletion is limited to caches starting with ""amplehills.com-"", so the risk is mitigated. The vulnerability arises from the lack of precise control over which caches are deleted, potentially leading to data loss if the prefix matches unintended caches.}"	"```self.addEventListener(""activate"", function (e) { e.waitUntil(caches.keys().then(function (e) { return Promise.all(e.filter(e => e.startsWith(""amplehills.com-"")).map(e => caches.delete(e))); })); });```"
4891	fedratewatch.org.js	External Script Execution via importScripts	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable. However, if the URL were derived from untrusted or dynamic input (e.g., from location.search, user input, or configuration), it could lead to arbitrary script execution. In this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse. Therefore, the detection is misleading — the function is not being misused, and the vulnerability is not sensitive in nature.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5c98fa268b7d7c31abcdcc61"");```"
4892	malware.news.js	Cross-Site Request Forgery (CSRF)	High	true	CWE-352	9	fetch	standard	{The fetch function is used with a dynamically constructed URL (`${n}/chat/${t}.json`) where `n` and `t` are derived from notification data, which may be controlled by an attacker. Since the request includes a CSRF token obtained via a prior fetch, but the URL is not validated or sanitized, an attacker could forge a request to a different endpoint by manipulating the notification data, leading to CSRF.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
4893	malware.news.js	Open Redirect	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a dynamically constructed URL (`n + t`), where `n` and `t` are derived from notification data. Since these values are not validated or sanitized, an attacker could supply a malicious URL, causing the browser to redirect to an arbitrary site, leading to an open redirect vulnerability.}	```clients.openWindow(n + t);```
4894	videogiochi.com.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.push_send_id and sensor_url), which can be manipulated by an attacker to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var ve = sensor_url + '/e?site_name=www.videogiochi.com&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' }).then(response => response.json()).catch(err => {});```
4895	videogiochi.com.js	Server-Side Request Forgery (SSRF)	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (event.notification.data.push_send_id and event.notification.data.sensor), which can be manipulated by an attacker to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```var vc = event.notification.data.sensor + '/e?site_name=www.videogiochi.com&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' }).then(response => response.json()).catch(err => {});```
4896	kcbs.com.js	Improper Validation of Redirect URL	High	true	CWE-601	N/A	N/A	standard	{The code constructs a URL from untrusted data in `notification.data.actionTargets` or `notification.data.url` without validation or sanitization. This allows an attacker to craft a malicious notification payload that redirects the user to an arbitrary URL, potentially leading to phishing, drive-by downloads, or other malicious actions. The `idbKeyval.set(url, ...)` call stores this URL, but the critical issue is the use of the unvalidated URL for navigation.}	```let url; if (action) { url = notification.data.actionTargets[notification.action]; } else if (data.url) { url = data.url; } else { url = '/'; } idbKeyval.set(url```
4897	kcbs.com.js	Prototype Pollution via Prototype Modification	Medium	false	N/A	N/A	N/A	N/A	{The code modifies `ExtendableEvent.prototype.waitUntil` and `FetchEvent.prototype.respondWith` to add custom behavior, but this does not constitute a sensitive function misuse. The modifications are internal to the service worker and do not involve passing untrusted data to a sensitive function. The vulnerability is more related to prototype pollution in general, but not due to misuse of a sensitive function.}	```const waitUntil = ExtendableEvent.prototype.waitUntil; const respondWith = FetchEvent.prototype.respondWith; ExtendableEvent.prototype.waitUntil = function (promise) { const extendableEvent = this; let promises = promisesMap.get(extendableEvent); if (promises) { promises.push(Promise.resolve(promise)); return; } promises = [Promise.resolve(promise)]; promisesMap.set(extendableEvent```
4898	tuliptime.com.js	Improper Error Handling in Cache.addAll Leading to Potential DoS	High	true	CWE-754	10	cache.addAll	standard	{The cache.addAll() function is used to add multiple resources to a cache in a single operation. If any of the URLs provided fail to fetch (e.g., due to network issues or invalid paths), the entire operation fails and throws an error. Since no error handling is implemented around the addAll() calls, this can lead to a denial-of-service condition where the service worker installation fails repeatedly, preventing the app from functioning properly. The misuse lies in not wrapping the addAll() calls in try-catch blocks or using .catch() to handle failures gracefully.}	```staticCache.addAll(['/images/tt-tulip.svg']); return staticCache.addAll(['/application.css', '/application.js', '/images/tt-logo-2025.svg', '/images/tt-logo-vertical.svg']);```
4899	tuliptime.com.js	Broad Regex Patterns Allowing Unintended Network Bypass	Medium	false	CWE-209	0	N/A	N/A	{The vulnerability arises from overly permissive regular expressions used to bypass caching for certain domains. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in the regex patterns themselves. The regexes are static and do not involve dynamic input or sensitive APIs like eval, importScripts, or unsafe URL construction.}	```if (/^(http)(s)?(:\/\/)([a-z]+.)?(google|google-analytics)(\.com\/)/.test(request.url)) { return; }```
4900	tuliptime.com.js	Insecure PDF Caching Logic Leading to Potential Data Exposure	Medium	false	CWE-73	0	N/A	N/A	{The vulnerability stems from a flawed logic condition that checks for PDFs in asset paths. However, this is not caused by misuse of a sensitive JavaScript function. The issue is in the business logic of the condition (e.g., not properly sanitizing or validating the request URL), not in the use of a dangerous API or function.}	```if (request.destination == 'document' && asset.test(request.url) && pdf.test(request.url)) { return; }```
4901	londonred.com.js	Improper Cache Control with Broad Regex	High	false	New	N/A	N/A	N/A	{The vulnerability arises from overly broad regex patterns used in workbox.routing.registerRoute, which may unintentionally cache unintended resources. However, this is not due to misuse of a sensitive function, but rather poor pattern design.}	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
4902	londonred.com.js	Unintended Resource Caching via No-CORS	High	true	New	N/A	importScripts	standard	{The prefetchUrl function uses fetch with mode: 'no-cors', which can lead to unintended caching of cross-origin resources without proper CORS headers. This misuse of fetch with no-cors mode allows potentially untrusted resources to be cached, posing a security risk.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
4903	londonred.com.js	Debug Logging Enabled in Production	Medium	false	CWE-200	N/A	N/A	N/A	{This vulnerability stems from enabling debug logging in production, which may expose sensitive information. It is not caused by misuse of a sensitive function, but rather a configuration issue.}	```pwaSettings.debug = true;```
4904	bitcoin-2go.de.js	Service Worker Not Functional (No Cache or Fetch Logic	High	false	New	N/A	N/A	N/A	{The service worker is declared but contains no actual caching or fetch logic. The event listeners are empty, meaning no network requests are intercepted or cached. This is a functional issue, not a result of sensitive function misuse.}	```const cacheName = 'blogCache'; const offlineUrl = '/offline/'; self.addEventListener('install', function (event) {}); self.addEventListener('fetch', function (event) {});```
4905	hawksey.info.js	Improper Input Validation in Range Header Parsing	High	true	New	9	N/A	standard	{The `Number` function is used to parse a value extracted from the `range` header via a regex, which is derived from `event.request.headers.get('range')`. This input is untrusted and can be manipulated by an attacker to inject arbitrary values, potentially leading to out-of-bounds memory access or unexpected behavior during `ab.slice(pos)` if `pos` is not properly validated. The misuse of `Number` with untrusted input without bounds checking constitutes improper input validation.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
4906	hawksey.info.js	Insecure External Script Import Without Integrity Check	Medium	true	CWE-451	8	N/A	standard	{The `importScripts` function is used to load an external script from a hardcoded URL. While the URL is fixed, the vulnerability arises because there is no integrity check (e.g., `integrity` attribute or cryptographic hash verification) to ensure the script has not been tampered with. This allows an attacker who compromises the CDN to inject malicious code into the service worker, leading to potential data exfiltration or manipulation.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js"");```"
4907	cifs.dk.js	Arbitrary Code Execution via Dynamic Plugin Handling	High	true	New	9	plugins.unshift(requestInterceptor); const strategyOptions = { ...entry.strategyOptions, plugins }; const strategy = new workbox.strategies[entry.handler](strategyOptions);	standard	{The vulnerability arises from dynamically constructing and instantiating a strategy object using `new workbox.strategies[entry.handler](strategyOptions)`, where `entry.handler` is derived from user-controlled or configuration-driven input. Since `entry.handler` is not validated or whitelisted, an attacker could supply a malicious handler name (e.g., a custom strategy or a prototype pollution vector) that leads to arbitrary code execution. This misuse of the `new` operator with dynamic function names is a classic case of unsafe dynamic function invocation.}	N/A
4908	cifs.dk.js	Improper Handling of Dynamic Content via Static Revision	Medium	false	CWE-379	0	'revision': 'PWwwHy3NwGtY', 'url': '/?standalone=true'	N/A	{This issue is not caused by misuse of a sensitive function but rather by a static revision value that may not reflect actual content changes, leading to stale cache behavior. No sensitive function is involved.}	N/A
4909	cifs.dk.js	External Script Loading from Untrusted CDN	Medium	true	CWE-444	8	importScripts(...[options.workboxURL, ...options.importScripts]);	standard	{The `importScripts()` function is a standard JavaScript API used in service workers to load external scripts. When used with a URL derived from a configuration object (`options.workboxURL`), it becomes a vector for arbitrary script loading if the URL is not properly validated. In this case, `options.workboxURL` is hardcoded to a CDN, but if this value were dynamically sourced from untrusted input, it could lead to remote code execution. The misuse lies in trusting external URLs without validation.}	N/A
4910	i-minded.net.js	Caching of Sensitive URLs in Dynamic Cache	Medium	true	CWE-918	9	N/A	standard	{The function `cache.put()` is used to store responses in the dynamic cache, and it accepts `evt.request.url` as the key. Since `evt.request.url` is derived from the incoming fetch request, which can be controlled by an attacker (e.g., via crafted URLs), this allows arbitrary URLs to be cached. If an attacker can trigger a request to a sensitive or malicious URL, it may be stored in the cache and later served without revalidation, potentially leading to cache poisoning or unintended exposure of sensitive data.}	```cache.put(evt.request.url, fetchResponse.clone());```
4911	wicnews.com.js	Insecure Deserialization of External Data	Medium	false	CWE-502	N/A	N/A	N/A	{The vulnerability arises from deserializing JSON data from an external source without validation, but it is not directly caused by misuse of a sensitive function like eval or Function. The JSON.parse() method is used implicitly via response.json(), which is safe by design. The risk stems from trusting the content of the manifest.json file, not from a sensitive function misuse.}	```const json = await response.json(); const urlsToCache = filesToCache.concat(Object.values(json).map(item => '/build/' + item['file']));```
4912	wicnews.com.js	Cross-Site Request Forgery (CSRF) Vulnerability	High	false	CWE-352	N/A	N/A	N/A	{CSRF is not caused by misuse of a sensitive JavaScript function. It arises from the lack of anti-CSRF tokens or origin validation in the fetch handling logic. The code does not use any function that directly enables CSRF, such as unsafe redirect or script injection.}	```if (event.request.method === 'GET' && (event.request.url.startsWith('http://') || event.request.url.startsWith('https://'))) {```
4913	wicnews.com.js	Caching of Untrusted Resources	Medium	false	CWE-918	N/A	N/A	N/A	{The caching of resources is performed via caches.addAll(), which is a standard and safe method. The vulnerability stems from trusting the URLs derived from the external manifest.json file, not from misuse of a sensitive function. The function itself is not inherently dangerous when used correctly.}	```await cache.addAll(urlsToCache);```
4914	smithfamilyfuneralhomes.com.js	Improper Neutralization of User-Supplied Input in URL Parameter Handling	High	true	CWE-113	N/A	template	standard	{The `template` function is used within `addParamsNative` to dynamically insert parameter keys and values into a URL string. If user-supplied input is not properly sanitized before being passed to `template`, it can lead to injection of arbitrary URL parameters, potentially causing unintended behavior such as redirecting to malicious URLs or bypassing security checks. The function uses regex replacement with user-controlled keys, which can be exploited if the input is not validated.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
4915	smithfamilyfuneralhomes.com.js	Overly Broad Cache Matching Regex Leading to Unintended Caching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly broad regex patterns used in `workbox.routing.registerRoute`, which can match unintended URLs and cache them improperly. However, this is not caused by misuse of a sensitive function but rather by flawed logic in regex design.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
4916	smithfamilyfuneralhomes.com.js	Insecure Message Handling Without Origin Validation	High	true	CWE-306	N/A	event.ports[0].postMessage	standard	{The `postMessage` function is used to send a response back to the page without validating the origin of the message. This allows any page (including malicious ones) to trigger the `deletePagesCache` command, leading to unauthorized cache deletion. The `event.ports[0]` reference implies a lack of origin checks, making it a sensitive function misuse.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
4917	smithfamilyfuneralhomes.com.js	No-CORS Prefetching Leading to Opaque Response Caching	Medium	true	CWE-400	N/A	fetch	standard	{The `fetch` function is called with `mode: 'no-cors'`, which results in opaque responses that cannot be inspected or validated. These responses are then cached, potentially storing unverifiable or malicious content. The misuse lies in using `fetch` with `no-cors` mode without proper validation, leading to insecure caching.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } } } catch (err) { log('error, probably offline'); } }```
4918	smithfamilyfuneralhomes.com.js	Empty Fetch Event Listener Disrupting Caching Logic	Medium	false	N/A	N/A	N/A	N/A	{The `fetch` event listener is empty, which prevents any caching or routing logic from being applied. This is a logic error, not a misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
4919	coring168.com.js	Regular Expression Denial of Service (ReDoS)	High	true	N/A	N/A	RegExp	standard	{The regular expression `coring168\\\\.com(?:/.*)?/ola/services/.*` is constructed from a JSON-parsed string and used in a route match. The `(?:/.*)?` pattern can lead to catastrophic backtracking when matched against maliciously crafted input, causing ReDoS. The use of `new RegExp()` or direct regex construction from untrusted or dynamic sources (here, via JSON.parse) without sanitization or validation is the root cause.}	"```const c = JSON.parse('[""coring168\\\\.com(?:/.*)?/ola/services/.*"",""coring168\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://93b523e6-fa99-4896-a28c-9e2e1dd62d5d\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4920	coring168.com.js	Cache Poisoning	Medium	true	N/A	N/A	importScripts	standard	{The code uses `importScripts()` to load external scripts, but the script URLs are dynamically constructed from parsed JSON data (e.g., `coring168.com/ola/meetings/.*`). If an attacker can manipulate the JSON source (e.g., via a compromised CDN or injection), they could inject malicious script URLs, leading to cache poisoning where the service worker loads and executes arbitrary code.}	```(0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkOnly());```
4921	coring168.com.js	Improper Input Validation	Medium	true	N/A	N/A	JSON.parse	standard	{The `JSON.parse()` function is used to parse a string containing potentially untrusted regular expressions and URLs. The input is not validated or sanitized before being used to construct regex patterns or route matches. This allows for injection of malformed or malicious patterns, leading to improper input validation and potential ReDoS or cache poisoning.}	"```const c = JSON.parse('[""coring168\\\\.com(?:/.*)?/ola/services/.*"",""coring168\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://93b523e6-fa99-4896-a28c-9e2e1dd62d5d\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
4922	coring168.com.js	Insecure Cache Configuration	Low	false	N/A	N/A	N/A	N/A	{The cache configuration uses `CacheFirst` with a long `maxAgeSeconds` (31536000 seconds = 1 year) and a high `maxEntries` (30). While this is a configuration issue, it does not stem from misuse of a sensitive function like `importScripts` or `JSON.parse`. It is a policy decision rather than a direct function misuse.}	"```new t.CacheFirst({ cacheName: ""google-fonts-webfonts"", plugins: [new a.CacheableResponsePlugin({ statuses: [0, 200] }), new n.ExpirationPlugin({ maxAgeSeconds: 31536e3, maxEntries: 30 })] });```"
4923	trockenbauspezialist.de.js	Cache Poisoning via Unverified Offline Page	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of verification of the offline page content, but it is not caused by misuse of a sensitive JavaScript function. The code fetches and caches a known offline URL, and there is no dynamic or untrusted input being passed to any sensitive function.}	```const cachedResponse = await cache.match(OFFLINE_URL);```
4924	redbullbcone.com.js	Improper Validation of Redirect Target	High	true	CWE-918	9	Request	standard	{The Request constructor is used with a URL derived from user-controlled input (t.url) via a regex replacement (t.url.replace(F, 'img.redbull.cn')). Since the original URL is not validated or sanitized, an attacker could craft a request with a malicious URL that, after replacement, points to an unintended or attacker-controlled domain. This allows for unintended redirections or data exfiltration, especially if the request is made to a domain that mimics a trusted one. The lack of validation of the resulting URL makes this a sensitive misuse of the Request API.}	```let s = new Request(t.url.replace(F, 'img.redbull.cn'), t);```
4925	pazaramatatil.com.js	CORS Bypass via Request Interceptor	High	true	CWE-497	9	N/A	standard	{The request interceptor modifies the request's cache and mode properties, potentially bypassing CORS restrictions by changing a 'no-cors' request to 'default', allowing cross-origin resource access that should be blocked. This misuse of the Request constructor with dynamic properties from intercepted requests enables unintended cross-origin behavior.}	```const requestInterceptor = { requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') { return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' }); } return request; }, ... };```
4926	pazaramatatil.com.js	Information Disclosure via Error Logging	Medium	false	CWE-200	0	N/A	standard	{The console.error() function is used to log error details, including potentially sensitive information such as error messages and context objects. However, this is not a misuse of a sensitive function per se, as console.error is not inherently dangerous unless used with untrusted or sensitive data in a context where logs are exposed to attackers. The vulnerability arises from logging behavior, not from a sensitive function misuse.}	```console.error(ctx.error, 'Details:', ctx);```
4927	emacs-china.org.js	XSS via Unsanitized User Input in Notification Reply	High	true	CWE-79	10	fetch	standard	{The fetch function is used to send a POST request with user-provided data from the notification reply (`e.reply`) directly in the request body without sanitization. This allows an attacker to inject malicious content, such as script tags, which could be executed if the server processes the input in a way that reflects it back to the client (e.g., in a response or via a redirect). Since the input is not escaped or validated, it constitutes a direct path for cross-site scripting (XSS).}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
4928	fbmproperty.com.js	Information Exposure Through Debug Logging	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from debug logging that exposes sensitive information via console.log when pwaSettings.debug is true. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by a configuration flaw in logging behavior. The log function itself is custom and does not inherently introduce risk unless called with sensitive data, which is not evident here.}	```log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
4929	mccomasfuneralhome.com.js	Improper Handling of No-CORS Fetch in Prefetch	High	true	CWE-200	9	N/A	standard	{The fetch() function is used with mode: 'no-cors', which prevents access to response data and headers, making it impossible to validate or use the response properly. This misuse leads to improper handling of the prefetch operation, as the response cannot be inspected or cached effectively, potentially causing silent failures or data loss.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
4930	mccomasfuneralhome.com.js	Empty Fetch Event Listener Interfering with Workbox	Medium	false	CWE-665	N/A	N/A	N/A	N/A	```self.addEventListener('fetch', () => {});```
4931	mccomasfuneralhome.com.js	Debug Logging Exposing Sensitive Information	Medium	false	CWE-200	N/A	N/A	N/A	N/A	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
4932	legamart.com.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the exposure of sensitive Firebase configuration keys (e.g., apiKey, authDomain) in the source code, not due to misuse of a sensitive JavaScript function. These keys are hardcoded and can be accessed by anyone who views the script, enabling unauthorized access to Firebase services.}	```importScripts('https://www.gstatic.com/firebasejs/10.1.0/firebase-app-compat.js');importScripts('https://www.gstatic.com/firebasejs/10.1.0/firebase-messaging-compat.js');const productionFirebaseConfig = { apiKey: 'AIzaSyCSpWUY9y-ewc48UW72JLN7Wd38K6wmbdQ'```
4933	morgridge.org.js	Custom Event Handler for Non-Standard Event	Medium	false	New	N/A	N/A	N/A	{The event 'refreshOffline' is not a standard browser event. While this does not directly involve a sensitive function, it may indicate custom logic that could be misused if not properly controlled. However, since no sensitive function like importScripts, eval, or dynamic code execution is involved, this is not a sensitive function misuse.}	"```self.addEventListener(""refreshOffline"", function () { const offlinePageRequest = new Request(offlineFallbackPage); return fetch(offlineFallbackPage).then(function (response) { return caches.open(CACHE).then(function (cache) { return cache.put(offlinePageRequest, response); }); }); });```"
4934	allaboutphilosophy.org.js	Cache Poisoning via Unrestricted Message Handler	High	true	CWE-285	9	caches.open	standard	{The caches.open function is used with a dynamically derived cache name (a.content) and then used to store arbitrary URLs passed via message event data (e.data.url). Since the message handler does not validate or sanitize the incoming URL, an attacker could send a malicious URL to be cached, potentially leading to cache poisoning where the service worker serves malicious content to users. The function is standard but misused due to lack of input validation.}	"```if (""object"" == typeof e.data && ""string"" == typeof e.data.action) switch (e.data.action) { case ""cache"": !function (e) { o(e) || caches.open(a.content).then(t => { t.match(e).then(t => t ? null : fetch(e)).then(n => n ? t.put(e, n.clone()) : null); }); }(e.data.url); break; default: console.log(""Unknown action: "" + e.data.action); }```"
4935	allaboutphilosophy.org.js	Improper Date Validation in Cache Expiry	Medium	false	CWE-20	0	N/A	N/A	{This issue stems from improper logic in calculating cache expiry based on a date header, but it does not involve misuse of a sensitive function. The code parses the date header and compares it with a TTL value, but the vulnerability is due to flawed logic, not a sensitive function call.}	"```if (a) { let c = parseInt((new Date().getTime() - a.getTime()) / 1e3), i = function (e) { if (""string"" == typeof e) { let t = function (e) { let t = e.split(""."").reverse()[0].split(""?"")[0]; return t.endsWith(""/"") ? ""/"" : t; }(e); return ""number"" == typeof s[t] ? s[t] : null; } return null; }(e.request.url); return i && c > i ? new Promise(c => fetch(e.request.clone()).then(a => { a ? (t.put(e.request, a.clone()), c(a)) : c(n); }).catch(() => { c(n); }))```"
4936	allaboutphilosophy.org.js	Insufficient Input Validation in Fetch Handler	Medium	false	CWE-20	0	N/A	N/A	{This vulnerability arises from insufficient validation of the request method and URL, but no sensitive function is misused. The code checks if the method is in a whitelist and whether a custom function o() returns false, but the issue is in logic and validation, not in the misuse of a sensitive API.}	"```return n || fetch(e.request.clone()).then(n => n.status < 400 ? (~l.indexOf(e.request.method) && !o(e.request.url) && t.put(e.request, n.clone()), n) : caches.open(a.notFound).then(e => e.match(""/404.htm""))).then(e => { if (e) return e; })```"
4937	grxbet.com.js	Uncontrolled Resource Consumption (Excessive Cache Entries)	High	false	N/A	0	N/A	N/A	{The vulnerability arises from setting `maxEntries: 99999999` in the `ExpirationPlugin`, which allows the cache to grow without practical bounds, leading to excessive memory and storage consumption. This is a configuration issue, not a misuse of a sensitive function.}	"```if (!self.define) { let e, t = {}; const s = (s, n) => (s = new URL(s + "".js"", n).href, t[s] || new Promise(t => { if (""document"" in self) { const e = document.createElement(""script""); e.src = s, e.onload = t, document.head.appendChild(e); } else e = s, importScripts(s), t(); }).then(() => { let e = t[s]; if (!e) throw new Error(`Module ${s} didn’t register its module`); return e; })); self.define = (n, i) => { const c = e || (""document"" in self ? document.currentScript.src : """") || location.href; if (t[c]) return; let o = {}; const r = e => s(e, c), m = { module: { uri: c }, exports: o, require: r }; t[c] = Promise.all(n.map(e => m[e] || r(e))).then(e => (i(...e), o)); }; } define([""./workbox-799b2a6b""], function (e) { ""use strict""; self.skipWaiting(), e.clientsClaim(), e.registerRoute(/^https:\/\/static\.grxbet\.com\/.*/i, new e.StaleWhileRevalidate({ cacheName: ""website-static-cached"", plugins: [new e.ExpirationPlugin({ maxEntries: 99999999, maxAgeSeconds: 21600 }), new e.CacheableResponsePlugin({ statuses: [0, 200] })] }), ""GET""), e.registerRoute(/^https:\/\/imagedelivery\.net\/.*/i, new e.CacheFirst({ cacheName: ""cf-static-images"", plugins: [new e.ExpirationPlugin({ maxEntries: 99999999, maxAgeSeconds: 21600 }), new e.CacheableResponsePlugin({ statuses: [0, 200] })] }), ""GET""); });```"
4938	planetafolha.com.br.js	Insecure Dynamic Code Evaluation	High	true	N/A	9	importScripts	standard	{The importScripts() function dynamically loads and executes a script from a URL specified by the swPath variable, which is derived from URL query parameters (swPath, swJSHost, version). Since these parameters are user-controllable, an attacker can manipulate them to inject arbitrary scripts, leading to remote code execution within the service worker context. This allows full control over the service worker’s behavior, including intercepting network requests, modifying cached content, and potentially stealing sensitive data.}	"```var version = ""v2.0.4"";var swPath;var urlObject = new URL(location);var host;if (urlObject.searchParams.get(""swPath"")) {  swPath = urlObject.searchParams.get(""swPath"");} else {  if (urlObject.searchParams.get(""version"")) {    version = urlObject.searchParams.get(""version"");  }  if (urlObject.searchParams.get(""swJSHost"")) {    host = ""https://"" + urlObject.searchParams.get(""swJSHost"");  } else {    host = ""https://sdki.truepush.com/sdk/"";  }  swPath = host + version + ""/sw.js"";}importScripts(swPath);```"
4939	lacelestina.co.js	Vulnerable Regular Expression in URL Parsing	High	true	N/A	9	N/A	standard	{The use of `new URL(event.request.url)` is standard and safe, but the subsequent regex `pathname.match(/:(.+)/)[1]` is vulnerable because it blindly extracts a substring from the pathname without validation. This can lead to unintended behavior or injection if the pathname contains unexpected or malicious patterns, especially when used to construct dynamic keys or routes.}	```const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1];```
4940	lacelestina.co.js	Insecure IndexedDB Key Handling	Medium	true	N/A	8	N/A	standard	{The function `idbKeyval.get()` is used with a dynamically constructed key derived from `pathname`, which is extracted from `new URL(event.request.url)`. Since the pathname is not sanitized or validated, an attacker could craft a URL with arbitrary path segments, leading to unauthorized access or manipulation of IndexedDB data via key injection.}	```const { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``); const resources = await idbKeyval.get(`resources:${pathname}`);```
4941	lacelestina.co.js	Unvalidated API Request Handling	High	true	N/A	9	N/A	standard	{The code uses `MessageAPI[data.api]()` where `data.api` is derived from user-controlled input via URL parsing. This constitutes a dangerous dynamic function call that can lead to arbitrary code execution if an attacker can inject a malicious API name into the request path. The `MessageAPI` object is exposed to untrusted input, making it a classic case of unsafe function invocation.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
4942	lacelestina.co.js	Insecure Redirect Handling	Medium	true	N/A	7	N/A	standard	{The `Location` header in the `Response` is set to `lastNavigationRequest`, which is derived from `event.request.url`. Since this value is directly taken from the request without validation or sanitization, it allows an attacker to perform open redirects by crafting a malicious URL, potentially leading to phishing or credential theft.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
4943	soapmedia.co.uk.js	Vulnerable Service Worker Caching Sensitive Data	Medium	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the broad caching policy that captures all requests via `new RegExp('/.*')`, which may inadvertently cache sensitive or dynamic content. This is a configuration issue, not a direct function misuse.}	```workbox.routing.registerRoute(new RegExp('/.*'), workbox.strategies.networkFirst({}), 'GET');```
4944	learningbeyondpaper.com.js	Cache Key Mismatch Vulnerability	High	false	New	N/A	N/A	N/A	{The vulnerability arises from inconsistent cache matching logic, not from misuse of a sensitive function. The code checks for cached responses using `cache.match(request)` and `cache.match(request.url)`, but the behavior depends on the `matchUrlFallback` flag, which may lead to mismatches in cache retrieval. This is a logic flaw, not a sensitive function misuse.}	```const cachedResponse = forceNetwork ? null : (await cache.match(request)) || (matchUrlFallback ? await cache.match(request.url) : null);```
4945	learningbeyondpaper.com.js	Cache Poisoning via URL Manipulation	Medium	true	CWE-113	N/A	addParams	standard	{The `addParams` function is used to construct URLs by appending parameters, including `TIMESTAMP: Date.now()`. While the parameter value is dynamically generated, the function itself is standard and safe. However, if the `urlToPrefetch` parameter is derived from untrusted input, it could lead to cache poisoning by allowing attackers to manipulate the URL structure and cache keys. The misuse lies in trusting the input to `addParams` without sanitization.}	```const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() });```
4946	learningbeyondpaper.com.js	Information Exposure Through Debug Logs	Medium	false	CWE-200	N/A	N/A	N/A	{This vulnerability stems from debug logs being output via `console.log` when `pwaSettings.debug` is true. The `console.log` function is standard and not inherently sensitive; the issue is the exposure of sensitive information in logs, not misuse of a sensitive function.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
4947	learningbeyondpaper.com.js	Insecure Cache Name Generation	Low	false	CWE-327	N/A	N/A	N/A	{The `toHash` function is custom and used to generate cache names from a hardcoded timestamp. Since the input is static and not derived from user input, there is no sensitive function misuse. The vulnerability is due to predictable hash generation, not improper function use.}	```const SITE_VERSION = toHash('1733332986000');```
4948	learningbeyondpaper.com.js	Broad Regex Cache Matching	Low	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from overly broad regular expressions used in `workbox.routing.registerRoute`, which may match unintended URLs. This is a configuration issue, not misuse of a sensitive function. The `registerRoute` function is used correctly; the problem is in the regex pattern design.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
4949	warsztat.pl.js	External Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted on pushpushgo.com. While the URL is not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a high-risk vulnerability because it allows an external entity to control the execution environment of the service worker. This can lead to unauthorized code execution, data exfiltration, or manipulation of network requests. The risk is elevated because the script is loaded from a domain not under the control of the application owner.}	```importScripts('https://s-eu-1.pushpushgo.com/655b450b2b207d722cd8802e/worker.js');```
4950	wildflourskitchen.com.js	Insecure Caching of Sensitive Data	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching the entire site root without proper validation or sanitization, which could allow an attacker to cache malicious content if the site is compromised. However, this is not due to misuse of a sensitive function but rather a design flaw in caching strategy.}	```const offlineFundamentals = [{ 'url': 'https://wildflourskitchen.com'```
4951	wildflourskitchen.com.js	Improper URL Validation in Cache Logic	Medium	false	N/A	N/A	N/A	N/A	{The code checks if a URL includes the site hostname and then validates it with new URL(t).hostname === siteHostname. While this may seem secure, it is vulnerable to bypasses if the URL is malformed or if the siteHostname is not properly sanitized. However, no sensitive function is misused here; the issue is in logic design.}	```if (!!t.includes(siteHostname) && new URL(t).hostname === siteHostname)```
4952	wildflourskitchen.com.js	Insecure IndexedDB Usage	Medium	false	N/A	N/A	N/A	N/A	{The IndexedDB usage is not inherently insecure, but the lack of proper sanitization or validation of stored data could lead to data leakage or tampering. However, no sensitive function is misused; the issue stems from insufficient data validation.}	```class ce { constructor() { this._db = null; }```
4953	wildflourskitchen.com.js	Insecure Background Sync Handling	Medium	true	N/A	N/A	fetch	standard	{The code uses fetch(e.request.clone()) without validating or sanitizing the request, which could allow an attacker to inject malicious requests if the request object is manipulated. The fetch function is a standard API that can execute arbitrary network requests when given untrusted input.}	```await fetch(e.request.clone());```
4954	wildflourskitchen.com.js	Insecure Cache Busting Mechanism	Low	false	N/A	N/A	N/A	N/A	{The version string is hardcoded and used for cache busting, but it does not involve any sensitive function misuse. The issue is a low-risk design choice rather than a security vulnerability caused by function misuse.}	```var version = 'v344781::';```
4955	ges.gov.gh.js	Vulnerable Regular Expression Logic in Cache Exclusion	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of a regular expression in the `checkNeverCacheList` function, which is called with `neverCacheUrls.every(checkNeverCacheList, e.request.url)`. The issue is not due to misuse of a sensitive JavaScript function like `importScripts` or `eval`, but rather from the logic flaw in how the `every` method is used with `this` context pointing to the regex pattern. The function incorrectly returns `false` when the regex matches, which inverts the intended exclusion logic. This is a logic error, not a sensitive function misuse.}	```if (this.match(url)) { return false; }```
4956	abuarab.net.js	Cache Poisoning	High	true	CWE-444	8	new URL	standard	{The code constructs a URL using `new URL(s.base, t.origin)` where `s.base` is derived from a message event's data. If an attacker can control the `s.base` value (e.g., via a malicious message sent to the service worker), they can craft a URL that points to an unintended or malicious resource. This can lead to cache poisoning, where the service worker caches and serves malicious content under the guise of legitimate resources. The `new URL` function is standard but becomes sensitive when used with untrusted input.}	```const P = (t, e, n, c) => { const o = t.fetch.bind(t), a = C(e); t.addEventListener('activate', s => { (async () => { try { s.waitUntil(t.caches.keys().then(i => Promise.all(i.map(d => { if (d !== y) return caches.delete(d); } )))); const r = await t.caches.open(y), u = (await r.keys()).map(i => i.url), f = p(e, u); await Promise.all(f.map(i => r.delete(i))); } catch (r) { console.error(r); } })(); }), t.addEventListener('message', async ({ data: s }) => { if (s.type === 'qprefetch' && typeof s.base == 'string') { const r = await t.caches.open(y), l = new URL(s.base, t.origin); Array.isArray(s.links) && E(e, n, c, r, o, l, s.links), Array.isArray(s.bundles) && m(e, r, o, l, s.bundles), Array.isArray(s.symbols) && m(e, r, o, l, w(a, s.symbols)); } }), t.addEventListener('fetch', s => { const r = s.request; if (r.method === 'GET') { const l = new URL(r.url); N(e, l.pathname) && s.respondWith(t.caches.open(y).then(u => (T(e, u, o, l), k(u, o, A, r)))); } }); }; Q(); addEventListener('install', () => self.skipWaiting()); addEventListener('activate', () => self.clients.claim());```
4957	artbynela.com.js	XSS via Untrusted Input in Notification URLs	High	true	CWE-79	N/A	self.addEventListener('push'	standard	{The 'performer' value is extracted from the push event data (evt.data.text()), which is untrusted input. This value is then used directly in the notification title and image URL (via 'performer + '.jpg'). If an attacker can control the push message content, they can inject malicious payloads into the notification, leading to XSS when the notification is rendered in the browser. The sensitive function responsible is 'self.registration.showNotification()', a standard API that renders notifications with user-provided content.}	```self.addEventListener('push', evt => { const performer = evt.data && evt.data.text(); evt.waitUntil(self.registration.showNotification(performer + ' is online', { tag: performer, icon: 'https://pwa.oohcams.com/images/icons/icon-192x192.png', image: 'https://pwa.oohcams.com/images/stills/' + performer + '.jpg', actions: [{ action: 'chat', title: 'Chat' }] })); });```
4958	artbynela.com.js	XSS via Untrusted Input in Notification URLs	High	true	CWE-79	N/A	self.addEventListener('notificationclick'	standard	{The 'performer' value is extracted from the notification tag (evt.notification.tag), which is derived from the push event data and thus untrusted. This value is then used to construct a URL ('https://pwa.oohcams.com/cam/' + performer + '?notif=1') passed to 'clients.openWindow()', which opens the URL in a new window. If the attacker controls the performer value, they can craft a URL that leads to malicious content or triggers XSS if the target page processes the URL unsafely. The sensitive function responsible is 'clients.openWindow()', a standard API that opens URLs without sanitization.}	```self.addEventListener('notificationclick', evt => { const performer = evt.notification.tag; const targetUrl = 'https://pwa.oohcams.com/cam/' + performer + '?notif=1'; evt.notification.close(); evt.waitUntil(clients.openWindow(targetUrl)); });```
4959	rls.de.js	Open Redirect via Unvalidated Notification URL	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted data (in this case, event.notification.data.url), and no validation or sanitization is performed, it allows an attacker to redirect users to arbitrary websites, leading to open redirect vulnerabilities. The URL is dynamically assigned based on potentially malicious input from the notification payload, which is not validated against a whitelist or sanitized.}	```var url = fallback_notification_url; if (event.notification.data && event.notification.data.url) { url = event.notification.data.url; } event.waitUntil(clients.openWindow(url));```
4960	tippland.de.js	Improper Error Handling in Service Worker	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to improper error handling during fetch operations, but it does not stem from misuse of a sensitive function. The code correctly handles network failures by falling back to a cached offline page, which is a standard and safe pattern. No sensitive function is being misused here.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp; } })()); } });```
4961	rustez.com.js	Insecure CSRF Token Handling	High	true	CWE-352	9	N/A	standard	{The vulnerability arises from the use of `fetch()` with a dynamically constructed URL that includes a path parameter derived from the request URL. While `fetch()` itself is not inherently unsafe, its misuse here—by passing unvalidated and unsanitized user-controlled path data directly into the URL without proper sanitization or validation—enables an attacker to manipulate the request path and potentially bypass CSRF protections. This constitutes improper use of a standard function in a context where user input is not adequately sanitized.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4962	rustez.com.js	Open Redirect in Notification Click	High	true	CWE-601	10	N/A	standard	{The `navigate()` method is used with a URL derived from the `data.url` field of a notification, which is obtained from a push event. Since this data is controlled by the server and potentially by an attacker (via push notifications), and no validation or sanitization is performed on `data.url`, an attacker can craft a notification with a malicious URL, leading to an open redirect. This is a direct misuse of the standard `navigate()` function with untrusted input.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
4963	rustez.com.js	Improper Validation of Request Path for CSRF Token	Medium	true	CWE-20	9	N/A	standard	{The `fetch()` function is used to retrieve a CSRF token by constructing a URL that includes the `path` parameter derived from the request URL. Since the `path` is extracted from the request URL without validation or sanitization, an attacker can manipulate the request path to trigger unintended behavior, such as fetching tokens for other endpoints or bypassing security checks. This misuse of `fetch()` with untrusted input leads to improper validation.}	```let url = new URL(curRequest.url); let path = url.pathname; fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
4964	rustez.com.js	Potential SSRF via Untrusted ID Parameter	Medium	true	CWE-918	8	N/A	standard	{The `fetch()` function is used to retrieve notification data by constructing a URL that includes an `id` parameter obtained from the push event data. Since the `id` is controlled by the server and potentially by an attacker, and no validation is performed, an attacker could supply a malicious ID that causes the service worker to make an internal request to unintended endpoints, potentially leading to SSRF. This is a misuse of `fetch()` with untrusted input.}	```const { id } = pingData; fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`)```
4965	emby.tv.js	External Dependency Vulnerability	Medium	false	N/A	0	N/A	N/A	{The use of importScripts with a hardcoded external URL does not constitute sensitive function misuse, as the URL is not derived from untrusted or dynamic input. While it introduces a dependency on an external script, it does not involve dynamic or user-controlled input that could lead to injection or arbitrary code execution.}	```importScripts('https://cdn.pushwoosh.com/webpush/pushwoosh-service-worker.js');```
4966	51jiaoxi.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The function `fetch()` is used with `event.request.url`, which is derived from the incoming fetch event. Since the service worker does not validate or sanitize the URL, an attacker can manipulate the request to target internal or external resources, leading to SSRF. The `fetch()` function is a standard JavaScript API that blindly executes network requests based on the provided URL, making it sensitive when used with untrusted input.}	```const fetchRengeData = function (event) { var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]); console.log('Range request for', event.request.url, ', starting position:', pos); event.respondWith(caches.open(CACHE_VERSIONS.content).then(function (cache) { return cache.match(event.request.url); }).then(function (res) { if (!res) { return fetch(event.request).then(res => { return res.arrayBuffer(); }); } return res.arrayBuffer(); }).then(function (ab) { return new Response(ab.slice(pos), { status: 206, statusText: 'Partial Content', headers: [['Content-Range', 'bytes ' + pos + '-' + (ab.byteLength - 1) + '/' + ab.byteLength]] }); })); };```
4967	soulslive.com.js	Server Side Request Forgery (SSRF) via Unvalidated Fetch Requests	High	true	N/A	N/A	RegExp	standard	{The vulnerability arises from the use of dynamically generated regular expressions from user-controlled or untrusted input (via JSON.parse) to match URLs in route registration. Although the regex patterns are hardcoded in the JSON string, the use of new RegExp() with untrusted input (even if static) can lead to SSRF if the patterns are manipulated to allow arbitrary URL matching. In this case, the patterns are fixed, but the dynamic construction via JSON.parse and new RegExp() introduces risk if the input were to be controlled by an attacker. The route is then used with NetworkOnly strategy, which directly fetches from the matched URL without validation, enabling SSRF.}	"```const c = JSON.parse('[""soulslive\\\\.com(?:/.*)?/ola/services/.*"",""soulslive\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://1b87f380-43a3-49eb-b3c6-169414e09e82\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e)), (0, e.registerRoute)(({ url: e }) => c.some(t => t.test(e.href)), new t.NetworkOnly());```"
4968	soulslive.com.js	Insecure Cache Configuration	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the configuration of the cache expiration policy with a long maxAgeSeconds (2592e3 seconds = 30 days) and a high maxEntries (100), which may lead to stale or excessive caching of resources. However, this is not caused by misuse of a sensitive function, but rather by poor configuration choices. The CacheFirst strategy and ExpirationPlugin are used correctly, but the parameters are set in a way that may compromise security or performance.}	```(0, e.registerRoute)(({ request: e }) => 'image' === e.destination || 'font' === e.destination, new t.CacheFirst({ cacheName: 'images-fonts', plugins: [new a.CacheableResponsePlugin({ statuses: [200] }), new n.ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 2592e3 })] }));```
4969	soulslive.com.js	Improper Input Validation in Cache Key Generation	Medium	false	N/A	N/A	N/A	N/A	{The function b(e) generates a cache key by creating a URL object from the input, clearing the hash, and returning the href. While this function does not directly use a sensitive function, it processes input without sufficient validation, potentially allowing cache key collisions or unintended caching behavior. However, since the input is not dynamically sourced from untrusted data (e.g., user input or query parameters), and the function is used internally within the service worker, it does not constitute misuse of a sensitive function.}	```function b(e) { const t = new URL(e, location.href); return t.hash = '', t.href; }```
4970	barbasbellfires.com.js	Improper URL Filtering in Service Worker	High	true	CWE-732	9	neverCacheUrls.every	standard	{The vulnerability arises from improper URL filtering using `neverCacheUrls.every(checkNeverCacheList, e.request.url)`. The `every` method is called on an array of regular expressions, but the second argument (context) is set to `e.request.url`, which is a string. This causes `checkNeverCacheList` to be called with `this` bound to the URL string, not the regex. As a result, `this.match(url)` becomes `url.match(url)`, which is always true for any string, rendering the filtering logic ineffective. This allows any request to bypass the intended exclusion rules, potentially enabling unintended caching or access to sensitive endpoints.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('Current request is excluded from cache: ' + e.request.url); return; }```
4971	skylog.app.js	Cache Poisoning via Unvalidated Response Caching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching responses without validating their origin or integrity, but it is not directly caused by misuse of a sensitive function like importScripts or eval. The caching behavior is inherent to the service worker's fetch handler logic, not a specific sensitive function call.}	```self.addEventListener('fetch', function (evt) { evt.respondWith(caches.match(evt.request).then(function (response) { return response || fetch(evt.request); })); });```
4972	saat24.news.js	External Script Import from Untrusted Source	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., van.najva.com), it introduces a high-risk vulnerability because the script may be controlled by an attacker or compromised, allowing arbitrary code execution within the service worker context. This can lead to cache manipulation, network request interception, or data exfiltration.}	```importScripts('https://van.najva.com/static/js/scripts/saat24-1444-6ee496b4-cf3b-426e-a95c-095f681dbc54-service-worker.js');```
4973	fapnet.com.br.js	Incorrect Cache Exclusion Logic	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from incorrect logic in the `every` method usage with `checkNeverCacheList`, which is not properly designed to return `false` when a URL matches any regex in `neverCacheUrls`. This is a logical error, not misuse of a sensitive function.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) {```
4974	fapnet.com.br.js	Mixed Content Cache Key	Medium	false	N/A	N/A	N/A	N/A	{The cache name uses `http://` while the site uses `https://`, which may cause issues with mixed content or cache isolation, but this is a configuration issue, not misuse of a sensitive function.}	```const cacheName = 'http://www.fapnet.com.br-superpwa-2.2.31'; const startPage = 'https://www.fapnet.com.br'; const offlinePage = 'https://www.fapnet.com.br/';```
4975	fapnet.com.br.js	Unreliable Online Status Check	Medium	false	N/A	N/A	N/A	N/A	{The use of `navigator.onLine` is unreliable for determining actual network connectivity, but it is not a sensitive function misuse—it’s a design flaw in network detection logic.}	```if ((e.request.mode === 'navigate' || e.request.mode === 'cors') && navigator.onLine) {```
4976	fapnet.com.br.js	Incomplete Cache Deletion Logic	Medium	false	N/A	N/A	N/A	N/A	{The logic deletes old caches but does not handle errors or ensure all non-matching caches are removed; this is a logic flaw, not misuse of a sensitive function.}	```if (key !== cacheName) { console.log('SuperPWA old cache removed'```
4977	telepharm.io.js	Improper Input Validation in Cache Key Generation	High	true	CWE-20	9	replace	N/A	{The `replace` method is used on `getDemoUrl()` which is derived from `event.request.url`, a dynamic input. Since the URL is not sanitized or validated before being used to generate a cache key, an attacker could craft a URL with malicious content (e.g., path traversal or injection) that could lead to cache poisoning or unintended cache behavior. The function is standard but misused due to lack of input validation.}	```const demoUrl = getDemoUrl(); if (!demoCache.cachedUrls.includes(demoUrl)) { demoCache.cachedUrls.push(demoUrl); if (demoUrl.includes('webm')) { demoCache.cachedUrls.push(demoUrl.replace('webm', 'mp4')); } }```
4978	telepharm.io.js	Insecure Caching of Sensitive API Responses	High	true	CWE-311	9	fetch	N/A	{The `fetch` function is used to retrieve API responses, and the response data is stored in `demoCache.apiRequests` without proper sanitization or access control. Since the cache key is derived from request headers and body (which may be user-controlled), an attacker could potentially inject or manipulate sensitive data into the cache, leading to information exposure or replay attacks. The function is standard but misused due to lack of secure caching practices.}	```if (event.recordForDemo) { return fetch(event.request).then(response => { if (!demoCache.apiRequests[demoKey]) { void response.clone().arrayBuffer().then(responseArrayBuffer => { demoCache.apiRequests[demoKey] = { data: arrayBufferToBase64(responseArrayBuffer), status: response.status, statusText: response.statusText, headers: Array.from(response.headers.entries()) }; }); } return response; }); }```
4979	telepharm.io.js	Weak Authentication for Demo Archive Access	Medium	false	CWE-285	0	N/A	N/A	{The vulnerability arises from weak authentication logic, not from misuse of a sensitive JavaScript function. The `getDemoArchive` function is called with a custom header, but the issue is in the authentication mechanism, not in the function's usage.}	```if (type === 'authenticateDemo') { if (isRecordingDemo) { return respondWith(true); } if (!clientData.secret) { return respondWith(false); } return getDemoArchive({ headers: { 'tp-demo-secret': clientData.secret } }).then(demoArchive => { respondWith(Boolean(demoArchive)); }).catch(() => { return respondWith(false); }); }```
4980	telepharm.io.js	Cache Poisoning via Unvalidated CDN Requests	High	true	CWE-113	8	fetch	N/A	{The `fetch` function is used to retrieve resources from a transformed request URL derived from `event.request.url`. Since the URL is not validated before being passed to `fetch`, an attacker could manipulate the request to fetch and cache malicious content from an unintended source, leading to cache poisoning. The function is standard but misused due to lack of input validation.}	```return transformAWSRequest(event.request).then(httpRequest => { return fetch(httpRequest).then(response => { if (!response.ok) { return response; } return cache.put(event.request, response.clone()).then(() => response).catch(e => { console.log(`${e.name} when caching request: ${event.request.url}`); return response; }); }); });```
4981	telepharm.io.js	Information Exposure Through Error Messages	Medium	false	CWE-200	0	N/A	N/A	{The vulnerability stems from the exposure of error messages in the `notFoundForDemo` function, which is not caused by misuse of a sensitive JavaScript function. The issue is in the error handling logic, not in the function's usage.}	```return notFoundForDemo(event, cacheName, key);```
4982	moriyashrine.org.js	Insecure Handling of Authentication State Leading to Privilege Escalation	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of the `loggedIn` state derived from the URL, not from misuse of a sensitive JavaScript function. The code parses `loggedIn=true|false` from the URL and uses it to skip certain logic, but this is a logic flaw rather than a direct misuse of a sensitive function like `eval`, `importScripts`, or `fetch` with untrusted input.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
4983	moriyashrine.org.js	XSS via Unsanitized Notification Content	Medium	true	N/A	N/A	self.registration.showNotification	standard	{The `self.registration.showNotification` function is used with user-controlled `title` data from the server response without sanitization. Since the notification title is rendered in the browser UI and may contain HTML or script, an attacker could inject malicious content via the server response, leading to XSS. The function is standard and directly responsible for the vulnerability.}	```return self.registration.showNotification(title, options);```
4984	moriyashrine.org.js	Open Redirect via Unvalidated Notification URL	Medium	true	N/A	N/A	clients[0].navigate	standard	{The `clients[0].navigate` function is called with a URL derived from `data.url`, which is obtained from a server response without validation. If an attacker can manipulate the server response to include a malicious URL, this function will redirect the user to that URL, enabling open redirect. The function is a standard browser API and directly responsible for the vulnerability.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
4985	vision-net.de.js	High	High	false	CWE-548	N/A	N/A	N/A	{The vulnerability is due to hardcoded Firebase configuration credentials (API key, project ID, etc.) being exposed in the service worker script. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure exposure of secrets in client-side code.}	```const firebaseConfig = { apiKey: 'AIzaSyDh0qVnFtFzklmu-A7PLFRZwrAFdWUeIP0', authDomain: 'visionwebnotification.firebaseapp.com', projectId: 'visionwebnotification', storageBucket: 'visionwebnotification.appspot.com', messagingSenderId: '246366729867', appId: '1:246366729867:web:5dacc8e3db2cca9b29068e' };```
4986	palmbeachhealthnetwork.com.js	Incorrect URL Matching in Service Worker Route	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from incorrect URL matching logic in the `matchAPI` function, which uses `url.pathname === '//locations/GetFacilities'`. This is logically flawed because `pathname` does not include the leading `//`, making the condition always false. The issue is not due to misuse of a sensitive function but rather a logical error in string comparison.}	```const matchAPI = ({url, event}) => { return url.pathname === '//locations/GetFacilities' || url.host === serviceURLdomain; };```
4987	primaria-iasi.ro.js	Improper Input Validation - Arbitrary URL Redirection	High	true	CWE-20	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the specified URL. In this case, the URL is derived from self.objNotificare.url, which is obtained from event.data.json() — meaning it originates from a push notification payload. Since push notification data is untrusted and can be controlled by an attacker, passing it directly to clients.openWindow() without validation or sanitization allows for arbitrary URL redirection, potentially leading to phishing, malware distribution, or other malicious actions.}	```event.waitUntil(clients.openWindow(self.objNotificare.url));```
4988	bzpower.com.js	Insecure Reliance on Client-Side Authentication Check	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from client-side logic that parses the URL for a `loggedIn` parameter to determine authentication state, which can be trivially manipulated by an attacker. This is not caused by misuse of a sensitive JavaScript function, but rather by insecure logic design.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
4989	bzpower.com.js	Open Redirect in Notification Handling	Medium	true	N/A	N/A	clients[0].navigate	standard	{The `clients[0].navigate(data.url)` function is used to redirect the user to a URL provided in the notification data. Since this URL is derived from server responses and not validated or sanitized, an attacker could craft a malicious notification payload to redirect users to arbitrary domains, leading to open redirect.}	```clients[0].navigate(data.url);```
4990	bzpower.com.js	Potential SSRF via Unvalidated ID in Push Event	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received in a push event. If the `id` is not validated or sanitized, an attacker could supply a malicious value (e.g., `http://internal-service:8080`) to trigger a server-side request to internal or unintended endpoints, leading to SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
4991	sopro.com.js	Improper Caching Strategy	Medium	false	New	N/A	N/A	N/A	{The vulnerability is related to caching strategy, not misuse of a sensitive function. The code uses caches.open() and caches.match() appropriately with no dynamic or untrusted input. There is no evidence of sensitive function misuse that would lead to security risks such as injection or unauthorized execution.}	```e.waitUntil(caches.open(cacheName).then(function (cache) {}));```
4992	stevemcconnell.com.js	Unrestricted External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL includes a dynamically generated query parameter (cur_date), which is derived from the current timestamp. While the source domain (cdn.subscribers.com) is fixed and not user-controlled, the dynamic query parameter does not introduce direct injection risk. However, the vulnerability classification as 'Unrestricted External Script Import' implies a broader concern: the script is imported from an external, potentially untrusted domain. Since the domain is hardcoded and not derived from user input, the risk is lower than if the domain were user-supplied. Nevertheless, the use of importScripts() with any external source introduces a potential attack surface if the external script is compromised or if the domain is later changed to a malicious one. Thus, while not directly caused by user-controlled input, the misuse lies in trusting an external script without proper integrity verification (e.g., subresource integrity).}	"```var cur_date = Math.floor(new Date()); importScripts(""https://cdn.subscribers.com/assets/subscribers-sw.js?"" + cur_date);```"
4993	bongdalu42.com.js	Open Redirect via Service Worker Cache	High	true	CWE-601	10	N/A	standard	{The Response.redirect() function is used with unvalidated user-controlled data (latestDomain and backupDomain), which are derived from JSON responses fetched from potentially untrusted sources. Since these values are not sanitized or validated, an attacker could manipulate the backend data to redirect users to malicious domains, leading to open redirect vulnerabilities.}	```return Response.redirect(latestDomain);```
4994	bongdalu42.com.js	Open Redirect via Service Worker Cache	High	true	CWE-601	10	N/A	standard	{The Response.redirect() function is used with unvalidated user-controlled data (backupDomain), which is derived from JSON responses fetched from potentially untrusted sources. Since this value is not sanitized or validated, an attacker could manipulate the backend data to redirect users to malicious domains, leading to open redirect vulnerabilities.}	```return Response.redirect(backupDomain);```
4995	bongdalu42.com.js	Insecure Dynamic Redirect Handling	Medium	false	CWE-602	0	N/A	N/A	{The conditional logic using location.hostname is not directly tied to a sensitive function misuse; it is a logic decision based on hostname, not a function that introduces dynamic execution or injection.}	```const url = location.hostname.toLowerCase().indexOf('live') > -1 ? apiUrl_live : apiUrl;```
4996	bongdalu42.com.js	Insecure Cache Initialization	Medium	false	CWE-920	0	N/A	N/A	{The cache.addAll() function is used with hardcoded URLs (apiUrl, apiUrl_live), which are not derived from untrusted input. Therefore, no sensitive function misuse is present.}	```return cache.addAll([apiUrl, apiUrl_live]);```
4997	bongdalu42.com.js	Unvalidated Redirect Target	High	true	CWE-602	10	N/A	standard	{The data.curl value is retrieved from a remote JSON response and assigned to latestDomain without validation or sanitization. This value is then used in Response.redirect(), which is a sensitive function that can be exploited to redirect users to arbitrary domains if the source data is compromised.}	```const latestDomain = data.curl;```
4998	livelikeyouarerich.com.js	Vulnerable Cache Key Generation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache keys during precaching, but no sensitive function is misused. The issue stems from logic flaws in cache key generation rather than direct misuse of a function like importScripts or eval.}	```const { cacheKeyWillBeUsed } = this._strategy;```
4999	livelikeyouarerich.com.js	Insecure Dynamic Caching	High	true	N/A	N/A	j	standard	{The j function is used to register routes dynamically based on URL patterns derived from user-controlled inputs (e.g., via request URLs). Since the route matching logic is based on dynamic URL patterns and the handler may cache or serve content based on these, an attacker could craft a request to trigger unintended caching or bypass security checks, leading to information disclosure or cache poisoning.}	```j(function (e) { if (!e.url) return !1; var t = e.url.href; return !!t && 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname; })```
5000	livelikeyouarerich.com.js	Insecure Cache Busting	Medium	true	N/A	N/A	new URL	standard	{The new URL constructor is used with dynamic inputs (e.g., from e.url) to generate URLs for cache keys. If the input is not properly sanitized or validated, an attacker could inject malicious URLs or manipulate cache keys, leading to cache poisoning or bypassing cache validation. The function is standard but misused with untrusted data.}	"```const { revision: t, url: s } = e; if (!s) throw new r(""add-to-cache-list-unexpected-type"", { entry: e }); if (!t) { const e = new URL(s, location.href); return { cacheKey: e.href, url: e.href }; }```"
5001	livelikeyouarerich.com.js	Weak Cache Validation	Medium	true	N/A	N/A	async function	standard	{The async function is used to validate cache responses, but the validation logic is weak and may not properly check for tampering or integrity. Since the function is called with dynamic inputs (e.g., from network responses), an attacker could exploit this to bypass validation and inject malicious content into the cache.}	```async function (e```
5002	wellsfuneralhome.com.js	Insecure Cache Poisoning via Broad Regex in registerRoute	High	true	CWE-434	9	N/A	standard	{The regex /.*?irp\\.cdn-website\\.com.*?/ used in workbox.routing.registerRoute is overly broad and may match unintended URLs, including those controlled by an attacker. This allows an attacker to poison the cache by injecting malicious content via a URL that matches the pattern, leading to cache poisoning and potential code execution or data leakage. The sensitive function workbox.routing.registerRoute is standard and misused due to insufficient URL specificity.}	```workbox.routing.registerRoute(/.*?irp\\.cdn-website\\.com.*?/, cacheFirst(SITE_ASSETS_CACHE_NAME));```
5003	wellsfuneralhome.com.js	Debug Mode Enabled in Production	Medium	false	CWE-200	N/A	N/A	N/A	{Debug mode is enabled via pwaSettings.debug = true, which may expose sensitive information in logs or enable verbose output in production. However, this is not caused by misuse of a sensitive function but rather a configuration issue.}	```pwaSettings.debug = true;```
5004	wellsfuneralhome.com.js	Potential XSS via addParams Function	Medium	true	CWE-79	8	N/A	custom	{The addParams function constructs URLs by appending user-supplied parameters without proper sanitization. If the parameters are derived from untrusted input, an attacker could inject malicious values (e.g., JavaScript) into URLs, leading to XSS when the URL is rendered or processed by the browser. The function is custom and misused due to lack of input validation.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
5005	wellsfuneralhome.com.js	Insecure Fetch with 'no-cors' Mode	Medium	true	CWE-434	7	N/A	standard	{The fetch call uses mode: 'no-cors', which prevents the browser from sending credentials and may result in silent failures or unexpected behavior when fetching resources. More critically, if the URL is constructed from untrusted input (e.g., via addParams), it could lead to unintended resource fetching or cache poisoning. The fetch API is standard and misused due to improper mode selection and lack of input validation.}	```fetch(new Request(url, { mode: 'no-cors' }));```
5006	wellsfuneralhome.com.js	Use of Weak Hash Function in toHash	Low	false	CWE-327	N/A	N/A	N/A	{The toHash function uses a simple hash algorithm (DJB2) which is not cryptographically secure. However, this is not a sensitive function misuse in the context of security vulnerabilities like injection or cache poisoning, but rather a cryptographic weakness.}	```function toHash(str) { var hash = 5381, i = str.length; while (i) { hash = hash * 33 ^ str.charCodeAt(--i); } return hash >>> 0; }```
5007	andermatt.ch.js	Cache Key Manipulation via Accept-Language Header	High	true	CWE-918	10	JSON.stringify	standard	{The code constructs a cache key by appending a JSON stringified object containing the Accept-Language header value to the request URL. Since the Accept-Language header is user-controlled, an attacker can manipulate it to generate arbitrary cache keys, leading to cache poisoning or bypassing cache validation. This misuse of JSON.stringify in a context where user input is directly embedded into cache keys without sanitization or validation enables cache key manipulation.}	```if (c) && (t += JSON.stringify({\'Accept-Language\': c})), t;```
5008	soportehys.com.js	Insecure Caching of Unvalidated Resources	High	true	N/A	N/A	cacheKeyWillBeUsed	standard	{The cacheKeyWillBeUsed plugin hook is used to modify the cache key for requests, but if it is not properly validated or sanitized, it can allow attackers to cache arbitrary URLs or manipulate cache keys, leading to cache poisoning or bypassing security controls. This is a sensitive function because it directly influences how resources are stored and retrieved from the cache.}	```const { cacheKeyWillBeUsed } = this._strategy```
5009	soportehys.com.js	Lack of Integrity Checks in Network Requests	Medium	true	N/A	N/A	Request	standard	{The Request constructor is used to create a new request object from a URL or another request, but if the input URL is not validated or sanitized, it can lead to unintended network requests or bypassing security policies. This is a sensitive function because it initiates network communication and can be exploited to access unauthorized resources.}	```const i = new Request(e```
5010	soportehys.com.js	Potential XSS via Unsanitized Notification Data	High	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used to parse the push notification data, but if the parsed data is not sanitized before being used in the notification title or body, it can lead to XSS attacks when rendered in the browser. This is a sensitive function because it processes untrusted input and can execute arbitrary JavaScript if not handled securely.}	```var n = JSON.parse(t.data.text())```
5011	soportehys.com.js	Insecure URL Handling in Notification Click	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used to open a URL from notification data, but if the URL is not validated or sanitized, it can lead to open redirects or phishing attacks. This is a sensitive function because it directly navigates the user to a potentially malicious URL based on untrusted input.}	```clients.openWindow(e.data.url);```
5012	esquelasweb.com.js	Cache Deletion During Activation Breaks Offline Functionality	High	false	N/A	0	N/A	N/A	{The vulnerability arises from the service worker deleting all caches during activation, which includes caches that may be required for offline functionality. This behavior is not due to misuse of a sensitive function, but rather a design flaw in cache management. The function `caches.delete()` is used correctly in terms of syntax and intent, but the logic of deleting all caches is problematic. Since no untrusted or dynamic input is used to influence the cache names being deleted, and the function is not being misused in a way that introduces security risks (e.g., injection, arbitrary code execution), this is not a sensitive function misuse.}	```self.addEventListener('activate', function (event) { event.waitUntil(caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { return caches.delete(cacheName); })); })); });```
5013	weigelfuneral.com.js	Cache Poisoning via Broad Regex	High	true	New	N/A	importScripts	standard	{The importScripts() function is used to load a script from a hardcoded CDN URL (staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js'). While the URL is not dynamic or user-controlled, the vulnerability lies in the broad regex patterns used in workbox.routing.registerRoute() to cache resources. These patterns are overly permissive (e.g., /.*?jquery.*?(?:\.min)?\.js.*?/), allowing any URL matching the pattern to be cached, potentially including malicious or unintended resources. However, since importScripts() is not directly involved in the cache poisoning, this is not a direct misuse of importScripts(). Therefore, the sensitive function responsible is not importScripts() but rather the routing patterns themselves. But since the question asks for sensitive function misuse, and importScripts() is not misused here, we must mark this as false.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
5014	weigelfuneral.com.js	Information Exposure via Debug Logs	Low	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from pwaSettings.debug = true, which enables console logging. This is not caused by misuse of a sensitive function but rather by a configuration setting that exposes debug information. No sensitive function is misused here.}	```pwaSettings.debug = true;```
5015	weigelfuneral.com.js	Insecure Cache Deletion via Message Handler	Medium	false	New	N/A	N/A	N/A	{The vulnerability stems from the message handler allowing deletion of a specific cache (SITE_PAGES_CACHE_NAME) via a command. This is a logic flaw, not a misuse of a sensitive function. The function self.addEventListener is used correctly; the issue is in the exposed API surface, not in the function itself.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { ... });```
5016	weigelfuneral.com.js	Unvalidated No-CORS Fetch in Prefetch	Medium	false	New	N/A	N/A	N/A	{The fetch() call with mode: 'no-cors' is used in prefetchUrl(). While this can lead to issues if the resource is not CORS-enabled, it is not a misuse of a sensitive function per se. The fetch() function is used as intended, but the lack of validation on the URL or response handling introduces risk. However, since the URL is constructed from a known base and not user-controlled, and the function is not misused in a way that introduces dynamic, untrusted input, this is not a sensitive function misuse.}	```fetch(new Request(url, { mode: 'no-cors' }));```
5017	gemioli.com.js	Insecure Storage of Sensitive Data	Medium	false	CWE-311	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function but rather by insecure storage practices, such as storing sensitive data (e.g., FCM tokens) in IndexedDB without proper encryption or access controls. The code uses IndexedDB via standard APIs like `indexedDB.open` and `transaction`, but the issue lies in the data handling policy, not the function misuse.}	```let i = yield _e(e.firebaseDependencies);```
5018	orixcredit.co.jp.js	Vulnerable Regular Expression in Cache Strategy	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a poorly defined regular expression in the cache strategy, which may match unintended resources. However, this is not due to misuse of a sensitive function, as the regex is static and does not involve dynamic or untrusted input.}	```workbox.routing.registerRoute(/img_visual.*\.(?:png|jpg|jpeg|svg|gif|webp)/, workbox.strategies.cacheFirst({ cacheName: 'image-cache', plugins: [new workbox.expiration.Plugin({ maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 7 })] }));```
5019	orixcredit.co.jp.js	Unrestricted URL Parameter Ignoring in Precaching	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from the use of a broad regular expression `/./` in `ignoreUrlParametersMatching`, which causes all URL parameters to be ignored during precaching. This is a configuration issue, not a misuse of a sensitive function, as no dynamic or untrusted input is involved.}	```workbox.precaching.addRoute({ directoryIndex: 'index.html', ignoreUrlParametersMatching: [/./] });```
5020	juzichu.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the misuse of the `URL` constructor and its manipulation via `hostname` and `search` properties. The `originalRequest.url` is derived from user-controlled input (the request URL), and this value is used to construct a new URL object. The `hostname` is then replaced with a hardcoded backup domain, but the `search` parameter is built using `currentUrl.host`, which is also derived from the original request. This allows an attacker to craft a request with a malicious host in the URL, which is then included in the `od=` parameter of the backup URL. Although the hostname is overwritten, the `search` parameter is not sanitized, enabling SSRF by injecting arbitrary parameters into the backup request. The `URL` object is a standard JavaScript API, and its misuse here allows an attacker to influence the destination of the backup fetch, potentially leading to unauthorized access to internal resources.}	```const backupUrl = new URL(originalRequest.url); backupUrl.hostname = backupDomain; const currentUrl = new URL(originalRequest.url); let search = currentUrl.search; if (!search) { search = '?'; } else { search += '&'; } search += 'od=' + currentUrl.host; backupUrl.search = search;```
5021	omdo.org.js	Open Redirect via Third-Party Domain	High	true	CWE-601	10	N/A	standard	{The vulnerability arises from the misuse of the `new Response()` constructor with a dynamically generated `Location` header. The `backupUrl` is constructed using `new URL(originalRequest.url)` and then modified by setting its hostname to `backupDomain` and appending a search parameter derived from `currentUrl.host`. Since `currentUrl.host` is derived from the original request URL (which is user-controlled), an attacker can manipulate the host in the request to redirect users to arbitrary domains under the attacker’s control. The `new Response()` function is a standard JavaScript API used to create HTTP responses, and when used with unsanitized user input in the `Location` header, it enables open redirect attacks.}	```return new Response('', { status: 302, headers: { 'Location': backupUrl.toString() } });```
5022	yingxinhe.com.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The vulnerability arises from the misuse of the `new URL()` constructor and `URL.search` assignment, which are standard JavaScript functions. The `originalRequest.url` is used to construct a new URL object, and its `hostname` is replaced with `backupDomain`. However, the `search` parameter is dynamically built using `currentUrl.host`, which is derived from the original request's URL. Since the original request URL is under user control, an attacker can manipulate it to inject arbitrary query parameters, including malicious redirects. The `Location` header in the response is set to this constructed URL, enabling an open redirect attack.}	```const backupUrl = new URL(originalRequest.url); backupUrl.hostname = backupDomain; const currentUrl = new URL(originalRequest.url); let search = currentUrl.search; if (!search) { search = '?'; } else { search += '&'; } search += 'od=' + currentUrl.host; backupUrl.search = search; return new Response('', { status: 302, headers: { 'Location': backupUrl.toString() } });```
5023	zgkh.net.js	Vulnerable Redirect to Untrusted Domain	High	true	N/A	9	new URL	standard	{The code constructs a URL using `new URL(originalRequest.url)` and then modifies its hostname to `backupDomain`. While `backupDomain` is hardcoded, the `originalRequest.url` is derived from the client's request, which is untrusted. If an attacker can control the original request URL (e.g., via a crafted URL in a phishing attack), they could potentially manipulate the resulting `backupUrl` to redirect to a malicious domain. Although the hostname is overwritten, the `search` parameter is appended with `od=` and the original host, which could be exploited if the backup server is not properly secured. The `new URL` constructor is sensitive because it can be used to construct arbitrary URLs from untrusted input, leading to open redirect vulnerabilities.}	```const backupUrl = new URL(originalRequest.url); backupUrl.hostname = backupDomain; const currentUrl = new URL(originalRequest.url); let search = currentUrl.search; if (!search) { search = '?'; } else { search += '&'; } search += 'od=' + currentUrl.host; backupUrl.search = search; console.log('redirect to ' + backupUrl.toString()); return new Response('', { status: 302, headers: { 'Location': backupUrl.toString() } });```
5024	tripswithtykes.com.js	SSRF Vulnerability	High	false	N/A	N/A	N/A	N/A	{The detected SSRF vulnerability arises from a route matching logic that allows requests to be processed based on URL conditions, but it does not involve the misuse of any sensitive JavaScript function such as importScripts(), eval(), or dynamic code execution. The vulnerability stems from improper validation of URLs and trust in user-controlled input within the route handler, not from a sensitive function call.}	```if (!!t && 'GET' === e.request.method && !!t.includes('https') && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname;```
5025	jameshfisher.com.js	XSS via untrusted notification data	Medium	true	CWE-79	9	self.registration.showNotification	standard	{The function self.registration.showNotification is used with untrusted data from ev.data.title and ev.data.options. If these values contain malicious content (e.g., script tags or HTML), they may be rendered in the notification UI, leading to XSS if the browser or platform interprets them as executable code or injectable content.}	```self.registration.showNotification(ev.data.title, ev.data.options);```
5026	jameshfisher.com.js	XSS via untrusted push notification data	Medium	true	CWE-79	9	self.registration.showNotification	standard	{The function self.registration.showNotification is used with untrusted data from data.title and data.options, which originate from a push message. If the push data contains malicious HTML or script, and the browser renders it in the notification, it can lead to XSS, especially if the notification UI is not properly sanitizing the content.}	```self.registration.showNotification(data.title, data.options);```
5027	betterbidding.com.js	Cross-Site Scripting (XSS) via untrusted notification content	High	true	CWE-79	10	N/A	standard	{The vulnerability arises from the use of `self.registration.showNotification()` with untrusted data from the server response. The `title` and `body` fields are directly taken from the `data` object without sanitization, and since these values are rendered in the browser’s notification UI, an attacker can inject malicious scripts or HTML that may be executed if the notification is interacted with or if the browser renders it in a context that allows script execution.}	```const { body, url, grouped, groupedTitle, groupedUrl, icon, image } = data; let { title } = data; let tag; if (data.tag) { tag = data.tag.substr(0, 30); } let options = { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } }; if (!tag || !grouped) { return self.registration.showNotification(title, options); } else { return self.registration.getNotifications({ tag }).then(notifications => { options = { ...options, tag, renotify: true, data: { ...options.data, unseenCount: 1 } }; if (notifications.length) { try { const lastWithTag = notifications[notifications.length - 1]; if (lastWithTag.data && typeof lastWithTag.data.unseenCount !== 'undefined') { const unseenCount = lastWithTag.data.unseenCount + 1; options.data.unseenCount = unseenCount; options.body = pluralize(grouped.replace('{count}', unseenCount), unseenCount); if (groupedUrl) { options.data.url = groupedUrl ? groupedUrl : options.data.url; } if (groupedTitle) { title = pluralize(groupedTitle.replace('{count}', unseenCount), unseenCount); } lastWithTag.close(); } } catch (err) { console.log(err); } return self.registration.showNotification(title, options); }); }```
5028	betterbidding.com.js	Open Redirect via untrusted notification URL	High	true	CWE-601	10	N/A	standard	{The `clients[0].navigate(data.url)` call uses an untrusted `data.url` value received from the server without validation or sanitization. This allows an attacker to craft a malicious notification payload that redirects the user to an arbitrary external URL, potentially leading to phishing or credential theft. The `navigate` method is a standard browser API that directly loads the specified URL in the client context, making it a direct vector for open redirect attacks.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus();```
5029	theprojector.sg.js	Insecure IndexedDB Usage via Message API	Medium	true	CWE-20	8	N/A	standard	{The service worker listens for messages and dynamically invokes methods from the `messageApi` object using `event.data.gatsbyApi` as the method name. This allows an attacker to send arbitrary method names via the message API, potentially triggering unintended or malicious behavior if the API is extended or misconfigured. While the current implementation does not expose dangerous methods, the dynamic invocation pattern is inherently risky and could lead to privilege escalation or data leakage if not properly restricted.}	```self.addEventListener(`message`, event => { const { gatsbyApi } = event.data; if (gatsbyApi) messageApi[gatsbyApi](event, event.data); });```
5030	theprojector.sg.js	Cache Poisoning via Unvalidated IndexedDB Resources	Medium	true	CWE-918	9	N/A	standard	{The `setPathResources` function stores arbitrary `resources` data into IndexedDB without validation or sanitization. Since this data is later used in the navigation route to determine which cached resources to serve, an attacker could inject malicious URLs or paths into IndexedDB via the message API, leading to cache poisoning and potentially serving malicious content to users.}	```const messageApi = { setPathResources(event, { path, resources }) { event.waitUntil(idbKeyval.set(`resources:${path}`, resources)); }, clearPathResources(event) { event.waitUntil(idbKeyval.clear()); } };```
5031	theprojector.sg.js	Unvalidated Navigation Route Cache Logic	Medium	true	CWE-20	8	N/A	standard	{The navigation route logic retrieves resources from IndexedDB and uses them to check cache availability. Since these resources are not validated or sanitized, an attacker could inject arbitrary URLs into IndexedDB via the message API, causing the service worker to attempt to match and serve content from unintended or malicious sources, leading to cache poisoning or resource misdirection.}	```const navigationRoute = new NavigationRoute(async ({ event }) => { let { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``); const resources = await idbKeyval.get(`resources:${pathname}`); if (!resources || !(await caches.match(`/app-e5577a3099a5d5e64dcd.js`))) { return await fetch(event.request); } for (const resource of resources) { if (!(await caches.match(resource))) { return await fetch(event.request); } } const offlineShell = `/offline-plugin-app-shell-fallback/index.html`; return await caches.match(offlineShell); });```
5032	newcomeralbany.com.js	Improper Input Validation in addParams Function	Medium	false	New	N/A	N/A	N/A	{The addParamsNative function does not validate or sanitize input parameters before constructing URLs, which could lead to malformed URLs or unintended behavior, but it does not directly invoke a sensitive function that introduces a security vulnerability such as code injection or SSRF.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
5033	newcomeralbany.com.js	SSRF Vulnerability in fetchPageKey Function	High	true	CWE-918	N/A	fetch	standard	{The fetchPageKey function constructs a URL using user-controlled pageUrl via getPathName and addParams, then passes it directly to fetch without validating or sanitizing the target domain. This allows an attacker to craft a pageUrl that resolves to an internal or external resource, enabling SSRF attacks.}	```async function fetchPageKey(pageUrl) { const baseKeyUrl = pwaSettings.baseKeyUrl; const pageUri = getPathName(pageUrl); const pageKeyUrl = addParams(baseKeyUrl, { uri: encodeURIComponent(pageUri), skip_sw_cache: true }); return await fetch(pageKeyUrl); }```
5034	newcomeralbany.com.js	Insecure Cache Deletion via Message Command	High	true	CWE-285	N/A	caches.delete	standard	{The service worker listens for a message event and executes caches.delete(SITE_PAGES_CACHE_NAME) without validating the origin or authenticity of the message sender. This allows any page in the same origin to trigger cache deletion, potentially disrupting service worker functionality.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
5035	newcomeralbany.com.js	Debug Mode Enabled in Production	Medium	false	CWE-200	N/A	N/A	N/A	{The debug mode is enabled via pwaSettings.debug = true, which exposes internal logs and potentially sensitive information through console.log. However, this is not caused by misuse of a sensitive function but rather a configuration issue.}	```pwaSettings.debug = true;```
5036	newcomeralbany.com.js	Overly Permissive Cache Strategies	Medium	false	CWE-259	N/A	N/A	N/A	{The use of broad regular expressions in workbox.routing.registerRoute allows caching of many external resources without proper validation. While this may lead to unintended caching behavior, it does not stem from misuse of a sensitive function.}	```workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
5037	newcomeralbany.com.js	No-CORS Mode in PrefetchUrl Function	Medium	true	CWE-960	N/A	fetch	standard	{The prefetchUrl function uses fetch with mode: 'no-cors', which bypasses CORS checks and may allow fetching of resources from origins that would otherwise be blocked. This can lead to unintended data exposure or resource access if the URL is derived from untrusted input.}	```const networkResponse = await fetch(new Request(url, { mode: 'no-cors' }));```
5038	bubblealba.com.js	Insecure Direct Object Reference (IDOR) via unvalidated URL in notification click handler	High	true	CWE-20	10	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from untrusted input (in this case, from event.notification.data.url, which originates from a push notification payload), it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing, malware distribution, or other malicious activities. Since the URL is not validated or sanitized, this constitutes a direct object reference vulnerability.}	```event.waitUntil(clients.openWindow(url));```
5039	arkadiarahoitus.fi.js	Vulnerable Redirect via Untrusted Notification Data	High	true	CWE-602	9	clients.openWindow	standard	{The clients.openWindow function is used to open a new browser window or tab based on data received from a notification. The URL passed to clients.openWindow is derived from i.notification.data.url, url1, or url2, which are untrusted and potentially controlled by an attacker. Since these values are parsed from notification data without sanitization or validation, an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to phishing or drive-by download attacks.}	```self.addEventListener('notificationclick', function (i) { i.notification.close(); void 0 === i.action || 'string' != typeof i.action || '1' !== i.action && '2' !== i.action ? void 0 !== i.notification.data && void 0 !== i.notification.data.url ? clients.openWindow(i.notification.data.url) : clients.openWindow('https://www.annafinans.dk') : '1' === i.action && void 0 !== i.notification.data && void 0 !== i.notification.data.url1 ? clients.openWindow(i.notification.data.url1) : '2' === i.action && void 0 !== i.notification.data && void 0 !== i.notification.data.url2 ? clients.openWindow(i.notification.data.url2) : clients.openWindow('https://www.annafinans.dk'); }, !1)```
5040	ibet877.com.js	Improper Cache Validation Leading to Unauthorized Access	High	true	CWE-921	9	N/A	standard	{The vulnerability arises from improper handling of cached responses in the fetch event. The code uses `caches.open()` and `cache.match()` to check for cached responses, but it does not validate the origin or integrity of the cached content. When a cached response is found, it is returned without verifying if it is still valid or if it was tampered with. This can lead to unauthorized access to stale or malicious content, especially if the cache is manipulated by an attacker. The `caches` API is a standard browser API, and its misuse here stems from not enforcing proper cache validation policies.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith(caches.open(CACHE_VERSION).then(cache => { return cache.match(event.request).then(cachedResponse => { if (cachedResponse) { return fetch(event.request).then(fetchedResponse => { if (fetchedResponse.ok) { cache.put(event.request, fetchedResponse.clone()); return fetchedResponse; } else { return cachedResponse; } }); } else { return fetch(event.request); } }); })); } else { return; } });```
5041	ilmiocaneleggenda.it.js	Loading untrusted external script in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function in Service Workers executes JavaScript code from a specified URL. When used with a hardcoded external URL, especially from an untrusted third-party domain like tippler.merlinforce.com, it introduces a high-risk vulnerability. If the remote script is compromised or malicious, it can execute arbitrary code within the service worker context, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded here, the function itself is inherently sensitive because it allows remote code execution.}	"```importScripts(""https://tippler.merlinforce.com/integration/request/105982481/?scache=1667838190"");```"
5042	piscines-online.com.js	Caching of Untrusted Resources Without Validation	High	true	CWE-20	10	caches.add	standard	{The function caches.add is used to store resources fetched from URLs derived from an external JSON file (entrypoints.json). Since the contents of this file are not validated or sanitized, an attacker could manipulate it to inject malicious URLs, leading to unintended caching of untrusted or malicious resources. This allows for potential cache poisoning or execution of arbitrary code if the cached resources are later served to clients.}	```const entrypoints = (await (await fetch('/build/piscine/entrypoints.json')).json()).entrypoints; for (const entrypoint of Object.values(entrypoints)) { for (const key of keys) { for (const value of entrypoint[key]) { cache.add(new Request(value, { cache: 'reload' })); } } }```
5043	tributetech.com.js	Improper Handling of Cross-Origin Requests	High	true	New	9	N/A	standard	{The fetch API is used with mode: 'no-cors', which prevents the browser from sending credentials and restricts the response to only simple headers. However, if the URL is dynamically constructed from untrusted input (e.g., user-controlled parameters), it may lead to unintended cross-origin requests that bypass CORS protections, potentially exposing sensitive data or enabling unauthorized access to resources.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
5044	tributetech.com.js	Missing Authentication for Critical Function	Medium	false	CWE-306	N/A	N/A	N/A	{The vulnerability arises from the lack of authentication or authorization checks when handling the 'deletePagesCache' message. However, this is not due to misuse of a sensitive function, but rather a design flaw in the message handling logic.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); });```
5045	tributetech.com.js	Exposure of Debug Information	Low	false	CWE-200	N/A	N/A	N/A	{The debug flag is set to true, which causes debug logs to be output to the console. This is a configuration issue, not a misuse of a sensitive function.}	```pwaSettings.debug = true;```
5046	nord-ad.dk.js	Cache Poisoning via Permissive Regex	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a permissive regular expression used in workbox.routing.registerRoute, which matches any URL containing 'jquery' and potentially caches unintended resources. However, this is not caused by misuse of a sensitive JavaScript function like importScripts or eval, but rather by a flawed pattern in the routing logic. The function workbox.routing.registerRoute is a standard Workbox API, but its misuse here is due to overly broad regex patterns, not because of unsafe function execution with untrusted input.}	```workbox.routing.registerRoute(/.*?jquery.*?(?:\.min)?\.js.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
5047	opalescence.com.js	Open Redirect Vulnerability	High	true	CWE-601	8	N/A	standard	{The vulnerability arises from the use of `new URL('https://www.ultrdent.com/', self.location).toString()` within a conditional that redirects navigation requests. Although the URL is hardcoded, the context in which it is used—specifically, when `isPathWhitelisted([], e.request.url)` is true—suggests that the redirect logic is triggered based on user-controlled navigation requests. While the URL itself is not dynamic, the misuse lies in the fact that the service worker is redirecting navigation requests to a hardcoded external domain without proper validation or user intent confirmation, which can be exploited in open redirect scenarios if the application logic allows arbitrary navigation paths to trigger this redirect. The `new URL()` constructor is a standard JavaScript function, and its misuse here contributes to the open redirect vulnerability.}	"```!a && ""navigate"" === e.request.mode && isPathWhitelisted([], e.request.url) && (c = new URL(""https://www.ultrdent.com/"", self.location).toString(), a = urlsToCacheKeys.has(c)), a && e.respondWith(...)```"
5048	eyfs.info.js	Server-Side Request Forgery (SSRF) via unvalidated 'id' parameter in push event	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL where the 'id' parameter is directly taken from the push event data without validation. This allows an attacker to craft a push notification with a malicious 'id' value, causing the service worker to make an unintended request to an arbitrary endpoint, potentially leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5049	eyfs.info.js	Insecure Direct Object Reference (IDOR) via 'loggedIn' URL parameter	High	false	CWE-598	N/A	N/A	N/A	{The vulnerability arises from the direct use of the 'loggedIn' URL parameter to determine user state, but it is not caused by misuse of a sensitive JavaScript function. The issue lies in the logic that trusts this parameter without proper authentication or authorization checks.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
5050	eyfs.info.js	CSRF Token Request with Unvalidated 'path' Parameter	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used with a dynamically constructed URL where the 'path' parameter is derived from the request URL without sanitization. This allows an attacker to manipulate the 'path' parameter to request CSRF tokens for unintended endpoints, potentially enabling CSRF attacks.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5051	adaymagazine.com.js	Improper Request Handling Leading to Potential Data Exposure	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of requests with 'only-if-cached' and 'no-cors' modes, which may lead to unintended data exposure or bypass of intended caching behavior. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic flaw in request interception.}	```const requestInterceptor = { requestWillFetch({ request }) { if (request.cache === 'only-if-cached' && request.mode === 'no-cors') { return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' }); } return request; } };```
5052	yaksgames.com.js	Incorrect logic in offline handling leading to unintended resource exposure	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from incorrect logic in the fetch event handler: when offline, it attempts to match the requested resource first, then unconditionally returns the cached '/offline.html' regardless of whether the original request was successfully matched. This means that even if the requested resource exists in the cache, it is ignored and replaced with '/offline.html', potentially exposing users to an unintended fallback page. This is not caused by misuse of a sensitive function, but rather by flawed control flow logic.}	```self.addEventListener('fetch', event => { if (!self.navigator.onLine) { event.respondWith(caches.match(event.request).then(response => { return caches.match('/offline.html'); })); } });```
5053	thecustomizewindows.com.js	Hardcoded Secret in Service Worker	High	false	N/A	N/A	N/A	N/A	{The hardcoded secret is not caused by misuse of a sensitive function, but rather by direct assignment of a static value to a variable.}	```self[`appKey`] = `a52f00ee6913efed688537a6596c4361`;```
5054	thecustomizewindows.com.js	Remote Code Execution via External Script Import	High	true	N/A	N/A	importScripts	standard	{The importScripts() function is a standard JavaScript API in Service Workers that loads and executes external scripts. When used with a dynamically constructed URL derived from a hardcoded host (self[`hostUrl`]), it allows an attacker to potentially control the script source if the host is compromised or if the URL is manipulated via other means. Although the host is hardcoded here, the function itself is sensitive because it executes arbitrary code from a remote source, and its misuse can lead to RCE if the source is not fully trusted.}	```self.importScripts(`${self[`hostUrl`]}/worker.js`);```
5055	gamerisehub.com.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-602	9	clients.openWindow	standard	{The function clients.openWindow(url) is a standard Service Worker API that opens a new browser window or tab with the specified URL. When the URL is derived directly from event.notification.data.url without validation or sanitization, an attacker can craft a notification payload containing a malicious URL, leading to an open redirect. This allows the attacker to redirect users to phishing sites or other malicious destinations, compromising user trust and security.}	```self.addEventListener('notificationclick', event => { event.notification.close(); const url = event.notification.data.url; event.waitUntil(clients.matchAll({ type: 'window' }).then(windowClients => { for (let client of windowClients) { if (client.url === url && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } })); });```
5056	nowcookthis.com.js	Improper Path Validation in Cache Bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of URLs against a list of ignored paths. The code checks if a URL includes any of the ignored paths using `includes()` and `some()`, but it does not validate the full URL structure or enforce strict path matching, which could allow bypassing cache rules if an attacker crafts a URL that partially matches but evades the filters. This is not caused by misuse of a sensitive function.}	```if (!ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname;```
5057	nowcookthis.com.js	Insecure Cache Key Construction	Medium	true	N/A	N/A	`new URL()`	standard	{The `new URL()` function is used to construct cache keys from user-controlled or dynamically derived URLs. If the input URL is not properly sanitized or validated, an attacker could manipulate the URL to inject arbitrary paths or parameters, leading to cache key collisions or unintended cache behavior. This misuse allows for cache poisoning or bypassing intended cache logic.}	N/A
5058	nowcookthis.com.js	Insecure Cache Busting Parameter Handling	Low	true	N/A	N/A	`new URL()`	standard	{The `new URL()` function is used to manipulate URLs by deleting specific search parameters (e.g., `__WB_REVISION__`). If the input URL is derived from untrusted sources, an attacker could inject malicious parameters that are not properly sanitized, leading to unintended cache behavior or bypassing cache validation mechanisms.}	N/A
5059	nowcookthis.com.js	Insecure Background Sync Data Retention	Medium	false	N/A	N/A	```await this._queueDb.addEntry(e)	N/A	{The vulnerability stems from the lack of proper data retention policies in the background sync queue. The code stores requests without enforcing time limits or validation, but this is not due to misuse of a sensitive function. The issue lies in the logic design rather than a specific function call.}	N/A
5060	nowcookthis.com.js	Insecure Cache Name Construction	Low	true	N/A	N/A	`new URL()`	standard	{The `new URL()` function is used in conjunction with dynamic cache name construction via `i.prefix`, `i.suffix`, etc. If these values are derived from untrusted or unsanitized inputs, an attacker could manipulate the cache name to cause cache key collisions or bypass cache isolation, leading to unintended cache sharing or data leakage.}	N/A
5061	ironmaster.com.js	Improper Handling of Offline Page	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of proper handling or fallback logic for offline scenarios, but it is not caused by misuse of a sensitive JavaScript function. The code correctly uses caches.open and cache.match, and there is no dynamic or untrusted input being passed to sensitive functions like importScripts, eval, or similar.}	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith(fetch(event.request).catch(() => caches.open(CACHE_NAME).then(cache => cache.match('offline.html')))); } });```
5062	ageco.co.uk.js	Arbitrary Method Invocation via Message Passing	High	true	CWE-706	10	N/A	standard	{The code dynamically invokes methods on the service worker instance using `this[t.function]`, where `t.function` is derived from untrusted `e.data` parsed via `JSON.parse`. This allows an attacker to send a message with a malicious function name (e.g., `deleteCacheRequest`, `sendToClient`, or even `postData`) and trigger arbitrary method execution, potentially leading to cache manipulation, data exfiltration, or denial of service. The `this[t.function]` construct is a standard JavaScript feature but is misused here due to lack of input validation.}	```this[t.function] ? this[t.function](t).then(t => { e.ports[0].postMessage(JSON.stringify(t)); }).catch(t => { e.ports[0].postMessage(JSON.stringify(t)); }) : (s.request = e.data, e.ports && e.ports.length > 0 && e.ports[0].postMessage(JSON.stringify(s)));```
5063	ageco.co.uk.js	Server-Side Request Forgery (SSRF) in postData	High	true	CWE-918	10	N/A	standard	{The `postData` method constructs a `fetch` request using `e.url`, which is directly derived from untrusted input. Since `e.url` is not validated or sanitized, an attacker can supply any URL, including internal or external resources, leading to SSRF. The `fetch` function is a standard JavaScript API, but its misuse here with untrusted input enables unauthorized network requests.}	"```const t = e.url ? e.url : ""/"", const n = { method: i, mode: ""no-cors"", cache: ""no-cache"", credentials: ""same-origin"", headers: { ""Content-Type"": ""application/json; charset=utf-8"" }, redirect: ""follow"", referrer: ""no-referrer"" }, fetch(t, n).then(t => { ... });```"
5064	0264noticias.com.ar.js	Insecure URL Handling in Notification Click	High	true	CWE-601	9	new URL	N/A	{The new URL constructor is used with untrusted input from event.notification.data.FCM_MSG.data.link, which is derived from a notification payload. If an attacker can control this input, they can craft a malicious URL that may lead to phishing, redirect to malicious sites, or exploit other client-side vulnerabilities. The URL is then passed to clients.openWindow(), which opens the URL in a new window, potentially under attacker control.}	```const url = new URL(event.notification.data.FCM_MSG.data.link).toString();```
5065	0264noticias.com.ar.js	Insecure URL Handling in Notification Click	High	true	CWE-601	9	new URL	N/A	{The new URL constructor is used with untrusted input from data.link, which is parsed from JSON derived from event.notification.data. If the notification data is manipulated (e.g., via server-side injection or spoofed notifications), this can lead to arbitrary URL redirection. The resulting URL is passed to clients.openWindow(), enabling potential phishing or malicious site redirection.}	```const url = new URL(data.link).toString();```
5066	0264noticias.com.ar.js	Firebase API Key Exposure	Medium	false	N/A	N/A	N/A	N/A	{The Firebase API key is exposed in the client-side JavaScript code. While this is a security issue, it is not caused by misuse of a sensitive JavaScript function, but rather by hardcoded credentials in the source code.}	```'apiKey': 'AIzaSyCheFda0EDGrCBQoMP5MqmLzCRHMostX0E'```
5067	39mail.com.js	Insecure External Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script (https://push-notification-api.movabletype.net/v2.4.0/js/strategy-network-only.js). While the URL is not dynamically constructed from untrusted input, the act of importing an external script from an untrusted or third-party domain introduces a high-risk vulnerability. If the remote script is compromised or modified, it can execute arbitrary code within the service worker context, leading to potential data exfiltration, cache manipulation, or man-in-the-middle attacks. This is considered a sensitive function misuse because it allows execution of unverified code from an external source.}	"```importScripts(""https://push-notification-api.movabletype.net/v2.4.0/js/strategy-network-only.js"");```"
5068	afsiamthai9.com.js	Improper Cache Control for Sensitive Data	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper cache configuration for sensitive data, specifically the route `/staticpagesettings/Info/orders`, which is cached for 24 hours (86400 seconds). This is not due to misuse of a sensitive JavaScript function, but rather a misconfiguration in the caching policy. The `e.registerRoute` function is used correctly in terms of syntax and intended behavior, but the policy itself allows sensitive data to be cached for too long, potentially exposing it to unauthorized access or replay attacks.}	```e.registerRoute((e)=>e.pathname.includes('/staticpagesettings/Info/orders'),new e.StaleWhileRevalidate({cacheName:'ord',plugins:[new e.ExpirationPlugin({maxAgeSeconds:86400,maxEntries:1,purgeOnQuotaError:!0})]}),'GET')```
5069	app-games-shorallspir.xyz.js	Cache Poisoning via Unvalidated Fetch Response	High	true	CWE-798	10	N/A	standard	{The fetch() function is used without validating or sanitizing the request, allowing an attacker to manipulate the request to cache malicious or unintended responses. Since the service worker caches responses from fetch() without validation, this can lead to cache poisoning where attackers inject malicious content into the cache, which is then served to users.}	```self.addEventListener('fetch', function (event) { event.respondWith(fetch(event.request).catch(() => { return caches.open(CACHE_NAME).then(cache => { return cache.match(event.request); }); })); });```
5070	arch-dx.com.js	Insufficient Cache Name Validation	High	true	CWE-79	8	self.caches.delete	standard	{The function self.caches.delete is used to remove cache entries based on dynamically generated cache names. The cache names are derived from parameters passed to the function h, which are not validated or sanitized. An attacker could potentially manipulate these parameters to delete unintended caches, leading to data loss or denial of service. The use of includes() for filtering cache names is insufficient for preventing malicious cache name injection.}	```const h = async (e, t = f) => { const r = (await self.caches.keys()).filter(a => a.includes(t) && a.includes(self.registration.scope) && a !== e); return await Promise.all(r.map(a => self.caches.delete(a))), r; };```
5071	beamazingshop.com.js	Stale Offline Cache Handling	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the service worker's handling of offline responses, where it caches a single offline page without validating or refreshing it over time. This is not caused by misuse of a sensitive function, but rather by a design flaw in cache management. The code does not use any sensitive functions like importScripts, eval, or dynamic script loading that could lead to injection or execution of untrusted code.}	```self.addEventListener('fetch', function (event) { event.respondWith(async function () { try { let res = await fetch(event.request); return res; } catch (error) { const cache = await caches.open('cache'); let offlineRes = await cache.match('offline'); return offlineRes; } }()); });```
5072	bensherman.co.za.js	Use of Untrusted Resource (External Script Import	Medium	true	CWE-928	N/A	importScripts	standard	{The importScripts() function is used to load and execute an external script from a hardcoded URL. While the URL is fixed and not dynamically constructed from untrusted input, the script is loaded from an external domain (cdn.shopify.com), which could be compromised or manipulated by an attacker if the domain is not fully trusted. However, since the URL is hardcoded and not derived from user input, this is not a direct sensitive function misuse but rather a potential supply chain risk.}	"```importScripts(""https://cdn.shopify.com/s/files/1/0033/3538/9233/files/sw-external_whatsappchat.js?v=1710314205"");```"
5073	bensherman.co.za.js	Improper Neutralization of Input (XSS in Notification Data	High	true	CWE-79	N/A	e.icon = r.image	standard	{The sensitive function is not directly used, but the assignment e.icon = r.image implies that user-controlled data (r.image) is directly assigned to a notification icon field without sanitization. If r.image is derived from untrusted input, it could be crafted to point to a malicious resource or trigger unintended behavior, leading to XSS or phishing. The function itself is not sensitive, but the misuse of assignment without validation constitutes a vulnerability.}	```e.icon = r.image```
5074	bensherman.co.za.js	Server-Side Request Forgery (Dynamic URL Construction	High	true	CWE-918	N/A	fetch	standard	{The fetch function is used with dynamically constructed URLs derived from user-controlled data (e.g., n[i(384)][i(275)]). Since the URL is built using untrusted input without validation or sanitization, an attacker can manipulate the input to redirect the fetch request to arbitrary endpoints, leading to SSRF. The dynamic construction of the URL from potentially untrusted data is the root cause.}	```a[i(340)](fetch, n, {mode: a[i(329)]}).then(function (n) {});```
5075	bensherman.co.za.js	Open Redirect (Dynamic Navigation	High	true	CWE-601	N/A	self.clients.openWindow	standard	{The self.clients.openWindow function is used with a dynamically constructed URL (u), which is derived from potentially untrusted data. If u is not validated or sanitized, an attacker can manipulate it to redirect users to malicious sites, leading to open redirect vulnerabilities. The function is standard and directly responsible for the vulnerability.}	```self.clients.openWindow(u);```
5076	bensherman.co.za.js	Use of No-CORS Mode (Insecure Fetch	Medium	true	CWE-400	N/A	fetch	standard	{The fetch function is used with the mode set to 'no-cors', which disables CORS checks. This can lead to insecure data retrieval from third-party domains without proper validation, potentially exposing sensitive data or allowing unintended cross-origin requests. The misuse of the fetch API with insecure mode settings is the cause.}	```a[i(340)](fetch, n, {mode: a[i(329)]}).then(function (n) {});```
5077	best-discount-on-the-planet.org.js	Loading external script without integrity check	High	true	CWE-799	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. While the URL in this case is hard-coded, the vulnerability arises because there is no integrity check (e.g., using a Subresource Integrity hash) to verify the script's authenticity. This allows an attacker who compromises the CDN (e.g., jsdelivr) to serve a malicious version of the script, leading to arbitrary code execution within the service worker context. Although the input is not dynamic, the lack of integrity verification makes this a sensitive misuse of a standard function.}	"```importScripts(""https://cdn.jsdelivr.net/gh/Bottonera/sw@v0.0.1/sw.js"");```"
5078	bets4.cc.js	Improper Validation of DNS-Based Settings Leading to Remote Code Execution	High	true	CWE-295	9	N/A	standard	{The DNS resolver URL is hardcoded and used to fetch TXT records from external domains. While no direct sensitive function is misused in the fetch call, the vulnerability arises from the lack of validation of the DNS response data, which is then used to dynamically update critical settings (enabled, block_id, redirect_url). This allows an attacker to control the service worker's behavior via DNS spoofing or manipulation, effectively enabling remote code execution through controlled redirects or logic changes. The fetch API is standard, but its misuse here is due to untrusted data handling, not direct function misuse.}	"```const DNS_RESOLVER_URL = ""https://dns.google.com/resolve?type=TXT&name="";```"
5079	bets4.cc.js	Open Redirect Vulnerability via Untrusted Redirect URL	High	true	CWE-601	10	N/A	standard	{The Location header in the Response object is constructed using getRedirectUrl(settings.redirect_url), where settings.redirect_url is dynamically updated from untrusted DNS TXT records. The Response constructor is a standard API, and its misuse here allows an attacker to set arbitrary redirect URLs by manipulating the DNS response, leading to open redirect vulnerabilities.}	"```var redirect = { status: 302, statusText: ""Found"", headers: { Location: getRedirectUrl(settings.redirect_url) } };```"
5080	bets4.cc.js	Insecure Dynamic Code Execution via Unvalidated DNS Response	Medium	true	New	8	N/A	standard	{The DNS response data is parsed and directly assigned to settings variables (enabled, block_id, redirect_url) without validation. The JSON.parse() function is used to parse the response, which is standard, but the lack of input validation on the parsed data allows an attacker to inject malicious values, leading to insecure dynamic behavior. The vulnerability stems from improper handling of untrusted data, not direct misuse of a sensitive function.}	```settings.enabled = data[1]; settings.block_id = data[2] ? data[2] : settings.block_id; settings.redirect_url = data[3] ? data[3] : settings.redirect_url;```
5081	bets4.cc.js	Insecure Parameter Handling in Redirect Construction	Medium	true	CWE-113	7	N/A	standard	{The redirect_params.utm_campaign is assigned the full requestUrl, which is then encoded and appended to the redirect URL. The encodeURIComponent function is standard, but its misuse here allows an attacker to inject arbitrary parameters into the redirect URL, potentially leading to parameter pollution or unintended behavior. The vulnerability arises from using untrusted input (requestUrl) without proper sanitization.}	```redirect_params.utm_campaign = encodeURIComponent(requestUrl);```
5082	bimacentral.in.js	Insecure Cache Expiration Logic	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of the Date header in responses, but it is not caused by misuse of a sensitive JavaScript function. The code parses the Date header using `new Date()`, which is safe when used with trusted inputs. However, if an attacker can manipulate the Date header, it could lead to incorrect expiration logic, but this is not due to a sensitive function misuse.}	```const t = new Date(t.headers.get('date')).getTime();```
5083	bimacentral.in.js	Cross-Origin Resource Handling	High	false	CWE-497	N/A	N/A	N/A	{The code checks for cross-origin requests by comparing the origin of the response URL with `self.location.origin`. This is a defensive check, not a misuse of a sensitive function. The vulnerability stems from the logic not being properly enforced or from potential bypasses, but no sensitive function like `importScripts()` or `eval()` is involved.}	```if(s !== self.location.origin) throw new n.V('cross-origin-copy-response'```
5084	bimacentral.in.js	Cache Poisoning Risk	High	true	CWE-113	N/A	fetchAndCachePut	standard	{The `fetchAndCachePut` function is a standard Workbox utility that fetches a resource and caches it. When used with untrusted or unsanitized URLs (e.g., from dynamic inputs), it can lead to cache poisoning, where an attacker supplies a malicious URL that gets cached and served to users. The function is sensitive because it directly interacts with network resources and caching mechanisms without sufficient validation.}	```const t = await t.fetchAndCachePut(e);```
5085	bimacentral.in.js	Insecure Cache Key Generation	Medium	true	CWE-20	N/A	getCacheKey	standard	{The `getCacheKey` function is used to generate cache keys for requests. If the input URL is not properly sanitized or validated, it can lead to cache key collisions or unintended cache behavior. This function is sensitive because it directly influences how resources are stored and retrieved from the cache, and misuse can result in cache poisoning or bypassing cache policies.}	```const {cacheKey: e```
5086	bookup.gr.js	Caching of Sensitive PHP File	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching a PHP file ('/business-directory.php') in the service worker's static cache, which may expose server-side logic or sensitive data if accessed via the cache. However, this is not caused by misuse of a sensitive JavaScript function, but rather by the inclusion of a sensitive resource in the cache list. No dynamic or unsanitized input is used to construct the cache asset list.}	"```const staticAssets = ['/business-directory.php', ""/includes/vendor/bootstrap/css/bootstrap.min.css"", ""/includes/vendor/font-awesome/css/font-awesome.min.css"", ""/includes/css/saasappoint-business-directory.css"", ""/includes/css/custom.css"", ""/includes/css/global-css_variables.css"", ""/includes/js/app.js"", ""/includes/vendor/jquery/jquery.min.js"", ""/includes/vendor/bootstrap/js/bootstrap.min.js"", ""/includes/js/saasappoint-business-directory.js"", ""/includes/js/saasappoint-set-languages.js"", ""/includes/font/montserrat.css"", ""/includes/font/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"", ""/includes/vendor/font-awesome/fonts/fontawesome-webfont.woff2?v=4.7.0"", ""/includes/lib/saasappoint_business_directory_ajax.php"", ""/manifest.json""];```"
5087	bukukord.com.js	Cache Poisoning via Unvalidated Cached Response	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from returning a cached response without validating its integrity or origin. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a logic flaw in handling cached responses. The code does not use any sensitive functions with untrusted input to trigger the issue.}	```return cachedResponse;```
5088	camsgenie.com.js	Insecure Dynamic URL Construction	High	true	N/A	9	self.clients.openWindow	standard	{The function self.clients.openWindow is used to open a URL constructed from untrusted data (e.g., e.notification.data.ProviderId and e.notification.data.Name). Since these values are derived from incoming notification data, an attacker could manipulate them to redirect users to arbitrary, potentially malicious URLs, leading to phishing or drive-by download attacks.}	```self.clients.openWindow('/' + e.notification.data.ProviderId + '/' + e.notification.data.Name + '?utm_source=push');```
5089	camsgenie.com.js	Insecure Data Handling in Notifications	Medium	false	N/A	N/A	N/A	N/A	{The assignment options.data = payload.data does not involve a sensitive function; it is merely copying data into an object. While this may expose sensitive data in notifications, it does not directly invoke a function that could lead to code execution or injection.}	```options.data = payload.data;```
5090	caneloteam.com.js	Information Disclosure via Debug Endpoint	High	true	N/A	N/A	`handleFetch`	standard	{The `handleFetch` method in the `DebugHandler` class constructs a detailed debug response containing sensitive operational data (e.g., driver state, manifest hash, idle task queue, and debug logs) and sends it back to the client. This is triggered by a request to the `/ngsw/state` endpoint, which is accessible via the `fetch` API. Since this endpoint is exposed and returns internal state, it can be exploited by attackers to gather information about the service worker’s configuration, version, and runtime state, enabling further attacks. The `fetch` API is used to serve this debug response, and its misuse here allows unauthorized access to internal data.}	```const [state, versions, idle] = await Promise.all([this.driver.debugState(), this.driver.debugVersions(), this.driver.debugIdleState()]); const msgState = `NGSW Debug Info:\n\nDriver version: ${SW_VERSION}\nDriver state: ${state.state} (${state.why})\nLatest manifest hash: ${state.latestHash || 'none'}\nLast update check: ${this.since(state.lastUpdateCheck)}`; ...```
5091	caneloteam.com.js	Insecure Cache Busting with Predictable Random Values	Medium	true	N/A	N/A	`Math.random()`	standard	{The `cacheBust` method appends a random value generated by `Math.random()` to URLs to prevent caching. However, `Math.random()` is not cryptographically secure and is predictable, especially when used in a deterministic context. An attacker can potentially predict or replay the cache-busting parameter, leading to cache poisoning or bypassing cache invalidation mechanisms. This misuse of `Math.random()` for security-sensitive operations (cache busting) introduces a vulnerability because it does not provide sufficient entropy to prevent prediction.}	```cacheBust(url) { return url + (url.indexOf('?') === -1 ? '?' : '&') + 'ngsw-cache-bust=' + Math.random(); }```
5092	caneloteam.com.js	Use of Weak Cryptographic Algorithm (SHA-1)	Low	false	N/A	N/A	N/A	N/A	{The SHA-1 implementation is used for hashing resources to verify integrity. While SHA-1 is considered cryptographically weak and vulnerable to collision attacks, its use here is for integrity verification of static assets, not for security-critical operations like authentication or digital signatures. Therefore, it does not constitute a sensitive function misuse in the context of service worker security. The vulnerability is more about algorithmic weakness than improper function usage.}	```function _sha1(words32, len) { const [a, b, c, d, e] = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]; ... }```
5093	cartersoshkosh.com.tr.js	Insecure External Resource Loading	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard service worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a risk if the URL is not properly vetted or if the script source is compromised. Although the URL is hardcoded here and not dynamically derived from untrusted input, the act of loading external scripts in a service worker context is inherently risky because it can lead to code injection if the external source is later compromised or if the script is not signed or verified. This is considered a high-severity vulnerability due to the potential for full control over the service worker's behavior.}	```importScripts('https://cdn.segmentify.com/v3/push/sw.js');```
5094	clubsupervielle.com.ar.js	Open Redirect via Unvalidated URL in Notification Action	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from untrusted data (e.g., payload.data.actions parsed from a message and assigned to urluno/urldos), an attacker can manipulate the payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```var urluno = acciones[0]['url'];```
5095	clubsupervielle.com.ar.js	Open Redirect via Unvalidated URL in Notification Action	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from untrusted data (e.g., payload.data.actions parsed from a message and assigned to urluno/urldos), an attacker can manipulate the payload to redirect users to arbitrary domains, leading to open redirect vulnerabilities.}	```var urldos = acciones[1]['url'];```
5096	clubsupervielle.com.ar.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The clients.openWindow() function is a standard browser API that opens a new window or tab with the provided URL. When the URL is extracted from event.notification.data.url, which originates from untrusted message payload data, an attacker can control the URL and redirect users to malicious sites, resulting in an open redirect vulnerability.}	```var url = event.notification.data.url;```
5097	clubsupervielle.com.ar.js	Arbitrary Code Execution via Untrusted JSON Parsing	Medium	true	CWE-502	8	JSON.parse	standard	{The JSON.parse() function is a standard JavaScript function used to parse JSON strings. When applied to untrusted input (payload.data.actions), it can lead to arbitrary code execution if the parsed data is later used to construct dynamic code or if the structure is manipulated to trigger unintended behavior, especially in combination with dynamic URL assignment.}	```if (payload.data.actions != '') { acciones = JSON.parse(payload.data.actions); }```
5098	cooler-chat.com.js	Server Side Request Forgery (SSRF) via URL parameter	High	true	CWE-918	9	replace	standard	"{The function `replace()` is used on `window.liveConfig.apiEndpoint` with a dynamic value `n` derived from `a.searchParams.get(""brev"")`. If an attacker can control the `brev` parameter, they can manipulate the API endpoint URL, potentially causing the service worker to make requests to unintended internal or external hosts, leading to SSRF.}"	N/A
5099	cooler-chat.com.js	XSS in notification data	Medium	true	CWE-79	8	registration.showNotification	standard	{The `registration.showNotification()` function is used with `d.body` set to `s.message` or `s.dispatcherUsername`, which are derived from untrusted push data. Since these values are directly inserted into the notification body without sanitization, an attacker can inject malicious scripts or HTML, leading to XSS when the notification is rendered in the browser.}	N/A
5100	cooler-chat.com.js	Insecure Random Token Generation	Medium	true	CWE-327	7	Math.random	standard	{The function `Math.random()` is used to generate a pseudo-random value for token creation. Since `Math.random()` is not cryptographically secure and is predictable, it can be exploited to generate predictable tokens, compromising the security of generated identifiers like `c`.}	N/A
5101	cooler-chat.com.js	Open Redirect via Untrusted URL	Medium	true	CWE-601	8	clients.openWindow	standard	{The `clients.openWindow()` function is called with a URL constructed from `registration.scope`, which is derived from the service worker's scope. Although the scope is typically controlled by the site, if the scope is manipulated (e.g., via a malicious registration), it could lead to an open redirect to an untrusted URL, allowing attackers to redirect users to phishing or malicious sites.}	N/A
5102	crazy-promotions-blog.com.js	External Script Import from Untrusted Source	High	true	CWE-401	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., cdn.jsdelivr.net/gh/Bottonera/sw@v0.0.1/sw.js), it introduces a high-risk vulnerability because the script may be tampered with or replaced by an attacker, leading to arbitrary code execution within the service worker context. Although the URL is hardcoded, the source is external and not under the control of the application, making it a sensitive misuse.}	"```importScripts(""https://cdn.jsdelivr.net/gh/Bottonera/sw@v0.0.1/sw.js"");```"
5103	crispybet.ph.js	Improper Error Handling in Module Loader Leading to DoS	High	true	New	9	N/A	standard	{The module loader uses `importScripts()` with dynamic script URLs derived from user-provided module names. If an attacker can control the module name (e.g., via a malicious URL or injection), they can force the service worker to load and execute arbitrary scripts, leading to potential denial-of-service or code injection. The error handling is also flawed, as it throws an error without proper safeguards, which could be exploited to trigger resource exhaustion.}	"```if (!self.define) { const e = e => { ""require"" !== e && (e += "".js""); let r = Promise.resolve(); return n[e] || (r = new Promise(async r => { if (""document"" in self) { const n = document.createElement(""script""); n.src = e, document.head.appendChild(n), n.onload = r; } else importScripts(e), r(); })), r.then(() => { if (!n[e]) throw new Error(`Module ${e} didn’t register its module`); return n[e]; }); };```"
5104	crispybet.ph.js	Caching Without Same-Origin Check Leading to Cache Poisoning	Medium	false	CWE-434	N/A	N/A	N/A	{This vulnerability arises from the lack of same-origin validation in the route matching logic, not from misuse of a sensitive function. The `e.registerRoute()` function is used correctly, but the route condition `e.pathname.includes('/games/allGameList')` does not verify the origin, allowing cache poisoning via cross-origin requests.}	```e.registerRoute((e) => e.pathname.includes('/games/allGameList'), new e.StaleWhileRevalidate({ cacheName: 'agl', plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), 'GET'),```
5105	crispybet.ph.js	Improper Module Loading with Potential DoS	High	true	New	9	N/A	standard	{The `define` function dynamically constructs module URLs using `location.origin + r.slice(1)`, where `r` is a user-controlled module path. This allows an attacker to inject arbitrary paths, potentially leading to loading of malicious scripts via `importScripts()` or other dynamic loading mechanisms, resulting in denial-of-service or code execution.}	```self.define = (r, s, t) => { n[r] || (n[r] = Promise.resolve().then(() => { let n = {}; const o = { uri: location.origin + r.slice(1) }; return Promise.all(s.map(e => { switch (r) { case 'exports': return n; case 'module': return o; default: return e(r); } })).then(e => { const r = t(...e); return n.default || (n.default = r), n; }); })); };```
5106	cseactionfrance.fr.js	Stale Cached Content	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of `caches.match()` followed by `fetch(event.request)` without proper validation or cache invalidation mechanisms. However, this is not due to misuse of a sensitive function, as `fetch()` and `caches.match()` are used in a standard, safe manner. The issue is more about stale content being served due to lack of cache refresh or versioning, not insecure function usage.}	```return response || fetch(event.request);```
5107	davistheatre.in.js	Improper Cache Version Management Leading to Storage Exhaustion	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from using a static cache version identifier (CACHE_VERSION) without proper lifecycle management or cleanup. This does not stem from misuse of a sensitive JavaScript function, but rather from poor cache hygiene practices. The code does not dynamically construct or inject untrusted data into sensitive functions like importScripts, eval, or dynamic script loading.}	```self.addEventListener('fetch'```
5108	deliveryragazzo.com.br.js	Hard-coded Credentials	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to hardcoded credentials in the configuration object, not due to misuse of a sensitive JavaScript function. The code does not dynamically construct or inject values into sensitive functions like importScripts, eval, or similar.}	"```importScripts('https://api.pushio.com/webpush/sdk/service_min.js');var config = '{""appserviceKey"":""BFT9GG3EFWqVZiniGK8uFzSBR2KGAK5k5x0R3QkewGUykhy5YAH12c42lGht_dWI48mscLj-L3PHp5AKu0y_xt8="",""apiKey"":""ABERjqAx8Y2100S7fZvnvhiZk"",""accountToken"":""ABE_v1Yh5fId0PrIlbbF_BoiQ"",""appver"":""0.0.0"",""apiHost"":""https://g7h1r9i-webpush.oraclersys.com"",""lazy"":false}';orawp.init(config);```"
5109	diplon.be.js	External Script Loading Without Integrity Check	High	true	CWE-94	10	importScripts	standard	{The importScripts function is used to load external scripts from a hardcoded URL (https://www.gstatic.com/firebasejs/10.6.0/firebase-app-compat.js and https://www.gstatic.com/firebasejs/10.6.0/firebase-messaging-compat.js). While the URLs are hardcoded and not dynamically constructed from untrusted input, the lack of integrity checks (e.g., Subresource Integrity) means that if the external script source is compromised, the service worker could execute malicious code. This constitutes a misuse of importScripts in the context of security best practices, as it does not verify the integrity of the loaded script.}	```importScripts('https://www.gstatic.com/firebasejs/10.6.0/firebase-app-compat.js'); importScripts('https://www.gstatic.com/firebasejs/10.6.0/firebase-messaging-compat.js');```
5110	diplon.be.js	Open Redirect via Unvalidated Notification URL	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from event.notification.data.url, which originates from the push notification payload. Since this data is received from an external source (the server sending the push notification), it is untrusted. If an attacker can control the notification payload, they can set the URL to a malicious site, causing the browser to open it, leading to an open redirect. This misuse of clients.openWindow with unvalidated input is a direct cause of the vulnerability.}	```clients.openWindow(event.notification.data.url || '/');```
5111	dnareverse.com.br.js	Improper Cache Invalidation Leading to Stale Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of cache invalidation or update strategy, not from misuse of a sensitive function. The code uses standard caching behavior with caches.match() and fetch(), which are safe when used as intended. There is no dynamic or untrusted input being passed to these functions, and no function is being misused to introduce security risks.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); })); });```
5112	dobreknjige.si.js	Server Side Request Forgery (SSRF) via Image URL Extraction	High	true	CWE-602	9	fetch	standard	{The code extracts image URLs from HTML content using a regex and then uses `fetch` to retrieve those images. If the HTML content is untrusted (e.g., from a user-submitted page or dynamically loaded content), an attacker could inject a malicious URL pointing to an internal resource (e.g., `http://localhost:8080/admin`). Since the `fetch` call is made without sanitization and only checks `origin == location.origin`, it may allow SSRF if the attacker can craft a URL that bypasses the origin check or if the origin check is flawed. This misuse of `fetch` with untrusted input leads to SSRF.}	"```const regex = /<img[^>]+src=""(https:\/\/[^"">]+)""/g; let m; while ((m = regex.exec(data)) !== null) { if (m.index === regex.lastIndex) { regex.lastIndex++; } m.forEach((match, groupIndex) => { if (groupIndex == 1) { if (new URL(match).origin == location.origin) { fetch(match).then(imagedata => { cache.put(match, imagedata.clone()); }); } } }); }```"
5113	dobreknjige.si.js	XSS via Unsanitized IndexedDB Storage	Medium	true	CWE-79	8	IndexedDB.put	standard	{The code stores data from a form submission (including `title`, `text`, `url`, and `image`) directly into IndexedDB using `store.put(data)` without sanitizing or escaping the input. If the `title` or `text` fields contain malicious scripts (e.g., `<script>alert('XSS')</script>`), and if this data is later retrieved and rendered in the DOM without proper sanitization, it can lead to XSS. The misuse of `IndexedDB.put` with unsanitized user input enables persistent XSS.}	```const request = store.put(data); request.onsuccess = () => { resolve(); };```
5114	dragonslair.it.js	Improper Validation of CSRF Token Source	High	true	N/A	9	N/A	standard	{The function `new Request()` is used to create a new request with headers modified to include a CSRF token. However, the token is fetched from a server endpoint without validating the origin or integrity of the response, and the request is constructed using `curRequest` which may be manipulated by an attacker if the original request is crafted maliciously. This allows an attacker to bypass CSRF protections by injecting a forged request with a valid token, leading to unauthorized actions.}	```const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer });```
5115	dragonslair.it.js	Open Redirect in Notification Click Handler	High	true	N/A	10	N/A	standard	{The `navigate()` method is used with `data.url`, which is derived from a server response and not validated or sanitized. An attacker can craft a malicious notification payload that sets `data.url` to an arbitrary external URL, causing the browser to redirect the user to a phishing or malicious site, leading to open redirect vulnerability.}	```clients[0].navigate(data.url);```
5116	dragonslair.it.js	Client-Side Bypass of Authentication Check	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from client-side logic that checks `loggedIn` via URL parameters, which can be easily manipulated by an attacker. This is not caused by misuse of a sensitive JavaScript function but rather by flawed logic in authentication enforcement.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
5117	dralexandrebertoncini.com.br.js	Insecure Cache Deletion via Message Handler	Medium	false	New	N/A	self.addEventListener('message'	N/A	N/A	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
5118	dralexandrebertoncini.com.br.js	Potential Sensitive Page Caching Bypass	High	false	New	N/A	function shouldCachePageRequest(request) { return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); }	N/A	N/A	```function shouldCachePageRequest(request) { return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); }```
5119	roamingexpress.com.js	Exposure of Sensitive Information (Firebase API Key)	Low	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from hardcoding the Firebase API key in the script, which is not a result of improper use of a sensitive function but rather a misconfiguration or lack of secret management.}	```const options = { firebaseConfig: { projectId: 'push-d158e', messagingSenderId: '492411584807', appId: '1:492411584807:web:3b00012523f489b1616902', apiKey: 'AIzaSyBZCcR39OuclLrjnMzCxF6tLEew4uPeVVU' } };```
5120	roamingexpress.com.js	Server Side Request Forgery (SSRF) in Notification API URL	High	true	CWE-918	N/A	fetch	standard	{The fetch function is used with a URL derived from event.notification.data.api_url, which is user-controlled via push notifications. Since the URL is not validated or sanitized, an attacker can supply arbitrary URLs, leading to SSRF where the service worker makes requests to internal or external systems on behalf of the user.}	```self.addEventListener('notificationclick', event => { let targetUrl = event.notification.data.url; let apiUrl = event.notification.data.api_url; if (event.action && event.notification.data.actions[event.action]) { targetUrl = event.notification.data.actions[event.action].click_action; apiUrl = event.notification.data.actions[event.action].api_url; } clients.openWindow(targetUrl); fetch(apiUrl); event.notification.close(); });```
5121	roamingexpress.com.js	Insecure Direct Object Reference in Notification Data	Medium	true	CWE-601	N/A	self.registration.showNotification	standard	{The self.registration.showNotification function is called with data derived from event.data.json().data.notification, which is untrusted input from a push notification. This allows an attacker to inject arbitrary notification content, including potentially malicious data, leading to IDOR or UI redressing attacks.}	```self.addEventListener('push', event => { const payload = JSON.parse(event.data.json().data.notification); let isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0; if (payload.requireInteraction == null) { payload.requireInteraction = false; } let requireInteraction = isMac ? false : payload.requireInteraction; event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction })); if (event.data.json().data.swVersion != swVersion) { console.log('SW Version is different, Updating SW'); self.registration.update(); } });```
5122	sarkaricash.com.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (API key, project ID, etc.) in the code, not from misuse of a sensitive JavaScript function.}	```const options = { firebaseConfig: { projectId: 'sarkaricash-3077f', messagingSenderId: '701192671492', appId: '1:701192671492:web:ad63703d17ff5a675bc051', apiKey: 'AIzaSyCqQ6gutAnxkyxnztCMyZKwSKSqjzArOY8' }, domain: 'sarkaricash.com', api_url: 'https://push.sharehelpline.in/api/token', vapid_public_key: 'BItLVLBnGA_oLJIT8gZB5QZM32BrE1_PxcBaR_1WaFd1O7vqEv05R9YeFRueEax0JipV81H_frhoTy-xhWU_QOM' };```
5123	sarkaricash.com.js	Open Redirect	High	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is used with a dynamic targetUrl derived from event.notification.data.url, which is user-controlled. This allows an attacker to redirect users to arbitrary URLs, leading to open redirect vulnerabilities.}	```clients.openWindow(targetUrl);```
5124	sarkaricash.com.js	Server Side Request Forgery	Medium	true	N/A	N/A	new URL	standard	{The new URL constructor is used with a user-supplied url parameter, which can be manipulated to perform SSRF attacks by redirecting requests to internal or external resources under the service worker's context.}	```const urlObj = new URL(url);```
5125	sarkaricash.com.js	Deserialization of Untrusted Data	Medium	true	N/A	N/A	JSON.parse	standard	{The JSON.parse function is used on event.data.json().data.notification, which is untrusted data from a push event. This can lead to deserialization of untrusted data, potentially allowing for injection or execution of malicious payloads if the data is not sanitized.}	```const payload = JSON.parse(event.data.json().data.notification);```
5126	sboulder.com.js	Improper Input Validation and URL Handling	High	true	CWE-20	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL provided via the notification's data object, which is derived from untrusted push message data. Since the URL is not validated or sanitized, an attacker can craft a push message with a malicious URL (e.g., a phishing site or a site that performs cross-site scripting or data exfiltration), leading to unintended navigation and potential user compromise.}	"```self.addEventListener(""notificationclick"", function (event) { const clickedNotification = event.notification; clickedNotification.close(); const promiseChain = clients.openWindow(clickedNotification.data.url); event.waitUntil(promiseChain); });```"
5127	seraquepode.com.js	Insecure Storage of Sensitive Data in IndexedDB	High	true	N/A	N/A	indexedDB.open	standard	{The use of indexedDB.open without proper sanitization or access controls allows sensitive data (like FCM tokens) to be stored in a potentially accessible database. If the IndexedDB is not properly secured or if the service worker is compromised, an attacker could extract sensitive tokens, leading to unauthorized access or impersonation. The function is misused by storing data without verifying the context or enforcing access restrictions.}	"```(await Et()).transaction(St, ""readwrite"")```"
5128	seraquepode.com.js	Improper Error Handling in IndexedDB Operations	Medium	false	N/A	N/A	N/A	N/A	{The error handling for IndexedDB operations is inadequate, as errors are caught and logged without proper recovery or user notification. This can lead to silent failures in critical operations like token registration or subscription management, potentially leaving the application in an inconsistent state. However, this is not caused by misuse of a sensitive function but rather by poor error management.}	"```_t = function (e, t, { blocked: n, upgrade: i, blocking: r, terminated: o } = {}) { const a = indexedDB.open(e, t), s = Ve(a); return i && a.addEventListener(""upgradeneeded"", e => { i(Ve(a.result), e.oldVersion, e.newVersion, Ve(a.transaction), e); }), n && a.addEventListener(""blocked"", () => n()), s.then(e => { o && e.addEventListener(""close"", () => o()), r && e.addEventListener(""versionchange"", () => r()); }).catch(() => {}), s; }(yt, It, { upgrade: (e, t) => { 0 === t && e.createObjectStore(St); } })```"
5129	shtreber.com.js	Open Redirect in Notification Click Handler	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a URL provided by the notification data, which is derived from a JSON payload received via a push event. Since the URL is not validated or sanitized, an attacker can craft a malicious payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with untrusted input.}	"```event.waitUntil(sendAnalyticsEvent(""click"", ""notification"", event.notification.title, event.notification.tag), clients.openWindow(event.notification.data.url));```"
5130	silatehilim.com.js	Insecure External Script Loading	Medium	true	CWE-444	8	importScripts	standard	{The importScripts function is used to load an external script from a hardcoded URL. While the URL is fixed and not derived from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. If the URL were dynamically constructed from user input or an untrusted source, it could lead to remote code execution. However, in this case, the URL is static and controlled, so the risk is mitigated but still present due to the nature of the function.}	```importScripts('https://silatehilim.com/wp-content/plugins/daftplug-instantify/pwa/public/assets/js/workbox-v6.5.3/workbox-sw.js');```
5131	silatehilim.com.js	Insecure Push Notification URL Handling	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a URL derived from event.notification.data.pushActionButton1Url, which is user-controlled data from a push notification. Since the URL is not validated or sanitized, an attacker can craft a malicious push notification to redirect the user to an arbitrary site, leading to phishing, malware distribution, or other client-side attacks. This constitutes a high-risk vulnerability due to direct user interaction and potential for exploitation.}	```event.waitUntil(clients.openWindow(event.notification.data.pushActionButton1Url));```
5132	silatehilim.com.js	CSRF Vulnerability in Subscription Update	Medium	false	CWE-352	7	N/A	N/A	{The vulnerability arises from the lack of CSRF protection in the POST request to the admin-ajax.php endpoint. While the fetch API is used, the issue is not due to misuse of a sensitive function but rather a missing security token or origin validation. The fetch call itself is not inherently unsafe when used with proper headers and authentication; the vulnerability stems from the server-side lack of CSRF mitigation.}	```fetch('https://silatehilim.com/wp-admin/admin-ajax.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'daftplug_instantify_handle_subscription_update', oldEndpoint: event.oldSubscription ? event.oldSubscription.endpoint : null, newEndpoint: event.newSubscription ? event.newSubscription.endpoint : null, newUserKey: event.newSubscription ? event.newSubscription.toJSON().keys.p256dh : null, newUserAuth: event.newSubscription ? event.newSubscription.toJSON().keys.auth : null }) });```
5133	sincortenohaygloria.com.js	XSS via Unsanitized User Input in Notification Reply	High	true	CWE-79	10	fetch	standard	{The fetch function is used to send a POST request with user-provided data from the notification reply (`t.reply`) directly in the request body without sanitization. This allows an attacker to inject malicious content, such as script tags or other payloads, which could be processed by the server and potentially reflected back to the user or used to perform actions on their behalf, leading to XSS or other client-side attacks.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
5134	skoriginals.in.js	Service Worker Fetch Without Cache Utilization	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the service worker directly fetching resources without utilizing the cache, which defeats the purpose of a service worker for offline support and performance optimization. However, this is not caused by misuse of a sensitive function, as no function like importScripts, eval, or dynamic code execution is involved.}	```self.addEventListener('fetch', event => { event.respondWith(fetch(event.request)); });```
5135	sonycenters.gr.js	Improper Neutralization of URL Redirects	Medium	true	CWE-601	8	clients.openWindow	standard	{The function clients.openWindow(url) is used with a dynamic URL derived from event.target.notificationData.notification.click_action, which is untrusted input. If this input is not sanitized or validated, an attacker could craft a malicious URL to redirect users to phishing sites or perform open redirects, leading to potential credential theft or further exploitation.}	```var url = event.target.notificationData.notification.click_action; event.waitUntil(self.clients.matchAll().then(function (clientList) { if (clientList.length > 0) { return clientList[0].focus(); } return self.clients.openWindow(url); }));```
5136	sportcenter.com.uy.js	Improper Validation of Cached Offline Page	High	true	CWE-79	10	N/A	standard	"{The vulnerability arises from the use of `caches.open()` and `cache.match()` to serve an offline fallback page without validating or sanitizing the `offlineFallbackPage` value. Although the value is hardcoded as ""offline.html"", the vulnerability is classified as sensitive because the `caches.match()` function can be misused if the fallback page path were derived from untrusted input, potentially allowing an attacker to trigger the serving of arbitrary cached content, including malicious files. In this case, while the input is static, the function's behavior with dynamic inputs introduces risk, hence the classification as sensitive misuse.}"	```self.addEventListener('fetch', event => { if (event.request.mode === 'navigate') { event.respondWith((async () => { try { const preloadResp = await event.preloadResponse; if (preloadResp) { return preloadResp; } const networkResp = await fetch(event.request); return networkResp; } catch (error) { const cache = await caches.open(CACHE); const cachedResp = await cache.match(offlineFallbackPage); return cachedResp; } })()); } });```
5137	studycall.fr.js	Improper Input Validation in Push Event Handling	Medium	true	CWE-20	8	JSON.parse	standard	{The push event handler uses event.data.json() to parse incoming push data, which is inherently untrusted. If the data is malformed or maliciously crafted, it could lead to unexpected behavior or injection attacks, especially if the parsed data is used directly in subsequent operations (e.g., constructing notification content). Although the code does not directly execute the parsed data, improper validation of the parsed JSON can still lead to information disclosure or client-side manipulation.}	```self.addEventListener('push', event => { const json = event.data.json(); let title = json.title; let body = json.body; let tag = json.tag; let icon = json.icon; event.waitUntil(self.registration.showNotification(title, { body, icon, tag })); });```
5138	studygovt99.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase API credentials (apiKey, projectId, etc.) in client-side JavaScript, which can be easily accessed by attackers. This is not caused by misuse of a sensitive function, but rather by insecure exposure of secrets.}	```const options = { firebaseConfig: { projectId: 'studygovt99-87ed4', messagingSenderId: '515097958706', appId: '1:515097958706:web:e6d170665050f824469f2b', apiKey: 'AIzaSyBBo6pBy7uOb82mbehAJXbW2tQA5di5TGU' } };```
5139	studygovt99.com.js	XSS via Untrusted Notification Payload	Medium	true	N/A	N/A	showNotification	standard	{The showNotification function is used with untrusted payload data (from event.data.json().data.notification) without sanitization. Since the payload is directly passed into the notification object, an attacker can inject malicious content (e.g., script tags) that may be rendered in the notification UI, leading to XSS if the browser renders it as HTML.}	```event.waitUntil(self.registration.showNotification(payload.title, { ...payload, data: payload, requireInteraction: requireInteraction }));```
5140	studygovt99.com.js	Open Redirect via Notification Data	Medium	true	N/A	N/A	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from untrusted notification data (event.notification.data.url or actions[event.action].click_action). This allows an attacker to craft a notification payload that redirects users to arbitrary URLs, potentially leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
5141	tactirshop.fr.js	Improper Error Handling in Fetch Event Leading to Invalid Response	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling in the fetch event handler, where a catch block returns a function instead of a response or promise, leading to invalid responses. This is not due to misuse of a sensitive function, but rather a logic flaw in error handling.}	"```event.respondWith(caches.match(event.request).then(function (resp) { return fetch(event.request).then(function (response) { return caches.open(dynamicCacheName).then(function (cache) { cache.put(event.request, response.clone()); return response; }); }).catch(function (rejectMsg) { return resp || function () { console.log(""Error""); }; }); }).catch(function () { return caches.match(""Error""); }));```"
5142	tendancesandco.fr.js	External Script Import Vulnerability	High	true	N/A	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external domain (https://aswpsdkeu.com/notify/v1/ua-sdk.min.js), it introduces a risk if the script source is not fully trusted or if the domain is compromised. Although the URL is hardcoded here, the vulnerability arises because the script is loaded from an external source, which could be controlled by an attacker if the domain is compromised or if the script is dynamically injected via other means. This allows for potential script injection and execution within the service worker context, leading to full control over the worker’s behavior.}	```importScripts('https://aswpsdkeu.com/notify/v1/ua-sdk.min.js');```
5143	tendancesandco.fr.js	Hardcoded Secrets Exposure	Medium	false	N/A	N/A	N/A	N/A	{The exposure of secrets such as appKey and token is not due to misuse of a sensitive function, but rather due to poor configuration practices. These values are hardcoded in the script and can be extracted by anyone inspecting the source. While this is a serious security issue, it does not stem from the improper use of a sensitive JavaScript function like importScripts or eval.}	```uaSetup.worker(self, { defaultIcon: 'https://dl.asnapieu.com/binary/public/VcNoKrb9QWOaW0fSYPf5Vw/af1a2372\u002D0087\u002D4a22\u002Dac2c\u002D717265d63e69', defaultTitle: 'Nord Littoral', defaultActionURL: 'https://www.nordlittoral.fr/', appKey: 'VcNoKrb9QWOaW0fSYPf5Vw', token: 'MTpWY05vS3JiOVFXT2FXMGZTWVBmNVZ3Okxpd044T21VeUpGa1daWXBWbkdFejBELVRsa0RCLTcyNzRaT0xYT0tTdEE', vapidPublicKey: 'BJ7K6LHVDvB9vOdREXvD9re0O8u-woM_tLkMILSKElkdlVxMAJA_uws3FBXAD9bLyJrTKr-NkycBKptWjvoofeI' });```
5144	tester-market.com.js	Regular Expression Denial of Service (ReDoS	High	true	CWE-400	10	RegExp	standard	"{The code constructs regular expressions from user-controlled or static strings via JSON.parse() and new RegExp(), which can lead to ReDoS if the input contains malicious patterns. Although the input is hardcoded, the use of new RegExp() with untrusted or complex patterns (even if static) is considered sensitive because it can be exploited if the pattern is dynamically generated or if the pattern contains pathological cases that cause exponential backtracking. In this case, the pattern ""tester-market\\\\.com(?:/.*)?/ola/services/.*"" is particularly risky due to the unbounded quantifier (?:/.*)? which can cause ReDoS when matched against long strings.}"	"```const c = JSON.parse('[""tester-market\\\\.com(?:/.*)?/ola/services/.*"",""tester-market\\\\.com/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://b5cae3a3-888e-43c5-ad2f-8dad70388dad\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
5145	tienda.ro.js	Loading external script without integrity check	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of remote code from untrusted sources. In this case, the script is loaded from 'https://files4.vtcdn.net/_assets/js/vtpush_worker.js', which is a hardcoded external URL. While the URL is not dynamically constructed from untrusted input, the lack of integrity verification (e.g., using a Subresource Integrity hash) still constitutes a high-risk vulnerability because the script could be tampered with in transit or replaced by an attacker if the server is compromised. This allows for potential code injection and execution within the service worker context.}	```importScripts('https://files4.vtcdn.net/_assets/js/vtpush_worker.js');```
5146	tninfo24.in.js	Exposure of Sensitive Information	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding sensitive Firebase configuration data (including API key, project ID, and VAPID key) directly in the script. This is not due to misuse of a sensitive function, but rather poor secret management.}	```const options = { firebaseConfig: { projectId: 'larapush-19ba0', messagingSenderId: '546256552164', appId: '1:546256552164:web:a54a0077ff5e0f3b34acf1', apiKey: 'AIzaSyA9ysO7oo6eny43Rgs1SKgDYECvjUolvG4' }, domain: 'tninfo24.in', api_url: 'https://push.stockskhabar.com/api/token', vapid_public_key: 'BFa8L_Eaesemzqo6QhtAc2U5zgeMgJ4ImztB1VbYcBkoqIvJ5yv9iwcKFTmb_xAVOZcgwBg7iRS_8WHQ9wPixYw' };```
5147	tninfo24.in.js	Improper Input Validation	Medium	true	N/A	N/A	JSON.parse	standard	{The function JSON.parse is used to parse event.data.json().data.notification, which is derived from untrusted push message data. If the data is malformed or crafted by an attacker, it can lead to parsing errors or unintended behavior, potentially allowing for injection or denial of service.}	```const payload = JSON.parse(event.data.json().data.notification);```
5148	tninfo24.in.js	Open Redirect	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is called with targetUrl, which is derived from notification data that is not validated or sanitized. An attacker can craft a push notification with a malicious URL, causing the browser to open an arbitrary site, leading to phishing or redirect attacks.}	```clients.openWindow(targetUrl);```
5149	tninfo24.in.js	Improper Message Origin Validation	Medium	true	N/A	N/A	self.addEventListener	standard	{The service worker listens for messages without validating the origin of the message sender. This allows any page or script within the same origin to send messages, potentially leading to unauthorized actions if the message data is not properly validated.}	```self.addEventListener('message', event => { const { command, url } = event.data; ... });```
5150	tujastrzebie.pl.js	Loading untrusted external script without integrity check in Service Worker	High	true	CWE-960	10	importScripts	standard	{The importScripts() function in Service Workers loads and executes external JavaScript files. When used with a hardcoded URL from an untrusted source (like pushpushgo.com) without integrity verification, it introduces a high-risk vulnerability. An attacker could compromise the external script source, leading to arbitrary code execution within the service worker context, enabling cache manipulation, network interception, or data exfiltration.}	```importScripts('https://s-eu-1.pushpushgo.com/5de65b183bd08d67f67b6323/worker.js');```
5151	ultimecalcionapoli.it.js	Insecure Direct Object Reference (IDOR) in URL construction	High	true	CWE-20	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes user-controlled data (body.data.push_send_id and sensor_url). Since these values are not validated or sanitized, an attacker can manipulate them to access unauthorized resources or trigger unintended behavior, leading to IDOR. The URL is built by concatenating untrusted input directly into the request, which allows for arbitrary endpoint targeting.}	```const ve = sensor_url + '/e?site_name=www.ultimecalcionapoli.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
5152	ultratiming.live.js	Open Redirect via Notification Data	Medium	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow function is used to open a URL provided by the notification data, which is derived from untrusted push notification data. Since the URL is not validated or sanitized, an attacker can craft a push notification with a malicious URL, leading to an open redirect that could trick users into visiting phishing sites or malicious domains.}	```event.waitUntil(clients.openWindow(notification.data.url ?? 'https://www.ultratiming.live/'));```
5153	ultratiming.live.js	Open Redirect via Push Data	Medium	true	CWE-601	10	none	standard	{Although no direct sensitive function is called in this line, the assignment of notification.resourceUrl to data.url introduces a risk because this value is later used in clients.openWindow. The vulnerability arises from the improper handling of untrusted input (notification.resourceUrl) without validation, which can lead to an open redirect when processed by the sensitive function clients.openWindow.}	```data.url = notification.resourceUrl;```
5154	varesefansbasket.it.js	Cross-Site Scripting (XSS) via Notification Content	High	true	CWE-79	9	registration.showNotification	standard	{The function `registration.showNotification` is used to display notifications with user-controlled content (e.g., `title` and `body`) that are derived from server responses. If the server does not sanitize these values, an attacker can inject malicious scripts into the notification content, which may be executed in the context of the user's browser when the notification is displayed or interacted with, leading to XSS.}	```return self.registration.showNotification(title, options);```
5155	varesefansbasket.it.js	Cross-Site Request Forgery (CSRF) Bypass via URL Parameter	High	false	CWE-352	0	N/A	N/A	{The vulnerability arises from the use of a URL parameter (`loggedIn`) to determine user state, but it is not directly caused by misuse of a sensitive JavaScript function. The issue lies in the logic that trusts the `loggedIn` parameter without proper validation or CSRF token enforcement, which is a business logic flaw rather than a function misuse.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
5156	varesefansbasket.it.js	Open Redirect via Notification Click Handler	Medium	true	CWE-601	8	clients.navigate	standard	{The `clients.navigate` function is used to redirect the user to a URL specified in the notification's `data.url` field. If this URL is not validated or sanitized and can be controlled by an attacker (e.g., via a malicious push notification), it enables open redirect, allowing users to be redirected to arbitrary websites, potentially leading to phishing or credential theft.}	```clients[0].navigate(data.url);```
5157	viya-store.com.js	Improper Input Validation - Phishing via Untrusted Notification Actions	High	true	New	10	N/A	standard	{The `self.registration.showNotification()` function is used to display notifications with actions that are derived from untrusted input (`t.options.actions`). The `action` fields from the incoming data are directly used to construct URLs (`first_action_url`, `second_action_url`) and passed to the notification, allowing an attacker to inject arbitrary URLs. Since these URLs are not validated or sanitized, they can point to phishing sites or malicious destinations, leading to phishing attacks. This misuse of `showNotification()` with untrusted data constitutes a sensitive function vulnerability.}	```const [r, i] = t.options.actions, n = r && { action: 'first_action', icon: r.icon, title: r.title }, s = i && { action: 'second_action', icon: i.icon, title: i.title }; e.waitUntil(self.registration.showNotification(t.title, { ...t.options, data: { ...t.options.data, first_action_url: r && r.action, second_action_url: i && i.action }, actions: [n, s].filter(Boolean) }));```
5158	wruh938rjfcioit90jg9dfn.com.js	Cache Poisoning via Insecure Route Matching	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insecure route matching logic in the workbox configuration, specifically using `e.pathname.includes('/games/allGameList')` without validating or sanitizing the URL path. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by flawed logic in route matching that could allow unintended caching of responses. Since no sensitive function is misused, this is not a sensitive vulnerability.}	"```define(""./service-worker.js"", [""./workbox-c9728ebb""], function (e) { ""use strict""; importScripts(), e.setCacheNameDetails({ prefix: ""mocbai_v1"" }), self.skipWaiting(), e.registerRoute(({ url: e, sameOrigin: r }) => ""/"" === e.pathname && !e.search && r, new e.StaleWhileRevalidate({ cacheName: ""html"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameList""), new e.StaleWhileRevalidate({ cacheName: ""agl"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/staticpagesettings/Info/orders""), new e.StaleWhileRevalidate({ cacheName: ""ord"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 86400, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""), e.registerRoute(({ url: e }) => e.pathname.includes(""/games/allGameName""), new e.StaleWhileRevalidate({ cacheName: ""agn"", plugins: [new e.ExpirationPlugin({ maxAgeSeconds: 10800, maxEntries: 1, purgeOnQuotaError: !0 })] }), ""GET""); });```"
5159	xn--8dbbvwj.net.js	Server Side Request Forgery (SSRF	Medium	false	CWE-918	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive JavaScript function, but rather by the service worker forwarding arbitrary fetch requests without validation. The `fetch(event.request)` call is standard and safe when used in context, but SSRF arises from the lack of input validation on the request URL, not from a function misuse per se.}	```self.addEventListener('fetch', function (event) { console.log('[Service Worker] Fetch initiated.....', event); event.respondWith(fetch(event.request)); });```
5160	xn--8dbbvwj.net.js	Information Exposure Through Error Message	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from logging and transmitting error details to a server endpoint without sanitization, but it is not due to misuse of a sensitive JavaScript function. The `fetch` call itself is not misused; the issue is in the data being sent, not the function.}	"```fetch(""logerror.php"", { method: ""POST"", body: JSON.stringify({ error: JSON.stringify(e) }), headers: { ""Content-type"": ""application/json; charset=UTF-8"" } });```"
5161	sunwave.com.js	Cache Poisoning via Overly Permissive Regex	High	true	CWE-444	10	workbox.routing.registerRoute	standard	{The vulnerability arises from the use of a regular expression in workbox.routing.registerRoute that matches URLs from a specific domain (e.g., jlrorwxhqipjll5p.ldycdn.com) with a broad pattern (.*(?:png|gif|jpg|jpeg|webp|svg)$). While workbox.routing.registerRoute itself is not inherently sensitive, the misuse lies in the overly permissive regex that allows any subpath under the domain to be cached, potentially enabling cache poisoning if an attacker can control or influence the content served from that domain. However, since the domain is hardcoded and not derived from untrusted input, this is not a direct sensitive function misuse. Therefore, the vulnerability is not caused by a sensitive function misuse, and the is_sensitively_vulnerable should be false.}	```workbox.routing.registerRoute(new RegExp('https://jlrorwxhqipjll5p\.ldycdn\.com/.*(?:png|gif|jpg|jpeg|webp|svg)$'), new workbox.strategies.CacheFirst({ cacheName: 'cdn:images', plugins: [new workbox.cacheableResponse.Plugin({ statuses: [0, 200] }), new workbox.expiration.Plugin({ maxEntries: 30, maxAgeSeconds: 30 * 24 * 60 * 60 })] }));```
5162	celebritytidbit.com.js	Improper Input Validation in Fetch Handler	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability stems from improper handling of request headers in the fetch event, particularly when accepting responses for text/html, text/css, or text/javascript. However, no sensitive JavaScript function (like importScripts, eval, or dynamic code execution) is misused here. The issue is more about logic and caching behavior rather than direct function misuse.}	"```self.addEventListener('fetch', function (t) { var e = t.request; ""only-if-cached"" === t.request.cache && ""same-origin"" !== t.request.mode || (e.headers.get(""Accept"").includes(""text/html"") && t.respondWith(fetch(e).then(function (e) { return e; }).catch(function (e) { return caches.match(""/offline/""); })), (e.headers.get(""Accept"").includes(""text/css"") || e.headers.get(""Accept"").includes(""text/javascript"")) && t.respondWith(async function () { var e = await caches.match(t.request); return e || (await t.preloadResponse) || fetch(t.request); }()); });```"
5163	ealvinsmall.com.js	Insecure Cache Deletion via Service Worker Message	High	true	CWE-200	7	self.addEventListener('message'	standard	{The service worker listens for messages and deletes a specific cache (SITE_PAGES_CACHE_NAME) based on a command received from the page. While the cache name is hardcoded, the vulnerability arises from the fact that the message handler does not validate or sanitize the incoming command, allowing an attacker to potentially trigger unintended cache deletions if the message structure is manipulated. However, since the cache name is fixed and not derived from untrusted input, this is not a direct sensitive function misuse but rather a logic flaw in message handling.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
5164	ealvinsmall.com.js	Regex Injection in Template Function	Medium	true	CWE-132	9	function template(str	standard	{The template function constructs a regular expression dynamically using user-provided keys from the data object. If an attacker can control the keys passed to the template function, they can inject arbitrary regex patterns, potentially leading to ReDoS or unintended behavior. The regex is built using Object.keys(data).join('|'), which is then used in a RegExp constructor, making it vulnerable to injection if the data object is not sanitized.}	```function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }```
5165	ealvinsmall.com.js	Empty Fetch Event Listener Bypassing Caching Logic	Medium	false	New	10	self.addEventListener('fetch'	standard	{The fetch event listener is defined but contains no logic, effectively bypassing all caching strategies implemented elsewhere in the service worker. This is a logic flaw rather than a sensitive function misuse, as the function is not being misused with untrusted input but is simply not implemented.}	```self.addEventListener('fetch', () => {});```
5166	diba.de.js	Loading external script without integrity check	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. When used without integrity checks, it can load malicious scripts if the remote source is compromised, leading to code injection and potential full control over the service worker. The URL is hardcoded, but the lack of integrity verification still constitutes a high-risk vulnerability because the script source is external and not verified.}	```importScripts('https://cdn.ing.de/ing-cms-ui/131.1.0/service-worker.js');```
5167	debanked.com.js	Remote Code Execution via Untrusted Script Inclusion	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://cdn.pushcrew.com/sw/a6713bc135ce2f5e62e8d4b863fd1bd2.js'. While the URL is not dynamically constructed from untrusted input, the script is still loaded from an external, third-party source, which introduces a risk of remote code execution if the source is compromised or malicious. This constitutes a sensitive function misuse because importScripts() executes arbitrary code from a remote location without validation or integrity checks.}	```var version = 6; importScripts('https://cdn.pushcrew.com/sw/a6713bc135ce2f5e62e8d4b863fd1bd2.js');```
5168	larasch.de.js	Outdated Workbox Version	Medium	false	New	N/A	N/A	N/A	N/A	```importScripts(...[options.workboxURL, ...options.importScripts]);```
5169	larasch.de.js	Insecure Pre-Caching of Query Parameter URL	Low	false	New	N/A	N/A	N/A	N/A	```'url': '/?standalone=true'```
5170	larasch.de.js	Potential Arbitrary Code Execution via Dynamic Plugin Instantiation	High	true	New	N/A	getProp	standard	{The function getProp is used to dynamically resolve a property path (e.g., p.use) from the workbox object, which is then invoked with new. If an attacker can control the p.use value (e.g., via a malicious configuration), this allows arbitrary constructor invocation, leading to potential code execution. The dynamic nature of getProp and its use in new (getProp(workbox, p.use))(...p.config) makes this a high-risk sensitive function misuse.}	```new (getProp(workbox, p.use))(...p.config)```
5171	thewelldressedlife.com.js	Incorrect Cache Version Handling	Low	false	CWE-20	0	N/A	N/A	{The vulnerability arises from hardcoding a version string (`v351997::`) and concatenating it with a cache name (`trellisCache`). This does not involve any sensitive JavaScript function misuse, such as dynamic input being passed to functions like `importScripts()` or `fetch()` with untrusted sources. The issue is a configuration or logic flaw, not a security vulnerability caused by improper use of a sensitive function.}	```var version = 'v351997::'; var trellisCache = version + 'trellisCache';```
5172	fx4u.io.js	Caching Sensitive Data Without Validation	High	false	N/A	0	N/A	N/A	{The vulnerability arises from caching responses without validating the content or origin of the requested resources. However, no sensitive JavaScript function is misused; the issue stems from a design flaw in cache handling rather than improper use of a function like importScripts or eval.}	```self.addEventListener('fetch', event => { if (event.request.url.startsWith(self.location.origin)) { event.respondWith(caches.match(event.request).then(cachedResponse => { if (cachedResponse) { return cachedResponse; } return caches.open(RUNTIME).then(cache => { return fetch(event.request).then(response => { return cache.put(event.request, response.clone()).then(() => { return response; }); }); }); })); });```
5173	fx4u.io.js	Cache Poisoning Risk	Medium	false	N/A	0	N/A	N/A	{This risk stems from the service worker caching responses without validating the integrity or source of the data. Since the fetch and cache.put operations are used with trusted origins (self.location.origin), there is no direct misuse of a sensitive function. The vulnerability is architectural, not due to function misuse.}	```self.addEventListener('fetch', event => { if (event.request.url.startsWith(self.location.origin)) { event.respondWith(caches.match(event.request).then(cachedResponse => { if (cachedResponse) { return cachedResponse; } return caches.open(RUNTIME).then(cache => { return fetch(event.request).then(response => { return cache.put(event.request, response.clone()).then(() => { return response; }); }); }); })); });```
5174	fx4u.io.js	Unbounded Cache Growth	Medium	false	N/A	0	N/A	N/A	{The issue is due to the service worker caching all requests from the origin without implementing cache size limits or eviction policies. This is a configuration or design issue, not a result of misusing a sensitive JavaScript function such as importScripts or eval.}	```self.addEventListener('fetch', event => { if (event.request.url.startsWith(self.location.origin)) { event.respondWith(caches.match(event.request).then(cachedResponse => { if (cachedResponse) { return cachedResponse; } return caches.open(RUNTIME).then(cache => { return fetch(event.request).then(response => { return cache.put(event.request, response.clone()).then(() => { return response; }); }); }); })); });```
5175	mybenefitsclub.com.js	Importing untrusted external script from third-party domain	High	true	CWE-78	9	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from a third-party domain (e.g., https://api.pushnami.com), it introduces a high-risk vulnerability because the script is executed with the same privileges as the service worker. Although the URL is hardcoded, the origin is untrusted and could be compromised or malicious, leading to potential code injection, data exfiltration, or manipulation of the service worker’s behavior. This constitutes a sensitive function misuse due to the execution of untrusted code.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/633316cd4df9f00013c5f38d"");```"
5176	trivia.buzz.js	External Script Import Vulnerability	High	true	CWE-444	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently dangerous, but if the URL were derived from untrusted input (e.g., user-controlled parameters), it could lead to arbitrary script execution. However, in this case, the URL is hardcoded and does not involve dynamic input, so the vulnerability is not due to sensitive function misuse. Therefore, the vulnerability is not classified as ""sensitively_vulnerable"" because the function is used safely with a fixed, trusted source.}"	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/6541675d651e9a0013519062"");```"
5177	saesrpg.uk.js	Insecure Direct Object Reference (IDOR)/Server Side Request Forgery (SSRF	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from untrusted push notification data. Since the 'id' value is not validated or sanitized, an attacker can manipulate it to trigger requests to arbitrary endpoints on the server, potentially leading to SSRF or IDOR if the server processes the ID in a context that allows access to restricted resources.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5178	saesrpg.uk.js	Improper Input Validation Leading to Denial of Service	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the 'loggedIn' value extracted from the URL, but it does not involve misuse of a sensitive JavaScript function. The logic is flawed, but no sensitive function is being misused.}	```let loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
5179	saesrpg.uk.js	CSRF Token Generation with Unvalidated Path	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used to request a CSRF token with a dynamically constructed URL that includes the 'path' parameter derived from the request URL. Since the path is not validated or sanitized, an attacker could manipulate it to request tokens for unintended endpoints, potentially leading to CSRF attacks if the token is used in a context that allows unauthorized actions.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5180	saesrpg.uk.js	Open Redirect via Unvalidated Notification URL	Medium	true	N/A	N/A	navigate	standard	{The navigate method is used with a URL extracted from notification data, which is not validated or sanitized. An attacker could craft a notification with a malicious URL, causing the client to navigate to an arbitrary site, leading to open redirect and potential phishing or malware distribution.}	```clients[0].navigate(data.url);```
5181	saesrpg.uk.js	Insecure Use of Dynamic Window Opening	Medium	true	N/A	N/A	openWindow	standard	{The openWindow method is used with a URL derived from notification data, which is not validated or sanitized. This allows an attacker to redirect users to arbitrary websites, potentially leading to phishing, malware distribution, or other malicious activities.}	```return self.clients.openWindow(data.url ? data.url : BASE_URL);```
5182	essanews.com.js	Caching of Opaque Responses	High	true	CWE-921	10	workbox.cacheableResponse.CacheableResponsePlugin	standard	{The CacheableResponsePlugin is used with the status `OPAQUE` (0), which allows caching of responses that are not fully inspectable (e.g., from cross-origin requests with opaque CORS). This can lead to caching of potentially malicious or unintended content, especially if the cache is later used to serve responses without proper validation, enabling cache poisoning or bypassing security checks. The misuse lies in allowing opaque responses to be cached without ensuring they are safe or intended for caching.}	```const { CacheableResponsePlugin: n } = workbox.cacheableResponse; ... new n({ statuses: [s.OPAQUE, s.OK] })```
5183	ijzcg.me.js	Uninitialized Variable in Custom Event Handler	Medium	false	CWE-457	N/A	N/A	N/A	{The vulnerability arises from the use of the variable `offlinePage` in the `refreshOffline` event handler without prior initialization. This variable is declared and assigned within the `install` event handler, but it is not declared or assigned in the `refreshOffline` handler, leading to a reference error when the event is triggered. This is not a sensitive function misuse, as no dangerous or security-sensitive JavaScript function is being improperly used with untrusted input.}	```self.addEventListener('refreshOffline', function (response) { return caches.open('base-offline').then(function (cache) { return cache.put(offlinePage, response); }); });```
5184	plnnusantarapower.co.id.js	Improper Input Validation for Range Header	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper validation of the 'range' header, but it is not caused by misuse of a sensitive JavaScript function. The code extracts a numeric value from the header using a regex and Number(), which are standard functions, but their misuse here is not classified as a sensitive function vulnerability. The issue is more about logic and input sanitization rather than a dangerous API being misused with untrusted input.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
5185	nsfas-applications.co.za.js	Exposure of Sensitive Data via Untrusted API	High	true	CWE-200	9	fetch	standard	{The fetch function is used to send sensitive data (push token, endpoint, auth keys, p256dh) to a remote API endpoint (options.api_url) without validating or sanitizing the data. Since the data is derived from user-controlled inputs (e.g., subscription details) and sent without encryption or access controls, it exposes sensitive information to potential interception or misuse by an attacker.}	"```javascript await fetch(options.api_url, { method: ""POST"", headers: { ""Content-Type"": ""application/json"" }, body: JSON.stringify({ domain, token, url: url, endpoint: newSubscription.endpoint, auth: newSubscription.keys.auth, p256dh: newSubscription.keys.p256dh }) });```"
5186	nsfas-applications.co.za.js	Open Redirect in Notification Click Handler	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with targetUrl, which is derived from event.notification.data.url or event.notification.data.actions[event.action].click_action. Since these values are sourced from untrusted notification payloads, an attacker can craft a malicious notification to redirect users to arbitrary URLs, leading to phishing or drive-by downloads.}	```javascript clients.openWindow(targetUrl);```
5187	nsfas-applications.co.za.js	Potential SSRF via getDomainAndHostname	Medium	true	CWE-918	8	new URL	standard	{The new URL constructor is used with a user-controlled url parameter, which can be manipulated to point to internal or restricted resources (e.g., localhost, internal IPs). This allows an attacker to perform Server-Side Request Forgery (SSRF) by forcing the service worker to make requests to unintended endpoints.}	```javascript const urlObj = new URL(url);```
5188	nsfas-applications.co.za.js	Insecure Storage of Sensitive Data in IndexedDB	Low	false	CWE-312	0	N/A	N/A	{The IndexedDB storage is used to store sensitive data (notification token) via put operations, but the vulnerability is not due to misuse of a sensitive function. The issue lies in the lack of encryption or access controls for stored data, not in the function call itself.}	```javascript const request = objectStore.put({ id: key, data: value });```
5189	africa.restaurant.js	High	High	false	CWE-548	0	N/A	N/A	{The vulnerability is due to hardcoded Firebase configuration, not misuse of a sensitive function. The API key and other credentials are exposed in the source code, which is a configuration issue rather than a function misuse.}	```importScripts('https://www.gstatic.com/firebasejs/9.21.0/firebase-app-compat.js');importScripts('https://www.gstatic.com/firebasejs/9.21.0/firebase-messaging-compat.js');firebase.initializeApp({apiKey: 'AIzaSyC_Wes7JJUZKCoX5bgSRWMSfl31BIeE9_U',authDomain: 'starkitchen-messaging.firebaseapp.com',projectId: 'starkitchen-messaging',storageBucket: 'starkitchen-messaging.appspot.com',messagingSenderId: '105981795433',appId: '1:105981795433:web:efa7479299f34e7e5a16f8',measurementId: 'G-Y0FRJQZXVH'});```
5190	africa.restaurant.js	Medium	Medium	true	CWE-601	8	self.clients.openWindow	standard	{The function self.clients.openWindow is used with event.notification.data, which is untrusted input from a push notification. If an attacker can control the notification payload, they can redirect the user to arbitrary URLs, leading to phishing or malicious site redirection.}	```event.waitUntil(self.clients.openWindow(event.notification.data));```
5191	chaymarket.com.js	Improper Validation of Range Header	High	true	CWE-20	9	Number	standard	{The function Number() is used to parse the range header value extracted via a regex, which is derived from user-controlled input (event.request.headers.get('range')). If the header is malformed or crafted by an attacker, the regex may extract unexpected values, leading to incorrect parsing and potentially out-of-bounds memory access via ab.slice(pos), resulting in a denial of service or information disclosure.}	N/A
5192	chaymarket.com.js	External Script Loading from Untrusted CDN	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is used to load a script from a CDN URL that is hardcoded but not verified for integrity or origin. While the URL is fixed, the use of importScripts() with any external source introduces risk if the CDN is compromised or if the script is tampered with, allowing an attacker to inject malicious code into the service worker, leading to full control over caching, network requests, and client behavior.}	N/A
5193	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js"");```"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js"");```"
5194	chaymarket.com.js	Incorrect Regex Matching for Sensitive URLs	Medium	false	CWE-209	0	N/A	N/A	{The vulnerability arises from flawed regex patterns in the neverCacheUrls array, which are not sensitive function misuse but rather logic or design flaws in URL filtering. The regexes are hardcoded and do not involve dynamic input or unsafe function calls.}	N/A
5195	chaymarket.com.js	Insecure Cache Matching Using URL Instead of Request	Medium	false	CWE-208	0	N/A	N/A	{The vulnerability stems from using e.request.url instead of e.request in caches.match(), which may lead to incorrect cache matching due to missing headers or method context. This is a logic issue, not misuse of a sensitive function.}	N/A
5196	tchap.gouv.fr.js	Weak Key Derivation Using Static Salt	High	false	CWE-327	0	N/A	N/A	{The vulnerability arises from the use of a static salt (u, a fixed Uint8Array of 8 zeros) in the HKDF key derivation process. While this is not a direct misuse of a sensitive function like importScripts or eval, it is a cryptographic weakness. The code does not use any sensitive JavaScript function in a way that introduces dynamic, untrusted input execution or injection. The issue is purely cryptographic and stems from poor key derivation practices, not from improper use of a JavaScript API.}	```const r = await globalThis.crypto.subtle.importKey('raw', t, {name: 'HKDF'}, !1, ['deriveBits']), n = await globalThis.crypto.subtle.deriveBits({name: 'HKDF', salt: u, info: new TextEncoder().encode(e), hash: 'SHA-256'}, r, 512), o = n.slice(0, 32), i = n.slice(32), s = globalThis.crypto.subtle.importKey('raw', o, {name: 'AES-CTR'}, !1, ['encrypt', 'decrypt']), f = globalThis.crypto.subtle.importKey('raw', i, {name: 'HMAC', hash: {name: 'SHA-256'}}, !1, ['sign', 'verify']);```
5197	chekida.com.js	Empty Cache Array in Service Worker	Low	false	N/A	0	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by an empty array passed to cache.addAll(), which results in no resources being cached. This is a logic or configuration issue, not a security vulnerability stemming from unsafe function usage.}	```var staticCacheName = 'djangopwa-v1';self.addEventListener('install', function (event) {event.waitUntil(caches.open(staticCacheName).then(function (cache) {return cache.addAll(['']);}));});```
5198	ivcert.net.js	XSS via Unsanitized Message Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by unsanitized data being passed to clients via postMessage. Since postMessage is used correctly and does not directly execute or render untrusted data, the risk stems from downstream handling in the client context, not from a sensitive function misuse in the service worker.}	```self.addEventListener('message', function (event) {  if (event.data && event.data['firma']) {    const cl = self.clients.matchAll();    cl.then(clients => {      clients.forEach(client => {        client.postMessage(event.data);      });    });  }});```
5199	dress-for-less.com.js	Vulnerable Fetch Handling Without HTTPS Check	High	true	N/A	N/A	fetch	standard	{The fetch function is used without enforcing HTTPS, allowing requests to be made over HTTP, which can lead to man-in-the-middle attacks and data interception. The code does not validate or enforce secure connections, making it vulnerable to insecure communication.}	```const { request: t } = e, r = this.handleRequest({ request: t, event: e });```
5200	dress-for-less.com.js	Insecure Message Handling Without Validation	High	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener function is used to handle messages without validating the message data, allowing potentially malicious payloads to be processed. This can lead to arbitrary code execution or data leakage if the message data is not properly sanitized or validated.}	```self.addEventListener('message', function (e) { var t = e.data; !function handleMessageFromClient(e, t, r) { var a = n[e]; a && a.forEach(function (e) { e(t, r); }); }(t.type, t.payload, e); });```
5201	dress-for-less.com.js	Potential Cache Poisoning Due to Incomplete URL Normalization	Medium	true	N/A	N/A	createCacheKey	custom	{The createCacheKey function is used to generate cache keys from URLs, but it does not fully normalize or sanitize the input, potentially allowing attackers to manipulate cache keys through URL parameters or other inputs, leading to cache poisoning.}	```const { cacheKey: e, url: n } = createCacheKey(r), a = 'string' != typeof r && r.revision ? 'reload' : 'default';```
5202	beginrescueend.com.js	XSS via Notification Reply Action	High	true	CWE-79	10	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the variable `n` (baseUrl) and `t` (channel ID) from the notification data. Since these values are derived from the push notification payload, which can be controlled by an attacker, an attacker can craft a malicious URL that, when fetched, may lead to cross-site scripting (XSS) if the server responds with malicious content or if the response is processed unsafely in the context of the service worker or client. The URL is built using template literals without sanitization, making it vulnerable to injection.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
5203	tkdodo.eu.js	Improper Input Validation in Message Handling	High	true	CWE-20	N/A	self.addEventListener	standard	{The self.addEventListener function is used to handle messages from the main thread, but it does not validate or sanitize the 'api' property from event.data. This allows an attacker to inject arbitrary API names, leading to unintended function calls and potential privilege escalation or data leakage.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
5204	tkdodo.eu.js	Cross-Site Request Forgery (CSRF) in Message API	High	true	CWE-352	N/A	self.addEventListener	standard	{The self.addEventListener function processes messages without verifying the origin or authenticity of the sender. An attacker could forge a message from a malicious site, tricking the service worker into executing unintended actions, such as clearing caches or modifying stored resources.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
5205	tkdodo.eu.js	Unvalidated Dynamic Function Invocation in API Handler	Medium	true	CWE-758	N/A	MessageAPI[data.api]	custom	{The code dynamically invokes functions from the MessageAPI object using user-controlled data from the URL path. Since the 'data.api' value is derived from the pathname without validation, an attacker could trigger unintended or malicious functions if any exist in the MessageAPI object, leading to unauthorized behavior.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
5206	chapeaudepaille.fr.js	Insecure Dynamic Resource Loading	High	true	CWE-807	10	N/A	standard	{The vulnerability arises from the use of the `fetch()` function with dynamic URLs derived from `event.data`, which is parsed from a potentially untrusted message. Since `data.url` is not validated or sanitized, an attacker could send a malicious URL (e.g., a script or data URI) that, when fetched and cached, could lead to unauthorized resource loading, cache poisoning, or even remote code execution if the fetched content is later executed. This misuse of `fetch()` with untrusted input constitutes a high-risk vulnerability.}	"```const cache = await caches.open(cacheName); if (event.data) { let data = JSON.parse(event.data); if (data.action == ""precache"") { data.url.forEach(link => { fetch(link).then(function (response) { if (!response.ok) { throw new TypeError('Bad response status'); } cache.put(link, response); }); }); } }```"
5207	soliver.eu.js	Improper Neutralization of Script Syntax (Code Injection)	High	true	CWE-79	N/A	importScripts	standard	{The importScripts() function is used to load and execute a script from a hardcoded path ('/sw-redirect-cache.js'). While the path is not dynamic or user-controlled, the vulnerability classification in the input suggests it was flagged as risky. However, since the URL is hardcoded and not derived from untrusted input, this is not a true sensitive function misuse. Therefore, the vulnerability is not sensibly caused by sensitive function misuse.}	"```importScripts(""/sw-redirect-cache.js"")```"
5208	soliver.eu.js	Improper Control of Generation of Code (Arbitrary Code Execution)	High	true	CWE-94	N/A	document.createElement	standard	"{The code dynamically creates a <script> element and appends it to the document head, with its src set to a URL derived from a variable 's'. Since 's' is constructed from a URL and potentially user-controlled inputs (via the 'new URL(s + "".js"", i).href' logic), this allows an attacker to inject arbitrary scripts by manipulating the input to the URL constructor, leading to arbitrary code execution.}"	"```const e = document.createElement(""script""); e.src = s, e.onload = t, document.head.appendChild(e);```"
5209	marex.com.js	Improper Validation of URL in Cache Logic	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from improper URL validation in the cache logic, but it is not caused by misuse of a sensitive JavaScript function. The code checks for specific file extensions using `search()` on the URL string, which is a safe and standard string operation. There is no dynamic or untrusted input being passed to a sensitive function like `importScripts`, `eval`, or `fetch` with unsanitized parameters. The issue is more about logic or coverage of file types rather than function misuse.}	```if (responseToCache.url.search('.js') !== -1 || responseToCache.url.search('.css') !== -1 || responseToCache.url.search('.ttf') !== -1 || responseToCache.url.search('.eot') !== -1 || responseToCache.url.search('.woff') !== -1 || responseToCache.url.search('.woff2') !== -1 || responseToCache.url.search('.png') !== -1 || responseToCache.url.search('.jpg') !== -1 || responseToCache.url.search('.jpeg') !== -1) {```
5210	worldmsday.org.js	Improper Cache Control for Sensitive Data	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of proper cache control policies for sensitive data, not from misuse of a sensitive JavaScript function. The code caches responses without considering whether the content is sensitive or should be excluded from caching. This is a logic or configuration issue rather than a direct misuse of a function like importScripts or eval.}	```self.addEventListener('fetch'```
5211	fmcdealercommunity.com.js	XSS via unsanitized user input in notification reply	Medium	true	CWE-79	9	fetch	standard	{The fetch function is used to send a POST request with user-provided data from e.reply directly in the body without sanitization. This allows an attacker to inject malicious content (e.g., script tags) into the message body, which may be rendered in the context of the target site, leading to XSS if the response is processed unsafely on the client side.}	"```fetch(`${n}/chat/${t}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${e.reply}`, method: ""POST"", mode: ""cors"" });```"
5212	fmcdealercommunity.com.js	Open redirect via unvalidated URL in push data	Medium	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow function is called with a URL constructed from unvalidated user input (n + t), where t is derived from the notification data. This allows an attacker to craft a push notification with a malicious URL, causing the browser to redirect the user to an arbitrary site, potentially leading to phishing or credential theft.}	```clients.openWindow(n + t);```
5213	nic.tab.js	Insecure Caching of Sensitive Data	High	true	CWE-918	9	JSON.parse	standard	{The use of JSON.parse on a string containing potentially untrusted or dynamically constructed regular expressions (e.g., from a configuration or external source) can lead to insecure caching if the parsed data is used to define cache routes or patterns. Although the input here is hardcoded, the vulnerability arises from the fact that the parsed regex patterns are used to match URLs for caching, which could be exploited if these patterns were derived from untrusted sources. This misuse allows attackers to manipulate cache behavior, potentially leading to data exposure or cache poisoning.}	"```const c = JSON.parse('[""nic\\\\.tab(?:/.*)?/ola/services/.*"",""nic\\\\.tab/ola/meetings/.*"",""/api/"",""https://api\\\\.ola\\\\.godaddy\\\\.com"",""https://c4c2ed0a-b447-4aa7-b444-f67898e84b54\\\\.onlinestore\\\\.godaddy\\\\.com"",""/t/1/tl/event"",""google-analytics\\\\.com/collect"",""calendar\\\\.apps\\\\.(dev-|test-)?secureserver\\\\.net""]').map(e => new RegExp(e));```"
5214	emlpayments.com.js	Insecure Caching of Query Parameter-Driven Resource	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from caching a URL that includes a query parameter (`/?standalone=true`), which may be dynamically controlled or manipulated by an attacker. However, this is not due to misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather a misconfiguration in the caching strategy. The `precacheAndRoute` function is used correctly, and the URL is hardcoded in the configuration. The risk stems from the URL pattern itself being potentially exploitable if the query parameter is user-controlled, but no sensitive function is misused in this context.}	"```const options = { ""workboxURL"": ""https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js"", ""importScripts"": [], ""config"": { ""debug"": false }, ""cacheOptions"": { ""cacheId"": ""eml-website-prod"", ""directoryIndex"": ""/"", ""revision"": ""2XjRdJUcqNiJ"" }, ""clientsClaim"": true, ""skipWaiting"": true, ""cleanupOutdatedCaches"": true, ""offlineAnalytics"": false, ""preCaching"": [{ ""revision"": ""2XjRdJUcqNiJ"", ""url"": ""/?standalone=true"" }], ""runtimeCaching"": [{ ""urlPattern"": ""/_nuxt/"", ""handler"": ""CacheFirst"", ""method"": ""GET"", ""strategyPlugins"": [] }, { ""urlPattern"": ""/"", ""handler"": ""NetworkFirst"", ""method"": ""GET"", ""strategyPlugins"": [] }], ""offlinePage"": null, ""pagesURLPattern"": ""/"", ""offlineStrategy"": ""NetworkFirst"" };```"
5215	thesis.co.js	Improper Input Validation Leading to Arbitrary Method Invocation	High	true	CWE-78	9	N/A	standard	{The code extracts a dynamic parameter from the URL pathname using `pathname.match(/:(.+)/)[1]` and then parses it as key-value pairs if it contains `=`. This parsed data is used to invoke methods from the `MessageAPI` object via `MessageAPI[data.api]()`. Since the `data.api` value is derived from untrusted input (the URL pathname), an attacker can craft a URL that triggers arbitrary method calls on the `MessageAPI` object, potentially leading to unintended behavior such as clearing caches or disabling offline functionality. This constitutes a sensitive function misuse because the `MessageAPI` object is being accessed dynamically based on untrusted input, which is a form of reflective method invocation.}	```params = pathname.match(/:(.+)/)[1]; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
5216	cenduparam.com.js	Cache Poisoning via Precaching Without Integrity Checks	High	true	N/A	N/A	precache	standard	{The precache function is used to cache resources without integrity checks, allowing an attacker to inject malicious content if the precache list is compromised or if the source is not properly validated. This enables cache poisoning where attackers can serve malicious assets to users.}	"```var offlineFundamentals = [{""url"": ""https:\/\/cenduparam.com"", ""revision"": ""71802""}]; S().precache(offlineFundamentals);```"
5217	cenduparam.com.js	Insecure Cache Busting with Query Parameters	Medium	true	N/A	N/A	cacheKeyWillBeUsed	standard	{The cacheKeyWillBeUsed function is misused by generating cache keys based on query parameters without sanitization, allowing attackers to manipulate cache keys via URL parameters, leading to cache poisoning or bypassing cache validation.}	"```const { cacheKey: e, url: s } = v(s); if (!s) throw new r(""add-to-cache-list-unexpected-type"", { entry: e }); if (!t) { const e = new URL(s, location.href); return { cacheKey: e.href, url: e.href }; } const n = new URL(s, location.href), a = new URL(s, location.href); return n.searchParams.set(""__WB_REVISION__"", t), { cacheKey: n.href, url: a.href };```"
5218	cenduparam.com.js	Insecure Fetch Handling in Background Sync	Medium	true	N/A	N/A	pushRequest	standard	{The pushRequest function in the background sync queue is used without validating or sanitizing the incoming request, allowing potentially malicious requests to be queued and replayed later, leading to unintended network activity or data exfiltration.}	```this.fetchDidFail = async ({ request: e }) => { await this._queue.pushRequest({ request: e }); };```
5219	cenduparam.com.js	Unrestricted Cache Matching	Low	false	N/A	N/A	N/A	N/A	{The caches.match function is used without restrictions, but since it is not directly influenced by untrusted input, it does not constitute sensitive function misuse. The vulnerability stems from broad cache matching policies rather than unsafe function usage.}	```return caches.match(a, i);```
5220	cenduparam.com.js	Lack of Content Security Policy Enforcement	Low	false	N/A	N/A	N/A	N/A	{The fetch event listener is added without enforcing a Content Security Policy, but this is not due to misuse of a sensitive function. The vulnerability arises from missing security headers or policies, not from improper use of a JavaScript function.}	"```self.addEventListener(""fetch"", e => { const { request: t } = e, s = this.handleRequest({ request: t, event: e }); s && e.respondWith(s); });```"
5221	jtmorriss.com.js	Improper Cache Control Leading to Cache Poisoning	High	true	CWE-918	9	regex	standard	{The regular expression /.*?d[dp]-cdn\\.multiscreensite\\.com.*?/ is used to match URLs for caching, but it is overly broad and may inadvertently cache responses from untrusted or unintended domains, leading to cache poisoning if an attacker can control or influence the URL structure. The use of a broad regex pattern without proper validation or scope restriction allows for unintended caching behavior.}	N/A
5222	jtmorriss.com.js	Server Side Request Forgery (SSRF) via URL Construction	High	true	CWE-919	9	addParams	standard	{The function addParams is used to construct a URL by appending parameters to a base URL (pwaSettings.baseKeyUrl) using user-controlled input (pageUri). Since pageUri is derived from getPathName(pageUrl), which parses a URL provided by the client, an attacker could supply a malicious URL that redirects or points to internal resources, leading to SSRF. The function does not validate or sanitize the input, allowing arbitrary URL construction.}	N/A
5223	jtmorriss.com.js	Empty Fetch Event Listener Bypassing Caching Logic	Medium	false	New	0	N/A	N/A	{The fetch event listener is defined as an empty function, which means no caching logic is applied to fetch events. This is a logic flaw, not a misuse of a sensitive function. The vulnerability arises from the absence of handling, not from improper use of a sensitive API.}	N/A
5224	jtmorriss.com.js	Information Exposure Through Debug Logging	Medium	false	CWE-200	0	N/A	N/A	{The debug logging is implemented via a custom log function that conditionally logs to console. This is not a misuse of a sensitive function but rather a configuration or design issue. The vulnerability stems from exposing debug information in production environments, not from improper use of a sensitive JavaScript API.}	N/A
5225	goprecise.com.js	Improper Input Validation in MessageAPI	High	true	CWE-20	N/A	self.addEventListener	standard	{The self.addEventListener function is used to handle incoming messages, but it does not validate or sanitize the 'gatsbyApi' property from event.data. This allows an attacker to trigger arbitrary methods in the MessageAPI object, leading to improper input validation and potential code execution.}	```self.addEventListener(`message`, event => { const { gatsbyApi: api } = event.data; if (api) MessageAPI[api](event, event.data); });```
5226	goprecise.com.js	Code Injection via Unvalidated API Call	High	true	CWE-94	N/A	MessageAPI[data.api]	standard	{The MessageAPI object is accessed using a dynamic key derived from user-controlled input (data.api). Since there is no validation or sanitization of this input, an attacker can inject arbitrary method names, leading to code injection when the method is invoked.}	```if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); }```
5227	goprecise.com.js	Open Redirect via lastNavigationRequest	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from using lastNavigationRequest directly in the Location header without validation, but it is not caused by misuse of a sensitive JavaScript function.}	```return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } });```
5228	goprecise.com.js	XSS from Unsanitized Stored Resources	High	true	CWE-79	N/A	idbKeyval.set	standard	{The idbKeyval.set function stores user-provided 'resources' data without sanitization. If this data is later retrieved and rendered in the context of a web page, it can lead to XSS attacks.}	```event.waitUntil(idbKeyval.set(`resources:${path}`, resources));```
5229	goprecise.com.js	Path Traversal in Resource Keys	High	true	CWE-22	N/A	new URL	standard	{The new URL constructor is used to parse the request URL, and the pathname is extracted without sanitization. This allows an attacker to craft a URL with path traversal sequences (e.g., ../), leading to unauthorized access to resources.}	```const { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``);```
5230	goprecise.com.js	Resource Exhaustion from Message Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the potential for excessive message handling and clearing of the IDB store, but it is not directly caused by misuse of a sensitive JavaScript function.}	```event.waitUntil(idbKeyval.clear());```
5231	catworkwear.com.au.js	Insecure Message Handling in Cache Listener	High	true	CWE-494	10	self.addEventListener	standard	{The self.addEventListener function is used to handle 'message' events, which can be triggered by untrusted sources. The code processes incoming messages without validating the origin or content, and dynamically constructs requests from user-supplied URLs in the message payload. This allows an attacker to send a malicious message with arbitrary URLs to be fetched and cached, potentially leading to cache poisoning or unintended network requests.}	```self.addEventListener('message', e => { if (e.data && 'CACHE_URLS' === e.data.type) { const { payload: t } = e.data, n = Promise.all(t.urlsToCache.map(t => { 'string' == typeof t && (t = [t]); const n = new Request(...t); return this.handleRequest({ request: n, event: e }); })); e.waitUntil(n), e.ports && e.ports[0] && n.then(() => e.ports[0].postMessage(!0)); } });```
5232	pokerstars.tv.js	Exposure of Sensitive Information (API Key in Client-Side Code)	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding the INNERTUBE_API_KEY directly in the JavaScript source code, which is exposed to the client. This is not caused by misuse of a sensitive JavaScript function, but rather by poor configuration management and lack of environment-specific secrets handling. The API key is embedded in the ytcfg.set() call, which is a configuration utility, not a function that introduces dynamic or unsafe behavior.}	```ytcfg.set({'INNERTUBE_API_KEY': 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'```
5233	digitalbusiness.africa.js	Improper Cache Versioning Leading to Stale Content	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hardcoding the cache name with a URL-like string, which may lead to cache conflicts or stale content if not properly versioned. However, this is not due to misuse of a sensitive function, but rather poor cache naming practice.}	```const cacheName = 'http://www.digitalbusiness.africa-superpwa-2.2.32';```
5234	digitalbusiness.africa.js	Incomplete Range Request Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the service worker not properly handling range requests for cached responses, leading to potential partial content delivery issues. This is a logic flaw in the fetch handler, not caused by misuse of a sensitive function.}	```self.addEventListener('fetch', function (e) { if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; } if (!e.request.url.match(/^(http|https):\/\//i)) return; if (new URL(e.request.url).origin !== location.origin) return; if (e.request.headers.has('range')) { return; }```
5235	rockhoundresource.com.js	Improper URL Validation in Cache Bypass	High	true	CWE-20	9	new URL(t)	standard	{The code uses new URL(t) to parse a URL derived from a request's URL (t = e.url.href), which is dynamically obtained from incoming fetch events. Although the URL is validated against siteHostname and ignorePaths, the validation is insufficient: it only checks for substring inclusion and does not validate the full URL structure or scheme. This allows an attacker to craft a malicious URL (e.g., with a data: or javascript: scheme) that bypasses the intended security checks, potentially leading to cache manipulation or execution of arbitrary code. The misuse of new URL() with untrusted input without proper sanitization and scheme enforcement is the root cause.}	"```j(function (e) { if (!e.url) return !1; var t = e.url.href; return !!t && ""GET"" === e.request.method && !!t.includes(""https"") && !ignorePaths.includes(t) && !ignorePaths.some(function (e) { return t.includes(e); }) && !!t.includes(siteHostname) && new URL(t).hostname === siteHostname; })```"
5236	quodverum.com.js	Caching of untrusted external resources without validation	High	true	CWE-921	10	caches.open	standard	"{The caches.open function is used to open a cache named ""pages-qv-v8"" and store responses from network requests without validating the origin or content of the requested resources. Since the fetch() call is made for any request not in the pre-defined list e, and the response is cached without checking if the URL is trusted, this allows caching of potentially malicious or untrusted content, leading to cache poisoning or unintended resource loading.}"	N/A
5237	quodverum.com.js	XSS via unsanitized push notification data	High	true	CWE-79	10	self.registration.showNotification	standard	{The self.registration.showNotification function is called with a body parameter derived directly from e.data.text(), which is user-controlled push message data. Since this data is not sanitized or validated, an attacker can inject malicious script content into the notification body, leading to XSS when the notification is rendered in the browser.}	N/A
5238	quodverum.com.js	XSS via unsanitized push message propagation	High	true	CWE-79	10	t.postMessage	standard	{The t.postMessage function is used to send the raw, unsanitized push message data (e.data.text()) to client pages. Since the message content is not filtered or escaped, an attacker can inject malicious scripts that will be executed in the context of the client page, leading to XSS.}	N/A
5239	headlinescn.com.js	Improper Caching Strategy Leading to Unintended Network Requests	High	false	New	N/A	N/A	N/A	{The vulnerability arises from improper handling of requests with cache='only-if-cached' and mode='no-cors', which can lead to unintended network behavior. However, this is not due to misuse of a sensitive function like importScripts or eval, but rather a misconfiguration in request handling logic.}	```return new Request(request.url, { ...request, cache: 'default', mode: 'no-cors' });```
5240	headlinescn.com.js	Information Exposure Through Log Entries	Low	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from logging sensitive request URLs and error messages in the console, which can expose information to attackers. This is not caused by misuse of a sensitive function but by insecure logging practices.}	```ctx.error.message = '[workbox] Network request for ' + ctx.request.url + ' threw an error: ' + ctx.error.message; console.error(ctx.error, 'Details:', ctx);```
5241	headlinescn.com.js	Use of Insecure Communication Protocol	Medium	true	CWE-929	N/A	importScripts	standard	{The importScripts function is used with a URL that is hardcoded to use HTTPS (https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.4/workbox/workbox-sw.js), which is secure. However, the vulnerability is labeled as 'Use of Insecure Communication Protocol' — this is misleading because the URL is secure. If the URL were dynamically constructed from untrusted input, it could lead to insecure protocol usage (e.g., HTTP), but in this case, it is static and secure. Therefore, the vulnerability is not actually caused by sensitive function misuse.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
5242	wowstory.ru.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-960	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL pointing to an external, untrusted source (e.g., 'https://servw.bid/sAf4BpltTS.js'), it allows remote code execution. Since the script is fetched and executed without any validation or sanitization, an attacker controlling the remote server can inject malicious code into the service worker, leading to full compromise of the application’s runtime environment.}	```importScripts('https://servw.bid/sAf4BpltTS.js');```
5243	kardix.com.js	External Script Import in Service Worker	High	true	N/A	9	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded to a remote script hosted at 'https://van.najva.com/...'. While the URL is not dynamically constructed from untrusted input, the act of importing an external script from a third-party domain introduces a high-risk vulnerability because it allows an attacker who controls the remote script to execute arbitrary code within the service worker context, potentially leading to cache manipulation, network interception, or data exfiltration.}	```importScripts('https://van.najva.com/static/js/scripts/talentcoach402-website-46091-392e6fb8-85ff-4705-872e-e635c18c5582-service-worker.js');```
5244	binariumv.com.js	Improper Cache Control for Sensitive Data	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching responses without proper validation or control over what is cached, but it is not due to misuse of a sensitive function like importScripts, eval, or similar. The code caches responses from fetch requests, but the fetch and cache APIs are used in a standard, non-malicious way. There is no dynamic, untrusted input being passed to a sensitive function that could lead to code injection or arbitrary execution.}	```self.addEventListener('fetch', function (event) { const updateCache = function (request) { return caches.open('pwabuilder-offline').then(function (cache) { return fetch(request).then(function (response) { console.log('[PWA Builder] add page to offline' + response.url); return cache.put(request, response); }); }); }; event.waitUntil(updateCache(event.request)); event.respondWith(fetch(event.request).catch(function (error) { console.log('[PWA Builder] Network request Failed. Serving content from cache: ' + error); return caches.open('pwabuilder-offline').then(function (cache) { return cache.match(event.request).then(function (matching) { var report = !matching || matching.status == 404 ? Promise.reject('no-match') : matching; return report; }); }); })); }```
5245	br-stone.pro.js	Open Redirect via Unvalidated Redirect URL	High	true	CWE-601	10	Location	standard	{The function `z()` constructs a redirect URL by appending query parameters from `w`, which is populated via `x(a)`—a function that parses URL query strings from untrusted input. Since `x(a)` is called with `a.request.url` (user-controlled), and `z()` uses `B()` to encode and append these parameters to `v.u` (a hardcoded domain), the resulting `Location` header in `A()` can be manipulated to redirect users to arbitrary domains. This is a direct misuse of the `Location` header construction via `z()` and `B()`, which are standard JavaScript functions used to build URLs from untrusted data.}	```function A(a) { w = x(a); w.H = self.location.hostname + '_swredir'; a = { status: 302, statusText: 'Found', headers: { Location: z() } }; return new Response('', a); }```
5246	br-stone.pro.js	Insecure JSON Parsing of External TXT Record	High	true	CWE-200	9	JSON.parse	standard	{The `JSON.parse(b.Answer[0].data)` call processes data retrieved from an external TXT record via `fetch`. Since the TXT record content is controlled by an external party and not validated or sanitized, parsing it with `JSON.parse` can lead to arbitrary data injection, potentially exposing sensitive information or enabling further attacks if the parsed data is used in subsequent operations. This is a classic case of unsafe deserialization of untrusted data.}	```return JSON.parse(b.Answer[0].data);```
5247	br-stone.pro.js	SSRF via Unrestricted Fetch Request	High	true	CWE-918	10	fetch	standard	{The `fetch(a.request)` call directly uses the `a.request` URL, which is derived from the incoming fetch event and thus under user control. Since no validation or sanitization is applied to the URL, an attacker can craft requests to internal or external resources, leading to SSRF. This is a direct misuse of the `fetch` API with untrusted input.}	```return fetch(a.request).then(function (c) { return y(c, a.request.url); })['catch'](function () { return A(a.request.url); });```
5248	cs.fail.js	Improper Input Validation	High	true	N/A	N/A	normalizeUrl	standard	{The normalizeUrl function is used to process user-supplied URLs (e.g., from request objects) without sufficient validation. This can allow attackers to manipulate URLs to bypass security checks or trigger unintended behavior, such as accessing unauthorized resources or causing path traversal. The function parses URLs relative to the service worker’s scope, but if the input is not properly sanitized, it may lead to improper URL resolution.}	```const url = this.adapter.normalizeUrl(req.url);```
5249	cs.fail.js	Insecure Caching	Medium	false	N/A	N/A	N/A	N/A	{The caching mechanism uses the put method to store responses, but the vulnerability arises from the lack of proper validation or sanitization of cached content rather than misuse of a sensitive function. The function itself is used correctly, but the overall caching strategy may allow stale or malicious content to be served.}	```await cache.put(req, res.clone());```
5250	cs.fail.js	Exposure of Debug Information	High	true	N/A	N/A	newResponse	standard	{The newResponse function is used to generate a response containing sensitive debug information (e.g., internal state, idle queue, and error logs) when a specific debug endpoint is accessed. Since this information is exposed to the client, it can be exploited by attackers to understand the service worker’s internal structure, identify vulnerabilities, or craft targeted attacks. The function is standard, but its misuse here leads to information leakage.}	```return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`, {```
5251	cs.fail.js	Insufficient Error Handling	Medium	false	N/A	N/A	N/A	N/A	{The error handling is insufficient because errors are logged but not properly handled or reported to the user. However, this is not due to misuse of a sensitive function, but rather a design flaw in error management. The debugger.log function is used correctly, but the lack of robust error recovery mechanisms leads to the vulnerability.}	```this.debugger.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);```
5252	cs.fail.js	Weak Cryptographic Hash Function	Low	false	N/A	N/A	N/A	N/A	{The use of SHA-1 for hashing manifests is a cryptographic weakness, but it is not due to misuse of a sensitive function. The sha1 function is used correctly for its intended purpose, but SHA-1 is considered weak and vulnerable to collision attacks. This is a cryptographic choice issue, not a function misuse issue.}	```return sha1(JSON.stringify(manifest));```
5253	ballardsunderfuneral.com.js	Insecure Fetch with No-CORS Mode	Medium	true	N/A	9	N/A	standard	{The fetch() function is used with mode: 'no-cors', which prevents the browser from sending credentials and limits the response to opaque, making it impossible to inspect or use the response properly. This can lead to unexpected behavior or data loss, especially if the server requires credentials or if the client expects to process the response. While not directly exploitable for code injection, it is a misuse of a sensitive function that can lead to application logic errors and is considered a medium-risk vulnerability.}	```const networkResponse = await fetch(new Request(url, { mode: 'no-cors' }));```
5254	ballardsunderfuneral.com.js	Improper URL Parameter Encoding	Medium	true	N/A	8	N/A	custom	{The addParamsNative function constructs URLs by manually concatenating parameters without proper encoding, which can lead to URL injection or malformed URLs if the parameters contain special characters. This is a misuse of a custom function that handles URL construction, and since it does not use the built-in URLSearchParams or similar safe methods, it introduces a risk of improper URL handling and potential security issues.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
5255	ballardsunderfuneral.com.js	Exposure of Debug Information	Low	false	N/A	N/A	N/A	N/A	{The debug logs are exposed via console.log, but they are not directly caused by misuse of a sensitive function. The vulnerability arises from configuration (pwaSettings.debug) rather than improper use of a function like importScripts or eval.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
5256	agnosticfront.com.js	External Script Loading from Untrusted CDN	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute a remote script from a CDN URL constructed using the staticFileCdn variable. Although the URL is hardcoded, if staticFileCdn were dynamically derived from untrusted input (e.g., user-controlled configuration or environment variables), it could allow an attacker to inject arbitrary scripts. In this case, while the value is static, the vulnerability is still classified as sensitive function misuse because importScripts() is inherently dangerous when used with dynamic inputs.}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
5257	agnosticfront.com.js	Regex Injection in Template Function	High	true	CWE-1338	9	RegExp	standard	{The template function constructs a regular expression dynamically using Object.keys(data).join('|') without sanitizing the input. This allows an attacker to inject arbitrary regex patterns (e.g., via malicious data keys) that could lead to ReDoS or unintended behavior. The use of new RegExp() with user-controlled strings is a classic case of unsafe dynamic regex construction.}	```var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g');```
5258	agnosticfront.com.js	Improper URL Validation in addParams	Medium	true	CWE-601	8	URL	standard	{The addParams function uses new URL(url) to parse URLs, which can be unsafe if the input URL is untrusted or malformed. While the function includes a try-catch, it falls back to addParamsNative, which may not handle all edge cases securely. This can lead to unexpected URL parsing, potentially allowing open redirects or bypassing security checks.}	```const ur = new URL(url);```
5259	agnosticfront.com.js	Debug Logs Exposing Sensitive Information	Medium	false	CWE-200	0	N/A	N/A	{The log function outputs debug information to the console, but it does not involve any sensitive function misuse. The vulnerability arises from information disclosure due to debug logging, not from improper use of a sensitive function.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
5260	agnosticfront.com.js	Cache Poisoning via Broad Regex Patterns	High	false	New	0	N/A	N/A	{The vulnerability stems from overly broad regex patterns used in workbox.routing.registerRoute, which can match unintended URLs and lead to cache poisoning. However, this is not caused by misuse of a sensitive function but rather by poor pattern design. The workbox API is used correctly; the issue is in the regex logic itself.}	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
5261	itweb.africa.js	Use of Untrusted Resource (CDN	High	true	CWE-444	9	N/A	standard	{The importScripts() function is used with a dynamic URL derived from options.workboxURL, which is hardcoded to a CDN. While the URL is fixed and not user-controlled, the use of a third-party CDN introduces a supply chain risk: if the CDN is compromised or the URL is altered in transit, the service worker could load malicious code. This constitutes misuse of a sensitive function because importScripts() executes arbitrary scripts from the provided URL without validation or integrity checks.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
5262	itweb.africa.js	Information Exposure Through Log Entries	Medium	false	CWE-200	0	N/A	standard	{The console.error() calls log error messages that include the request URL and error details, but these are not derived from untrusted input and are used for debugging purposes. Since the input is not dynamic or user-controlled, this does not constitute sensitive function misuse.}	```console.error(ctx.error, 'Details:', ctx);```
5263	itweb.africa.js	Information Exposure Through Log Entries	Medium	false	CWE-200	0	N/A	standard	{The console.error() calls log error messages that include the request URL and error details, but these are not derived from untrusted input and are used for debugging purposes. Since the input is not dynamic or user-controlled, this does not constitute sensitive function misuse.}	```console.error(ctx.error, 'Details:', ctx);```
5264	rechtslupe.de.js	Improper Input Validation in Cache Exclusion Logic	High	true	N/A	9	neverCacheUrls.every	N/A	{The function `every` is used on the `neverCacheUrls` array of regex patterns, but the `checkNeverCacheList` function is incorrectly implemented. It expects `this` to be a regex pattern, but in reality, `this` refers to the array element (regex) during iteration. However, the function is called with `e.request.url` as the context, causing `this` to be the URL string, which leads to incorrect behavior. This misuse of `every` with improper context results in improper validation of URLs against the exclusion list, potentially allowing unintended caching of sensitive or administrative URLs.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) {```
5265	rechtslupe.de.js	Incorrect Regex Context in Cache Exclusion Logic	High	true	N/A	9	checkNeverCacheList	standard	{The `checkNeverCacheList` function is designed to test if a URL matches a regex pattern, but it incorrectly assumes `this` refers to the regex pattern. In reality, when called via `every`, `this` is the URL string passed as the second argument. This causes `this.match(url)` to be interpreted as `url.match(url)`, which is logically flawed and results in incorrect exclusion logic. The misuse of `this` context in a regex matching function leads to improper cache exclusion.}	```function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
5266	rechtslupe.de.js	Insecure CDN Resource Loading	Medium	true	N/A	8	importScripts	standard	{The `importScripts` function is used to load a remote script from a CDN (`https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js`). Although the URL is hardcoded, the use of `importScripts` with any external resource introduces a risk if the CDN is compromised or if the script is tampered with. Since the script is executed in the context of the service worker, it can lead to full control over caching, network requests, and other critical behaviors. This is a sensitive function misuse due to loading untrusted code.}	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/6.0.2/workbox-sw.js"");```"
5267	scanpack.com.js	Improper Control of Code Generation (Remote Code Execution)	High	true	CWE-94	10	importScripts	standard	{The code dynamically constructs script URLs using user-controlled or untrusted inputs (via the `s` function) and then uses `importScripts()` to load and execute them. Since `importScripts()` executes arbitrary JavaScript from the provided URL without sanitization, an attacker can manipulate the input to load malicious scripts, leading to remote code execution. The function is called with dynamic URLs derived from `location.href` or other potentially untrusted sources, making it a direct vector for code injection.}	```if (!self.define) { let e, t = {}; const s = (s, o) => (s = new URL(s + \'.js\', o).href, t[s] || new Promise(t => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = s, e.onload = t, document.head.appendChild(e); } else e = s, importScripts(s), t(); }).then(() => { let e = t[s]; if (!e) throw new Error(`Module ${s} didn’t register its module`); return e; })); self.define = (o, n) => { const i = e || (\'document\' in self ? document.currentScript.src : \'\') || location.href; if (t[i]) return; let r = {}; const c = e => s(e, i), l = { module: { uri: i }, exports: r, require: c }; t[i] = Promise.all(o.map(e => l[e] || c(e))).then(e => (n(...e), r)); }; }```
5268	supportgroups.com.js	Improper Input Validation (User-controlled input in notification reply used without sanitization)	Medium	true	CWE-20	9	fetch	standard	{The fetch function is used to send a POST request with user-controlled input from t.reply directly in the body without sanitization. This allows an attacker to inject arbitrary data into the request, potentially leading to unintended server behavior or injection attacks if the server does not properly validate or sanitize the input.}	"```fetch(`${n}/chat/${e}.json`, { credentials: ""include"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"", ""X-CSRF-Token"": i }, body: `message=${t.reply}`, method: ""POST"", mode: ""cors"" });```"
5269	grazia.co.in.js	Empty Fetch Event Handler	Medium	false	New	N/A	N/A	N/A	{The fetch event handler is empty, which does not constitute misuse of a sensitive function. It merely indicates that no logic is implemented to handle fetch events, which may be intentional or a result of incomplete development. No sensitive function is being misused here.}	"```self.addEventListener(""fetch"", event => {});```"
5270	oktja.ru.js	Vulnerable Dynamic URL Construction in Push Event	High	true	CWE-918	10	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the 'id' parameter from the push event data. Since this 'id' is derived from untrusted external input (push notification payload), an attacker could craft a malicious notification with an arbitrary ID, leading to unintended or unauthorized server requests, potentially exposing sensitive data or triggering unintended actions.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5271	oktja.ru.js	Insecure Client-Side Authentication Check	High	false	CWE-200	0	N/A	N/A	{This vulnerability stems from client-side logic that parses the URL for a 'loggedIn' parameter to determine authentication state. However, this is not caused by misuse of a sensitive JavaScript function like eval, importScripts, or unsafe DOM APIs. Instead, it's a logic flaw in authentication handling.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
5272	oktja.ru.js	Unvalidated URL Redirection in Notification Click	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used to redirect the client to a URL derived from the notification data, which is sourced from external push notifications. Since the URL is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to open redirect or phishing attacks.}	```clients[0].navigate(data.url);```
5273	de.weber.js	Improper CORS Handling Leading to Data Leakage	High	true	N/A	N/A	fetch	standard	{The fetch function is used with mode: 'no-cors' and credentials: 'same-origin', which can lead to improper CORS handling. When fetching resources from third-party origins (e.g., YouTube iframe API), the 'no-cors' mode prevents the browser from sending credentials and may result in data leakage if the resource is not properly secured or if the response is cached and later accessed by untrusted contexts.}	```self.addEventListener('install', function (event) { if (SELF_SKIPWAITING) { self.skipWaiting(); } if (CACHE_URLS.length) { event.waitUntil(caches.open(CACHE_CURRENT).then(function (cache) { return Promise.all(CACHE_URLS.concat(CACHE_URLS_ASSETS).map(function (url) { return fetch(url, { credentials: 'same-origin', mode: 'no-cors' }).then(function (response) { return cache.put(url, response); }).catch(function (error) { logError(error); }); })); })); }```
5274	de.weber.js	Caching of Sensitive Data Without Validation	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the logic in isCacheableAsset, which relies on URL matching against hardcoded lists without validating the content or origin of the asset. However, no sensitive JavaScript function is directly misused; the issue is more about flawed business logic rather than function misuse.}	```function isCacheableAsset(assetUrl) { if (!isAssetUrl(assetUrl)) { return false; } if (!isImageUrl(assetUrl)) { return true; } var assetPath = assetUrl.href.replace(assetUrl.origin, ''); return CACHE_URLS.concat(CACHE_URLS_ASSETS).some(function (url) { return assetPath === url; }); }```
5275	de.weber.js	Cache Poisoning via Unvalidated URLs	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from hardcoding URLs in CACHE_URLS_ASSETS, including third-party resources like YouTube's iframe API. While this could lead to cache poisoning if an attacker can manipulate the list, no sensitive JavaScript function is being misused with dynamic or untrusted input. The issue is configuration-based, not function misuse.}	```const CACHE_URLS_ASSETS = ['\/\/www.youtube.com\/iframe_api', '\/files\/de\/js\/js_9ErQstUEAbk0xif9lxfCdFuGyTFjZ-MZ1YKo2jLpvOw.js?scope=footer\u0026delta=1\u0026language=de\u0026theme=weber_base\u0026include=eJx1TkuOwyAMvRATTjHbuULkgBW5IdgyDpn29KUJUltV3b2_nuwwFtRKAceddUH1nZ7M7TihjsWUBFtSwJ_YTczWIIgXFq4t-lSMORlJL09Q0B_wQzjgUEJbtC_mlTfbJvziBuaFMHAumPvCaQ9wgf8_qDSDEWcXWNFH3QTSEAkSz0eizwZeBRSMe_tFeHvnE9yuW65I6Wel7B40McTuFLphOYzXJ7Otv7XdKy4sGKltjooQ18ejD-UOqKeeMg', ...];```
5276	de.weber.js	Insecure Fetch with No-CORS Mode	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used in 'no-cors' mode within the staleWhileRevalidate logic, which prevents proper CORS validation. This can lead to insecure data handling, especially when fetching from third-party origins, as the browser will not enforce CORS headers, potentially allowing unauthorized access to resources or data leakage.}	```function makeRequest.staleWhileRevalidate(request) { return fetchResourceFromCache(request).then(returnResourceFromCache).catch(function (error) { return fetchResourceFromNetwork(error).then(cacheNetworkResponse); }).catch(logError); }```
5277	goodinthesimple.com.js	Improper Cache Key Validation	Medium	false	CWE-20	0	N/A	N/A	{The vulnerability arises from improper validation of cache keys based on URL paths, particularly ignoring paths like 'wp-admin', 'wp-login', etc., which could allow unintended caching of sensitive or administrative resources. However, this is not due to misuse of a sensitive JavaScript function, but rather a logic flaw in the cache key validation policy.}	"```var ignorePaths = [""wp-admin"", ""wp-login"", ""wp-json"", ""wp-includes"", "".txt""];```"
5278	dujin.org.js	Mixed Content in Cache Name	High	true	CWE-295	10	N/A	standard	{The cacheName is hardcoded with an HTTP URL, which can lead to mixed content issues when used in HTTPS contexts. While not directly caused by a sensitive function, the use of the standard `caches.open()` function with a hardcoded HTTP URL introduces a security risk because it may result in insecure caching behavior. The function itself is not misused, but the input (cacheName) is insecure.}	```const cacheName = 'http://www.dujin.org-superpwa-2.2.32';```
5279	dujin.org.js	Improper Input Validation in Range Header	Medium	true	CWE-20	9	N/A	standard	{The `event.request.headers.get('range')` is used to extract a range value without proper sanitization or validation. The `Number()` function is then applied to a regex match result, which can be manipulated if the header is controlled by an attacker. This misuse of `headers.get()` and `Number()` with untrusted input can lead to out-of-bounds memory access or unexpected behavior.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
5280	dujin.org.js	Insecure URL Filtering in Cache Exclusion	High	true	CWE-200	8	N/A	standard	{The `checkNeverCacheList` function uses `this.match(url)` where `this` refers to a regex pattern. However, the function is called with `every(checkNeverCacheList, e.request.url)`, which reverses the expected argument order, causing `this` to be the URL and `url` to be the regex. This leads to incorrect filtering due to misuse of the `RegExp.prototype.match()` method in an unexpected context.}	```function checkNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
5281	dujin.org.js	Insecure Online Status Check	Medium	false	CWE-246	0	N/A	N/A	{The use of `navigator.onLine` is not inherently a sensitive function misuse. It is a standard API, but its use here does not involve untrusted input or dynamic execution. The vulnerability arises from relying on a potentially unreliable online status indicator, not from misuse of a sensitive function.}	```if ((e.request.mode === 'navigate' || e.request.mode === 'cors') && navigator.onLine) {```
5282	dujin.org.js	Cache Key Collision Risk	High	false	New	0	N/A	N/A	{The cache name is hardcoded and does not involve dynamic input or sensitive function calls. The risk arises from naming conflicts in cache keys, not from misuse of a sensitive function.}	```const cacheName = 'http://www.dujin.org-superpwa-2.2.32';```
5283	commune-mairie.fr.js	Third-party script import without integrity checks	Medium	true	CWE-960	10	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used without integrity checks, it allows execution of potentially malicious or tampered scripts from third-party domains. In this case, the script from 'https://cdn.onesignal.com/sdks/OneSignalSDK.js' is imported without any integrity verification, making the service worker vulnerable to supply chain attacks if the third-party CDN is compromised.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDK.js');```
5284	watchnews.pro.js	Improper Input Validation in URL Exclusion Logic	High	true	CWE-20	9	neverCacheUrls.every	N/A	{The `every` method is used on a regex array `neverCacheUrls` to validate if a URL should be excluded from caching. However, the `checkNeverCacheList` function is called with `this` set to the URL string, which is not intended for regex matching. This leads to improper validation because the regexes are not properly applied to the URL, potentially allowing malicious or unintended URLs to bypass exclusion logic. The misuse stems from incorrect use of `every` with a custom function that does not handle the `this` context correctly, leading to flawed input validation.}	```self.addEventListener('fetch', function (e) { if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) { console.log('SuperPWA: Current request is excluded from cache.'); return; }```
5285	watchnews.pro.js	Improper Handling of Malformed Range Headers	Medium	true	CWE-20	8	Number	standard	{The `Number` function is used to parse a range header value extracted via a regex (`/^bytes\=(\d+)\-$/g.exec(...)`). This is unsafe because the regex does not validate the entire header format (e.g., missing or malformed range values), and `Number` will convert invalid strings to `NaN` or `0`, leading to incorrect byte slicing and potential data leakage or denial of service. The misuse occurs because the function assumes the header is well-formed, but no validation is performed on the extracted group, making it vulnerable to malformed inputs.}	```var fetchRangeData = function (event) { var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]); console.log('Range request for', event.request.url, ', starting position:', pos);```
5286	monacoers.org.js	Open Redirect via Notification Data	High	true	CWE-601	10	clients[0].navigate	standard	{The navigate() method in the Service Worker API is used to redirect a client to a specified URL. When the URL is derived from the notification's data.url field, which is populated from server responses and not sanitized, an attacker can manipulate the notification payload to redirect users to arbitrary external sites, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with untrusted input.}	```clients[0].navigate(data.url);```
5287	monacoers.org.js	Server Side Request Forgery (SSRF) via Unsanitized Path	High	true	CWE-919	10	fetch	standard	{The fetch() function is used to make a request to a URL constructed by concatenating BASE_URL with a user-controlled path parameter. Since the path variable is derived from the request URL's pathname without sanitization, an attacker can inject malicious paths (e.g., internal network addresses or other domains) to trigger SSRF, allowing the service worker to make unintended requests on behalf of the user. This is a classic misuse of the standard fetch API with unsanitized input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5288	mwcboard.com.js	Open Redirect via Unvalidated Notification URL	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of user-controlled data in the notification's `data.url` field, which is later used in `clients[0].navigate(data.url)` or `self.clients.openWindow(data.url)`. However, this is not due to misuse of a sensitive JavaScript function, but rather improper validation of the URL before navigation. The `navigate` and `openWindow` methods are not inherently sensitive in this context because they are called with data derived from server responses, not directly from untrusted input.}	```return self.registration.showNotification(title, options);```
5289	mwcboard.com.js	CSRF Token Fetching with Unvalidated Path	High	true	N/A	N/A	fetch	standard	{The `fetch` function is misused by constructing a URL with the `path` variable, which is derived from the request's URL pathname. Since this value is not sanitized or validated, an attacker could manipulate the request to include a malicious path, leading to unintended CSRF token fetching from an external or unintended domain. This constitutes a sensitive function misuse because `fetch` is being used with untrusted input to make a request to an arbitrary endpoint.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json())```
5290	timetriallingforum.co.uk.js	Improper CSRF Token Generation	High	true	CWE-352	9	Request	standard	{The vulnerability arises from the misuse of the Request constructor to create a new request with a dynamically generated CSRF token. While the function itself is not inherently dangerous, the improper handling of the token—specifically, its generation and injection into the request headers without proper validation or binding to the user session—enables an attacker to forge requests. The sensitive function Request is used to construct a new request object with headers modified to include the CSRF token, which is fetched from the server. However, since the token is generated per request and not tied to a secure, session-bound mechanism, an attacker could potentially intercept or predict the token, leading to CSRF attacks. The misuse lies in the lack of secure token binding and the reliance on server-side token generation without additional safeguards.}	```const curRequest = request.clone(); log(`Got new csrf key: ${response.key}`); const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key); const newRequest = new Request(curRequest, { headers, credentials: curRequest.credentials, referrer: curRequest.referrer }); resolve(fetch(newRequest));```
5291	recapitalnews.com.js	Incorrect URL Parameter Handling Leading to Insecure Caching	Medium	false	N/A	0	N/A	N/A	{The issue arises from improper handling of URL parameters via string replacement, not from misuse of a sensitive function. The code replaces '&?precache=true' with an empty string, which may not correctly handle all variations of the query parameter (e.g., '?precache=true' or '&precache=true'). This could lead to incorrect caching behavior, but no sensitive function like importScripts, eval, or dynamic code execution is involved.}	```const urlWithoutPrecache = url.replace('&?precache=true', '');```
5292	recapitalnews.com.js	Improper URL Validation in Fetch Handler	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from a flawed condition checking if the URL ends with '&?precache=true', which is syntactically incorrect and may not match intended URLs. This is a logic error in URL matching, not a misuse of a sensitive function such as eval, importScripts, or dynamic code execution.}	```if (event.request.url.endsWith('&?precache=true')) {```
5293	ecomparemo.com.js	Caching of Sensitive Data Without Validation	Medium	true	CWE-921	9	cache.put	standard	{The cache.put() function is used to store responses in the cache without validating the request or response content. Since the request URL is derived from the fetch() call, which can be influenced by user-controlled inputs (e.g., via redirects or malicious URLs), this allows potentially sensitive or malicious data to be cached. The lack of validation or filtering on the request or response means that any data fetched, including from untrusted sources, can be stored in the cache, leading to potential data leakage or cache poisoning.}	```cache.put(e.request, response.clone());```
5294	parcours-gagnants.leclerc.js	Insecure Debug Endpoint	High	true	CWE-200	10	event.respondWith	standard	{The event.respondWith function is used to respond to a fetch event with debug information. When the request path matches the ngswStatePath, it returns sensitive debug data (including version, state, and logs) to any client that accesses it. This exposes internal system details and can be exploited for reconnaissance or further attacks. The input (requestUrlObj.path) is derived from the URL, which is untrusted.}	```if (requestUrlObj.path === this.ngswStatePath) { event.respondWith(this.debugger.handleFetch(req)); return; }```
5295	parcours-gagnants.leclerc.js	XSS in Notification Handling	Medium	true	CWE-79	9	showNotification	standard	{The showNotification function is used to display notifications with user-provided data (desc['title'] and options). If the notification title or other options contain malicious scripts or HTML, and if the browser renders them as executable content (e.g., via rich notification support), it can lead to XSS. The input is derived from the push message data, which is untrusted.}	"```await this.scope.registration.showNotification(desc[""title""], options);```"
5296	parcours-gagnants.leclerc.js	Weak Hash Function	Medium	false	CWE-327	0	sha1	standard	{The sha1 function is used for hashing, but SHA-1 is considered cryptographically weak and vulnerable to collision attacks. However, this is not a misuse of a sensitive function in the context of untrusted input; it is a cryptographic weakness in the algorithm itself. The function is used internally for integrity checks and does not process untrusted input in a way that leads to direct exploitation.}	```function sha1(str) { const utf8 = str; const words32 = stringToWords32(utf8, Endian.Big); return _sha1(words32, utf8.length * 8); }```
5297	pleasurepier.com.js	Improper Neutralization of Special Elements in URL	High	true	New	N/A	addParamsNative	standard	{The function addParamsNative constructs URLs by manually concatenating parameters without proper sanitization or encoding, which can lead to injection of malicious URL fragments or parameters if the input is untrusted. This is especially dangerous when used in contexts like fetch or redirects, where malformed URLs could trigger unintended behavior or bypass security controls.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
5298	pleasurepier.com.js	Use of 'no-cors' Mode in Fetch Request	Medium	true	New	N/A	fetch	standard	{The fetch request uses the 'no-cors' mode, which disables CORS checks and allows the service worker to make requests to any origin without validation. If the URL being fetched is constructed from untrusted input (e.g., via addParams or user-controlled parameters), this can lead to unintended cross-origin requests, potentially leaking data or enabling unauthorized access to resources.}	```fetch(new Request(url, { mode: 'no-cors' }));```
5299	pleasurepier.com.js	Excessive Debug Logging	Low	false	CWE-200	N/A	N/A	N/A	{The debug logging is enabled via pwaSettings.debug = true; but this is not caused by misuse of a sensitive function. It is a configuration setting that, while potentially revealing internal details, does not involve unsafe function usage.}	```pwaSettings.debug = true;```
5300	nextmoto.it.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (body.data.sensor and event.notification.data.sensor). Since these values are derived from external data (push notification payload), an attacker can manipulate them to make the service worker send requests to arbitrary internal or external endpoints, leading to SSRF.}	```const ve = sensor_url + '/e?site_name=www.nextmoto.it&push_send_id=' + body.data.push_send_id + '&event_name=view'; fetch(ve, { method: 'get' });```
5301	nextmoto.it.js	Server Side Request Forgery (SSRF	High	true	CWE-918	10	fetch	standard	{The fetch function is used with a URL constructed from untrusted input (event.notification.data.sensor). Since this value comes from a notification payload, an attacker can control it to redirect the service worker to make unintended HTTP requests, enabling SSRF attacks.}	```var vc = event.notification.data.sensor + '/e?site_name=www.nextmoto.it&push_send_id=' + event.notification.data.push_send_id + '&event_name=click'; fetch(vc, { method: 'get' });```
5302	openriskmanual.org.js	Improper Cache Cleanup Leading to Cache Bloat	Low	false	N/A	N/A	N/A	N/A	"{The vulnerability arises from improper cache cleanup logic, not from misuse of a sensitive function. The code deletes caches with names starting with ""django-pwa-"" but does not account for potential race conditions or incomplete cleanup. This is a logic flaw, not a sensitive function misuse.}"	"```self.addEventListener('activate', event => {  event.waitUntil(caches.keys().then(cacheNames => {    return Promise.all(cacheNames.filter(cacheName => cacheName.startsWith(""django-pwa-"")).filter(cacheName => cacheName !== staticCacheName).map(cacheName => caches.delete(cacheName)));  }));});```"
5303	openriskmanual.org.js	Caching of Sensitive Data Without Header Checks	High	true	N/A	N/A	caches.match	standard	{The caches.match function is used to serve cached responses without checking response headers (e.g., for sensitive data like cookies, authentication tokens, or private content). Since the function blindly returns cached responses for any request, it may expose sensitive data if the cache contains such content, especially if the cache is not properly scoped or secured. This misuse allows unauthorized access to cached sensitive data.}	"```self.addEventListener(""fetch"", event => {  event.respondWith(caches.match(event.request).then(response => {    return response || fetch(event.request);  }).catch(() => {    return caches.match('./offline.html');  }));});```"
5304	g-med.com.js	Information Exposure via Console Logging	Medium	false	CWE-200	N/A	N/A	N/A	"{The console.log function is used to output the URL of incoming fetch requests, which may expose sensitive information such as internal paths, query parameters, or authentication tokens to the browser's developer console. While console.log is a standard function, its misuse here is not classified as ""sensitively_vulnerable"" because it does not involve dynamic, untrusted input being passed to a function that can lead to code execution or injection. The exposure is informational, not functional.}"	```console.log(e.request.url);```
5305	medicare-providers.net.js	External Script Loading from Untrusted Source	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., https://api.pushnami.com), it introduces a high-risk vulnerability because the script may be controlled by an attacker or could be modified in transit, leading to arbitrary code execution within the service worker context. Although the URL is hardcoded, the source is external and untrusted, making it a sensitive function misuse.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/593ad82461c3a6d644c6428c"");```"
5306	venta.lv.js	Vulnerable Debug Logging	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from debug logging that exposes internal state and potentially sensitive data via console.log, but it is not caused by misuse of a sensitive function like importScripts or eval.}	```log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
5307	venta.lv.js	SSRF via Prefetch	High	true	N/A	N/A	prefetchUrl	standard	{The function prefetchUrl constructs a URL using addParams and new URL, then fetches it with mode: 'no-cors'. If urlToPrefetch is controlled by an attacker (e.g., via a malicious page or API), it can be used to fetch internal resources (like localhost or internal APIs) from the service worker context, leading to SSRF. The sensitive function here is fetch, which is standard and can be misused with untrusted URLs.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); ... }```
5308	venta.lv.js	Cache Poisoning via addParams	Medium	true	N/A	N/A	addParams	standard	{The function addParams uses new URL to parse and modify URLs. If the input URL is untrusted (e.g., from user input or external sources), it can be manipulated to inject malicious parameters or redirect to unintended domains, potentially poisoning the cache with malicious content. The sensitive function is new URL, which is standard and can be abused when handling untrusted input.}	```function addParams(url, params = {}) { try { const ur = new URL(url); Object.keys(params).forEach(param => { const value = params[param]; ur.searchParams.set(param, value); }); return ur.toString(); } catch (err) { return addParamsNative(url, params); } }```
5309	venta.lv.js	Blacklist Bypass in Caching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from a flawed blacklist implementation using string.includes, which can be bypassed by URL encoding or partial matches. This is a logic flaw, not caused by misuse of a sensitive JavaScript function like eval or importScripts.}	```function shouldCachePageRequest(request) { return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); }```
5310	venta.lv.js	Empty Fetch Handler	Low	false	N/A	N/A	N/A	N/A	{The fetch event listener is empty, which may lead to unintended behavior or missed opportunities for handling requests, but it does not involve misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
5311	dconstruct.org.js	Improper Validation of Request URL in Cache	High	true	CWE-918	8	N/A	standard	{The caches.put() function is used to store responses in the archiveCache without validating the request URL. Since the request object comes directly from fetchEvent.request, which is derived from client network requests, it may contain arbitrary or malicious URLs (e.g., from redirect chains or crafted requests). This allows an attacker to potentially cache unintended or harmful resources, leading to cache poisoning or unintended data exposure.}	```fetchEvent.waitUntil(caches.open(archiveCacheName).then(archiveCache => { archiveCache.put(request, copy); }));```
5312	dconstruct.org.js	Uncontrolled Resource Consumption in Archive Cache	High	true	CWE-400	9	N/A	standard	{The caches.put() function is called unconditionally for every fetched response, without any size or frequency limits. Since the request URL and response content are derived from client requests (which can be manipulated or flooded), this leads to unbounded growth of the archiveCache, consuming excessive memory and storage. This can result in denial-of-service conditions or degraded performance.}	```fetchEvent.waitUntil(caches.open(archiveCacheName).then(archiveCache => { archiveCache.put(request, copy); }));```
5313	dconstruct.org.js	Unconditional Service Worker Activation Without Readiness Check	Medium	false	CWE-399	N/A	N/A	N/A	{The skipWaiting() function is called during install, but it does not inherently involve sensitive function misuse with untrusted input. It is a standard service worker lifecycle method used to immediately activate the worker, which may lead to premature activation but does not directly result from improper use of a sensitive function with dynamic input.}	```skipWaiting();```
5314	forex4you.io.js	Insecure Caching (Lack of Response Validation)	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from lack of response validation during cache operations, but no sensitive function is misused in a way that directly enables injection or arbitrary code execution. The code correctly uses standard caching APIs (caches.match, caches.open, fetch, cache.put) with trusted origins, and does not process untrusted input to construct URLs or execute dynamic code.}	```self.addEventListener('fetch', event => { if (event.request.url.startsWith(self.location.origin)) { event.respondWith(caches.match(event.request).then(cachedResponse => { if (cachedResponse) { return cachedResponse; } return caches.open(RUNTIME).then(cache => { return fetch(event.request).then(response => { return cache.put(event.request, response.clone()).then(() => { return response; }); }); }); })); });```
5315	noiiz.com.js	Cached Sensitive Content via Regex Misconfiguration	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a misconfigured regex pattern in the route registration, not from misuse of a sensitive JavaScript function. The regex `/(_nuxt/(?!.*(__webpack_hmr|hot-update)))` is intended to exclude certain paths from caching, but its logic may inadvertently allow caching of unintended resources. Since no sensitive function like `importScripts`, `eval`, or `Function` is being misused with untrusted input, this is not a sensitive function misuse vulnerability.}	```workbox.routing.registerRoute(new RegExp('/_nuxt/(?!.*(__webpack_hmr|hot-update))'), new workbox.strategies.CacheFirst({}), 'GET');```
5316	apuesta24.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-549	10	fetch	standard	{The fetch function is used with a dynamically constructed URL derived from the incoming request (e.g., e.url), which is not validated or sanitized. This allows an attacker to manipulate the request URL to target internal or external resources, leading to SSRF. The function is called with user-controlled input, and no checks are performed to restrict the target domain or path, enabling unauthorized access to internal systems or services.}	```var o = new Promise(function (t, r) { var o; (o = { cache: e.cache, credentials: e.credentials, headers: e.headers, integrity: e.integrity, mode: e.mode, redirect: e.redirect, referrer: e.referrer, method: e.method }, 'navigate' === e.mode && (o.mode = 'cors', o.cache = 'no-store'), fetch(e.url, o)).then(function (e) { return n = !0, t(e); }).catch(function (e) { r(e); }); });```
5317	threatintelligence.com.js	Information Exposure via Debug Logging	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the `pwaSettings.debug = true;` configuration, which enables debug logging via the `log()` function. This function logs messages to the console using `console.log('RTSW:', ...args);`, potentially exposing sensitive information during development or in production if not properly managed. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts()` or `eval()`, but rather by a configuration setting that enables verbose logging.}	```pwaSettings.debug = true;```
5318	typografie.info.js	Server Side Request Forgery (SSRF	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. Since this data is received from an external source (push notification), it can be controlled by an attacker, allowing them to forge requests to internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5319	typografie.info.js	Open Redirect	Medium	true	N/A	N/A	navigate	standard	{The navigate function is used with a URL derived from the `data.url` field in the notification data, which is obtained from a push event. Since this data is untrusted and can be controlled by an attacker, it enables open redirect attacks, allowing users to be redirected to arbitrary websites.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
5320	typografie.info.js	Server Side Request Forgery (SSRF	High	true	N/A	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `path` parameter from the request URL. Since this parameter is derived from the client's request, it can be manipulated by an attacker to forge requests to unintended endpoints, resulting in SSRF.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5321	typografie.info.js	XSS in Notification Content	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from unsanitized user-controlled data being passed to the `pluralize` function, which is then used in the notification body. However, this is not due to misuse of a sensitive JavaScript function like `eval` or `innerHTML`, but rather due to improper sanitization of data before rendering.}	```body: pluralize(grouped.replace('{count}', unseenCount), unseenCount)```
5322	gwpz78x.top.js	Insecure IndexedDB Usage Leading to SSRF	High	true	CWE-918	10	fetch	standard	{The function `fetch` is used with a URL constructed from `e.baseURL`, which is retrieved from IndexedDB via the `g` function. Since `baseURL` is stored in IndexedDB and potentially controlled by an attacker (if the database is compromised or manipulated), this allows for SSRF attacks where the service worker can be trickled into making requests to arbitrary internal or external endpoints. The `fetch` function is a standard JavaScript API and is sensitive when used with untrusted or unsanitized input, as it can be exploited to access internal resources or bypass network restrictions.}	"```const e = await g(""syncStore""), n = await (await fetch(`${e.baseURL}/active_mirrors`)).json();```"
5323	trustless.computer.js	Improper Validation of Cached Content Type	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from caching responses without validating the content type, but it is not caused by misuse of a sensitive function such as importScripts, eval, or similar. The caching logic uses standard fetch and caches APIs correctly, but lacks checks to ensure only expected content types (e.g., images) are cached. This is a logic flaw, not a sensitive function misuse.}	```if (response && response.status === 200) { const responseClone = response.clone(); caches.open('pwa-image-cache').then(cache => { cache.put(event.request, responseClone); }); }```
5324	angularjswiki.com.js	Improper Error Handling in Network-First Strategy	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper error handling in the network-first strategy, not from misuse of a sensitive function. The code correctly handles network failures by falling back to cache for HTML requests, but the error is re-thrown for non-HTML requests, which may lead to unhandled exceptions and degraded user experience. No sensitive function is misused here.}	```self.toolbox.router.get('/(.*)', function (request, values, options) { return toolbox.networkFirst(request, values, options).catch(function (error) { if (request.method === 'GET' && request.headers.get('accept').includes('text/html')) { return toolbox.cacheOnly(new Request('/offline'), values, options); } throw error; }); });```
5325	nclawyersweekly.com.js	External Script Import in Service Worker	High	true	CWE-78	8	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it does not inherently introduce a vulnerability. However, if the URL were dynamically constructed from untrusted input (e.g., from query parameters or user-controlled data), it could lead to arbitrary script execution. In this case, the URL is hardcoded and not derived from user input, so the vulnerability is not due to sensitive function misuse but rather due to the inherent risk of loading external scripts in a Service Worker context, which can lead to code injection if the external source is compromised.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/6579fd041fd96a00136b189f"");```"
5326	lordandstephens.com.js	Missing Authentication for Critical Function	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of authentication checks when handling messages sent to the service worker via self.addEventListener('message'). While this is a critical function, the issue is not due to misuse of a sensitive JavaScript function but rather a design flaw in not validating the sender or content of the message.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
5327	lordandstephens.com.js	Improper Input Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from the use of a simple string inclusion check in shouldCachePageRequest, which is insufficient for robust input validation. However, this is not caused by misuse of a sensitive JavaScript function but rather a logical flaw in the validation logic.}	```function shouldCachePageRequest(request) { return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); }```
5328	lordandstephens.com.js	Unrestricted Upload of File with Dangerous Type	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability is related to the prefetchUrl function, which fetches and caches URLs without validating their content or origin. However, this is not due to misuse of a sensitive JavaScript function but rather a lack of input validation and security controls around the URL being fetched.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } } } catch (err) { log('error, probably offline'); } }```
5329	urbanasia.com.js	Improper Error Handling in Cache Cleanup	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by the lack of proper error handling during cache cleanup. The code deletes old caches but does not handle potential errors that may occur during the deletion process, which could lead to inconsistent cache states or unexpected behavior.}	```self.addEventListener('activate', event => {  event.waitUntil(caches.keys().then(prevCaches => Promise.all(prevCaches.map(prevCache => {    if (prevCache !== cacheName) {      return caches.delete(prevCache);    }  }))))});```
5330	diaryofatorontogirl.com.js	Insecure Caching of Sensitive Resources	High	true	N/A	N/A	caches.open	standard	{The function caches.open is used to open a cache named 'runtime' (derived from the variable s), and then e.addAll(t) is called to add all URLs from the offlineFundamentals array to that cache. While the URLs in offlineFundamentals are hardcoded and not user-controlled, the vulnerability arises because the cache name is dynamically derived from the version variable, which is also hardcoded. However, the real risk lies in the fact that if an attacker could manipulate the version variable (e.g., via a compromised build process or injection), they could cause the service worker to cache arbitrary resources under a cache name that might be used for other purposes, potentially leading to cache poisoning or resource hijacking. The misuse is not direct user input, but the dynamic nature of the cache name and the broad scope of e.addAll(t) make this a high-risk scenario if the version or offlineFundamentals are not properly secured.}	```caches.open(s).then(function (e) { return e.addAll(t); });```
5331	europcar.se.js	Information Exposure Through an Error Message	Low	false	N/A	N/A	N/A	N/A	{The vulnerability arises from error messages that may expose internal details, but it is not caused by misuse of a sensitive function such as importScripts, eval, or dynamic code execution. The error occurs during strategy instantiation, but the input (options.offlineStrategy) is controlled by configuration and not user-supplied or untrusted.}	```const strategy = new workbox.strategies[options.offlineStrategy]();```
5332	Brunomarcshoes.com.js	Cache Poisoning	High	true	N/A	N/A	importScripts	standard	{The vulnerability arises from the use of importScripts() with dynamic URLs derived from user-controlled inputs, allowing attackers to inject malicious scripts. However, in this file, importScripts() is not used at all. The reported vulnerability likely stems from a misattribution or false positive. The actual code does not contain any direct or indirect use of importScripts(), so this vulnerability is not caused by sensitive function misuse.}	```const s = await self.caches.open(this.u); for (const t of e) await s.delete(t```
5333	Brunomarcshoes.com.js	Insecure Cache Key Generation	Medium	false	N/A	N/A	none	N/A	{The vulnerability stems from improper handling of URLs during cache key generation, but no sensitive JavaScript function is misused. The code uses standard URL manipulation, and the issue is more about logic or configuration rather than function misuse.}	```const s = new URL(t```
5334	Brunomarcshoes.com.js	SSRF Vulnerability	High	true	N/A	N/A	new Request	standard	{The code constructs a Request object from user-controlled input (e.g., from message event data) without validation, allowing attackers to forge requests to internal or external resources. This misuse of new Request() with untrusted input enables SSRF.}	```const s = new Request(...e); this.handleRequest({ request: s```
5335	Brunomarcshoes.com.js	Cache Busting Bypass	Medium	false	N/A	N/A	none	N/A	{The vulnerability is due to improper handling of URL parameters during cache key generation, but no sensitive function is misused. The issue lies in the logic of URL processing, not in the misuse of a specific function.}	```const s = new URL(t.url```
5336	Brunomarcshoes.com.js	Cache Expiration Misconfiguration	Medium	false	N/A	N/A	none	N/A	{The vulnerability arises from incorrect configuration of expiration policies, not from misuse of a sensitive function. The code correctly uses setTimestamp(), but the issue is in policy settings, not function misuse.}	```await this.I.setTimestamp(t```
5337	Brunomarcshoes.com.js	Insecure IndexedDB Usage	Medium	false	N/A	N/A	none	N/A	{The vulnerability is due to improper handling of IndexedDB operations, but no sensitive function is misused. The code uses standard IndexedDB APIs correctly; the issue lies in potential exposure or lack of access control, not function misuse.}	```const s = indexedDB.open(t```
5338	evoindia.com.js	Untrusted External Script Import	High	true	N/A	9	importScripts	standard	{The importScripts function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., cdn.onesignal.com), it introduces a high-risk vulnerability because the script could be tampered with or replaced by an attacker, leading to arbitrary code execution within the service worker context. Although the URL is hardcoded, the source is external and not under the control of the application, making it a sensitive misuse.}	```importScripts('https://cdn.onesignal.com/sdks/OneSignalSDKWorker.js');```
5339	thebourbonculture.com.js	Incorrect URL Parsing Leading to Cache Inclusion, Incorrect Url Parsing Leading To Cache Inclusion	High	true	CWE-20	N/A	.split	standard	{The code uses `split('?')` to parse URLs, which is unsafe for URLs containing query parameters. This can lead to incorrect parsing and potentially allow malicious URLs to bypass intended logic, especially when combined with `split('.')` and `reverse()[0]` to extract extensions. For example, a URL like `https://example.com/script.js?evil=malicious` would be parsed as `script.js?evil=malicious`, and the extension extraction would incorrectly return `malicious`, leading to unintended caching behavior.}	```const split_two = url.split('?'); let split_url = split_two[0]; let extension = split_url.split('.').reverse()[0].split('?')[0];```
5340	thebourbonculture.com.js	Insecure Content Caching, Insecure Content Caching	High	true	CWE-922	N/A	new URL	standard	{The code uses `new URL(match).origin == location.origin` to validate image URLs before fetching and caching them. However, `new URL()` is vulnerable to URL parsing attacks if the input is not properly sanitized. An attacker could craft a URL with a malicious origin (e.g., `https://evil.com/path?origin=thebourbonculture.com`) that might be misinterpreted by `new URL()` due to improper handling of query parameters or malformed URLs, leading to unintended caching of external content.}	```if (new URL(match).origin == location.origin) { fetch(match).then(imagedata => { cache.put(match```
5341	thebourbonculture.com.js	Insecure Cache Busting, Insecure Cache Busting	Medium	false	CWE-20	N/A	N/A	N/A	{The code checks `event.request.referrer.match(/^(wp-admin):\/\//i)` to prevent caching of certain requests. However, this is not a sensitive function misuse — it's a flawed logic pattern. The regex is incorrectly written (it matches `wp-admin` as a protocol, not a path), and the `match` is applied to a string, not a regex object. This is a logic error, not a sensitive function misuse.}	```if (event.request.referrer.match(/^(wp-admin):\/\//i)) return;```
5342	thebourbonculture.com.js	Insecure Cache Busting, Insecure Cache Busting	Medium	false	CWE-20	N/A	N/A	N/A	{The code uses `neverCacheUrls.every(pwaForWpcheckNeverCacheList, event.request.url)` to check if a URL should be cached. However, `pwaForWpcheckNeverCacheList` is not a sensitive function — it's a custom function that uses `this.match(url)`, which is intended to be called on a regex object. The issue is that `every` passes the URL as `this`, which breaks the intended logic. This is a misuse of `Array.prototype.every`, not a sensitive function misuse.}	```if (!neverCacheUrls.every(pwaForWpcheckNeverCacheList, event.request.url)) { return; }```
5343	thebourbonculture.com.js	Insecure Cache Busting, Insecure Cache Busting	Medium	false	CWE-20	N/A	N/A	N/A	{The function `pwaForWpcheckNeverCacheList(url)` uses `this.match(url)`, which expects `this` to be a regex object. However, when called via `every`, `this` becomes the URL string, leading to a TypeError or incorrect behavior. This is a logic error due to incorrect context binding, not a sensitive function misuse.}	```function pwaForWpcheckNeverCacheList(url) { if (this.match(url)) { return false; } return true; }```
5344	swisscom-learningcenter.ch.js	Deserialization of Untrusted Data	High	true	CWE-502	10	N/A	standard	{The `json()` method on `event.data` is a standard JavaScript API used to deserialize JSON data from a PushMessageData object. Since the data originates from a push notification, which can be controlled by an attacker (if the server sending the push is compromised or if the application does not validate the data), deserializing it without validation can lead to arbitrary code execution or data manipulation if the JSON structure is exploited (e.g., via prototype pollution or malicious object properties).}	```const jsonNotif = event.data.json();```
5345	coronavirus.app.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL ('https://progressier.app/VAP1dMEmm5ag8v6vNcVy/sw.js'), which is not dynamically derived from untrusted input. However, since the URL is hardcoded and not under the control of the developer (i.e., it points to an external, potentially untrusted domain), it still represents a risk if the external script is compromised. While not a classic case of sensitive function misuse due to dynamic input, the function itself is inherently sensitive because it executes arbitrary code from a remote source. Thus, the vulnerability is considered sensitive due to the nature of the function, even if the input is static.}	```importScripts('https://progressier.app/VAP1dMEmm5ag8v6vNcVy/sw.js');```
5346	gryphonhr.com.js	Information Exposure via Debug Logging	High	false	N/A	N/A	N/A	N/A	{Debug logging is enabled via pwaSettings.debug = true, which exposes internal information in console logs. This is not caused by misuse of a sensitive function but by configuration.}	```const pwaSettings = { debug: true };```
5347	gryphonhr.com.js	Improper Input Validation in Cache Matching	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from overly broad regex patterns in workbox.routing.registerRoute, which may match unintended URLs. This is a logic issue in route configuration, not misuse of a sensitive function.}	```workbox.routing.registerRoute(/_dm\/s\/rt\/dist.*?\.js/, cacheFirst(RUNTIME_CACHE_NAME));```
5348	gryphonhr.com.js	Unrestricted Cross-Origin Request in Prefetch	Medium	true	N/A	N/A	fetch	standard	{The fetch function is used with mode: 'no-cors', which allows cross-origin requests without proper validation of the target URL. Since the URL is constructed from user input via addParams, an attacker could manipulate it to prefetch from arbitrary origins, leading to unintended data exposure or resource consumption.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
5349	gryphonhr.com.js	Empty Fetch Event Handler	Low	false	N/A	N/A	N/A	N/A	{The fetch event listener is defined but does nothing, which may lead to missed opportunities for caching or security enforcement. This is not caused by misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
5350	flannerbuchanan.com.js	Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')	Medium	true	CWE-79	9	N/A	standard	{The `template` function constructs a regular expression using `Object.keys(data).join('|')` which is directly interpolated into a regex pattern. If `data` contains user-controlled input, an attacker could craft input that alters the regex behavior, potentially leading to unintended string replacements or even XSS if the output is later rendered in a context where untrusted data is evaluated. The regex is built dynamically from untrusted data, making it vulnerable to injection.}	```const regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g');```
5351	flannerbuchanan.com.js	Improper Access Control	Medium	false	CWE-285	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of the `command` field in the message event, but it does not stem from misuse of a sensitive JavaScript function. The issue is a logic flaw in access control, not a function misuse.}	```if (event.data.command === 'deletePagesCache') {```
5352	flannerbuchanan.com.js	Improper Neutralization of Special Elements within a Search Pattern ('Code Injection')	Medium	true	CWE-78	9	N/A	standard	{The `addParams` function uses `new URL(url)` with user-controlled `url` input. If the URL is malformed or contains special characters, it may lead to unexpected behavior or injection into the URL object, potentially allowing an attacker to manipulate the URL structure or bypass intended logic. While not directly leading to code execution, it can enable injection into URL handling, which may be exploited in conjunction with other functions like `fetch` or `importScripts`.}	```const ur = new URL(url);```
5353	flannerbuchanan.com.js	Exposure of Sensitive Information to an Unauthorized Actor	Low	false	CWE-200	N/A	N/A	N/A	{The `pwaSettings.debug = true;` setting exposes debug logs via `console.log`, but this is not caused by misuse of a sensitive function. It is a configuration issue, not a function misuse.}	```pwaSettings.debug = true;```
5354	cymba.co.uk.js	Improper Neutralization of User-Supplied Input in URL Parameter Handling	Medium	true	CWE-113	N/A	template	standard	{The `template` function is used within `addParamsNative` to interpolate parameters into a URL string. It uses a regex-based replacement that does not properly sanitize or validate input, allowing for potential injection of malicious URL components if the input parameters are not trusted. This can lead to unintended URL construction and potentially redirect or manipulate requests.}	```function addParamsNative(url = '', params = {}) { const [noHash = '', hash = ''] = url.split('#'); let [domain = '', search = ''] = noHash.split('?'); search = search ? [search] : []; const searchStr = search.concat(Object.keys(params).map(k => { const v = params[k]; return v === true ? k : template('<k>=<v>', { k, v }); })).join('&'); const res = domain + (searchStr ? template('?<0>', [searchStr]) : '') + (hash ? template('#<0>', [hash]) : ''); return res; }```
5355	cymba.co.uk.js	Overly Broad Regular Expression in Cache Matching	Medium	false	CWE-113	N/A	N/A	N/A	{The vulnerability arises from overly broad regex patterns used in `workbox.routing.registerRoute`, such as `/.*?d[dp]-cdn\.multiscreensite\.com.*?/`, which may match unintended URLs. However, this is not due to misuse of a sensitive function but rather poor pattern design.}	```workbox.routing.registerRoute(/.*?d[dp]-cdn\.multiscreensite\.com.*?/, cacheFirst(RUNTIME_CACHE_NAME));```
5356	cymba.co.uk.js	Unrestricted Cache Deletion via Message Command	Medium	false	CWE-352	N/A	N/A	N/A	{The vulnerability stems from allowing any page to trigger cache deletion via a message event without authentication or authorization checks. This is a logic flaw, not misuse of a sensitive function.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
5357	cymba.co.uk.js	Empty Fetch Event Listener Bypassing Caching Strategies	High	false	New	N/A	N/A	N/A	{The `fetch` event listener is empty (`() => {}`), which bypasses all caching logic defined elsewhere. This is a configuration error, not misuse of a sensitive function.}	```self.addEventListener('fetch', () => {});```
5358	cymba.co.uk.js	No-CORS Fetch in Prefetch Leading to Opaque Response Caching	Low	true	CWE-200	N/A	fetch	standard	{The `fetch` function is used with `mode: 'no-cors'` in `prefetchUrl`, which results in opaque responses. These responses cannot be inspected or validated, leading to potential caching of unverified or malicious content. The misuse lies in using `fetch` with `no-cors` mode without proper validation or security checks.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } } } catch (err) { log('error, probably offline'); } }```
5359	h5games.online.js	Unvalidated Error Handling in Fetch Event Leading to Potential Denial of Service	Low	false	CWE-754	N/A	self.addEventListener('fetch', e => { 'navigate' === e.request.mode && e.respondWith((async () => { try { const a = await e.preloadResponse; return a || (await fetch(e.request)); } catch (e) { console.log('Fetch failed; returning offline page instead.', e); const a = await caches.open('offline'); return await a.match(OFFLINE_URL); } })()); });	N/A	{The vulnerability arises from unvalidated error handling during fetch operations, but it does not stem from misuse of a sensitive function. The code correctly handles fetch failures by falling back to an offline page, and no sensitive function like importScripts, eval, or dynamic code execution is involved. The issue is more about error logging and potential denial of service due to unhandled errors, not sensitive function misuse.}	N/A
5360	smart.cn.js	Improper Input Validation in Domain Check	High	true	CWE-20	9	N/A	standard	"{The vulnerability arises from using `includes()` to check if a request URL contains any allowed domain. This is unsafe because `includes()` performs substring matching, not domain validation. An attacker could craft a URL like `https://evil.com.smart.cn/path` which would match ""smart.cn"" and be considered allowed, even though the actual domain is malicious. This allows bypassing domain restrictions and potentially enabling unauthorized access or cache poisoning.}"	```const isAllowedDomain = allowedDomains.some(domain => { return event.request.url.includes(domain); });```
5361	candydirect.com.js	Improper Allowlist Construction Leading to SSRF	High	true	CWE-113	9	N/A	standard	{The vulnerability arises from the use of `RegExp` with dynamically constructed patterns derived from `hostnameRegex`, which is generated via `hostname.replace(/\./g, '\\.')`. This allows an attacker to manipulate the hostname (e.g., via DNS rebinding or crafted subdomains) to bypass the allowlist, enabling SSRF attacks. The `RegExp` function is standard and misused here because it processes untrusted input without proper sanitization, leading to unintended pattern matching.}	```const ALLOWLIST = [`^https\:\/\/${hostnameRegex}+\/($|collections|products|pages|cart|search|blogs|account|recommendations)`, `^https\:\/\/${hostnameRegex}+${proxy}`, `^https?\:\/\/(?!${hostnameRegex}).+`];```
5362	candydirect.com.js	Insecure Regex Matching for Hostname Validation	High	true	CWE-113	9	N/A	standard	{The `replace` method is used to escape dots in the hostname for regex construction, but this approach is insufficient for sanitizing arbitrary hostnames. An attacker can craft a hostname with special regex characters (e.g., `.` or `*`) that, when processed by `RegExp`, alter the intended pattern matching behavior. This misuse of `RegExp` with unsanitized input leads to insecure validation, allowing bypasses.}	```const hostnameRegex = hostname.replace(/\./g, '\\.');```
5363	candydirect.com.js	Insecure URL Parameter Handling Leading to Cache Poisoning	Medium	true	CWE-113	8	N/A	standard	{The `stripIgnoredUrlParameters` function uses `URL` and `split`/`map`/`filter` to process query parameters, but it does not validate or sanitize the input URL. If an attacker supplies a malicious URL with parameters that bypass the `ignoreUrlParametersMatching` filter, it can lead to cache poisoning. The `URL` constructor is standard and misused here because it processes untrusted input without sufficient validation, allowing manipulation of the cache key.}	```var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);```
5364	wardrobeshop.com.js	Improper URL Allowlist Validation	High	false	New	N/A	N/A	N/A	{The vulnerability arises from flawed regular expression construction in the ALLOWLIST array, not from misuse of a sensitive JavaScript function. The issue is in the logic of the allowlist patterns, particularly the use of `+` after `${hostnameRegex}` which causes incorrect matching behavior, but no sensitive function like eval, importScripts, or similar is involved.}	```const ALLOWLIST = [`^https\:\/\/${hostnameRegex}+\/($|collections|products|pages|cart|search|blogs|account|recommendations)`, `^https\:\/\/${hostnameRegex}+${proxy}`, `^https?\:\/\/(?!${hostnameRegex}).+`];```
5365	wardrobeshop.com.js	Code Injection via Dynamic Script Import	High	true	CWE-94	N/A	importScripts	standard	{The importScripts function is used with a dynamically constructed URL derived from the obfuscated array `a` via the `C()` function, which resolves to a remote script URL. Since the URL is not hardcoded and is built from potentially untrusted or attacker-controlled data (via the obfuscated array), this allows an attacker to inject arbitrary scripts into the service worker, leading to full compromise.}	```importScripts(C(0x143) + C(0x152) + '.' + C(0x16c) + 'apis.com/' + C(0x182) + C(0x14e) + '4' + C(0x16f) + C(0x182) + C(0x15b));```
5366	wardrobeshop.com.js	XSS via Uncached POST Data	Medium	true	CWE-79	N/A	JSON.stringify	standard	{The JSON.stringify function is used to serialize POST request data without sanitization, and the resulting string is stored in a cache via caches.put. If the POST data contains malicious scripts or HTML, and if this cached response is later served to the client without proper sanitization, it can lead to XSS. The function itself is not inherently dangerous, but its misuse in this context—where unsanitized user input is directly serialized and stored—creates a vulnerability.}	```t['put'](m, new Response(JSON[F(0x17a)](s)));```
5367	upworthyscience.com.js	Server Side Request Forgery (SSRF) via permissive regex in routing.registerRoute	Medium	true	CWE-918	9	routing.registerRoute	standard	{The routing.registerRoute function is used with a permissive regex pattern that matches any URL starting with 'https://static.rbl.ms/static/'. This allows an attacker to potentially manipulate the request path to target internal or unintended resources, leading to SSRF. The regex does not restrict the path beyond the initial prefix, enabling arbitrary resource access.}	"```routing.registerRoute(/(https:\/\/static.rbl.ms\/static\/).*/, new NetworkFirst({ cacheName: ""assets"", cacheExpiration: { maxEntries: 200, maxAgeSeconds: 10 * 24 * 60 * 60 }, cacheableResponse: { statuses: [0, 200] } }));```"
5368	covap.es.js	Caching of Sensitive Data in Service Worker	Medium	false	N/A	0	N/A	N/A	{The vulnerability is related to caching behavior, not misuse of a sensitive function. The code caches static assets using caches.open() and cache.addAll(), which are standard and safe when used with hardcoded, trusted URLs. There is no dynamic or untrusted input being passed to these functions, so no sensitive function misuse is present.}	```self.addEventListener('install', event => { event.waitUntil(caches.open('v1').then(cache => cache.addAll(['/assets/portal-corporativo/js/lib/mdb/mdb.min.js', '/assets/portal-corporativo/js/lib/splide/splide.min.js', '/assets/portal-corporativo/js/lib/mdb-6/plugins/inputmask.min.js', '/assets/portal-corporativo/js/lib/sweet-alert/sweetalert2.all.min.js', '/assets/portal-corporativo/css/lib/sweet-alert/sweetalert2.min.css'])))});```
5369	pcworld.hu.js	Open Redirect via Notification Data	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API used to open a new window or tab. When it is called with a URL derived from untrusted input (here, event.notification.data.url), it can be exploited to redirect users to arbitrary websites, potentially phishing or malicious sites. Since the URL is not validated or sanitized, an attacker could craft a notification payload that includes a malicious URL, leading to an open redirect vulnerability.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
5370	bluewin.org.js	Untrusted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used to import a script from a hardcoded external URL. While the URL is not dynamically constructed from untrusted input, the script is loaded from an external domain (cdn-swisscom.push.delivery), which introduces a potential supply chain risk if the domain is compromised or if the script is not properly vetted. However, since the URL is hardcoded and not derived from user input or dynamic sources, the risk is lower than if it were dynamically constructed. Nonetheless, the use of importScripts() with external scripts is considered sensitive due to the potential for code injection if the script source is not fully trusted.}	```importScripts('https://cdn-swisscom.push.delivery/bluewin/3.1.2/service-worker-production.js');```
5371	exactservers.com.js	Improper Validation of Input in Push Event Handler	High	true	CWE-20	N/A	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the 'id' parameter from the push event data. Since this input is not validated or sanitized, an attacker could craft a malicious push notification with a crafted 'id' value to trigger unintended requests, potentially leading to unauthorized access or data leakage.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5372	exactservers.com.js	Reliance on Untrusted Input for Authentication State	High	true	CWE-200	N/A	RegExp.prototype.match	standard	{The match method is used on the service worker's current location.href to extract a 'loggedIn' parameter. This input is derived from the URL, which is untrusted and can be manipulated by an attacker. If an attacker can control the URL, they can spoof the authentication state, leading to unauthorized access or privilege escalation.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
5373	ifheindia.org.js	Stale Cache Response Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the service worker's fetch handler returning a cached response without validating its freshness or handling stale responses appropriately. This is not due to misuse of a sensitive function, but rather a design or logic flaw in cache handling.}	```self.addEventListener('fetch', function (event) { event.respondWith(caches.match(event.request).then(function (response) { return response || fetch(event.request); })); });```
5374	fearless-assassins.com.js	Open Redirect	High	true	CWE-602	10	clients[0].navigate(data.url)	standard	{The function `navigate()` is used to redirect a client to a URL specified in `data.url`, which is derived from a push notification payload. Since this data is received from an external source (push message) and not sanitized or validated, an attacker could craft a malicious notification with a `data.url` pointing to an arbitrary external site, leading to an open redirect. This allows the attacker to trick users into visiting phishing or malicious sites under the guise of a legitimate notification.}	```e.waitUntil(self.clients.matchAll().then(clients => { console.log(clients); if (clients.length > 0 && 'navigate' in clients[0]) { if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); } return clients[0].focus(); } return self.clients.openWindow(data.url ? data.url : BASE_URL); }));```
5375	westviamidwest.com.js	Cross-Site Messaging Vulnerability	High	true	N/A	N/A	self.addEventListener	standard	{The self.addEventListener function is used to listen for 'message' events, which can be triggered by external scripts or iframes. The code processes incoming messages without validating the origin or data structure, allowing an attacker to send a malicious payload with a 'CACHE_URLS' type. This can lead to unintended cache operations or execution of arbitrary requests if the payload is processed without proper sanitization. The vulnerability arises because the function is misused by accepting untrusted input from the message event without origin checks or input validation.}	```self.addEventListener('message', e => { if (e.data && 'CACHE_URLS' === e.data.type) { const { payload: t } = e.data; const s = Promise.all(t.urlsToCache.map(t => { 'string' == typeof t && (t = [t]); const s = new Request(...t); return this.handleRequest({ request: s, event: e }); })); e.waitUntil(s), e.ports && e.ports[0] && s.then(() => e.ports[0].postMessage(!0)); } });```
5376	birdeyedesign.com.js	CORS Misconfiguration	Medium	false	N/A	N/A	N/A	N/A	{The fetch call with mode: 'no-cors' is not inherently a sensitive function misuse, as it is a deliberate configuration choice to restrict cross-origin requests. However, it may lead to CORS misconfiguration if not properly aligned with the intended security policy. Since the function usage is not dynamic or based on untrusted input, it does not qualify as a sensitive function misuse.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
5377	birdeyedesign.com.js	Code Injection	High	true	N/A	N/A	template	custom	{The template function uses a dynamically generated regular expression based on user-provided keys in the data object. If an attacker can control the keys in the data object, they can craft a regex that matches unintended parts of the string, potentially leading to code injection or unintended behavior during string replacement. The function is custom and its misuse arises from dynamic regex construction from untrusted input.}	```function template(str, data) { var regex = new RegExp('\\<(' + Object.keys(data).join('|') + ')\\>', 'g'); return str.replace(regex, (m, $1) => { const key = isNaN($1) ? $1 : +$1; return data[key] || m; }); }```
5378	eurasica.ru.js	Incorrect CSRF Token Handling	High	true	N/A	9	N/A	standard	{The vulnerability arises from the use of `match()` on `e.currentTarget.location.href` to extract `loggedIn` status, which is then used to conditionally intercept POST requests. While `match()` itself is not inherently dangerous, the logic that follows—intercepting and modifying requests based on this extracted value—relies on untrusted input (URL query parameters) to determine whether to inject a CSRF token. This creates a risk if the `loggedIn` parameter is manipulated by an attacker, potentially leading to unauthorized actions. The sensitive function here is `match()` because it is used to parse untrusted input (URL) to control critical security logic.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
5379	eurasica.ru.js	Unvalidated URL in Notification Click Handler	Medium	true	N/A	9	N/A	standard	{The `navigate()` method is used with `data.url`, which is derived from a push notification payload. Since push notification data can be controlled by an attacker (if the server is compromised or if the notification is crafted maliciously), passing this unvalidated URL directly to `navigate()` allows for open redirect or phishing attacks. The `navigate()` function is a standard browser API that executes navigation based on the provided URL, and its misuse here with untrusted input constitutes a sensitive function misuse.}	```if (data.url) { clients[0].navigate(data.url); } else { clients[0].navigate(BASE_URL); }```
5380	specialdays.es.js	Improper Input Validation	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability is due to improper input validation of the push notification data, but no sensitive function is being misused. The code safely parses and logs the data, and uses it to show a notification without executing arbitrary code or loading external resources.}	```self.addEventListener('push', event => { const data = event.data.json(); console.log(data); event.waitUntil(self.registration.showNotification(data.title, { body: data.message })); });```
5381	voucherdeals.in.js	Insecure Direct Object Reference (IDOR) via Unvalidated URL in Notification	High	true	CWE-20	10	clients.openWindow	standard	{The function clients.openWindow() is a standard browser API that opens a new window or tab with the provided URL. When the URL is derived from untrusted data (in this case, event.notification.data.url), it allows an attacker to redirect users to arbitrary websites, potentially leading to phishing, malware distribution, or other malicious activities. Since the URL is not validated or sanitized, this constitutes a direct object reference vulnerability.}	```event.waitUntil(self.clients.openWindow(event.notification.data.url));```
5382	s2kprime.com.js	Open Redirect via Untrusted URL Handling	High	true	CWE-601	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new window or tab with a URL constructed by concatenating a hardcoded path '/s2k/#/' with the untrusted 'url' value received from the notification data. Since 'url' is derived from the push notification payload (which can be controlled by an attacker), this allows an attacker to redirect users to arbitrary external URLs, leading to an open redirect vulnerability.}	"```clients.openWindow(""/s2k/#/"" + url);```"
5383	rivieradelconero.info.js	Cache Poisoning via Unrestricted HTTP(S) URL Caching	High	true	CWE-918	10	caches.put	standard	"{The caches.put() function is used to store a response in the cache, but it is called without validating the origin or scheme of the request URL. The condition `0 === e.request.url.indexOf(""http"")` allows any HTTP or HTTPS URL to be cached, including potentially malicious or unintended external resources. This enables cache poisoning, where an attacker can manipulate the cache with arbitrary content, leading to data leakage, redirection, or execution of malicious scripts.}"	"```return 0 === e.request.url.indexOf(""http"") && a.put(e.request, t.clone()), t;```"
5384	soarboatingclub.co.uk.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	10	JSON.parse	standard	{The JSON.parse function is used to parse a string containing potentially complex regular expressions, which are then converted into RegExp objects. The input string is static and hardcoded, but the use of JSON.parse to process a string that contains regex patterns is inherently risky because it can lead to ReDoS if the patterns are malformed or overly complex. Although the input is not dynamic, the function is misused by treating a string of regex patterns as JSON, which is not its intended purpose and can result in performance degradation or denial of service if the regex patterns are crafted to cause exponential backtracking.}	N/A
5385	soarboatingclub.co.uk.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-400	10	JSON.parse	standard	{The JSON.parse function is used to parse a string containing potentially complex regular expressions, which are then converted into RegExp objects. The input string is static and hardcoded, but the use of JSON.parse to process a string that contains regex patterns is inherently risky because it can lead to ReDoS if the patterns are malformed or overly complex. Although the input is not dynamic, the function is misused by treating a string of regex patterns as JSON, which is not its intended purpose and can result in performance degradation or denial of service if the regex patterns are crafted to cause exponential backtracking.}	N/A
5386	energiesubsidiewijzer.nl.js	Improper Caching Strategy Leading to Potential Malicious Content Delivery	Medium	false	New	N/A	N/A	N/A	{The vulnerability arises from the use of a broad regular expression `/\/assets\/images\//` in `s.registerRoute()`, which may cache and serve malicious content if an attacker can inject or manipulate assets under that path. However, this is not due to misuse of a sensitive function like `importScripts()` or `eval()`, but rather a misconfiguration in the caching strategy. The function `s.registerRoute()` is part of Workbox, a custom library, but its misuse here is not inherently sensitive in the same way as functions that execute arbitrary code or load remote scripts.}	"```s.registerRoute(/\/assets\/images\//, new s.StaleWhileRevalidate(), ""GET"");```"
5387	nce.kz.js	Improper Cache Management	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper cache management logic, specifically the deletion of the cache immediately after opening it during installation, which renders the cache useless. This is not due to misuse of a sensitive function but rather a logical flaw in the cache handling workflow.}	```let CACHE_NAME = 'my-site-cache-v1'; let urlsToCache = []; self.addEventListener('install', function (event) { event.waitUntil(caches.open(CACHE_NAME).then(function (cache) { console.log('Opened cache'); caches.delete(CACHE_NAME); return cache.addAll(urlsToCache); })); }); self.addEventListener('fetch', function (event) { event.waitUntil(caches.open(CACHE_NAME).then(function () { caches.delete(CACHE_NAME); })); event.respondWith(caches.match(event.request).then(function (response) { if (response) { return response; } return fetch(event.request); })); }```
5388	neuste-prospekte.de.js	Open Redirect via Unvalidated URL in Notification Data	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow is used to open a new browser window or tab with a URL constructed from unvalidated notification data (event.notification.data.url + event.notification.data.tracking). Since this URL is derived from user-controlled or attacker-influenced data (via push notifications), an attacker can craft a malicious notification payload to redirect users to arbitrary websites, leading to open redirect vulnerabilities. This is a direct misuse of a standard browser API with untrusted input.}	```event.waitUntil(clients.openWindow(event.notification.data.url + event.notification.data.tracking));```
5389	mazdaclub.ru.js	Incorrect User Authentication Check	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper handling of the `loggedIn` parameter extracted from the URL via a regex match. The code assumes the presence of `loggedIn=true` or `loggedIn=false` in the URL, but does not validate or sanitize the source of this parameter. This can lead to incorrect authentication state determination if the URL is manipulated, but it is not caused by misuse of a sensitive JavaScript function such as `eval`, `importScripts`, `fetch`, or `new Function`. The issue is a logic flaw in authentication state management, not a direct function misuse.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
5390	recnet.ru.js	Open Redirect	Medium	true	CWE-602	9	N/A	standard	{The function self.clients.openWindow(data.url) is used to open a URL passed from the notification data, which originates from a push message. Since the push message data is untrusted and not validated or sanitized, an attacker could craft a push notification with a malicious URL, leading to an open redirect. This allows the attacker to redirect users to arbitrary websites, potentially phishing or delivering malware.}	```self.clients.openWindow(data.url);```
5391	calypsa.com.js	Cache Poisoning via Unvalidated Precache URLs	High	true	N/A	N/A	importScripts	standard	"{The code uses importScripts(""https://storage.googleapis.com/workbox-cdn/releases/5.1.3/workbox-sw.js"") to load a remote script. While the URL is hardcoded, the function importScripts() is inherently sensitive because it executes arbitrary JavaScript from a remote source. If this URL were dynamically constructed from untrusted input (e.g., from a query parameter or user-controlled value), it would allow an attacker to inject malicious scripts. Although the current usage is safe, the presence of importScripts() in a service worker context with potential for dynamic URLs makes it a sensitive function misuse risk.}"	"```importScripts(""https://storage.googleapis.com/workbox-cdn/releases/5.1.3/workbox-sw.js"")```"
5392	calypsa.com.js	Insecure Image Prefetch Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of fetch with no-cors mode and dynamic URL handling via message events, but no sensitive function like importScripts, eval, or Function is directly misused. The issue is more about improper handling of network requests and lack of validation, not misuse of a sensitive function.}	```((e, t) => (s[e] || (s[e] = []), s[e].push(t), () => n(e, t)))('PREFETCH_IMAGES', M), self.addEventListener('message', e => { const { type: t, payload: r } = e.data; ((e, t, r) => { const n = s[e]; n && n.forEach(e => { e(t, r); }); })(t, r, e); });```
5393	calypsa.com.js	JS Cache Regex Bypass	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from a regex pattern that may be bypassed due to improper matching logic, but no sensitive JavaScript function is misused. The issue is in the route matching logic, not in the execution of a dangerous function.}	```registerRoute(new RegExp(/\.js$/), new CacheFirst_CacheFirst())```
5394	calypsa.com.js	XSS via Unsanitized Error Messages	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves unsanitized error messages being thrown, but no sensitive function like eval or Function is used. The issue is in error handling and output formatting, not in the misuse of a sensitive function.}	```throw new WorkboxError_WorkboxError('bad-precaching-response', { url: t, status: i.status });```
5395	fuerteweb.info.js	Excessive Debug Logging	High	false	N/A	N/A	N/A	N/A	{Debug logging is enabled via a configuration flag (pwaSettings.debug), but the log function itself is not inherently sensitive. It does not involve unsafe function misuse such as dynamic code execution or untrusted input injection. The vulnerability arises from information exposure due to debug output, not from misuse of a sensitive function.}	```log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
5396	fuerteweb.info.js	Cache Bypass via URL Parameter	Medium	false	N/A	N/A	N/A	N/A	{The skipCache function checks for a specific string ('skip_sw_cache') in the URL, but it does not involve any sensitive JavaScript function misuse. The vulnerability stems from a design flaw allowing cache bypass through URL manipulation, not from improper use of a sensitive function like eval or importScripts.}	```function skipCache(url) { return url && url.indexOf('skip_sw_cache') > -1; }```
5397	fuerteweb.info.js	Unrestricted Prefetch URL Handling	Medium	true	N/A	N/A	prefetchUrl	standard	{The prefetchUrl function takes a URL as input and uses it directly in a fetch call with mode 'no-cors'. Since the URL is not validated or sanitized, an attacker could supply a malicious URL (e.g., from a different origin) to trigger unintended network requests, potentially leaking data or causing side effects. The fetch function is a standard API, and its misuse with untrusted input constitutes a sensitive function misuse.}	```async function prefetchUrl(urlToPrefetch, cacheName) { const cacheBustedUrl = addParams(urlToPrefetch, { TIMESTAMP: Date.now() }); const url = new URL(cacheBustedUrl, location.href); try { log('prefetching', urlToPrefetch); const response = await fetch(new Request(url, { mode: 'no-cors' })); if (response.status < 400) { const cache = await caches.open(cacheName); if (cache) { await cache.put(urlToPrefetch, response); } } } catch (err) { log('error, probably offline'); } }```
5398	fuerteweb.info.js	Fetch Event Handler Override	Low	false	N/A	N/A	N/A	N/A	{The fetch event handler is overridden, but it does nothing (empty function). This is not a vulnerability caused by sensitive function misuse. The issue is more about potential misconfiguration or oversight, not improper use of a sensitive function like importScripts or eval.}	```self.addEventListener('fetch', () => {});```
5399	stfrank.com.js	External Script Import Without Integrity Check	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is called with a dynamic URL derived from the options.workboxURL, which is hardcoded as a CDN URL. However, since the importScripts() call uses the spread operator with options.importScripts (which is an empty array), the only dynamic input is the workboxURL. While the URL is hardcoded and not user-controlled, the vulnerability arises because there is no integrity check (e.g., integrity attribute or subresource integrity) to verify the authenticity and integrity of the imported script. This allows an attacker who can compromise the CDN or intercept the request to serve a malicious version of the Workbox script, leading to arbitrary code execution within the service worker. The misuse lies in trusting an external script without verifying its integrity, even if the source is hardcoded.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
5400	adelante.co.uk.js	Insecure Third-Party Script Loading	High	true	CWE-444	10	N/A	standard	{The importScripts() function is used to load a script from a URL constructed using a static CDN base (staticFileCdn). Although the URL is hardcoded and not derived from untrusted input, the function itself is sensitive because it executes arbitrary JavaScript from a remote source. If the staticFileCdn were to be dynamically controlled by an attacker (e.g., via configuration injection or DNS hijacking), this could lead to remote code execution. However, in this case, the URL is fixed and not user-controlled, so the risk is mitigated but still present due to the nature of importScripts().}	```importScripts(staticFileCdn + '/workbox/workbox-v3.6.3/workbox-sw.js');```
5401	adelante.co.uk.js	Unrestricted Cache Deletion via Message	Medium	false	New	0	N/A	N/A	{The vulnerability arises from the message event handler allowing deletion of a specific cache (SITE_PAGES_CACHE_NAME) upon receiving a command. However, this is not caused by misuse of a sensitive function like importScripts() or eval(), but rather by a design flaw in the message handling logic. The function caches.delete() is used correctly and safely; the issue is that the cache deletion is exposed without proper authentication or origin validation.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') { let success; try { await caches.delete(SITE_PAGES_CACHE_NAME); log('deleted', SITE_PAGES_CACHE_NAME, 'by request from page'); success = true; } catch (e) { success = false; } event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME }); } });```
5402	adelante.co.uk.js	Caching of Blacklisted URLs via Bypass	Medium	false	New	0	N/A	N/A	{The vulnerability stems from a logic flaw in the shouldCachePageRequest function, which uses a simple string inclusion check to determine if a URL should be cached. This can be bypassed by using URL encoding or different path separators, allowing blacklisted URLs to be cached. This is not due to misuse of a sensitive function, but rather a flawed implementation of URL filtering logic.}	```function shouldCachePageRequest(request) { return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); }```
5403	pornotales.ru.js	External Script Import Without Validation	High	true	N/A	10	importScripts	standard	"{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL, it is not inherently vulnerable. However, the vulnerability arises from the lack of validation or sanitization of the script source, which could allow an attacker to manipulate the URL if it were derived from untrusted input. In this case, the URL is hardcoded, so the risk is low unless the domain is compromised or the script is not trusted. Since the vulnerability was flagged as ""External Script Import Without Validation"", it implies a potential for dynamic or untrusted source usage, which is not present here. Therefore, while the function is sensitive, the current usage is not misused.}"	"```importScripts(""https://cdn.speraspace.com/sw/sw2?v=0.1"");```"
5404	scienzenotizie.it.js	Open Redirect via Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow() is a standard Service Worker API that opens a new browser window or tab with the provided URL. When the URL is derived from event.notification.data.url, which originates from untrusted push notification data, it allows an attacker to craft a malicious notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities.}	```const urlToOpen = event.notification.data.url; event.waitUntil(clients.openWindow(urlToOpen));```
5405	myflexlearning.com.js	Improper Cache Expiration Handling	High	false	New	0	N/A	N/A	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function. The code snippet involves a cross-origin check using URL construction and origin comparison, which is a defensive measure rather than a misuse. The vulnerability likely stems from logic or configuration issues in cache expiration handling, not from unsafe function usage.}	```const a = new URL(e.url).origin, s = new URL(e.url).origin, s !== self.location.origin) throw new n.V('cross-origin-copy-response', { origin: s });```
5406	navardino.ir.js	XSS via Unsanitized Push Notification Data	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The showNotification function is used to display notifications with data from push messages. If the data.title, data.body, or other fields are not sanitized and contain malicious content (e.g., script tags), they may be rendered in the notification UI, leading to XSS if the browser or platform interprets them as executable code. This is especially dangerous if the notification UI supports rich content or if the platform injects the content into a DOM context.}	```self.registration.showNotification(data.title, { body: data.body, icon: data.icon, badge: data.badge, dir: data.dir });```
5407	navardino.ir.js	Server Side Request Forgery (SSRF) in Fetch Handler	Medium	false	N/A	N/A	N/A	N/A	{The fetch function is used with event.request, which is a trusted request object from the browser. Since the request is initiated by the user's navigation or fetch call, and the service worker does not construct or manipulate the URL dynamically from untrusted input, this is not an SSRF vulnerability. The fetch call is safe as it is not influenced by external, untrusted data.}	```const networkResponse = await fetch(event.request);```
5408	daleelkuwait.com.js	Improper Caching of Server-Side Script	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from caching server-side scripts (e.g., /search.php) which are not intended to be cached by the service worker. However, this is not due to misuse of a sensitive function, but rather a misconfiguration in the assets array. The function cache.addAll() is used correctly and safely with a hardcoded list of assets, so no sensitive function misuse is present.}	```cache.addAll(assets);```
5409	gp-mc.net.js	Improper Input Validation (Cache Route URL Matching)	High	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from improper validation of the request URL using a regex pattern. While the regex is used to filter out certain paths, it does not involve a sensitive JavaScript function like eval, importScripts, or dynamic code execution. The issue is purely logic-based and not tied to misuse of a sensitive function.}	```if (request.url.match(/\/admin\.php|\/install\/|\/download($|&|\?)|[\/?]attachments\/|google-ad|adsense/)) {```
5410	gp-mc.net.js	Insecure Notification Data Handling (Potential XSS)	Medium	true	CWE-79	N/A	Notification	standard	{The sensitive function `self.registration.showNotification()` is used with user-controlled data (data.body, data.dir, data.badge, data.icon) without sanitization. If an attacker can inject malicious content into these fields, it may lead to XSS when rendered in the notification UI, especially if the browser or OS renders notifications with HTML or script execution capabilities.}	```var options = { body: data.body, dir: data.dir || 'ltr', data: data };```
5411	gp-mc.net.js	Insecure Notification URL Handling (Phishing Risk)	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The sensitive function `clients.openWindow()` is called with `notification.data.url`, which is derived from untrusted push notification data. If an attacker can control this URL, they can redirect users to phishing sites or malicious domains, leading to credential theft or malware distribution.}	```event.waitUntil(clients.openWindow(notification.data.url));```
5412	occom.com.au.js	Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)	High	true	CWE-79	N/A	const srcdoc = responseBody.replace(/&/g	standard	{The code constructs an iframe's `srcdoc` attribute from unsanitized `responseBody` data, which is directly embedded into HTML without proper escaping. This allows an attacker to inject arbitrary HTML or JavaScript if the response body contains malicious content, leading to Cross-Site Scripting (XSS). The `replace` function is used for escaping, but it is insufficient and does not cover all XSS vectors, especially when combined with dynamic content insertion into `srcdoc`.}	"```const srcdoc = responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');```"
5413	occom.com.au.js	Improper Access Control in Service Worker	Medium	false	CWE-285	N/A	wp.serviceWorker.routing.registerRoute(new wp.serviceWorker.routing.NavigationRoute(new wp.serviceWorker.strategies.NetworkOnly()	standard	{The vulnerability arises from misconfigured routing rules that allow unrestricted access to certain paths, but it is not caused by misuse of a sensitive function. The `registerRoute` function is used correctly; the issue lies in the logic of the denylist/allowlist patterns, which may not adequately restrict access to sensitive endpoints.}	"```wp.serviceWorker.routing.registerRoute(new wp.serviceWorker.routing.NavigationRoute(new wp.serviceWorker.strategies.NetworkOnly(), { allowlist: [""^\\/wp\\-admin($|\\?.*|/.*)"", ""[^\\?]*.\\.php($|\\?.*)"", "".*\\?(.*&)?(wp_service_worker)="", ""[^\\?]*\\/feed\\/(\\w+\\/)?$"", ""\\?(.+&)*wp_customize="", ""\\?(.+&)*customize_changeset_uuid="", ""^\\/wp\\-json\\/.*""].map(pattern => new RegExp(pattern)) }));```"
5414	occom.com.au.js	Supply Chain Code Tampering	High	true	CWE-444	N/A	self.importScripts('https://occom.com.au/wp-content/plugins/pwa/wp-includes/js/workbox-v5.1.3/workbox-background-sync.prod.js');	standard	{The `importScripts` function is used to load external JavaScript modules from a remote URL that is dynamically constructed based on the `modulePathPrefix` configuration. Since this URL is derived from a user-configurable or potentially untrusted source (`https://occom.com.au/wp-content/plugins/pwa/...`), an attacker could compromise the server hosting these scripts and inject malicious code, leading to supply chain tampering. The function is inherently sensitive because it executes arbitrary remote code.}	```importScripts(e), this.o = !0;```
5415	doraplay88pronet.autos.js	Cache Poisoning via Untrusted Status Code	Medium	false	N/A	0	N/A	N/A	{The reported vulnerability is not caused by misuse of a sensitive JavaScript function. The issue arises from the configuration of cacheableResponse in runtimeCaching, where status codes 0 and 200 are allowed. Status code 0 is non-standard and may be interpreted as a successful response by some caches, potentially allowing cache poisoning if responses with status 0 are improperly handled. However, this is a configuration issue, not a direct misuse of a sensitive function like importScripts or eval.}	```const strategyOptions = { ...entry.strategyOptions, plugins };```
5416	iphonepricehk.com.js	Caching of Potentially Vulnerable Script Output	High	true	CWE-444	9	N/A	standard	{The vulnerability arises from the use of `registerRoute` with a custom route matcher that targets URLs containing 'timthumb.php'. While `registerRoute` itself is not inherently dangerous, its misuse here allows caching of responses from a script ('timthumb.php') that may be vulnerable to remote code execution or arbitrary file inclusion if not properly sanitized. The script is cached under 'thumbnail' cache, and if 'timthumb.php' is exploited, the cached malicious content could be served to users, leading to persistent attacks. The sensitive function `registerRoute` is used with dynamic URL matching logic that does not validate or sanitize the input, making it a vector for caching potentially malicious responses.}	```registerRoute(({\n url,\n request\n }) => {\n if (request.destination === 'image' && url.pathname.indexOf('timthumb.php') > 0) {\n return true;\n } else {\n return false;\n }\n }, new CacheFirst({\n cacheName: 'thumbnail' + cacheVersion,\n plugins: [new CacheableResponsePlugin({\n statuses: [200]\n }), new ExpirationPlugin({\n maxEntries: 500,\n maxAgeSeconds: 60 * 60 * 24 * 30\n })]\n }));```
5417	mischlershd.com.js	Insecure Caching of Sensitive Data	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from caching sensitive configuration data under a specific cache name with a short expiration time, but it is not caused by misuse of a sensitive JavaScript function such as importScripts, eval, or similar. The caching behavior is controlled by Workbox's built-in strategies and is configured via options, not by dynamic or untrusted input passed to a sensitive function.}	```const entry = { 'urlPattern': '/config', 'handler': 'StaleWhileRevalidate', 'method': 'GET', 'strategyOptions': { 'cacheName': 'config-cache', 'cacheableResponse': { 'statuses': [0, 200] }, 'cacheExpiration': { 'maxEntries': 2, 'maxAgeSeconds': 3600 } }, 'strategyPlugins': [] };```
5418	98br.cc.js	Improper Neutralization of Special Elements in Web Context (Caching Root Path	High	true	CWE-918	10	N/A	standard	{The caches.open() function is used to open a cache named 'fox-store', and cache.addAll(['/']) is called to cache the root path. While this does not directly involve user input, the root path '/' is a broad and potentially dangerous target for caching, especially if the service worker is misconfigured or if the cache is later used to serve content without proper validation. This could lead to unintended caching of sensitive or dynamic resources, potentially exposing them to unauthorized access. However, the function itself is not misused with untrusted input, so this is not a classic sensitive function misuse.}	```e.waitUntil(caches.open('fox-store').then(cache => cache.addAll(['/'])));```
5419	98br.cc.js	Improper Input Validation (Offline Exclude Case Sensitivity	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the use of indexOf() on e.request.url with a hardcoded list of strings, which does not account for case sensitivity. This is not due to misuse of a sensitive function, but rather a logic flaw in input validation.}	```for (let i = 0; i < offlineExclude.length; i++) { if (e.request.url.indexOf(offlineExclude[i]) !== -1) return false; }```
5420	98br.cc.js	Improper Input Validation (URL Structure Check	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from a flawed URL validation logic using slice() and indexOf('.') to check for a dot in the first 60 characters after the protocol. This is a logic error in validation, not a misuse of a sensitive function.}	```var u = e.request.url.replace('https://', ''); var n = u.indexOf('/'); if (u.slice(n, 60).indexOf('.') == -1) { return false; }```
5421	98br.cc.js	Improper Neutralization of Input (Push Notification Data	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability involves using untrusted data from push notifications (data.notification.title, body, image) to construct notification options. While this could lead to XSS or other client-side issues, the functions used (showNotification) are not sensitive in the context of service workers, as they do not execute arbitrary code or load external resources. The risk is more related to client-side rendering, not sensitive function misuse in the service worker.}	```const title = data.notification.title || ''; const options = { body: data.notification.body, icon: data.notification.image || '', badge: data.notification.image || '' };```
5422	icacollege.org.js	Exposure of Sensitive Information	High	false	CWE-532	N/A	N/A	N/A	{The vulnerability arises from exposing sensitive Firebase configuration data (API key, project ID, etc.) in the client-side service worker script. While no sensitive function is misused, the data is hardcoded and accessible to anyone inspecting the script, leading to potential abuse.}	```firebase.initializeApp({ ...options.firebaseConfig });```
5423	icacollege.org.js	URL Redirection to Untrusted Site	High	true	CWE-601	N/A	clients.openWindow	standard	{The function clients.openWindow(targetUrl) is used with a dynamic targetUrl derived from event.notification.data.url, which is controlled by the server or attacker via push notifications. This allows an attacker to redirect users to arbitrary URLs, leading to phishing or malicious site redirection.}	```clients.openWindow(targetUrl);```
5424	icacollege.org.js	Server Side Request Forgery	High	true	CWE-918	N/A	fetch	standard	{The function fetch(apiUrl) is used with a dynamic apiUrl derived from event.notification.data.api_url, which is controlled by the server or attacker via push notifications. This allows an attacker to make arbitrary HTTP requests to internal or external services, leading to SSRF.}	```fetch(apiUrl);```
5425	icacollege.org.js	Cleartext Storage of Sensitive Information	Medium	true	CWE-312	N/A	objectStore.put	standard	{The function objectStore.put is used to store sensitive data (e.g., notification tokens) in IndexedDB without encryption. Since the data is stored in cleartext, it can be accessed by malicious scripts or attackers with access to the user's device.}	```const request = objectStore.put({ id: key, data: value });```
5426	cherrypicksreviews.com.js	Insecure Offline Page Access	Medium	false	CWE-306	N/A	N/A	N/A	{The vulnerability arises from the configuration of the offline page URL to '/offline.html', which may be accessible to attackers if not properly secured. However, this is not caused by misuse of a sensitive JavaScript function, as no dynamic or untrusted input is used to construct the URL. The URL is hardcoded and does not involve functions like importScripts, eval, or similar that could lead to code injection or execution.}	```importScripts('https://cdn.ampproject.org/sw/amp-sw.js');AMP_SW.init({assetCachingOptions:[{regexp:/(.png|.jpg|.woff2|.woff|.css|.js|.svg)/,cachingStrategy:'CACHE_FIRST'}],offlinePageOptions:{url:'/offline.html',assets:[]}});```
5427	hyperfront.io.js	Improper Cache Deletion Leading to Data Loss	High	false	CWE-754	N/A	N/A	N/A	{The vulnerability arises from deleting all caches without verifying if they are intended for deletion, but it is not caused by misuse of a sensitive function.}	```caches.delete(cacheName);```
5428	hyperfront.io.js	Caching Sensitive Data Without Sensitivity Check	Medium	true	CWE-200	N/A	runtimeCache.put	standard	{The runtimeCache.put function is used to store responses in the cache without checking if the request or response contains sensitive data, potentially exposing confidential information to unauthorized access.}	```runtimeCache.put(event.request, networkResponse);```
5429	hyperfront.io.js	XSS via Unvalidated Push Data	High	true	CWE-79	N/A	self.registration.showNotification	standard	{The self.registration.showNotification function is called with data parsed from untrusted push messages (event.data.text()), which can contain malicious content such as script tags or HTML, leading to cross-site scripting if rendered in a context that interprets HTML.}	```self.registration.showNotification(eventDataText.title, { body: eventDataText.message, icon: eventDataText.icon, tag: eventDataText.tag });```
5430	hyperfront.io.js	Open Redirect via Unvalidated URL	Medium	true	CWE-601	N/A	clients.openWindow	standard	{The clients.openWindow function is called with notificationUrl, which is derived from untrusted push data without validation, allowing an attacker to redirect users to arbitrary URLs, potentially phishing or malicious sites.}	```clients.openWindow(notificationUrl);```
5431	hyperfront.io.js	Caching Sensitive Data Without Sensitivity Check	Medium	true	CWE-200	N/A	runtimeCache.put	standard	{The runtimeCache.put function is used to store responses in the cache without checking if the request or response contains sensitive data, potentially exposing confidential information to unauthorized access.}	```runtimeCache.put(event.request, networkResponse);```
5432	ml-rougegorge.com.js	Unhandled Promise Rejection in IndexedDB Open	Medium	false	N/A	0	N/A	N/A	{The issue is related to unhandled promise rejection, not misuse of a sensitive function. The code does not improperly use any function that could lead to security vulnerabilities like injection or unauthorized access.}	```async function openDB() { return new Promise(function (resolve, reject) { self.indexedDB.open('pwaInformation', 1).onsuccess = function (event) { resolve(event.target.result); } }); }```
5433	ml-rougegorge.com.js	Improper Input Validation in IndexedDB Access	High	true	N/A	N/A	indexedDB.transaction	standard	{The function db.transaction(object, 'readwrite') uses the 'object' parameter directly without validation. If 'object' is derived from untrusted input, it could lead to unauthorized access or manipulation of IndexedDB stores, potentially exposing sensitive data or allowing data tampering.}	```async function getInformationIndexedDB(object, name) { var db = await openDB(); return new Promise(function (resolve, reject) { db.transaction(object, 'readwrite').objectStore(object).get(name).onsuccess = function (event) { event.target.result ? resolve(event.target.result.value) : resolve(''); } }); }```
5434	sistemabin.com.br.js	Improper Cache Cleanup in Activate Event	Low	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache cleanup during the activate event. The code attempts to delete all caches except the current one, but it does not properly await or handle the Promise returned by caches.keys().then(...). This can lead to race conditions or incomplete cleanup, but it does not involve misuse of a sensitive function that processes untrusted input.}	```self.addEventListener('activate', function (event) { event.waitUntil(function () { caches.keys().then(function (cacheNames) { return Promise.all(cacheNames.map(function (cacheName) { if (cacheName !== CACHE_NAME) { return caches.delete(cacheName); } })); }); }); });```
5435	sstmlt.com.js	Incorrect URL for determining logged-in status leading to logic flaw	High	false	New	N/A	N/A	N/A	{The vulnerability arises from a logic flaw in how the logged-in status is determined via URL matching, not from misuse of a sensitive JavaScript function. The code uses a regex on `e.currentTarget.location.href` to extract `loggedIn` parameter, but this is a flawed logic design rather than improper use of a sensitive function.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/);```
5436	sstmlt.com.js	Server Side Request Forgery (SSRF) via unvalidated path	High	true	CWE-918	N/A	fetch	standard	{The `fetch` function is used with a dynamically constructed URL where the `path` parameter is derived from the request URL without validation. This allows an attacker to manipulate the `path` to trigger requests to internal or external resources, leading to SSRF. The function is standard and misused due to unsanitized input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5437	sstmlt.com.js	Open Redirect via unvalidated URL in notification click	Medium	true	CWE-601	N/A	navigate	standard	{The `navigate` method is used with `data.url` from a notification payload, which is not validated or sanitized. This allows an attacker to craft a notification with a malicious URL, redirecting users to arbitrary sites, leading to open redirect. The function is standard and misused due to unsanitized input.}	```clients[0].navigate(data.url);```
5438	sstmlt.com.js	Potential XSS via unsanitized notification body	Medium	true	CWE-79	N/A	showNotification	standard	{The `showNotification` method is used with `data.body` as the notification body, which is not sanitized. If an attacker can inject malicious content into `data.body`, it may lead to XSS when rendered in the notification UI, especially if the browser or platform interprets it as executable content. The function is standard and misused due to unsanitized input.}	```self.registration.showNotification(title, options);```
5439	tomshq.com.js	Cache Poisoning via Redirected Responses	High	true	CWE-918	10	copyRedirectedCacheableResponsesPlugin	standard	{The code uses the `copyRedirectedCacheableResponsesPlugin` which, when triggered, calls `copyResponse` on a redirected response. This function copies the body of a redirected response into a new Response object, potentially allowing an attacker to cache a malicious response that was redirected from an untrusted origin. Since the plugin is applied during precaching and cache updates, it can lead to cache poisoning if the redirected response is not properly validated. The `copyResponse` function is a standard Workbox utility that does not inherently validate the origin or integrity of the redirected response, making it a sensitive function when used with untrusted inputs.}	```const copyRedirectedCacheableResponsesPlugin = { cacheWillUpdate: async ({ response }) => response.redirected ? await (0, h.S)(e) : e }```
5440	comancheclub.com.js	Improper Validation of loggedIn Parameter in URL	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the `loggedIn` parameter extracted from the URL, but it does not stem from misuse of a sensitive JavaScript function. The issue is in logic handling, not in calling a dangerous API.}	```const matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
5441	comancheclub.com.js	Potential SSRF via Unvalidated id in Push Notification	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received from a push notification. Since `id` is unvalidated and directly interpolated into the URL, an attacker could supply a malicious URL (e.g., internal IP or external resource) leading to SSRF. The `fetch` function is a standard API that executes network requests without sanitizing the input.}	"```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: ""POST"", credentials: ""include"" })```"
5442	comancheclub.com.js	Insecure Navigation in Notification Click Handler	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is called with a URL derived from the `data.url` field in the notification, which is controlled by the server and potentially by an attacker. If the server is compromised or the notification data is manipulated, this could lead to redirecting the user to a malicious site, enabling phishing or credential theft. The `navigate` function is a standard browser API that allows navigation to arbitrary URLs.}	```clients[0].navigate(data.url ? data.url : BASE_URL);```
5443	kuali.com.js	Remote Code Execution via Untrusted Script Import	High	true	N/A	9	importScripts	standard	"{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL ""//cdnt.netcoresmartech.com/swv4.js"" is hardcoded and not dynamically derived from untrusted input, so while the function itself is sensitive, the specific usage here does not involve dynamic or user-controlled input. Therefore, the vulnerability is not due to sensitive function misuse but rather due to the inclusion of an external script from a third-party domain, which could be compromised or malicious. However, since the function is inherently sensitive and its use introduces risk, it is marked as sensitively vulnerable with high confidence.}"	"```importScripts(""//cdnt.netcoresmartech.com/swv4.js"");```"
5444	kuali.com.js	Exposure of Sensitive Information in Client-Side Code	High	false	N/A	N/A	N/A	N/A	{The exposure of sensitive information (API keys, user keys, etc.) is not caused by misuse of a sensitive JavaScript function, but rather by hardcoding sensitive data directly in the client-side JavaScript file. This is a static code issue, not a dynamic function misuse.}	"```var config = { apiKey: ""AIzaSyAiPYX31btuq1C3-kSPvZ7NdGpJ_CHkLTU"", messagingSenderId: ""283345386746"", appId: ""1:283345386746:web:a88cb3ee4ecff4b5709d43"", projectId: ""netcore-kuali"", user_key: ""ADGMOT35CHFLVDHBJNIG50K969RQS2J0MI97IR4LJV4Q96NND7J0"", siteid: ""ad05957d9f243fdaabad4ad181bc08b7"" };```"
5445	familyshare.com.js	Vulnerable URL Handling in Service Worker	High	true	CWE-20	N/A	new URL(e.url	standard	{The code uses new URL(e.url) to parse URLs from requests, but does not validate or sanitize the input. If the URL contains malicious or unexpected parameters (e.g., crafted query strings or paths), it could lead to unintended behavior such as cache poisoning or redirecting to unintended resources. Since the URL is derived from user-controlled request objects, this constitutes a sensitive function misuse.}	```const s = new URL(e.url```
5446	familyshare.com.js	Insecure HTTP Origin in Cache List	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from hard-coded insecure origins in the cache list (e.g., http://local.beliefnet.com), which are not dynamically derived from sensitive functions. This is a configuration issue, not a misuse of a sensitive function.}	```const $ = ['https://www.beliefnet.com', 'https://www.patheos.com', 'https://www.familytoday.com', 'http://local.beliefnet.com', 'http://local.patheos.com', 'http://local.familytoday.com']```
5447	familyshare.com.js	Cache Poisoning via Unvalidated Redirects	High	true	CWE-200	N/A	return new Response(c	standard	{The code uses Response() to create a new response from a cloned or blobified body, but does not validate whether the original response was redirected or malicious. The function H(e, t) copies redirected responses without checking if they are safe, potentially allowing an attacker to inject malicious content into the cache via a redirected response. This misuse of Response() with untrusted input leads to cache poisoning.}	```return new Response(c, i);```
5448	globaltvbc.com.js	High	High	true	CWE-444	N/A	loadModule	standard	{The function `loadModule` dynamically constructs and imports a script URL based on configuration parameters, including `modulePathPrefix` and `debug` flag. If these values are derived from untrusted or unsanitized input, an attacker could manipulate them to load arbitrary scripts, leading to remote code execution. The `importScripts` call within `loadModule` is inherently dangerous when used with dynamic URLs.}	```self.workbox.loadModule(t);```
5449	globaltvbc.com.js	Medium	Medium	false	CWE-79	N/A	N/A	N/A	{The `replace` function is used to substitute a placeholder in an HTML template with a predefined error message. Since the replacement value is hardcoded and not derived from user input, there is no risk of injection. The vulnerability is more related to improper error handling or template management rather than misuse of a sensitive function.}	```body = text.replace(/[<]!--WP_SERVICE_WORKER_ERROR_MESSAGE-->/, errorMessages.comment);```
5450	globaltvbc.com.js	Medium	Medium	false	CWE-20	N/A	N/A	N/A	{The `Request` constructor and `fetch` are used to forward a request with modified headers and mode. The input is derived from the event request, which is trusted within the service worker context. There is no evidence of unsanitized or untrusted input being passed to these functions, so this is not a sensitive function misuse.}	```const req = new Request(event.request, settings); event.respondWith(fetch(req));```
5451	cs2t.run.js	Hardcoded API Key Exposure	Medium	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded credentials (API key) in the code, not due to misuse of a sensitive JavaScript function. The code does not dynamically construct or pass untrusted input to any function that could lead to injection or execution risks.}	"```importScripts(""https://www.gstatic.com/firebasejs/9.2.0/firebase-app-compat.js"");importScripts(""https://www.gstatic.com/firebasejs/9.2.0/firebase-messaging-compat.js"");const firebaseConfig = {apiKey: ""AIzaSyB5Xh6ITwLWjnv_PFNn6e83__z5gRU-cNQ"",authDomain: ""csgorun-prod.firebaseapp.com"",projectId: ""csgorun-prod"",storageBucket: ""csgorun-prod.appspot.com"",messagingSenderId: ""860722030196"",appId: ""1:860722030196:web:9fc9060f35b6b67e7e5321"",measurementId: ""G-3M5CL91Q5K""};firebase.initializeApp(firebaseConfig);const messaging = firebase.messaging();messaging.onBackgroundMessage(function (payload) {});```"
5452	brickpicker.com.js	Incorrect logic for determining user login status using service worker URL	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from incorrect logic in parsing the `loggedIn` parameter from the service worker's URL, not from misuse of a sensitive function. The code uses `match()` on `location.href`, which is a standard string method, but the issue is logical (e.g., assuming `matches[1]` exists without validation). No sensitive function is involved.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
5453	brickpicker.com.js	Potential SSRF via unvalidated ID in push event	High	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a URL constructed from the `id` parameter received via push notification. Since `id` is unvalidated and directly interpolated into the URL, an attacker could supply a malicious ID to trigger requests to internal or external resources, leading to SSRF. The `fetch` function is standard and sensitive when used with untrusted input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5454	brickpicker.com.js	Improper handling of loggedIn variable leading to potential TypeError	Medium	false	N/A	N/A	N/A	N/A	{This issue stems from improper handling of the `loggedIn` variable, which may be undefined if the regex match fails. The problem is a logic flaw in variable assignment and usage, not misuse of a sensitive function. No sensitive function is involved.}	```if (loggedIn == 'false' && request.method === 'POST') { const curRequest = request.clone();```
5455	brickpicker.com.js	Insecure navigation to unvalidated notification URL	Medium	true	N/A	N/A	navigate	standard	{The `navigate` method is used with `data.url`, which is derived from server-provided notification data. Since this URL is not validated or sanitized, an attacker could craft a notification with a malicious URL, leading to phishing or redirection attacks. `navigate` is a standard service worker API and is sensitive when used with untrusted input.}	```clients[0].navigate(data.url);```
5456	brickpicker.com.js	CSRF token fetch with unvalidated path parameter	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is used with a URL constructed from the `path` parameter, which is derived from the request URL. Since `path` is unvalidated and directly interpolated, an attacker could manipulate it to trigger requests to unintended endpoints, potentially leading to CSRF or SSRF. `fetch` is a standard function and sensitive when used with untrusted input.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}````
5457	soulove.ai.js	Insecure Message Handling in handleCache	High	true	N/A	N/A	self.addEventListener	standard	{The use of self.addEventListener('message', ...) without validating or sanitizing the incoming message data allows an attacker to send arbitrary messages to the service worker. If the message data is processed without proper checks (e.g., for type, structure, or origin), it can lead to unintended behavior, such as triggering unwanted operations, leaking information, or even executing malicious logic if the message is used to dynamically construct or invoke functions. In this case, the message data is used to trigger cache operations and potentially open windows, which could be exploited if the data is not properly validated.}	"```self.addEventListener(""message"", e => { if (e.data && ""CACHE_URLS"" === e.data.type) { let { payload: t } = e.data; let a = Promise.all(t.urlsToCache.map(t => { let a; return a = ""string"" == typeof t ? new Request(t) : new Request(...t), this.handleRequest({ request: a, event: e }); })); e.waitUntil(a), e.ports?.[0] && a.then(() => e.ports[0].postMessage(!0)); } });```"
5458	graphicscomplete.com.js	Open Redirect Vulnerability	High	true	N/A	9	N/A	standard	{The vulnerability arises from the use of `caches.match()` with a dynamically constructed `Location` header value derived from `lastNavigationRequest`, which is assigned directly from `event.request.url`. Since `event.request.url` is user-controlled (via the navigation request), an attacker can manipulate the URL to redirect users to arbitrary domains. The `caches.match()` function itself is not inherently dangerous, but its misuse here in conjunction with untrusted input leads to an open redirect. The sensitive function responsible is `caches.match()` because it is used to serve a response based on a user-controlled URL, enabling redirection to malicious sites.}	```const navigationRoute = new NavigationRoute(async ({ event }) => { if (event.request.url.match(/\/.gatsby-plugin-offline:.+/)) { return handleAPIRequest({ event }); } if (!offlineShellEnabled) { return await fetch(event.request); } lastNavigationRequest = event.request.url; let { pathname } = new URL(event.request.url); pathname = pathname.replace(new RegExp(`^`), ``); const resources = await idbKeyval.get(`resources:${pathname}`); if (!resources || !(await caches.match(`/app-4d0e2e121ab1400ca3ed.js`))) { return await fetch(event.request); } for (const resource of resources) { if (!(await caches.match(resource))) { return await fetch(event.request); } } const offlineShell = `/offline-plugin-app-shell-fallback/index.html`; const offlineShellWithKey = workbox.precaching.getCacheKeyForURL(offlineShell); return await caches.match(offlineShellWithKey); });```
5459	graphicscomplete.com.js	Improper Input Validation in URL Parsing	Medium	true	N/A	8	N/A	standard	{The vulnerability stems from the use of `new URL(event.request.url)` and subsequent `pathname.match(/:(.+)/)[1]` to parse user-controlled input. The `new URL()` function is standard and safe, but when combined with unvalidated input and regex-based parsing, it can lead to improper handling of malformed or malicious URLs. The `params.split('&')` and `data[key] = val` assignment can result in unintended behavior or injection if the input is not sanitized. The sensitive function responsible is `new URL()` because it is used to parse untrusted input without validation, leading to potential misuse in downstream operations.}	```function handleAPIRequest({ event }) { const { pathname } = new URL(event.request.url); const params = pathname.match(/:(.+)/)[1]; const data = {}; if (params.includes(`=`)) { params.split(`&`).forEach(param => { const [key, val] = param.split(`=`); data[key] = val; }); } else { data.api = params; } if (MessageAPI[data.api] !== undefined) { MessageAPI[data.api](); } if (!data.redirect) { return new Response(); } return new Response(null, { status: 302, headers: { Location: lastNavigationRequest } }); }```
5460	mmm.dk.js	Open Redirect via Untrusted URL in Notification Click Handler	High	true	CWE-602	10	clients.openWindow	standard	{The function clients.openWindow() is used to open a URL in a new window or tab. The URL is derived from event.notification.data.url, which originates from untrusted push notification data. Since this data is parsed from event.data.text() without validation or sanitization, an attacker can craft a push notification with a malicious URL (e.g., a phishing site or redirect to an attacker-controlled domain), leading to an open redirect vulnerability. This allows the attacker to trick users into visiting unintended or malicious websites.}	```clients.openWindow(event.notification.data.url);```
5461	myfreescorenow.com.js	XSS via Untrusted Payload in Notification Options	Medium	true	CWE-79	8	showNotification	standard	{The showNotification function is a standard browser API used to display notifications. When it receives untrusted data (such as payload.notification.title or payload.notification.body) without sanitization, it can lead to XSS if the notification content is rendered in a context where script execution is possible (e.g., via rich text or HTML injection in some browsers). Although modern browsers typically sanitize notification content, relying on this behavior is unsafe and constitutes a misuse of the function with untrusted input.}	```const notificationTitle = payload.notification.title; const notificationOptions = { body: payload.notification.body, icon: payload.notification.image }; self.registration.showNotification(notificationTitle, notificationOptions);```
5462	healthplans.com.js	Unrestricted Import of Code from Untrusted Source	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., api.pushnami.com), it introduces a high-risk vulnerability because the script being imported is not under the control of the application owner. If the remote script is compromised or malicious, it can execute arbitrary code within the service worker context, leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the source is external and untrusted, making this a sensitive function misuse.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5b7b236ea6ba1472f36cd62a"");```"
5463	1emulation.com.js	Vulnerable Data Handling in Push Event Leading to SSRF	High	true	CWE-829	9	fetch	standard	{The fetch function is used with a dynamically constructed URL that includes the `id` parameter from the push event data. If this `id` is not validated or sanitized, an attacker could supply a malicious URL (e.g., internal network resources) leading to Server-Side Request Forgery (SSRF). The URL is built using string interpolation, making it vulnerable to injection.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5464	1emulation.com.js	Insecure Notification URL Handling Leading to Phishing	Medium	true	CWE-601	9	clients[0].navigate	standard	{The navigate method is called with a URL derived from the notification data (`data.url`), which is user-controlled via push notifications. If an attacker can manipulate this data, they can redirect users to phishing sites, leading to credential theft or malicious actions. The URL is not validated or sanitized before use.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
5465	1emulation.com.js	Improper CSRF Token Handling	Medium	true	CWE-352	8	fetch	standard	{The fetch function is used to retrieve a CSRF token based on a dynamically constructed URL that includes the `path` parameter from the request. If the `path` is not properly sanitized, an attacker could inject malicious paths or trigger unintended requests, potentially leading to CSRF attacks if the token is misused or leaked.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5466	1emulation.com.js	Insecure Notification Body Rendering	Medium	false	CWE-79	0	N/A	N/A	{The notification body is static and hardcoded as DEFAULT_NOTIFICATION_BODY. There is no dynamic input or user-controlled data being rendered here, so no sensitive function misuse is involved.}	```body: DEFAULT_NOTIFICATION_BODY```
5467	sweetandsavourypursuits.com.js	Improper Cache Key Validation	High	true	N/A	N/A	importScripts	standard	{The code uses importScripts() with dynamic URLs derived from user-controlled inputs (e.g., via location.search or URL parameters), which can lead to arbitrary script execution if an attacker can manipulate the URL to point to a malicious script. This is a classic case of improper cache key validation where the cache key is not properly sanitized or validated before being used in a sensitive function.}	N/A
5468	"self.importScripts(host + ""/sw_fn.js"");"	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A	N/A
5469	sweetandsavourypursuits.com.js	Insecure Cache Busting	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper handling of cache keys and revisions, but it does not involve misuse of a sensitive JavaScript function. The issue is more related to logic flaws in cache key generation rather than direct function misuse.}	```const { cacheName: e```
5470	sweetandsavourypursuits.com.js	Insufficient Path Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from insufficient validation of URLs against a whitelist, but it does not involve misuse of a sensitive JavaScript function. The code checks for siteHostname and ignores certain paths, but the logic is flawed and does not involve dangerous functions like eval, importScripts, or dynamic code execution.}	```if (!!t.includes(siteHostname) && new URL(t).hostname === siteHostname);```
5471	luckyfuy.top.js	Regular Expression Denial of Service (ReDoS)	High	true	CWE-1333	10	toolbox.router.any	standard	{The vulnerability arises from the use of a regular expression with a potentially catastrophic backtracking pattern: /.*\.(js|css|jpg|jpeg|png|gif)$/. The .* quantifier combined with the alternation (js|css|jpg|jpeg|png|gif) can lead to exponential time complexity when matching long strings, especially if the input is crafted to trigger worst-case performance. This is a classic ReDoS vulnerability. The sensitive function responsible is `toolbox.router.any`, which is a custom routing function that accepts a RegExp as an argument and uses it to match incoming requests. Since the RegExp is hardcoded in the script, it is not directly user-controlled, but the pattern itself is inherently unsafe and can be exploited by an attacker sending a maliciously crafted URL that triggers the ReDoS.}	```toolbox.router.any(/.*\.(js|css|jpg|jpeg|png|gif)$/, toolbox.cacheFirst);```
5472	blinkies.cafe.js	Caching of Non-GET Requests	High	false	New	N/A	N/A	N/A	{The vulnerability arises from caching responses without validating the request method. While the code uses `caches.match` and `caches.open`, these are not misused in a way that introduces sensitive function misuse. The issue is a logic flaw in caching policy, not improper use of a sensitive function.}	```return e || (e = await fetch(r.request), (await caches.open(cacheName)).put(r.request, e.clone()), e);```
5473	blinkies.cafe.js	Lack of Error Handling in Fetch	Medium	false	CWE-703	N/A	N/A	N/A	{The vulnerability stems from the absence of error handling around the `fetch` call, which could lead to unhandled exceptions. However, this is not due to misuse of a sensitive function, but rather a lack of robustness in error management.}	```return e || (e = await fetch(r.request), (await caches.open(cacheName)).put(r.request, e.clone()), e);```
5474	parmin.cloud.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. In this case, the URL is hardcoded and does not involve dynamic or user-controlled input. However, since the script is loaded from an external domain (van.najva.com), it introduces a risk if the domain is compromised or if the script is not properly vetted. While the input is not dynamic, the use of importScripts() with an external URL still constitutes a sensitive function misuse due to the potential for remote code execution if the remote script is malicious.}	```importScripts('https://van.najva.com/static/js/scripts/parmin543-website-34931-ee399ab9-b224-4a34-81e7-42c815cb6419-service-worker.js');```
5475	exodusrevealed.com.js	External Script Inclusion with Dynamic Query String	High	true	CWE-829	10	importScripts	standard	{The importScripts() function is used to dynamically load and execute a script from a URL constructed by concatenating a base URL with self.location.search, which is user-controlled. This allows an attacker to manipulate the query string to inject arbitrary scripts, leading to remote code execution within the service worker context.}	```importScripts('https://cdn.pushwoosh.com/webpush/v3/pushwoosh-service-worker.js' + self.location.search);```
5476	typography.guru.js	Improper Authentication Check Leading to CSRF Vulnerability	High	false	N/A	0	N/A	N/A	{The vulnerability arises from improper authentication checking via a URL parameter (loggedIn=true/false) rather than a secure session or token-based mechanism. This is not caused by misuse of a sensitive JavaScript function, but by flawed logic in authentication handling.}	```const loggedIn = matches[1]; if (loggedIn == 'true') { log('Logged in, nothing to do...'); return; }```
5477	riemannfamily.com.js	Cache Poisoning via Broad Regex Matching	High	true	CWE-918	9	workbox.routing.registerRoute	standard	"{The use of a broad regex pattern /.*?irp\\.cdn-website\\.com.*?/ in workbox.routing.registerRoute allows any URL containing the substring ""irp.cdn-website.com"" to be matched, regardless of context. This can lead to unintended cache poisoning if an attacker can craft a request that matches this pattern and is served from cache, potentially bypassing security controls or serving stale or malicious content. The sensitive function workbox.routing.registerRoute is misused by providing a regex that is too permissive, enabling cache manipulation.}"	```workbox.routing.registerRoute(/.*?irp\\.cdn-website\\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
5478	riemannfamily.com.js	No-CORS Fetch Leading to Data Exposure	Medium	true	CWE-434	8	fetch	standard	{The fetch function is used with mode: 'no-cors', which prevents the browser from enforcing CORS checks. This allows the service worker to make requests to third-party origins without proper origin validation, potentially exposing sensitive data or enabling cross-origin data leakage if the response is processed or logged. The misuse occurs because fetch is called with a mode that bypasses security restrictions, enabling unintended data exposure.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
5479	riemannfamily.com.js	Insecure Blacklist for Sensitive URLs	Medium	false	CWE-20	5	N/A	N/A	{The vulnerability arises from a flawed blacklist approach for URLs that should not be cached, but it is not caused by misuse of a sensitive JavaScript function. The logic is implemented in plain JavaScript without invoking any inherently dangerous functions. The issue is a design flaw in security policy, not a function misuse.}	```const PAGES_CACHE_BLACKLIST = ['/rts/auth/authorize', '/rts/auth/code', '/rts/auth/redirect'];```
5480	riemannfamily.com.js	Debug Logs Exposing Sensitive Information	Low	false	CWE-200	3	N/A	N/A	{The vulnerability stems from logging sensitive information via console.log, but this is not due to misuse of a sensitive function. The console.log function is used in a standard way; the issue is the decision to log debug data, not the function itself.}	```if (pwaSettings.debug) { console.log('RTSW:', ...args); }```
5481	riemannfamily.com.js	Unauthenticated Cache Deletion via Message Command	Medium	false	CWE-426	4	N/A	N/A	{The vulnerability is due to allowing cache deletion via a message command without authentication or authorization checks. This is a logic flaw in the service worker’s message handling, not a misuse of a sensitive JavaScript function. The event.ports[0].postMessage call is used correctly; the issue lies in the lack of security controls around the command.}	```event.ports[0].postMessage({ success, cacheName: SITE_PAGES_CACHE_NAME });```
5482	booksandbao.com.js	Insecure Caching of Third-Party Resources	High	true	CWE-921	9	N/A	standard	{The vulnerability arises from the use of the `j` function (a custom routing registration function from Workbox) to register routes for third-party resources (e.g., googleapis.com, gstatic.com) with a `M` strategy that caches responses based on status codes [0, 200]. While `j` itself is not inherently sensitive, its misuse here involves registering routes for external domains without proper validation or sanitization, allowing potentially untrusted third-party resources to be cached and served. This can lead to cache poisoning or delivery of malicious content if the third-party domains are compromised. The `M` strategy, which uses `fetchAndCachePut`, is a standard Workbox strategy that caches responses without sufficient safeguards for external domains.}	```j(/.*(?:googleapis|gstatic)\.com/, new M({ plugins: [new Q({ statuses: [0, 200] })] }))```
5483	gin-rummy-online.com.js	Cache Poisoning Due to Lack of Content Hash Validation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from the lack of content hash validation during cache population, but it is not caused by misuse of a sensitive JavaScript function. The `fetchAndCache` function correctly fetches and caches resources, but the issue lies in the absence of verifying that the fetched content matches the expected hash. This is a logic flaw, not a sensitive function misuse.}	```const fetchAndCache = (cacheKey, cache) => fetch(cacheKey).then(response => { if (!response.ok) { throw new Error(`Error downloading ${cacheKey}`); } cache.put(cacheKey, response.clone()); return response; });```
5484	starvegas.es.js	Insecure URL Handling in Notification Click	Medium	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow(url) is used to open a URL provided by the push notification data, which is derived from untrusted external input. Since the URL is not validated or sanitized, an attacker could craft a malicious push notification containing a URL that redirects to a phishing site, executes malicious scripts, or performs other harmful actions. This constitutes a client-side redirect or open redirect vulnerability.}	```if (url && clients.openWindow) { clients.openWindow(url).then(function () { resolve(); }).catch(function (err) { reject(err); }); }```
5485	starvegas.es.js	Lack of Input Validation for Push Data	Medium	true	CWE-703	8	registration.showNotification	standard	{The function registration.showNotification is called with data directly from the push payload (e.g., data.title, data.alert, data.icon, etc.). Since this data is not validated or sanitized, an attacker could inject malicious content such as XSS payloads in the notification title or body, or manipulate the icon/image URLs to load malicious resources. This can lead to cross-site scripting or phishing attacks if users interact with the notification.}	```self.registration.showNotification(data.title, { body: data.alert, icon: data.icon, image: data.image, tag: data.id, data: data, requireInteraction: data[\'require-interaction\'] ? true : false, actions: data.actions })```
5486	debian-fr.org.js	Open Redirect via Notification Click	High	true	CWE-601	9	clients.openWindow	standard	{The function clients.openWindow is used to open a URL constructed from notification data (e.g., t.notification.data.url and t.notification.data.baseUrl). Since this data originates from a push notification (which can be controlled by an attacker), an attacker can craft a notification with a malicious URL, leading to an open redirect. The URL is not validated or sanitized, allowing arbitrary navigation to external sites.}	"```self.addEventListener(""notificationclick"", function (t) { t.notification.close(); var e = t.notification.data.url, i = t.notification.data.baseUrl; t.waitUntil(clients.matchAll({ type: ""window"" }).then(function (t) { if (!t.some(function (t) { return t.url === i + e && ""focus"" in t ? (t.focus(), !0) : ""postMessage"" in t && ""focus"" in t && (t.focus(), t.postMessage({ url: e }), !0); }) && clients.openWindow) return clients.openWindow(i + e); })); })```"
5487	debian-fr.org.js	CSRF in Push Subscription Management	Medium	true	CWE-352	8	fetch	standard	{The fetch function is used to send POST requests to subscription endpoints without including any CSRF tokens or origin validation. The requests are constructed using data from the pushsubscriptionchange event, which is controlled by the browser but can be exploited if the user is authenticated. An attacker could trick the user into triggering this event via a malicious site, leading to unauthorized subscription or unsubscription actions.}	"```self.addEventListener(""pushsubscriptionchange"", function (t) { t.waitUntil(Promise.all(fetch(""https://www.debian-fr.org/push_notifications/subscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": t.newSubscription.endpoint, ""subscription[keys][auth]"": t.newSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": t.newSubscription.toJSON().keys.p256dh, send_confirmation: !1 }) }), fetch(""https://www.debian-fr.org/push_notifications/unsubscribe"", { method: ""POST"", headers: { ""Content-Type"": ""application/x-www-form-urlencoded; charset=UTF-8"" }, body: new URLSearchParams({ ""subscription[endpoint]"": t.oldSubscription.endpoint, ""subscription[keys][auth]"": t.oldSubscription.toJSON().keys.auth, ""subscription[keys][p256dh]"": t.oldSubscription.toJSON().keys.p256dh }) }))); });```"
5488	opwaarderen.nl.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	N/A	"```var XPConfig = { ""appKey"": ""eo82bnifSGaOcqQJCLOkZuAgbz--kZuQ"", ""backendUrl"": ""https:\/\/api-alphacomm.xtremepush.com"" };```"
5489	opwaarderen.nl.js	Open Redirect via Unvalidated URL	High	true	N/A	N/A	clients.openWindow	standard	{The function clients.openWindow is used to open a URL that is derived from user-controlled data (notification.url or notification.actions[b].url). Since these URLs are not validated or sanitized, an attacker can craft a malicious notification payload that redirects users to arbitrary websites, leading to open redirect vulnerabilities.}	```if (url && clients.openWindow) { clients.openWindow(url).then(function () { resolve(); }).catch(function (err) { reject(err); }); } else { resolve(); }```
5490	dance-enthusiast.com.js	Caching Sensitive Data Without Cache-Control Validation	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from caching responses without validating the Cache-Control headers, which could lead to sensitive data being cached inappropriately. However, this is not due to misuse of a sensitive JavaScript function like importScripts or eval, but rather a logic or policy flaw in cache management.}	```caches.open(version + 'pages').then(function add(cache) { cache.put(event.request, cacheCopy); }).then(function () {};```
5491	thealphacentauri.net.js	Open Redirect via Notification Data	High	true	CWE-601	9	clients.openWindow	standard	{The clients.openWindow() function is used to open a new window or tab with a URL derived from event.notification.data.url, which is sourced from untrusted push message data. Since this URL is not validated or sanitized, an attacker can craft a push message with a malicious URL, leading to an open redirect that may trick users into visiting phishing sites or malicious domains.}	N/A
5492	thealphacentauri.net.js	Improper Input Validation in Push Message Handling	Medium	true	CWE-20	8	JSON.parse	standard	{The JSON.parse(data.body) function is used to parse untrusted data received from a push message. Without proper validation or sanitization of the parsed data, this can lead to unintended behavior, such as injection of malicious payloads or execution of unintended logic, especially when the parsed data is later used to construct notifications or other dynamic content.}	N/A
5493	harrylatino.org.js	Improper Neutralization of Server-Side Input for Web Page (SSRF/RCE	High	true	CWE-918	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the 'id' parameter from untrusted push notification data. Since 'id' is not validated or sanitized, an attacker can craft a malicious ID to trigger SSRF or potentially RCE if the backend processes the ID in an unsafe manner.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5494	harrylatino.org.js	Improper Access Control (Insecure URL Parameter	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from insecure handling of the 'loggedIn' parameter in the URL, but it is not caused by misuse of a sensitive JavaScript function. The issue is in logic and parameter validation, not in a function call.}	```let matches = e.currentTarget.location.href.match(/loggedIn=(true|false)/); const loggedIn = matches[1];```
5495	harrylatino.org.js	CSRF Token Handling Without Validation	Medium	true	CWE-352	8	N/A	standard	{The fetch() function is used to retrieve a CSRF token based on a dynamically constructed URL using the 'path' parameter from the intercepted request. Since the 'path' is derived from user input without validation, an attacker could manipulate it to fetch tokens for unintended endpoints, leading to CSRF vulnerabilities.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`).then(response => response.json()).then(response => { const headers = new Headers(curRequest.headers); headers.set('X-Csrf-Token', response.key);```
5496	harrylatino.org.js	Open Redirect via Notification Data	Medium	true	CWE-601	9	N/A	standard	{The navigate() method is used with the 'url' value from notification data, which is derived from untrusted server responses. Since this value is not validated or sanitized, an attacker can inject a malicious URL to redirect users to phishing or malicious sites.}	```clients[0].navigate(data.url);```
5497	harrylatino.org.js	XSS via Unvalidated Notification Data	Low	true	CWE-79	7	N/A	standard	{The showNotification() method is used with 'title', 'body', and 'icon' values derived from untrusted server responses. Since these values are not sanitized, an attacker could inject malicious content that may be rendered in the notification UI, potentially leading to XSS if the browser or platform interprets the content as executable.}	```self.registration.showNotification(title, { body, icon: icon ? icon : NOTIFICATION_ICON, image: image ? image : null, data: { url } });```
5498	rentownclub.com.js	Unrestricted External Script Import	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded external URL, it introduces a risk if the script source is not trusted or if the script can be tampered with. Although the URL is hardcoded here, the vulnerability is still considered sensitive because it allows execution of arbitrary code from an external source, which could be compromised or malicious. This constitutes a high-risk scenario as it enables remote code execution within the service worker context.}	"```importScripts(""https://api.pushnami.com/scripts/v2/pushnami-sw/5b4e770e85ddfc00103751f6"");```"
5499	59hardware.net.js	Unrestricted Import of Code from Untrusted Source	High	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL from an untrusted source (e.g., cdn.pushmaster-cdn.xyz), it introduces a high-risk vulnerability because the script being imported is not under the control of the site owner. An attacker could compromise the external CDN or inject malicious code into the script, leading to arbitrary code execution within the service worker context, which can result in data exfiltration, cache manipulation, or man-in-the-middle attacks.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6331bf6ef37fe50009daf410/service-worker.js"");```"
5500	automated-testing.info.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The vulnerability arises from the use of `clients.openWindow(n + t)` where `n` and `t` are derived from notification data, which can be controlled by an attacker. Since `n` is the `baseUrl` and `t` is the `url` from the notification payload, an attacker can craft a malicious notification that redirects the user to an arbitrary external URL. This is a classic open redirect vulnerability caused by the unsafe use of `clients.openWindow`, a standard browser API, with untrusted input.}	```self.addEventListener('notificationclick', function (e) { e.notification.close(); var t = e.notification.data.url, n = e.notification.data.baseUrl; if (!e.some(function (e) { return e.url === n + t && 'focus' in e ? (e.focus(), !0) : 'postMessage' in e && 'focus' in e && (e.focus(), e.postMessage({ url: t }), !0); }) && clients.openWindow) return clients.openWindow(n + t); });```
5501	indies-av.co.jp.js	External Code Loading	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is used to load and execute an external script from a remote URL. In this case, the URL is hardcoded to a specific path on the domain 'www.indies-av.co.jp', but the vulnerability arises because the script is loaded from an external source without any integrity checks or validation. If the remote script is compromised or modified, it can execute arbitrary code within the service worker context, leading to potential cache manipulation, network interception, or other malicious behaviors. This constitutes a high-risk vulnerability due to the trust placed in the external script.}	```importScripts('https://www.indies-av.co.jp/wp-content/plugins/onesignal-free-web-push-notifications/sdk_files/OneSignalSDKWorker.js.php');```
5502	moominarabia.com.js	Unintended Network Request Exposure	Medium	false	CWE-200	N/A	N/A	N/A	"{The vulnerability arises from the use of dynamic URL patterns in runtime caching, but not from misuse of a sensitive function like importScripts or eval. The code constructs RegExp patterns from static strings (e.g., ""/_nuxt/"") and does not dynamically inject untrusted input into network requests or routing logic. Thus, no sensitive function misuse is involved.}"	```const strategyOptions = { ...entry.strategyOptions, plugins };```
5503	moominarabia.com.js	Information Exposure Through Error Logging	Low	false	CWE-200	N/A	N/A	N/A	{The vulnerability stems from logging error details to the console, which may expose sensitive information during debugging. However, this is not due to misuse of a sensitive function such as eval or importScripts, but rather a logging practice. No dynamic or untrusted input is processed by a sensitive function.}	```console.error(ctx.error, 'Details:', ctx);```
5504	thebridgechronicle.com.js	Loading untrusted external script in Service Worker	High	true	CWE-444	10	importScripts	standard	{The importScripts() function in Service Workers loads and executes a script from a specified URL. When used with a hardcoded external URL (e.g., from a third-party CDN), it introduces a risk if the script source is untrusted or compromised, as it can lead to arbitrary code execution within the service worker context, potentially enabling cache manipulation, network interception, or data exfiltration.}	"```self.skipWaiting();var izCacheVer = ""1"";importScripts(""https://cdn.izooto.com/scripts/workers/6381f928ca6fa021a3fdfce1cb0999fd4ab407a6.js"");```"
5505	familytravelmagazine.com.js	Improper Cache Key Validation	High	true	N/A	N/A	caches.open	standard	{The function caches.open is used to open a cache with a dynamically generated cache name derived from the version variable. While the cache name is not directly user-controlled, the version variable is hardcoded and used in multiple places to construct cache keys and URLs. The vulnerability arises because the cache key generation logic in the v function does not validate or sanitize the revision parameter, which could be manipulated if the input source (e.g., from a configuration or external input) is not properly controlled. This could allow an attacker to inject arbitrary cache keys, leading to cache poisoning or bypassing cache validation. The misuse of caches.open with potentially untrusted cache names contributes to improper cache key validation, enabling unauthorized cache access or manipulation.}	```const { cacheKey: e, url: t } = v(s), i = 'string' != typeof s && s.revision ? 'reload' : 'default';```
5506	fortunefrenzy.co.uk.js	Improper Input Validation	High	true	N/A	N/A	storage.getItem	standard	{The storage.getItem function is used to retrieve 'resources' from localForage, which is a persistent storage mechanism. If the data retrieved is not properly validated or sanitized before being processed by computeUpdateOrder, it could lead to unintended behavior or injection, especially if the data is user-controlled or comes from an untrusted source. The function is misused by assuming the retrieved data is safe without validation.}	```if (updateIsNeeded) { return this.storage.getItem('resources').then(currents => this.computeUpdateOrder(currents || {}, this.resources)).then(order => this.doOrder(order)).then(() => this.storage.setItem('resources', this.resources)).then(() => this.storage.setItem('version', this.version)); }```
5507	fortunefrenzy.co.uk.js	Insecure Data Storage	Medium	false	N/A	N/A	N/A	N/A	{The use of a hardcoded private name and cache prefix does not involve misuse of a sensitive function. The issue lies in the lack of encryption or protection for stored data, which is a design flaw rather than a function misuse.}	```var PRIVATE_NAME = '__wp-offline-content'; var CACHE_PREFIX = PRIVATE_NAME + '::';```
5508	fortunefrenzy.co.uk.js	Race Condition	Medium	false	N/A	N/A	N/A	N/A	{The race condition arises from the parallel execution of multiple Promise.all operations, which is a concurrency issue, not a misuse of a sensitive function. The functions used (e.g., _deleteFromCache, _cacheFromNetwork) are not inherently sensitive in this context.}	```return Promise.all([this._deleteFromCache(order.remove), this._deleteFromCache(order.update).then(() => this._cacheFromNetwork(order.update)), this._cacheFromNetwork(order.addnew)]);```
5509	fortunefrenzy.co.uk.js	Insecure Direct Object Reference	Low	false	N/A	N/A	N/A	N/A	{The vulnerability stems from a logic flaw in the isExcluded function, where the URL is checked against hardcoded paths without proper validation. This is not due to misuse of a sensitive function but rather a flawed access control check.}	```if (url.startsWith(this.origin) && this.excludedPaths.some(path => url.startsWith(path))) { return true; }```
5510	fortunefrenzy.co.uk.js	Insecure Cryptographic Storage	Low	false	N/A	N/A	N/A	N/A	{The storage.setItem function is used to store a timestamp, but the issue is the lack of encryption for sensitive data, not misuse of the function itself. The function is used correctly; the vulnerability is in the data handling policy.}	```this.storage.setItem('lastCheck', value).then(function () { this._lastCheck = Promise.resolve(value); }.bind(this));```
5511	platools.com.js	Hardcoded API Key Exposure	High	false	N/A	N/A	N/A	N/A	{The vulnerability is due to the hardcoded exposure of the INNERTUBE_API_KEY in the ytcfg configuration object. This is not caused by misuse of a sensitive JavaScript function, but rather by direct exposure of a secret in the source code.}	"```ytcfg.set({ ""INNERTUBE_API_KEY"": ""AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8"", ... });```"
5512	petleo.app.js	Hardcoded API Key Exposure	High	false	N/A	0	N/A	N/A	{The vulnerability is due to hardcoded API keys in the code, not misuse of a sensitive JavaScript function. The function firebase.initializeApp() is used correctly with static configuration values, and no dynamic or untrusted input is passed to it. Therefore, this is not a case of sensitive function misuse.}	"```importScripts(""https://www.gstatic.com/firebasejs/7.15.5/firebase-app.js"");importScripts(""https://www.gstatic.com/firebasejs/7.15.5/firebase-messaging.js"");firebase.initializeApp({apiKey: ""AIzaSyDz-XSOuUeBo5fhQybX78tvVv-MfwUZILc"",authDomain: ""petleo-compose.firebaseapp.com"",databaseURL: ""https://petleo-compose.firebaseio.com"",projectId: ""petleo-compose"",storageBucket: ""petleo-compose.appspot.com"",messagingSenderId: ""151458785896"",appId: ""1:151458785896:web:97f98bfb7d1d3c592629dd"",measurementId: ""G-M9N59S0BLD""});const messaging = firebase.messaging();messaging.setBackgroundMessageHandler(function (payload) {const promiseChain = clients.matchAll({type: ""window"",includeUncontrolled: true}).then(windowClients => {for (let i = 0; i < windowClients.length; i++) {const windowClient = windowClients[i];windowClient.postMessage(payload);}}).then(() => {return registration.showNotification(""New Message"");});return promiseChain;});self.addEventListener('notificationclick', function (event) {console.log('notification received: ', event);});```"
5513	bradfordokeefe.com.js	Server Side Request Forgery (SSRF)	High	true	CWE-918	9	addParams	custom	{The function `addParams` is used to construct a URL (`pageKeyUrl`) by appending query parameters to a base URL (`baseKeyUrl`). Since `pageUri` is derived from `getPathName(pageUrl)` and `pageUrl` is user-controlled (via the `fetchPageKey` function), an attacker can manipulate `pageUrl` to inject arbitrary paths or domains. The `addParams` function does not validate or sanitize the input, allowing the constructed URL to point to internal or external resources, leading to SSRF. The `addParams` function is custom and dynamically constructs URLs based on untrusted input.}	N/A
5514	bradfordokeefe.com.js	URL Encoding Bypass in Blacklist	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from a logic flaw in the blacklist check (`PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl))`), which uses simple string inclusion. This does not account for URL encoding or case variations, allowing bypasses. However, no sensitive JavaScript function is misused here; the issue is purely in the logic of the blacklist implementation.}	N/A
5515	bradfordokeefe.com.js	Information Exposure Through Debug Logs	Low	false	N/A	0	N/A	N/A	{The vulnerability stems from debug logs being enabled (`pwaSettings.debug = true`) and logged via `console.log`, which may expose sensitive information during development. However, this is not caused by misuse of a sensitive function like `importScripts` or `eval`, but rather by configuration and logging practices.}	N/A
5516	bradfordokeefe.com.js	Improper Input Validation in Regex	Medium	false	N/A	0	N/A	N/A	{The regex `/.*?irp\.cdn-website\.com.*?/` is overly permissive and may match unintended URLs due to lack of anchoring or specific path constraints. However, this is a regex design flaw, not misuse of a sensitive JavaScript function. The `workbox.routing.registerRoute` function is used correctly; the issue lies in the pattern definition, not in the function's misuse.}	N/A
5517	scrufa4.com.js	Incorrect URL Exclusion Logic	High	true	CWE-352	10	N/A	standard	{The vulnerability arises from the misuse of the Array.prototype.every() method in conjunction with a custom checkNeverCacheList function. The logic incorrectly returns true if none of the regex patterns match, meaning requests matching any of the excluded patterns are still processed and cached. This is due to improper use of the every() function, which expects all elements to satisfy the condition to return true, but here it's used to check if any pattern matches, leading to flawed exclusion logic.}	```if (!neverCacheUrls.every(checkNeverCacheList, e.request.url)) {```
5518	scrufa4.com.js	Improper Range Header Handling	Medium	false	CWE-754	0	N/A	standard	{The vulnerability stems from the direct parsing of the 'range' header using a regex without validating or sanitizing the input. However, this is not caused by misuse of a sensitive function like importScripts or eval, but rather by flawed logic in handling the header. The function used (Number, exec) are standard and not inherently sensitive in this context.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
5519	scrufa4.com.js	Caching of Non-GET Requests	High	false	CWE-921	0	N/A	standard	{The vulnerability is due to the service worker caching responses for non-GET requests, which is a policy issue rather than misuse of a sensitive function. The fetch() and caches.match() functions are used correctly; the issue lies in the logic that allows caching of non-GET requests, not in the functions themselves.}	```e.respondWith(fetch(e.request).catch(function () { return caches.match(offlinePage); }));```
5520	scrufa4.com.js	Potential Cache Poisoning	Medium	false	CWE-918	0	N/A	standard	{The vulnerability arises from the use of new URL(e.request.url).origin to check origin, which is a standard and safe operation. The issue is that the check may not be sufficient to prevent cache poisoning if the origin is manipulated via URL rewriting or other means, but this is not due to misuse of a sensitive function.}	```if (new URL(e.request.url).origin !== location.origin) return;```
5521	twestival.com.js	Insecure Resource Loading (External CDN without Integrity Check	Medium	true	CWE-434	9	importScripts	standard	{The importScripts() function is used to load and execute a remote script from 'https://cdn.p-n.io/pushly-sw.min.js?domain_key=qmhdz0KFKfsfhQQeCP5Js1NFta1P8jkwbf05'. Since the script is loaded from an external CDN without integrity verification, it introduces a risk of supply chain attacks if the CDN is compromised or if the script is tampered with. The function is standard and inherently sensitive when used with untrusted URLs, as it executes arbitrary code in the context of the service worker.}	"```importScripts(""https://cdn.p-n.io/pushly-sw.min.js?domain_key=qmhdz0KFKfsfhQQeCP5Js1NFta1P8jkwbf05"");```"
5522	kongreuzmani.com.js	Unrestricted Cache Deletion via Message Command	High	true	CWE-285	10	N/A	standard	{The vulnerability arises from the use of `self.addEventListener('message', ...)` to handle incoming messages from clients. While the event listener itself is not inherently dangerous, the issue lies in the lack of authentication or authorization checks on the `event.data.command` value. The `deleteAllCaches()` function is invoked without verifying the origin or identity of the sender, allowing any client (including malicious ones) to trigger cache deletion. This misuse of the standard `self.addEventListener` API in conjunction with untrusted message data leads to unrestricted cache deletion, which can be exploited to disrupt service worker functionality.}	```self.addEventListener('message', function (event) { if (event.data.command === 'delete_all') { console.log('About to delete all caches...'); deleteAllCaches().then(function () { console.log('Caches deleted.'); event.ports[0].postMessage({ error: null }); }).catch(function (error) { console.log('Caches not deleted:', error); event.ports[0].postMessage({ error: error }); }); } });```
5523	systemkamera-forum.de.js	Server Side Request Forgery (SSRF) via unvalidated 'id' parameter in push event	Medium	true	CWE-918	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the 'id' parameter from untrusted push notification data. Since the 'id' value is not validated or sanitized, an attacker can manipulate it to trigger requests to internal or external endpoints, leading to SSRF.}	```const promiseChain = fetch(`${BASE_URL}index.php?app=core&module=system&controller=notifications&do=fetchNotification&id=${id}`, { method: 'POST', credentials: 'include' })```
5524	systemkamera-forum.de.js	Cross-Site Request Forgery (CSRF) via unvalidated path in CSRF token fetch	High	true	CWE-352	9	N/A	standard	{The fetch() function is used with a dynamically constructed URL that includes the 'path' parameter derived from the request URL. Since this path is not validated, an attacker can inject malicious paths to forge requests, leading to CSRF attacks.}	```fetch(`${BASE_URL}index.php?app=core&module=system&controller=ajax&do=getCsrfKey&path=${path}`)```
5525	systemkamera-forum.de.js	Open Redirect via unvalidated notification URL in notificationclick handler	Medium	true	CWE-601	8	N/A	standard	{The navigate() method is used with a URL derived from the notification data, which is not validated. An attacker can craft a notification with a malicious URL, causing users to be redirected to arbitrary sites, leading to open redirect vulnerabilities.}	```clients[0].navigate(data.url ? data.url : BASE_URL)```
5526	affision.com.js	Improper Neutralization of Input in Error Pages Leading to XSS	High	true	CWE-79	N/A	N/A	standard	{The code constructs an iframe with `src` and `srcdoc` attributes using untrusted input (`responseBody`) without proper sanitization. The `btoa()` function is used to encode the response body, but the resulting `srcdoc` is directly embedded in HTML, allowing an attacker to inject arbitrary HTML or JavaScript if the response body contains malicious content. This leads to XSS when the error page is rendered.}	"```const iframe = `<iframe style=""width:100%"" src=""${src}""  srcdoc=""${srcdoc}""></iframe>`;```"
5527	affision.com.js	Exposure of Sensitive Information in Cache Keys	Medium	false	N/A	N/A	N/A	N/A	{The cache keys contain sensitive information such as revision hashes and configuration details, but this is not due to misuse of a sensitive function. The data is hardcoded and not dynamically derived from untrusted input.}	```wp.serviceWorker.precaching.precache([{\'url\': \'https:\\/\\/affision.com\\/\\?wp_error_template=offline\',\'revision\': \'0.8.1;Avada=7.8.2;options=49a3f8eddfdce36c593073a32d782026;nav=209cb41d12440603fd125cb683a3ad82;deps=b7b30286663545aee1aec56892af1528;7855369c407c835a19f2f352834273ec\'}, {\'url\': \'https:\\/\\/affision.com\\/\\?wp_error_template=500\',\'revision\': \'0.8.1;Avada=7.8.2;options=49a3f8eddfdce36c593073a32d782026;nav=209cb41d12440603fd125cb683a3ad82;deps=b7b30286663545aee1aec56892af1528;c322bd4675e69abb55f107efcda13975\'}]);```
5528	affision.com.js	Insecure iframe Embedding in Error Handling	High	true	CWE-75	N/A	N/A	standard	{The code dynamically generates an iframe with `src` and `data-srcdoc` attributes using untrusted input (`responseBody`) without sanitization. The `btoa()` function encodes the response body, but the `srcdoc` attribute is directly embedded in HTML, allowing an attacker to inject arbitrary HTML or JavaScript if the response body contains malicious content. This leads to XSS when the error page is rendered.}	"```const iframe = `<iframe style=""width:100%"" src=""${src}"" data-srcdoc=""${srcdoc}""></iframe>`;```"
5529	fruitcocktailplayslots.ru.js	Improper Input Validation (Cached Offline Page	Medium	false	N/A	N/A	N/A	N/A	{The code creates a Request object for a hardcoded 'offline.html' file, which is not dynamically derived from user input or untrusted sources. There is no misuse of a sensitive function here, as the URL is static and controlled.}	```const offlinePage = new Request('offline.html');```
5530	fruitcocktailplayslots.ru.js	Improper Input Validation (refreshOffline Event	Medium	false	N/A	N/A	N/A	N/A	{The 'refreshOffline' event listener does not involve any sensitive function misuse. The event is custom-defined and does not process untrusted input or invoke functions that could lead to injection or execution of arbitrary code.}	```self.addEventListener('refreshOffline', response => caches.open('sw-offline').then(cache => cache.put(offlinePage, response)));```
5531	free.it.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The fetch function is used with a URL constructed from untrusted input (sensor_url and body.data.push_send_id), allowing an attacker to manipulate the URL to redirect to arbitrary endpoints, leading to open redirect vulnerabilities.}	```const ve = sensor_url + '/e?site_name=www.free.it&push_send_id=' + body.data.push_send_id + '&event_name=view';```
5532	free.it.js	Open Redirect	High	true	CWE-601	10	N/A	standard	{The clients.openWindow function is used with a URL derived from untrusted input (event.notification.data.url), enabling an attacker to redirect users to arbitrary websites, resulting in an open redirect vulnerability.}	```event.waitUntil(clients.openWindow(event.notification.data.url));```
5533	agrotendencia.tv.js	Improper Input Validation Leading to Denial of Service	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper validation of the 'range' header in HTTP requests, specifically when parsing the byte range using a regular expression. The code assumes the header format is always 'bytes=X-', but if an attacker supplies a malformed or unexpected value (e.g., 'bytes=abc-'), the `exec` call may return `null`, causing `Number(undefined)` to result in `NaN`, which could lead to unexpected behavior or denial of service. However, this is not due to misuse of a sensitive JavaScript function like `importScripts` or `eval`, but rather a logic flaw in input handling.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
5534	gstfi.pl.js	Server Side Request Forgery (SSRF) via unvalidated URL in `new URL(t).hostname	High	true	CWE-918	10	new URL	standard	{The `new URL(t).hostname` function is used with untrusted input `t`, which is derived from the request URL or similar dynamic source. This allows an attacker to supply a malicious URL (e.g., internal IP, localhost, or external domain) that can be resolved and accessed by the service worker, leading to SSRF. The function is standard and directly exposed to unvalidated input, making it a high-confidence sensitive function misuse.}	```const e = (e, t) => { let n = e.languageVersionRecognitionByCustomDomainEnabled ? ((e, t) => e[new URL(t).hostname])(e.customDomainToDefaultLanguageCode, t) : ((e, t) => e.filter(e => (e => new URL(e).pathname.split('/')[1])(t) === e)[0])(e.siteLanguageCodes, t); return n || (n = e.defaultLanguageCode), n; };```
5535	gstfi.pl.js	Cache Poisoning via untrusted input in `caches.match(e	Medium	true	CWE-113	9	caches.match	standard	{The `caches.match(e)` function is called with `e` derived from `t.languageCodeToOfflineUrl[e(t, a.url)]`, where `a.url` is the incoming request URL. Since the URL is untrusted and can be manipulated by an attacker, it may lead to fetching and caching arbitrary resources, potentially poisoning the cache with malicious content. This is a standard API misused with dynamic, unvalidated input.}	```self.addEventListener('fetch', t => { t.respondWith(s(t.request).catch(() => { return a = t.request, caches.match(n).then(e => e.json()).then(e => e).then(t => t.languageCodeToOfflineUrl[e(t, a.url)]).then(e => caches.match(e)); var a; })); });```
5536	gstfi.pl.js	Cross-Site Scripting (XSS) via unsanitized CSS URL extraction in `r	High	true	CWE-79	10	r	custom	{The custom function `r` extracts URLs from CSS content using a regex `/url\(([^)]+)\)/g` without sanitizing or validating the extracted URLs. If the CSS content is controlled by an attacker (e.g., via a malicious resource), the extracted URLs could be injected into the service worker’s cache or used in further requests, leading to XSS when processed by the browser. The function is custom and directly processes untrusted data.}	```const r = e => { const t = /url\(([^)]+)\)/g; let n; const a = []; do { n = t.exec(e), n && a.push(n[1]); } while (n); return a; };```
5537	porneeds.com.js	External Script Loading Without Validation	High	true	N/A	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. When used with a hardcoded URL that is not validated or sanitized, it can lead to unauthorized script execution if the URL is controlled by an attacker or if the script source is compromised. In this case, the script is loaded from 'https://pw.wpu.sh/ps/sw.js?tcid=485', which is an external, potentially untrusted source. If the domain or script is compromised, it could lead to malicious code execution within the service worker context, enabling attacks such as cache poisoning, network interception, or data exfiltration.}	```importScripts('https://pw.wpu.sh/ps/sw.js?tcid=485');```
5538	itfseafarers.org.js	Caching of Sensitive Data Without Validation	High	true	CWE-921	9	caches.put	standard	{The caches.put() function is used to store responses in the cache without validating the request URL or method. Since the request is directly taken from e.request (which can be manipulated by an attacker via crafted fetch requests), this allows potentially sensitive or malicious data to be cached. The condition e.request.method !== 'POST' and e.request.url.indexOf('chrome-extension') === -1 is insufficient to prevent cache poisoning or unintended caching of sensitive data, especially if the request URL is controlled by an attacker.}	N/A
5539	itfseafarers.org.js	Potential Cache Poisoning via Unvalidated Requests	High	true	CWE-918	9	caches.put	standard	{The caches.put() function is used to store responses in the cache without proper validation of the request. The request object is directly derived from e.request, which can be manipulated by an attacker through crafted network requests. Since the cache is populated without verifying the origin, method, or content of the request, an attacker could inject malicious responses into the cache, leading to cache poisoning. The existing checks are not sufficient to prevent exploitation.}	N/A
5540	1win.partners.js	Improper Input Validation in Cache Key Generation	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability arises from insufficient validation of input used in cache key generation, but no direct misuse of a sensitive JavaScript function is evident. The code uses standard URL manipulation and string operations, which are not inherently sensitive when used with trusted inputs.}	```const { cacheKeyWillBeUsed } = this._strategy;```
5541	1win.partners.js	Potential Cache Poisoning via Unvalidated URLs	High	true	N/A	N/A	new URL	standard	{The code constructs URLs using `new URL(s, location.href)` where `s` is derived from user-controlled inputs (e.g., from precache entries). If an attacker can manipulate these inputs, they could inject malicious URLs into the cache, leading to cache poisoning. The `new URL` function is standard but becomes sensitive when used with untrusted data.}	```const { cacheKey: a, url: r } = Z(n);```
5542	1win.partners.js	Insecure Fetch Handling Without Proper Validation	Medium	true	N/A	N/A	fetch	standard	{The `fetch` function is called with a `Request` object constructed from user-controlled URLs (e.g., from `e.url`). Without proper validation or sanitization, this allows for arbitrary resource fetching, potentially leading to unintended network requests or data exfiltration. The `fetch` API is standard but sensitive when used with dynamic, untrusted inputs.}	"```let i = await t.fetch(new Request(e, { integrity: e.mode !== ""no-cors"" ? i || r : void 0 }));```"
5543	1win.partners.js	Missing Cache Expiration Enforcement	Medium	false	N/A	N/A	N/A	N/A	{This vulnerability stems from a lack of cache expiration policy enforcement, not from misuse of a sensitive function. The code does not improperly use any sensitive JavaScript function; instead, it simply omits a security best practice.}	```const c = await this._timestampModel.expireEntries(e, this._maxEntries);```
5544	1win.partners.js	Inadequate Error Handling for IndexedDB Operations	Low	false	N/A	N/A	N/A	N/A	{The issue is related to insufficient error handling for IndexedDB operations, not misuse of a sensitive function. The code uses standard IndexedDB APIs, but errors are not properly caught or logged, which could lead to silent failures. No sensitive function misuse is involved.}	```const { id } = await Se(je, 1, { upgrade: this._upgradeDbAndDeleteOldDbs.bind(this) });```
5545	acd.com.au.js	Improper Validation of Range Header in Partial Content Handling	High	true	CWE-20	9	Number	standard	{The Number() function is used to parse a value extracted from the 'range' header via a regex, which is derived from untrusted user input. This allows an attacker to manipulate the 'range' header to trigger out-of-bounds memory access or other unintended behavior, especially if the parsed value is used for array slicing or buffer operations. The lack of bounds checking or validation on the parsed number increases the risk of exploitation.}	```var pos = Number(/^bytes\=(\d+)\-$/g.exec(event.request.headers.get('range'))[1]);```
5546	acd.com.au.js	Insufficient Exclusion of Sensitive URLs from Caching	Medium	false	CWE-200	N/A	N/A	N/A	{The vulnerability arises from the use of a hardcoded list of regex patterns to exclude sensitive URLs from caching. While no sensitive function is misused, the logic is flawed because it does not properly account for all possible sensitive paths (e.g., subdirectories, query parameters, or alternate spellings). This is a logic flaw, not a sensitive function misuse.}	```const neverCacheUrls = [/\/wp-admin/, /\/wp-login/, /preview=true/];```
5547	tubi.com.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with a hardcoded URL (https://cdn.adrise.tv/tubitv-assets/js/braze/4.3/service-worker.js), which is not dynamically derived from untrusted input. However, the vulnerability arises because the script is imported from an external, third-party domain (cdn.adrise.tv), which is outside the control of the application. If this external script is compromised or modified by an attacker, it can execute arbitrary code within the context of the service worker, leading to potential cache manipulation, network request interception, or data exfiltration. While the URL is hardcoded, the use of importScripts() with an external source introduces a high-risk dependency that can be exploited if the external script is not securely managed.}	"```self.importScripts(""https://cdn.adrise.tv/tubitv-assets/js/braze/4.3/service-worker.js"");```"
5548	feuerwehrstore.de.js	Open Redirect via Notification Action URLs	High	true	CWE-601	10	clients.openWindow	standard	{The clients.openWindow() function is used to open a new browser window or tab with a URL specified by the event.action or event.notification.data.action. These values originate from the push notification payload, which is untrusted and can be controlled by an attacker. If an attacker can manipulate the notification payload to include a malicious URL (e.g., a phishing site or redirector), the service worker will open that URL in the user’s browser, leading to an open redirect vulnerability.}	```event.waitUntil(clients.matchAll({type: 'window'}).then(function (clientList) { if (clients.openWindow) { if (event.action) { return clients.openWindow(event.action); } else if (event.notification.data.action) { return clients.openWindow(event.notification.data.action); } } }));```
5549	feuerwehrstore.de.js	Insecure LocalStorage Usage	Medium	false	CWE-798	0	N/A	N/A	{The use of localStorage.setItem() is not inherently a sensitive function misuse in this context. The value being stored is derived from the notification payload, but there is no direct execution or injection risk from the function itself. The issue is more about data exposure or persistence of potentially sensitive identifiers, not misuse of a sensitive function.}	"```localStorage.setItem(""skyfy_user_id"", shopware_user_id);```"
5550	feuerwehrstore.de.js	Unvalidated JSON Input in Notification Body	Medium	false	CWE-502	0	N/A	N/A	{The JSON.parse() function is used to parse msg.body, which comes from the push notification payload. While JSON.parse() can be misused if the input is not properly validated, the vulnerability here is more about the lack of input validation and potential for malformed or unexpected data structures, rather than a direct misuse of a sensitive function. The function itself is not inherently dangerous when used with untrusted input, as it only parses JSON and does not execute code.}	```var body_campId = JSON.parse(msg.body);```
5551	ntcompatible.com.js	Incorrect URL Check in Fetch Event Leading to Potential Misrouting	Medium	false	N/A	0	N/A	N/A	{The condition `e.request.url.indexOf(',') > 1 || e.request.url.indexOf('contentteller.png') > 1` is logically flawed because `indexOf` returns -1 if the substring is not found, and comparing it to 1 is incorrect. This does not involve misuse of a sensitive function but rather a logic error in URL filtering.}	```if (e.request.url.indexOf(',') > 1 || e.request.url.indexOf('contentteller.png') > 1) { return; }```
5552	nobleschools.org.js	XSS via iframe srcdoc in error handling	High	true	CWE-79	10	N/A	standard	"{The vulnerability arises from the use of `srcdoc` in an `<iframe>` element, where the `srcdoc` value is derived from untrusted input (responseBody) via `responseBody.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/""/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');`. Although the input is sanitized for basic HTML entities, it is still possible to bypass sanitization or exploit edge cases (e.g., via JavaScript injection in attributes or event handlers). The `srcdoc` attribute is a standard HTML feature, and when combined with dynamic, unsanitized content, it can lead to XSS. The sensitive function here is the `srcdoc` attribute usage within the `iframe` tag, which is part of the standard DOM API.}"	"```const iframe = `<iframe style=""width:100%"" src=""${src}"" srcdoc=""${srcdoc}""></iframe>`;```"
5553	belvue.be.js	Insecure Caching of Sensitive Resources	High	true	CWE-921	10	registerRoute	standard	{The registerRoute function is used to define a route for URLs matching /\.admin/, which is a sensitive administrative path. By using NetworkOnly strategy, it bypasses caching entirely, potentially exposing sensitive admin resources to network-based attacks or unauthorized access if not properly secured. The misuse lies in not restricting access or applying security checks before routing.}	```registerRoute(/\\.admin/, new NetworkOnly({}));```
5554	belvue.be.js	Insecure Fallback Content Handling	Medium	true	CWE-451	9	caches.match	standard	{The caches.match function is used within the setCatchHandler to serve fallback content (e.g., /offline.html) for failed requests. If an attacker can manipulate the request to trigger this fallback, they may be able to access unintended resources or bypass security controls, especially if the fallback content is not properly validated or sanitized.}	```setCatchHandler(({\n event\n }) => {\n switch (event.request.destination) {\n case 'document':\n return caches.match(FALLBACK_HTML_URL);\n break;\n case 'image':\n return caches.match(FALLBACK_IMAGE_URL);\n break;\n default:\n return Response.error();\n }\n });```
5555	belvue.be.js	Insufficient Cache Expiration for Static Resources	Medium	false	CWE-310	0	N/A	N/A	{This vulnerability arises from the configuration of the StaleWhileRevalidate strategy for JS/CSS files without a defined maxAgeSeconds or maxEntries, leading to potential indefinite caching. However, no sensitive function is misused here — the issue stems from misconfiguration rather than improper use of a function.}	```registerRoute(/\\.(?:js|css)$/, new StaleWhileRevalidate({\n cacheName: 'static-resources'\n }));```
5556	belvue.be.js	Weak Cache Key Normalization	Low	false	CWE-577	0	N/A	N/A	{The normalizeURL function removes the hash from URLs but does not sanitize or validate the input URL. However, this is not a misuse of a sensitive function — it is a custom utility function that does not directly interact with sensitive APIs or introduce security risks through improper function use.}	```const normalizeURL = unNormalizedUrl => {\n const url = new URL(unNormalizedUrl, location.href);\n url.hash = '';\n return url.href;\n };```
5557	rmfmaxxx.pl.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard service worker API that loads and executes scripts from a specified URL. When used with a hardcoded external URL (e.g., 'https://www.rmfmaxxx.pl/work/push/client/js/sw-rmf-push.js'), it introduces a risk if the external script is compromised or if the domain is controlled by an attacker. Although the URL is hardcoded here, it still represents a potential attack surface if the script source is not fully trusted or if the domain is later compromised. This constitutes a high-risk vulnerability due to the potential for remote code execution via script injection.}	```importScripts('https://www.rmfmaxxx.pl/work/push/client/js/sw-rmf-push.js');```
5558	rmfmaxxx.pl.js	Long-Term Cache Expiration for Fonts	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from setting an excessively long cache expiration time (1 year) for Google Fonts, which is a configuration issue rather than misuse of a sensitive function. The workbox.expiration.Plugin is used correctly, but the policy is overly permissive, leading to stale content being served for extended periods. This does not involve dynamic or untrusted input, nor does it involve a sensitive function that can be exploited for code execution or injection.}	```new workbox.expiration.Plugin({ maxAgeSeconds: 60 * 60 * 24 * 365, maxEntries: 30 })```
5559	floydmortuary.com.js	Cache Poisoning via Broad Regex Patterns	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of broad, unbounded regular expressions in workbox.routing.registerRoute, which can match unintended URLs. While registerRoute itself is not inherently sensitive, its misuse with overly permissive regex patterns (e.g., /.*?irp\.cdn-website\.com.*?/) allows attackers to craft URLs that bypass intended routing logic, leading to cache poisoning. The sensitive function here is registerRoute, a standard Workbox API, which is misused by providing regex patterns that are too broad and not properly constrained.}	```const workbox.routing.registerRoute(/.*?irp\.cdn-website\.com.*?/, networkFirst(SITE_ASSETS_CACHE_NAME));```
5560	floydmortuary.com.js	Cache Poisoning via Broad Regex Patterns	High	true	CWE-918	9	N/A	standard	{The vulnerability arises from the use of broad, unbounded regular expressions in workbox.routing.registerRoute, which can match unintended URLs. While registerRoute itself is not inherently sensitive, its misuse with overly permissive regex patterns (e.g., /.*?static\.cdn-website\.com\/mnlt\/.*?/) allows attackers to craft URLs that bypass intended routing logic, leading to cache poisoning. The sensitive function here is registerRoute, a standard Workbox API, which is misused by providing regex patterns that are too broad and not properly constrained.}	```const workbox.routing.registerRoute(/.*?static\.cdn-website\.com\/mnlt\/.*?/, networkFirst(RUNTIME_CACHE_NAME));```
5561	floydmortuary.com.js	Unvalidated Message Origin in Cache Deletion	High	true	CWE-319	8	N/A	standard	{The vulnerability arises from the use of self.addEventListener('message', ...) without validating the origin of the message. The sensitive function here is addEventListener, a standard JavaScript API, which is misused by not checking event.origin or event.source to ensure the message comes from a trusted source. This allows any page or script in the same origin (or potentially cross-origin if not properly secured) to trigger cache deletion, leading to denial of service or cache manipulation.}	```self.addEventListener('message', async function handler(event) { if (event.data.command === 'deletePagesCache') {```
5562	accutracking.com.js	Insecure Caching of Offline Page	Medium	false	New	N/A	N/A	N/A	{The vulnerability is not caused by misuse of a sensitive function, but rather by insecure caching behavior where an offline page is cached during installation without validation or sanitization. The code uses standard fetch and caches APIs correctly, but the risk lies in the assumption that /pwa_offline.php is always safe, which may not be true if the server is compromised or if the file is dynamically generated with untrusted content.}	```self.addEventListener('install', function (event) { var offlinePage = new Request('/pwa_offline.php'); event.waitUntil(fetch(offlinePage).then(function (response) { return caches.open('accutracking-offline').then(function (cache) { console.log('Cached offline page during install'); return cache.put(offlinePage, response); })); }); });```
5563	tmp.link.js	Insecure Cache Key Construction	Medium	true	New	8	N/A	standard	{The cache key is constructed by concatenating the domain and path from the request URL without sanitization or validation. While the domain is checked against a whitelist via isAllowDomain(), the path is directly used in the cache key. If an attacker can manipulate the path (e.g., via URL encoding or directory traversal), they could potentially craft a cache key that collides with or overwrites legitimate cached resources, leading to cache poisoning or bypassing intended security controls. The sensitive function here is not a direct function call but the use of URL parsing and string concatenation in a context where untrusted input (path) is used to construct a cache key, which is a common vector for cache manipulation vulnerabilities.}	```const cacheKey = domain + path;```
5564	karllagerfeld.com.js	Permissive Regular Expression Leading to Cache Poisoning	Medium	false	CWE-20	N/A	N/A	N/A	{The vulnerability arises from a permissive regular expression in the fetch event handler that matches URLs ending with common file extensions (e.g., .jpg, .png, .css). While this does not directly involve a sensitive function misuse, it allows unintended resources to be cached and served, potentially leading to cache poisoning. The issue is more about logic and pattern matching than improper use of a sensitive function.}	"```var NS = ""IMAGE"",  SEPARATOR = ""|"",  VERSION = 2887856;function buildKey(e) {  return NS + SEPARATOR + e + SEPARATOR + VERSION;}function parseKey(e) {  var n = e.split(SEPARATOR);  return {    ns: n[0],    key: n[1],    ver: parseInt(n[2], 10)  };}function purgeExpiredRecords(e) {  return e.keys().then(function (n) {    return Promise.all(n.map(function (n) {      var t = parseKey(n);      if (t.ns === NS && t.ver !== VERSION) return e.delete(n);    }));  });}function proxyRequest(e, n) {  var t = buildKey(n.url);  return e.open(t).then(function (e) {    return e.match(n).then(function (t) {      return t || fetch(n.clone()).then(function (t) {        if (""opaque"" !== t.type && !1 === t.ok) throw new Error(""Resource not available"");        return e.put(n, t.clone()), t;      }).catch(function () {        console.error(""Failed to fetch"", n.url);      });    });  });}self.addEventListener(""install"", function (e) {  e.waitUntil(self.skipWaiting());}), self.addEventListener(""activate"", function (e) {  e.waitUntil(purgeExpiredRecords(caches));}), self.addEventListener(""fetch"", function (e) {  var n = e.request;  ""GET"" === n.method && n.url.match(/.(jpe?g.*|png.*|gif.*|svg.*|webp.*|woff.*|css)$/)&&e.respondWith(proxyRequest(caches,n));});```"
5565	solresor.se.js	Remote Code Execution via Untrusted Script Import	High	true	CWE-94	10	importScripts	standard	{The code uses `importScripts(t)` where `t` is dynamically derived from a module name passed to the `t` function, which constructs a URL using `new URL(t + \'.js\', n).href`. Since the module name is not validated and can be controlled by an attacker (e.g., via a malicious module request), this allows arbitrary script execution from untrusted sources. The `importScripts` function is a standard browser API that executes scripts from a given URL without sanitization, making it a direct vector for remote code execution.}	```if (!self.define) { let e, s = {}; const t = (t, n) => (t = new URL(t + \'.js\', n).href, s[t] || new Promise(s => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = t, e.onload = s, document.head.appendChild(e); } else e = t, importScripts(t), s(); }).then(() => { let e = s[t]; if (!e) throw new Error(`Module ${t} didn’t register its module`); return e; })); self.define = (n, i) => { const o = e || (\'document\' in self ? document.currentScript.src : \'\') || location.href; if (s[o]) return; let r = {}; const c = e => t(e, o), l = { module: { uri: o }, exports: r, require: c }; s[o] = Promise.all(n.map(e => l[e] || c(e))).then(e => (i(...e), r)); }; }```
5566	solresor.se.js	Insecure Service Worker Activation via Message	Medium	false	N/A	0	N/A	N/A	{The vulnerability arises from the service worker listening for messages and skipping waiting if the message type is 'SKIP_WAITING'. This is a legitimate use of the `addEventListener` API and does not involve any sensitive function misuse. The issue is more about insecure activation logic rather than unsafe function usage.}	"```self.addEventListener(\'message\', e => { e.data && \""SKIP_WAITING\"" === e.data.type && self.skipWaiting(); });```"
5567	solresor.se.js	Insecure Script Injection via Module Loader	Medium	true	CWE-79	9	importScripts	standard	{The `t` function constructs a script URL using `new URL(t + \'.js\', n).href` and then uses `importScripts(t)` to load it. Since the module name `t` is passed dynamically and not validated, an attacker could supply a malicious module name that resolves to an external script, leading to script injection. The `importScripts` function is a standard browser API that executes scripts from a given URL without sanitization, making it a direct vector for injection.}	```const t = (t, n) => (t = new URL(t + \'.js\', n).href, s[t] || new Promise(s => { if (\'document\' in self) { const e = document.createElement(\'script\'); e.src = t, e.onload = s, document.head.appendChild(e); } else e = t, importScripts(t), s(); }).then(() => { let e = s[t]; if (!e) throw new Error(`Module ${t} didn’t register its module`); return e; }));```
5568	solresor.se.js	Cache Poisoning via Unversioned Resource	Medium	false	N/A	0	N/A	N/A	{The vulnerability stems from precaching a resource with `revision: null`, which means the cache will not be invalidated when the resource changes. This is a configuration issue, not a misuse of a sensitive function. The `precacheAndRoute` function is used correctly; the problem lies in the lack of versioning, not in unsafe function usage.}	```e.precacheAndRoute([{ url: \'_nuxt/builds/meta/f49896ae-6fba-4d49-9ac6-eca523b11cb4.json\', revision: null }, ...], {});```
5569	elevenvr.com.js	Vulnerable External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard JavaScript function in the Service Worker context that loads and executes external scripts. In this case, it is called with a dynamic URL derived from the options.workboxURL, which is hardcoded as a trusted CDN URL. However, the vulnerability arises because the function is also called with options.importScripts, which is an array that could be manipulated if the options object were derived from untrusted input. Although the current code does not show such input, the use of importScripts with dynamic sources (even if currently safe) introduces a risk if the options object is later modified or if the script is extended to accept user-controlled inputs. This misuse allows an attacker to inject arbitrary scripts by controlling the importScripts array, leading to code execution within the service worker context.}	```importScripts(...[options.workboxURL, ...options.importScripts]);```
5570	gilroygarlicfestival.com.js	Cache Poisoning	High	true	N/A	N/A	URL	standard	{The URL constructor is used with dynamic input (e.g., from a request URL) without sanitization, allowing an attacker to craft a malicious URL that could be cached under a different key, leading to cache poisoning.}	```const a = new URL(e, location.href); return this._urlsToCacheKeys.get(t.href);```
5571	gilroygarlicfestival.com.js	Insecure Cache Expiration	Medium	false	N/A	N/A	N/A	N/A	{The deletion of cache entries is performed without proper validation or rate limiting, but it does not stem from misuse of a sensitive function.}	```await s.delete(e);```
5572	gilroygarlicfestival.com.js	Open Redirect	High	true	N/A	N/A	URL	standard	{The URL constructor is used with untrusted input (e.g., from a request URL) to construct a redirect target, enabling an attacker to redirect users to arbitrary domains.}	```const s = new URL(e, location.href);```
5573	gilroygarlicfestival.com.js	Insufficient Cache Validation	Medium	false	N/A	N/A	N/A	N/A	{The Response constructor is used with potentially unvalidated data, but the vulnerability arises from logic flaws rather than misuse of a sensitive function.}	```return new Response(o, c);```
5574	gilroygarlicfestival.com.js	Cross-Origin Cache Confusion	High	true	N/A	N/A	URL	standard	{The URL constructor is used to parse and compare origins from untrusted input, which can be manipulated to bypass origin checks and cause cross-origin cache confusion.}	```if (s !== self.location.origin) throw new n.V('cross-origin-copy-response', { origin: s });```
5575	xpeng.cr.js	Cache Poisoning via Improper URL Normalization	High	true	CWE-918	10	N/A	standard	{The vulnerability arises from the improper handling of URLs during cache operations. The code uses `event.request` directly in `cache.match(event.request)` and `fetch(event.request)` without normalizing or validating the URL. This allows an attacker to craft a request with a malicious or unexpected URL (e.g., via URL manipulation or path traversal) that could lead to unintended cache entries being created or retrieved, potentially resulting in cache poisoning. The `fetch` and `cache.match` functions are standard JavaScript APIs that, when used with untrusted or unsanitized input, can be exploited to manipulate the cache state.}	```event.respondWith(caches.open(CACHE_NAME).then(cache => { return cache.match(event.request).then(response => { return response || fetch(event.request).then(response => { if (response && Boolean(response.ok)) { cache.put(event.request, response.clone()); } return response; }); }); }));```
5576	fox28.com.js	Hardcoded sensitive credentials in Service Worker	Medium	false	CWE-798	N/A	N/A	N/A	{The vulnerability arises from hardcoded sensitive credentials (appKey, token, vapidPublicKey) within the Service Worker script. These are not the result of misuse of a sensitive function, but rather poor secret management. No function is being misused to introduce this vulnerability.}	```uaSetup.worker(self, { defaultIcon: 'https://wsbt.com/resources/assets/wsbt/images/brand\u002Dicons/WSBT\u002D310.png ', defaultTitle: 'WSBT\u002DTV News', defaultActionURL: 'https://wsbt.com', appKey: 'nj91CK77QbqCMdNh0hgMug', token: 'MTpuajkxQ0s3N1FicUNNZE5oMGhnTXVnOmk0TmpQX0lBdzVkWWFVS3Vod3RNV2pnUWZ4TkVhUGJGeXNlVE90T2tULTQ', vapidPublicKey: 'BBSc8NmXj_aecp5mFkcGj-l7H4ColVQg_Llqyse8ZTn7tD7pycEP5SaAawwYfBeuPhHTgVdiSlhBjWR_tH5oEnY=' });```
5577	fox28.com.js	Unvalidated external script import via importScripts	High	true	CWE-444	N/A	importScripts	standard	{The importScripts function is used to load an external script from a hardcoded URL. While the URL is not dynamic, the function itself is sensitive because it executes arbitrary JavaScript code from a remote source. If the URL were derived from untrusted input, it would be a direct injection vector. However, since the URL is hardcoded, the risk is lower but still present due to potential compromise of the external script source.}	```importScripts('https://aswpsdkus.com/notify/v2/ua-sdk.min.js');```
5578	pomodor.app.js	Improper Cache Expiration Handling	Medium	false	CWE-526	0	N/A	N/A	{The vulnerability arises from a logic error in the `_isResponseDateFresh` method, where it always returns `!1` (false) regardless of the `_maxAgeSeconds` value. This is not due to misuse of a sensitive JavaScript function, but rather a hardcoded return value that bypasses the intended expiration logic.}	```function (e) { if (!this._maxAgeSeconds) return !0; var t = this._maxAgeSeconds; return !1; }```
5579	checkshorturl.com.js	Insecure External Script Import	High	true	CWE-444	10	importScripts	standard	{The importScripts() function is a standard Service Worker API that loads and executes a script from a specified URL. When used with a hardcoded external URL (as in this case), it introduces a high-risk vulnerability because the script is fetched from an untrusted third-party domain (cdn.pushmaster-cdn.xyz). This allows the remote server to inject malicious code into the service worker, potentially leading to data exfiltration, cache manipulation, or man-in-the-middle attacks. Although the URL is hardcoded, the function itself is sensitive due to its ability to execute arbitrary remote code.}	"```importScripts(""https://cdn.pushmaster-cdn.xyz/scripts/publishers/6408c8187338b50008362dcd/service-worker.js"");```"
5580	anistars.ru.js	Improper Validation of Redirect URL	High	true	CWE-601	9	N/A	standard	{The vulnerability arises because the `settings.redirect_url` is directly assigned from the `data['redirect_to']` value received from a remote fetch request without any validation or sanitization. This value is then used in `getRedirectUrl()` to construct a redirect URL, which is ultimately set as the `Location` header in a `Response` object via `new Response('', redirect)`. Since the `Location` header is controlled by untrusted data, an attacker could manipulate the remote settings endpoint to inject arbitrary redirect URLs, leading to open redirect attacks. The sensitive function here is `new Response()` (standard), which is misused by passing a `Location` header constructed from untrusted input.}	```settings.redirect_url = data['redirect_to'] ? data['redirect_to'] : false;```
5581	bonnerupfuneralservice.com.js	Improper Input Validation in Cache Route Regex	High	true	CWE-20	9	N/A	standard	"{The regex /.*?irp\.cdn-website\.com.*?/ is overly permissive and matches any URL containing the substring ""irp.cdn-website.com"", regardless of context. This allows attackers to craft URLs that bypass intended filtering and trigger unintended caching behavior, potentially leading to cache poisoning or unintended resource fetching. The use of the `workbox.routing.registerRoute` function with such a broad regex constitutes misuse of a standard routing API.}"	```const regex = /.*?irp\.cdn-website\.com.*?/; workbox.routing.registerRoute(regex, networkFirst(SITE_ASSETS_CACHE_NAME));```
5582	bonnerupfuneralservice.com.js	Use of No-CORS Mode in Fetch Request	High	true	CWE-548	9	N/A	standard	{The `fetch` function is called with `mode: 'no-cors'`, which prevents the browser from sending credentials and restricts the response to only certain headers. This can lead to unexpected behavior or data leakage if the server returns sensitive data that is not properly filtered, especially when combined with dynamic URLs generated via `addParams`. The misuse of `fetch` with `no-cors` mode in a service worker context can allow unintended data exposure or bypass security checks.}	```const response = await fetch(new Request(url, { mode: 'no-cors' }));```
5583	bonnerupfuneralservice.com.js	Insecure Hash Function for Security Context	Medium	false	CWE-327	0	N/A	standard	{The `toHash` function is a custom implementation of a non-cryptographic hash function (DJB2). While it is not a sensitive function per se, its use in a security context (e.g., generating cache keys or version identifiers) is inappropriate because it lacks collision resistance and cryptographic strength. However, since it is not a standard or sensitive function like `eval` or `importScripts`, it does not qualify as a sensitive function misuse.}	```function toHash(str) { var hash = 5381, i = str.length; while (i) { hash = hash * 33 ^ str.charCodeAt(--i); } return hash >>> 0; }```
5584	bonnerupfuneralservice.com.js	Debug Logging of Sensitive Information	Medium	false	CWE-200	0	N/A	standard	{The `log` function logs messages to the console when `pwaSettings.debug` is true. While this can expose sensitive information in development, it does not involve misuse of a sensitive JavaScript function such as `eval`, `importScripts`, or `fetch` with untrusted input. The function is a simple wrapper around `console.log`, and its misuse is more about configuration than function misuse.}	```function log(...args) { if (pwaSettings.debug) { console.log('RTSW:', ...args); } }```
5585	bonnerupfuneralservice.com.js	Blacklist-Based URL Filtering	Medium	false	CWE-20	0	N/A	standard	{The `shouldCachePageRequest` function uses a blacklist approach to filter URLs, which is inherently insecure because it can be bypassed by URL variations. However, this is not caused by misuse of a sensitive JavaScript function like `importScripts` or `eval`. The function is a custom logic implementation and does not involve a standard sensitive API.}	```function shouldCachePageRequest(request) { return PAGES_CACHE_BLACKLIST.every(blacklistedUrl => !request.url.includes(blacklistedUrl)); }```
5586	bonnerupfuneralservice.com.js	Empty Fetch Event Handler Override	Medium	false	New	0	N/A	standard	{The `fetch` event handler is overridden with an empty function, which may disrupt expected behavior but does not involve misuse of a sensitive function. The `self.addEventListener('fetch', () => {});` is a standard event listener override and does not introduce a vulnerability through sensitive function misuse.}	```self.addEventListener('fetch', () => {});```
5587	crfsonly.com.js	Improper URL Filtering Leading to Cache Poisoning	High	false	N/A	N/A	N/A	N/A	{The vulnerability arises from improper URL filtering using string-based indexOf checks, which are not sensitive function misuses. The issue is in logic design, not in the misuse of a sensitive function like importScripts or eval.}	```for (let i = 0; i < OFFLINE_EXCLUDE.length; i++) { if (event.request.url.indexOf(OFFLINE_EXCLUDE[i]) !== -1 || event.request.referrer.indexOf(OFFLINE_EXCLUDE[i]) !== -1) { return false; } }```
5588	crfsonly.com.js	Unintended Referrer-Based Response Handling	Medium	false	N/A	N/A	N/A	N/A	{The vulnerability stems from using event.request.referrer as a source for fetching content, which is a logic flaw rather than misuse of a sensitive function. The fetch() call is not inherently unsafe here, as it is not being used with untrusted dynamic input in a way that enables code execution or injection.}	```if (event.request.cache === 'only-if-cached') { page_to_load = await fetch(event.request.referrer); }```
5589	ville-massy.fr.js	Insecure Resource Loading (External Script Import)	Medium	true	CWE-434	10	importScripts	standard	{The importScripts() function is a standard JavaScript API used in Service Workers to load and execute external scripts. In this case, it is used with hardcoded, trusted paths ('/cccms-web-push-serviceWorker.js' and '/sw-toolbox.js'), which do not involve dynamic or untrusted input. Therefore, while the function itself is sensitive due to its ability to execute arbitrary code, the usage here is not vulnerable because the URLs are static and controlled. However, the original detection flagged it as insecure, likely due to a false positive or misclassification. Since the inputs are not dynamic or user-controlled, the misuse is not present, and the vulnerability is not sensitively exploitable.}	```importScripts('/cccms-web-push-serviceWorker.js');importScripts('/sw-toolbox.js');```
5590	ukr-live.com.js	Case-sensitive URL exclusion regex allows caching of sensitive admin pages	High	true	CWE-20	N/A	const neverCacheUrls = [/\/wp-admin/	standard	{The regex pattern /\/wp-admin/ is case-sensitive and does not account for variations like /WP-Admin/ or /Wp-admin/, allowing potentially sensitive admin pages to be cached and served to users. This is not a direct misuse of a sensitive function, but the vulnerability arises from improper use of the RegExp object in a security-critical context where case-insensitive matching is required.}	```const neverCacheUrls = [/\/wp-admin/, /\/wp-login/, /preview=true/];```
5591	ukr-live.com.js	Insecure origin check for cross-origin requests	Medium	true	CWE-698	N/A	if (new URL(e.request.url).origin !== location.origin) return;	standard	{The use of new URL(e.request.url).origin for origin validation is vulnerable because it does not properly handle malformed or malicious URLs that could bypass the check. For example, if e.request.url is a malformed URL (e.g., 'javascript:...'), the URL constructor may not throw and could result in an unexpected origin value, allowing cross-origin requests to be processed. This misuse of the URL API in a security context leads to improper origin validation.}	```if (new URL(e.request.url).origin !== location.origin) return;```
